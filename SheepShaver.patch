--- macemu/SheepShaver/src/Unix/Linux/NetDriver/sheep_net.c
+++ sheepshaver/SheepShaver/src/Unix/Linux/NetDriver/sheep_net.c
@@ -240,7 +220,7 @@
 {
 	/* Unregister driver */
 	misc_deregister(&sheep_net_device);
-	printk("sheep net: driver removed\n");
+	D(bug("Sheep net driver removed\n"));
 }
 
 
@@ -268,9 +248,12 @@
 	memset(v, 0, sizeof(struct SheepVars));
 	skb_queue_head_init(&v->queue);
 	init_waitqueue_head(&v->wait);
-	v->fake_addr[0] = 'v'; /* "SheepShaver" */
-	v->fake_addr[1] = 'r'; /*          ^ ^  */
-	get_random_bytes(&v->fake_addr[2], 4);
+	v->fake_addr[0] = 0xfe;
+	v->fake_addr[1] = 0xfd;
+	v->fake_addr[2] = 0xde;
+	v->fake_addr[3] = 0xad;
+	v->fake_addr[4] = 0xbe;
+	v->fake_addr[5] = 0xef;
 
 	/* Put our stuff where we will be able to find it later */
 	f->private_data = (void *)v;
@@ -499,13 +470,11 @@
 
 	/* Is this packet addressed solely to the local host? */
 	if (is_local_addr(v, skb->data) && !(skb->data[0] & ETH_ADDR_MULTICAST)) {
 		skb->destructor = do_nothing;
 		skb->protocol = eth_type_trans(skb, v->ether);
 		netif_rx(skb);
 		return count;
 	}
 	/* Relay multicast for host process except ARP packet */
-	if ((skb->data[0] & ETH_ADDR_MULTICAST) && (eth_hdr(skb)->h_proto != htons(ETH_P_ARP))) {
+	if (skb->data[0] & ETH_ADDR_MULTICAST) {
 		/* We can't clone the skb since we will manipulate the data below */
 		struct sk_buff *lskb = skb_copy(skb, GFP_ATOMIC);
 		if (lskb) {
@@ -601,7 +569,7 @@
 
 			/* Allocate socket */
 #ifdef LINUX_26
-			v->skt = compat_sk_alloc(dev_net(v->ether), GFP_USER, 1, &sheep_proto);
+			v->skt = sk_alloc(dev_net(v->ether), GFP_USER, 1, &sheep_proto);
 #else
 			v->skt = sk_alloc(0, GFP_USER, 1);
 #endif
--- macemu/SheepShaver/src/Unix/ether_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/ether_unix.cpp
@@ -230,7 +193,7 @@
 
 bool ether_init(void)
 {
-	int val;
+	int val, nonblock = 1;
 	char str[256];
 
 	// Do nothing if no Ethernet device specified
@@ -355,7 +288,6 @@
 
 	// Set nonblocking I/O
 #ifdef USE_FIONBIO
-	int nonblock = 1;
 	if (ioctl(fd, FIONBIO, &nonblock) < 0) {
 		sprintf(str, GetString(STR_BLOCKING_NET_SOCKET_WARN), strerror(errno));
 		WarningAlert(str);
@@ -379,18 +311,24 @@
 		ether_addr[3] = p >> 16;
 		ether_addr[4] = p >> 8;
 		ether_addr[5] = p;
 #ifdef HAVE_SLIRP
 	} else if (net_if_type == NET_IF_SLIRP) {
 		ether_addr[0] = 0x52;
 		ether_addr[1] = 0x54;
 		ether_addr[2] = 0x00;
 		ether_addr[3] = 0x12;
 		ether_addr[4] = 0x34;
 		ether_addr[5] = 0x56;
+	} else {
+#elif defined __linux
+		struct ifreq ifr;
+		int r, sock;
+		memset(&ifr, 0, sizeof(ifr));
+		sock = socket(PF_INET, SOCK_DGRAM, 0);
+		strcpy(ifr.ifr_name, net_if_name);
+		r = ioctl(sock, SIOCGIFHWADDR, &ifr);
+		if (r == -1)
+			perror("ioctl(SIOCGIFHWADDR)");
+		else
+			memcpy(ether_addr, ifr.ifr_hwaddr.sa_data, 6);
+		close(sock);
+#else
+		ioctl(fd, SIOCGIFADDR, &ether_addr);
 #endif
-	} else
-		ioctl(fd, SIOCGIFADDR, ether_addr);
-	D(bug("Ethernet address %02x %02x %02x %02x %02x %02x\n", ether_addr[0], ether_addr[1], ether_addr[2], ether_addr[3], ether_addr[4], ether_addr[5]));
+	}
+	D(bug("Ethernet address %02x:%02x:%02x:%02x:%02x:%02x\n", ether_addr[0], ether_addr[1], ether_addr[2], ether_addr[3], ether_addr[4], ether_addr[5]));
 
 	// Start packet reception thread
 	if (!start_thread())
--- macemu/SheepShaver/src/Unix/user_strings_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/user_strings_unix.cpp
@@ -84,6 +83,7 @@
 	{STR_VOSF_INIT_ERR, "Cannot initialize Video on SEGV signals."},
 
 	{STR_OPEN_WINDOW_ERR, "Cannot open Mac window."},
+	{STR_WINDOW_TITLE_GRABBED, "SheepShaver (mouse grabbed, press Ctrl-F5 to release)"},
 
 	{STR_NO_B2_EXE_FOUND, "Could not start %s (%s)."},
 
--- macemu/SheepShaver/src/Unix/user_strings_unix.h
+++ sheepshaver/SheepShaver/src/Unix/user_strings_unix.h
@@ -78,6 +77,7 @@
 	STR_MOUSEWHEELLINES_CTRL,
 
 	STR_OPEN_WINDOW_ERR,
+	STR_WINDOW_TITLE_GRABBED,
 
 	STR_NO_B2_EXE_FOUND
 };
--- macemu/SheepShaver/src/Windows/clip_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/clip_windows.cpp
@@ -21,6 +21,8 @@
 #include "sysdeps.h"
 
 #include <vector>
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
 
 #include "macos_util.h"
 #include "clip.h"
--- macemu/SheepShaver/src/Windows/sysdeps.h
+++ sheepshaver/SheepShaver/src/Windows/sysdeps.h
@@ -32,22 +32,59 @@
 #error "You don't have ANSI C header files."
 #endif
 
+#ifdef _MSC_VER
+#ifdef _M_IX86
+#define __i386__ 1
+#endif
+#ifdef _M_X64
+#define __x86_64__ 1
+#endif
+#endif
+
 #include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifndef _MSC_VER
 #include <stdint.h>
+#endif
+#include <inttypes.h>
 #include <string.h>
 #include <time.h>
 #ifdef __WIN32__
+#define NOMINMAX
+#define WINVER 0x0501
+#define _WIN32_WINNT 0x0501
+#include <winsock2.h>
 #include <windows.h>
 #endif
 #include <sys/types.h>
+#include <sys/timeb.h>
+#include <math.h>
 
+#ifdef _MSC_VER
+#define snprintf _snprintf
+#define O_ACCMODE 0x0003
+typedef size_t ssize_t;
+#include <float.h>
+extern double round(double x);
+extern float roundf(float x);
+extern double trunc(double x);
+extern float truncf(float x);
+#endif
 
+inline double sys_time()
+{
+    struct _timeb tb;
+    _ftime(&tb);
+	return (double)tb.time + ((double)tb.millitm / 1000.0);
+}
+
 // Define for external components
 #define SHEEPSHAVER 1
 #define POWERPC_ROM 1
+#ifndef EMULATED_PPC
 #define EMULATED_PPC 1
+#endif
 #define CONFIG_WIN32 1
 
 // Use Direct Addressing mode
@@ -148,6 +185,21 @@
 #endif
 #endif
 
+#if defined(_MSC_VER) && 0
+#define opt_bswap_16 _byteswap_ushort
+#define opt_bswap_32 do_opt_bswap_32
+static inline uint32 do_opt_bswap_32(uint32 x)
+{
+	uint32 v;
+	__asm {
+		mov eax, x;
+		bswap eax;
+		mov v, eax;
+	}
+	return v;
+}
+#endif
+
 #ifdef  opt_bswap_16
 #undef  bswap_16
 #define bswap_16 opt_bswap_16
@@ -178,12 +230,16 @@
 }
 
 #if defined(__i386__)
+#if defined(_MSC_VER) && 0
+#define opt_bswap_64 _byteswap_uint64
+#else
 #define opt_bswap_64 do_opt_bswap_64
 static inline uint64 do_opt_bswap_64(uint64 x)
 {
   return (bswap_32(x >> 32) | (((uint64)bswap_32((uint32)x)) << 32));
 }
 #endif
+#endif
 
 #ifdef  opt_bswap_64
 #undef  bswap_64
@@ -315,7 +371,20 @@
 
 #endif /* __GNUC__ */
 
+#ifdef _MSC_VER
+#define HAVE_TEST_AND_SET 1
+static inline LONG testandset(volatile LONG *p)
+{
+	assert(*p >= 0 && *p <= 1);
+	return InterlockedExchange(p, 1);
+}
+#endif /* _MSC_VER */
+
+#ifdef _MSC_VER
+typedef volatile LONG spinlock_t;
+#else
 typedef volatile int spinlock_t;
+#endif
 
 static const spinlock_t SPIN_LOCK_UNLOCKED = 0;
 
@@ -394,7 +463,9 @@
 // Misc platform specific definitions
 #ifdef __WIN32__
 typedef int64 loff_t;
-#endif
+#define ATTRIBUTE_PACKED
+#else
 #define ATTRIBUTE_PACKED __attribute__((__packed__))
+#endif
 
 #endif
--- macemu/SheepShaver/src/Windows/timer_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/timer_windows.cpp
@@ -20,6 +20,9 @@
 
 #include "sysdeps.h"
 
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
 #include "main.h"
 #include "macos_util.h"
 #include "timer.h"
--- macemu/SheepShaver/src/Windows/user_strings_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/user_strings_windows.cpp
@@ -45,6 +45,7 @@
 	{STR_VOSF_INIT_ERR, "Cannot initialize Video on SEGV signals."},
 
 	{STR_OPEN_WINDOW_ERR, "Cannot open Mac window."},
+	{STR_WINDOW_TITLE_GRABBED, "SheepShaver (mouse grabbed, press Ctrl-F5 to release)"},
 	{STR_NO_WIN32_NT_4, "SheepShaver does not run on Windows NT versions less than 4.0"},
 
 	{STR_PREFS_MENU_FILE_GTK, "/_File"},
--- macemu/SheepShaver/src/Windows/user_strings_windows.h
+++ sheepshaver/SheepShaver/src/Windows/user_strings_windows.h
@@ -39,6 +39,7 @@
 	STR_KEYCODE_FILE_WARN,
 	STR_KEYCODE_VENDOR_WARN,
 	STR_OPEN_WINDOW_ERR,
+	STR_WINDOW_TITLE_GRABBED,
 	STR_NO_WIN32_NT_4,
 
 	STR_PREFS_MENU_FILE_GTK,
--- macemu/SheepShaver/src/extfs.cpp
+++ sheepshaver/SheepShaver/src/extfs.cpp
@@ -33,7 +33,7 @@
  *    (SetForeignPrivs)
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -175,9 +175,9 @@
 
 #if defined __APPLE__ && defined __MACH__
 struct crtimebuf {
-    u_int32_t length;
-    struct timespec crtime;
-} __attribute__((aligned(4), packed));
+	unsigned long length;
+	struct timespec crtime;
+};
 
 static uint32 do_get_creation_time(const char *path)
 {
@@ -334,7 +334,7 @@
 // Convert C string to pascal string
 static void cstr2pstr(char *dst, const char *src)
 {
-	*dst++ = char(strlen(src));
+	*dst++ = strlen(src);
 	char c;
 	while ((c = *src++) != 0) {
 		// Note: we are converting host ':' characters to Mac '/' characters here
@@ -820,9 +820,9 @@
 				break;
 
 			case dtmvWDRefNum:		// Determined by working directory refNum
-				if (dirID) {
+				if (dirID)
 					current_dir = dirID;
-				} else {
+				else {
 					D(bug("  resolving WDCB\n"));
 					r.d[0] = 0;
 					r.d[1] = 0;
@@ -838,9 +838,9 @@
 				break;
 
 			case dtmvDefault:		// Determined by default volume
-				if (dirID) {
+				if (dirID)
 					current_dir = dirID;
-				} else {
+				else {
 					uint32 wdpb = fs_data + fsReturn;
 					WriteMacInt32(wdpb + ioNamePtr, 0);
 					D(bug("  getting default volume\n"));
@@ -1320,9 +1320,8 @@
 	get_finfo(full_path, pb + ioFlFndrInfo, hfs ? pb + ioFlXFndrInfo : 0, false);
 
 	WriteMacInt16(pb + ioFlStBlk, 0);
-	uint32 file_size = (uint32) st.st_size;
-	WriteMacInt32(pb + ioFlLgLen, file_size);
-	WriteMacInt32(pb + ioFlPyLen, (file_size | (AL_BLK_SIZE - 1)) + 1);
+	WriteMacInt32(pb + ioFlLgLen, st.st_size);
+	WriteMacInt32(pb + ioFlPyLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);
 	WriteMacInt16(pb + ioFlRStBlk, 0);
 	uint32 rf_size = get_rfork_size(full_path);
 	WriteMacInt32(pb + ioFlRLgLen, rf_size);
@@ -1477,9 +1476,8 @@
 		WriteMacInt16(pb + ioDrNmFls, count);
 	} else {
 		WriteMacInt16(pb + ioFlStBlk, 0);
-		uint32 file_size = (uint32) st.st_size;
-		WriteMacInt32(pb + ioFlLgLen, file_size);
-		WriteMacInt32(pb + ioFlPyLen, (file_size | (AL_BLK_SIZE - 1)) + 1);
+		WriteMacInt32(pb + ioFlLgLen, st.st_size);
+		WriteMacInt32(pb + ioFlPyLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);
 		WriteMacInt16(pb + ioFlRStBlk, 0);
 		uint32 rf_size = get_rfork_size(full_path);
 		WriteMacInt32(pb + ioFlRLgLen, rf_size);
@@ -1588,9 +1586,8 @@
 	// Initialize FCB, fd is stored in fcbCatPos
 	WriteMacInt32(fcb + fcbFlNm, fs_item->id);
 	WriteMacInt8(fcb + fcbFlags, ((flag == O_WRONLY || flag == O_RDWR) ? fcbWriteMask : 0) | (resource_fork ? fcbResourceMask : 0) | (write_ok ? 0 : fcbFileLockedMask));
-	uint32 file_size = (uint32) st.st_size;
-	WriteMacInt32(fcb + fcbEOF, file_size);
-	WriteMacInt32(fcb + fcbPLen, (file_size | (AL_BLK_SIZE - 1)) + 1);
+	WriteMacInt32(fcb + fcbEOF, st.st_size);
+	WriteMacInt32(fcb + fcbPLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);
 	WriteMacInt32(fcb + fcbCrPs, 0);
 	WriteMacInt32(fcb + fcbVPtr, vcb);
 	WriteMacInt32(fcb + fcbClmpSize, CLUMP_SIZE);
@@ -1696,13 +1693,12 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {	// "pseudo" resource fork
 			WriteMacInt32(pb + ioMisc, 0);
 			return noErr;
 		} else
 			return fnOpnErr;
-	}
 
 	// Get file size
 	struct stat st;
@@ -1710,10 +1706,9 @@
 		return errno2oserr();
 
 	// Adjust FCBs
-	uint32 file_size = (uint32) st.st_size;
-	WriteMacInt32(fcb + fcbEOF, file_size);
-	WriteMacInt32(fcb + fcbPLen, (file_size | (AL_BLK_SIZE - 1)) + 1);
-	WriteMacInt32(pb + ioMisc, file_size);
+	WriteMacInt32(fcb + fcbEOF, st.st_size);
+	WriteMacInt32(fcb + fcbPLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);
+	WriteMacInt32(pb + ioMisc, st.st_size);
 	D(bug("  adjusting FCBs\n"));
 	r.d[0] = ReadMacInt16(pb + ioRefNum);
 	Execute68k(fs_data + fsAdjustEOF, &r);
@@ -1734,12 +1729,11 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask)	// "pseudo" resource fork
 			return noErr;
 		else
 			return fnOpnErr;
-	}
 
 	// Truncate file
 	uint32 size = ReadMacInt32(pb + ioMisc);
@@ -1772,16 +1766,15 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {	// "pseudo" resource fork
 			WriteMacInt32(pb + ioPosOffset, 0);
 			return noErr;
 		} else
 			return fnOpnErr;
-	}
 
 	// Get file position
-	uint32 pos = (uint32) lseek(fd, 0, SEEK_CUR);
+	uint32 pos = lseek(fd, 0, SEEK_CUR);
 	WriteMacInt32(fcb + fcbCrPs, pos);
 	WriteMacInt32(pb + ioPosOffset, pos);
 	return noErr;
@@ -1799,13 +1792,12 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {	// "pseudo" resource fork
 			WriteMacInt32(pb + ioPosOffset, 0);
 			return noErr;
 		} else
 			return fnOpnErr;
-	}
 
 	// Set file position
 	switch (ReadMacInt16(pb + ioPosMode) & 3) {
@@ -1824,7 +1816,7 @@
 		default:
 			break;
 	}
-	uint32 pos = (uint32) lseek(fd, 0, SEEK_CUR);
+	uint32 pos = lseek(fd, 0, SEEK_CUR);
 	WriteMacInt32(fcb + fcbCrPs, pos);
 	WriteMacInt32(pb + ioPosOffset, pos);
 	return noErr;
@@ -1846,13 +1838,12 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {	// "pseudo" resource fork
 			WriteMacInt32(pb + ioActCount, 0);
 			return eofErr;
 		} else
 			return fnOpnErr;
-	}
 
 	// Seek
 	switch (ReadMacInt16(pb + ioPosMode) & 3) {
@@ -1875,7 +1866,7 @@
 	int16 read_err = errno2oserr();
 	D(bug("  actual %d\n", actual));
 	WriteMacInt32(pb + ioActCount, actual >= 0 ? actual : 0);
-	uint32 pos = (uint32) lseek(fd, 0, SEEK_CUR);
+	uint32 pos = lseek(fd, 0, SEEK_CUR);
 	WriteMacInt32(fcb + fcbCrPs, pos);
 	WriteMacInt32(pb + ioPosOffset, pos);
 	if (actual != (ssize_t)ReadMacInt32(pb + ioReqCount))
@@ -1900,13 +1891,12 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {	// "pseudo" resource fork
 			WriteMacInt32(pb + ioActCount, ReadMacInt32(pb + ioReqCount));
 			return noErr;
 		} else
 			return fnOpnErr;
-	}
 
 	// Seek
 	switch (ReadMacInt16(pb + ioPosMode) & 3) {
@@ -1929,7 +1919,7 @@
 	int16 write_err = errno2oserr();
 	D(bug("  actual %d\n", actual));
 	WriteMacInt32(pb + ioActCount, actual >= 0 ? actual : 0);
-	uint32 pos = (uint32) lseek(fd, 0, SEEK_CUR);
+	uint32 pos = lseek(fd, 0, SEEK_CUR);
 	WriteMacInt32(fcb + fcbCrPs, pos);
 	WriteMacInt32(pb + ioPosOffset, pos);
 	if (actual != (ssize_t)ReadMacInt32(pb + ioReqCount))
@@ -2162,7 +2152,7 @@
 int16 ExtFSHFS(uint32 vcb, uint16 selectCode, uint32 paramBlock, uint32 globalsPtr, int16 fsid)
 {
 	uint16 trapWord = selectCode & 0xf0ff;
-	bool hfs = (selectCode & kHFSMask) != 0;
+	bool hfs = selectCode & kHFSMask;
 	switch (trapWord) {
 		case kFSMOpen:
 			return fs_open(paramBlock, hfs ? ReadMacInt32(paramBlock + ioDirID) : 0, vcb, false);
--- macemu/SheepShaver/src/gfxaccel.cpp
+++ sheepshaver/SheepShaver/src/gfxaccel.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include "prefs.h"
 #include "video.h"
--- macemu/SheepShaver/src/include/audio.h
+++ sheepshaver/SheepShaver/src/include/audio.h
@@ -76,7 +76,7 @@
 
 extern vector<uint32> audio_sample_rates;	// Vector of supported sample rates (16.16 fixed point)
 extern vector<uint16> audio_sample_sizes;	// Vector of supported sample sizes
-extern vector<uint8> audio_channel_counts;	// Array of supported channels counts
+extern vector<uint16> audio_channel_counts;	// Array of supported channels counts
 
 // Audio component global data and 68k routines
 enum {
--- macemu/SheepShaver/src/include/clip.h
+++ sheepshaver/SheepShaver/src/include/clip.h
@@ -24,7 +24,6 @@
 extern void ClipInit(void);
 extern void ClipExit(void);
 
-extern void ZeroScrap();
 extern void PutScrap(uint32 type, void *scrap, int32 length);
 extern void GetScrap(void **handle, uint32 type, int32 offset);
 
--- macemu/SheepShaver/src/include/cpu_emulation.h
+++ sheepshaver/SheepShaver/src/include/cpu_emulation.h
@@ -58,46 +58,22 @@
 extern uint8 *ROMBaseHost;		// Base address of Mac ROM (host address space)
 
 // Mac memory access functions
-#if EMULATED_PPC
+#ifdef EMULATED_PPC
 #include "cpu/vm.hpp"
-
-#define ReadMacInt8(addr) vm_read_memory_1((vm_addr_t)addr)
-#define WriteMacInt8(addr, v) vm_write_memory_1((vm_addr_t)addr, v)
-#define ReadMacInt16(addr) vm_read_memory_2((vm_addr_t)addr)
-#define WriteMacInt16(addr, v) vm_write_memory_2((vm_addr_t)addr, v)
-#define ReadMacInt32(addr) vm_read_memory_4((vm_addr_t)addr)
-#define WriteMacInt32(addr, v) vm_write_memory_4((vm_addr_t)addr, v)
-#define ReadMacInt64(addr) vm_read_memory_8((vm_addr_t)addr)
-#define WriteMacInt64(addr, v) vm_write_memory_8((vm_addr_t)addr, v)
-#define Host2MacAddr vm_do_get_virtual_address
-#define Mac2HostAddr(addr) vm_do_get_real_address((vm_addr_t)addr)
-#define Mac_memset(addr, c, n) vm_memset((vm_addr_t)addr, c, n)
-#define Mac2Host_memcpy(dest, src, n) vm_memcpy(dest, src, n)
-#define Host2Mac_memcpy Mac2Host_memcpy
-#define Mac2Mac_memcpy Mac2Host_memcpy
-
-#define read_bswap_int_8 ReadMacInt8
-#define write_bswap_int_8 WriteMacInt8
-#define read_bswap_int_16(addr) vm_read_memory_2_reversed((vm_addr_t)addr)
-#define write_bswap_int_16(addr, v) vm_write_memory_2_reversed((vm_addr_t)addr, v)
-#define read_bswap_int_32(addr) vm_read_memory_4_reversed((vm_addr_t)addr)
-#define write_bswap_int_32(addr, v) vm_write_memory_4_reversed((vm_addr_t)addr, v)
-#define read_bswap_int_64(addr) vm_read_memory_8_reversed((vm_addr_t)addr)
-#define write_bswap_int_64(addr, v) vm_write_memory_8_reversed((vm_addr_t)addr, v)
-/*static inline uint32 ReadMacInt8(uint32 addr) {return vm_read_memory_1((vm_addr_t)addr);}
-static inline void WriteMacInt8(uint32 addr, uint32 v) {vm_write_memory_1((vm_addr_t)addr, v);}
-static inline uint32 ReadMacInt16(uint32 addr) {return vm_read_memory_2((vm_addr_t)addr);}
-static inline void WriteMacInt16(uint32 addr, uint32 v) {vm_write_memory_2((vm_addr_t)addr, v);}
-static inline uint32 ReadMacInt32(uint32 addr) {return vm_read_memory_4((vm_addr_t)addr);}
-static inline void WriteMacInt32(uint32 addr, uint32 v) {vm_write_memory_4((vm_addr_t)addr, v);}
-static inline uint64 ReadMacInt64(uint32 addr) {return vm_read_memory_8((vm_addr_t)addr);}
-static inline void WriteMacInt64(uint32 addr, uint64 v) {vm_write_memory_8((vm_addr_t)addr, v);}
+static inline uint32 ReadMacInt8(uint32 addr) {return vm_read_memory_1(addr);}
+static inline void WriteMacInt8(uint32 addr, uint32 v) {vm_write_memory_1(addr, v);}
+static inline uint32 ReadMacInt16(uint32 addr) {return vm_read_memory_2(addr);}
+static inline void WriteMacInt16(uint32 addr, uint32 v) {vm_write_memory_2(addr, v);}
+static inline uint32 ReadMacInt32(uint32 addr) {return vm_read_memory_4(addr);}
+static inline void WriteMacInt32(uint32 addr, uint32 v) {vm_write_memory_4(addr, v);}
+static inline uint64 ReadMacInt64(uint32 addr) {return vm_read_memory_8(addr);}
+static inline void WriteMacInt64(uint32 addr, uint64 v) {vm_write_memory_8(addr, v);}
 static inline uint32 Host2MacAddr(uint8 *addr) {return vm_do_get_virtual_address(addr);}
-static inline uint8 *Mac2HostAddr(uint32 addr) {return vm_do_get_real_address((vm_addr_t)addr);}
-static inline void *Mac_memset(uint32 addr, int c, size_t n) {return vm_memset((vm_addr_t)addr, c, n);}
+static inline uint8 *Mac2HostAddr(uint32 addr) {return vm_do_get_real_address(addr);}
+static inline void *Mac_memset(uint32 addr, int c, size_t n) {return vm_memset(addr, c, n);}
 static inline void *Mac2Host_memcpy(void *dest, uint32 src, size_t n) {return vm_memcpy(dest, src, n);}
 static inline void *Host2Mac_memcpy(uint32 dest, const void *src, size_t n) {return vm_memcpy(dest, src, n);}
-static inline void *Mac2Mac_memcpy(uint32 dest, uint32 src, size_t n) {return vm_memcpy(dest, src, n);}*/
+static inline void *Mac2Mac_memcpy(uint32 dest, uint32 src, size_t n) {return vm_memcpy(dest, src, n);}
 #else
 static inline uint32 ReadMacInt8(uint32 addr) {return *(uint8 *)addr;}
 static inline void WriteMacInt8(uint32 addr, uint32 b) {*(uint8 *)addr = b;}
@@ -124,24 +100,22 @@
 #ifdef WORDS_BIGENDIAN
 #define PW(W) W
 #else
-#define PW(X) bswap_16(X)
-/*#define PW(X) ((((X) >> 8) & 0xff) | (((X) & 0xff) << 8))*/
+#define PW(X) ((((X) >> 8) & 0xff) | (((X) & 0xff) << 8))
 #endif
 
 // PowerPC procedure helper to write a big-endian 32-bit word
 #ifdef WORDS_BIGENDIAN
 #define PL(X) X
 #else
-#define PL(X) bswap_32(X)
-/*#define PL(X)													\
+#define PL(X)													\
      ((((X) & 0xff000000) >> 24) | (((X) & 0x00ff0000) >>  8) |	\
-      (((X) & 0x0000ff00) <<  8) | (((X) & 0x000000ff) << 24))*/
+      (((X) & 0x0000ff00) <<  8) | (((X) & 0x000000ff) << 24))
 #endif
 
 struct M68kRegisters;
 extern void Execute68k(uint32, M68kRegisters *r);			// Execute 68k subroutine from EMUL_OP routine, must be ended with RTS
 extern void Execute68kTrap(uint16 trap, M68kRegisters *r);	// Execute 68k A-Trap from EMUL_OP routine
-#if EMULATED_PPC
+#ifdef EMULATED_PPC
 extern void FlushCodeCache(uintptr start, uintptr end);		// Invalidate emulator caches
 #endif
 extern void ExecuteNative(int selector);					// Execute native code from EMUL_OP routine (real mode switch)
--- macemu/SheepShaver/src/include/debug.h
+++ sheepshaver/SheepShaver/src/include/debug.h
@@ -30,62 +30,24 @@
 #include <sys/types.h>
 #include <sys/timeb.h>
 
-static inline void _cdecl vwinbug(const char *s, va_list vargs)
+static inline void _cdecl winbug( const char *s, ...)
 {
+	va_list vargs;
 	char msg[1024], date[50], hours[50];
 	struct _timeb tstruct;
 
 	_ftime( &tstruct );
 	_strtime( hours );
 	_strdate( date );
-	_snprintf( msg, lengthof(msg), "B2: %s %s:%03u ", date, hours, tstruct.millitm );
+	sprintf( msg, "B2: %s %s:%03u ", date, hours, tstruct.millitm );
+	
+	va_start( vargs, s );
+	vsprintf( &msg[strlen(msg)], s, vargs );
+	va_end( vargs );
 
-	char *rest = &msg[strlen(msg)];
-	_vsnprintf( rest, lengthof(msg) - (rest - msg), s, vargs );
-
-	OutputDebugStringA(msg);
+	printf(msg);
 }
-static inline void _cdecl vwwinbug( const wchar_t *s, va_list vargs)
-{
-	wchar_t msg[1024], date[50], hours[50];
-	struct _timeb tstruct;
-
-	_ftime( &tstruct );
-	_wstrtime( hours );
-	_wstrdate( date );
-	_snwprintf( msg, lengthof(msg), L"B2: %s %s:%03u ", date, hours, tstruct.millitm );
-
-	wchar_t *rest = &msg[wcslen(msg)];
-	_vsnwprintf( rest, lengthof(msg) - (rest - msg), s, vargs );
-
-	OutputDebugStringW(msg);
-}
-static inline void _cdecl winbug( const char *s, ...)
-{
-	va_list vargs;
-	va_start(vargs, s);
-	vwinbug(s, vargs);
-	va_end(vargs);
-}
-static inline void _cdecl wwinbug(const wchar_t *s, ...)
-{
-	va_list vargs;
-	va_start(vargs, s);
-	vwwinbug(s, vargs);
-	va_end(vargs);
-}
-
-#ifdef __cplusplus
-static inline void _cdecl winbug(wchar_t *s, ...)
-{
-	va_list vargs;
-	va_start(vargs, s);
-	vwwinbug(s, vargs);
-	va_end(vargs);
-}
-#endif
 #define bug winbug
-#define wbug wwinbug
 
 #elif defined(AMIGA)
 
--- macemu/SheepShaver/src/include/emul_op.h
+++ sheepshaver/SheepShaver/src/include/emul_op.h
@@ -44,7 +44,7 @@
 	OP_DISK_OPEN, OP_DISK_PRIME, OP_DISK_CONTROL, OP_DISK_STATUS,
 	OP_CDROM_OPEN, OP_CDROM_PRIME, OP_CDROM_CONTROL, OP_CDROM_STATUS,
 	OP_AUDIO_DISPATCH, OP_SOUNDIN_OPEN, OP_SOUNDIN_PRIME, OP_SOUNDIN_CONTROL, OP_SOUNDIN_STATUS, OP_SOUNDIN_CLOSE,
-	OP_ADBOP, OP_INSTIME, OP_RMVTIME, OP_PRIMETIME, OP_MICROSECONDS, OP_ZERO_SCRAP, OP_PUT_SCRAP, OP_GET_SCRAP,
+	OP_ADBOP, OP_INSTIME, OP_RMVTIME, OP_PRIMETIME, OP_MICROSECONDS, OP_PUT_SCRAP, OP_GET_SCRAP,
 	OP_DEBUG_STR, OP_INSTALL_DRIVERS, OP_NAME_REGISTRY, OP_RESET, OP_IRQ,
 	OP_SCSI_DISPATCH, OP_SCSI_ATOMIC,
 	OP_CHECK_SYSV, OP_NTRB_17_PATCH, OP_NTRB_17_PATCH2, OP_NTRB_17_PATCH3, OP_NTRB_17_PATCH4, OP_CHECKLOAD,
@@ -87,7 +87,6 @@
 const uint16 M68K_EMUL_OP_RMVTIME = M68K_EMUL_BREAK + OP_RMVTIME;
 const uint16 M68K_EMUL_OP_PRIMETIME = M68K_EMUL_BREAK + OP_PRIMETIME;
 const uint16 M68K_EMUL_OP_MICROSECONDS = M68K_EMUL_BREAK + OP_MICROSECONDS;
-const uint16 M68K_EMUL_OP_ZERO_SCRAP = M68K_EMUL_BREAK + OP_ZERO_SCRAP;
 const uint16 M68K_EMUL_OP_PUT_SCRAP = M68K_EMUL_BREAK + OP_PUT_SCRAP;
 const uint16 M68K_EMUL_OP_GET_SCRAP = M68K_EMUL_BREAK + OP_GET_SCRAP;
 const uint16 M68K_EMUL_OP_DEBUG_STR = M68K_EMUL_BREAK + OP_DEBUG_STR;
--- macemu/SheepShaver/src/include/ether_defs.h
+++ sheepshaver/SheepShaver/src/include/ether_defs.h
@@ -27,7 +27,7 @@
 #define PACKED__
 #elif defined __GNUC__
 #define PACKED__ __attribute__ ((packed))
-#elif defined __sgi
+#elif defined(__sgi) || defined(_MSC_VER)
 #define PRAGMA_PACK_SUPPORTED 1
 #define PACKED__
 #else
@@ -518,7 +518,7 @@
 #endif
 
 #ifdef PRAGMA_PACK_SUPPORTED
-#pragma pack(1)
+#pragma pack(push,1)
 #endif
 
 // Packet headers
@@ -553,7 +553,7 @@
 } PACKED__;
 
 #ifdef PRAGMA_PACK_SUPPORTED
-#pragma pack(0)
+#pragma pack(pop)
 #endif
 
 #ifdef PRAGMA_ALIGN_SUPPORTED
--- macemu/SheepShaver/src/include/extfs_defs.h
+++ sheepshaver/SheepShaver/src/include/extfs_defs.h
@@ -185,7 +185,7 @@
 	dtmvVRefNum					= 2,
 	dtmvWDRefNum				= 3,
 	dtmvDriveNum				= 4,
-	dtmvDefault					= 5
+	dtmvDefault					= 5	
 };
 
 // Miscellaneous constants used by FSM
--- macemu/SheepShaver/src/include/macos_util.h
+++ sheepshaver/SheepShaver/src/include/macos_util.h
@@ -298,7 +298,7 @@
 };
 
 
-/*
+/* 
  *  Definitions for Mixed Mode Manager
  */
 
@@ -357,7 +357,6 @@
 extern void InitCallUniversalProc(void);				// Init CallUniversalProc()
 extern long CallUniversalProc(void *upp, uint32 info);	// CallUniversalProc()
 extern uint32 TimeToMacTime(time_t t);					// Convert time_t value to MacOS time
-extern time_t MacTimeToTime(uint32 t);				// Convert MacOS time to time_t value
 extern uint32 Mac_sysalloc(uint32 size);				// Allocate block in MacOS system heap zone
 extern void Mac_sysfree(uint32 addr);					// Release block occupied by the nonrelocatable block p
 
Only in macemu/: SheepShaver/src/include/pict.h
--- macemu/SheepShaver/src/include/thunks.h
+++ sheepshaver/SheepShaver/src/include/thunks.h
@@ -22,7 +22,6 @@
 #define THUNKS_H
 
 #include "cpu_emulation.h"
-#include <assert.h>
 
 /*
  *  Native function invocation
@@ -78,7 +77,7 @@
 extern void ThunksExit(void);
 
 // Return the fake PowerPC opcode to handle specified native code
-#if EMULATED_PPC
+#ifdef EMULATED_PPC
 extern uint32 NativeOpcode(int selector);
 #endif
 
@@ -115,7 +114,7 @@
 class SheepMem {
 	static uint32 align(uint32 size);
 protected:
-	/*static uint32  page_size;*/
+	static uint32  page_size;
 	static uintptr zero_page;
 	static uintptr base;
 	static uintptr data;
--- macemu/SheepShaver/src/include/user_strings.h
+++ sheepshaver/SheepShaver/src/include/user_strings.h
@@ -166,7 +166,6 @@
 	// Mac window
 	STR_WINDOW_TITLE = 4000,
 	STR_WINDOW_TITLE_FROZEN,
-	STR_WINDOW_TITLE_GRABBED,
 	STR_WINDOW_MENU = 4050,
 	STR_WINDOW_ITEM_ABOUT,
 	STR_WINDOW_ITEM_REFRESH,
--- macemu/SheepShaver/src/include/version.h
+++ sheepshaver/SheepShaver/src/include/version.h
@@ -22,6 +22,6 @@
 #define VERSION_H
 
 const int VERSION_MAJOR = 2;
-const int VERSION_MINOR = 4;
+const int VERSION_MINOR = 3;
 
 #endif
--- macemu/SheepShaver/src/include/video_defs.h
+++ sheepshaver/SheepShaver/src/include/video_defs.h
@@ -25,10 +25,10 @@
 #include <stddef.h>
 
 
-/*
+/* 
  * Definitions for Display Manager
  */
-
+ 
 /* csMode values describing pixel depth in VDSwitchInfo */
 enum {
 	firstVidMode=128,						// first depth mode, representing lowest supported
@@ -45,7 +45,7 @@
 	kFixedModeCRTConnect,					// very limited displays
 	kMultiModeCRT1Connect,					// 12" optional, 13" default, 16" required
 	kMultiModeCRT2Connect,					// 12" optional, 13" req., 16" def., 19" req.
-	kMultiModeCRT3Connect,					// 12" optional, 13" req., 16" req., 19" req.,21" def.
+	kMultiModeCRT3Connect,					// 12" optional, 13" req., 16" req., 19" req.,21" def. 
 	kMultiModeCRT4Connect,					// expansion to large multimode (not yet implemented)
 	kModelessConnect,						// expansion to modeless model (not yet implemented)
 	kFullPageConnect,						// 640x818 (to get 8bpp in 512K case) and
@@ -60,7 +60,7 @@
 
 /* csConnectFlags values in VDDisplayConnectInfoRec */
 enum {
-	kAllModesValid=0,						// all display modes not deleted by PrimaryInit code
+	kAllModesValid=0,						// all display modes not deleted by PrimaryInit code 
 											// are optional
 	kAllModesSafe,							// all display modes not deleted by PrimaryInit code
 											// are required; is you set this bit, set the
@@ -78,7 +78,7 @@
 #define kDeclROMtables FOURCC('d','e','c','l')	// use information in this record instead of looking
 												// in the decl. ROM for timing info; used for patching
 												// existing card without updating declaration ROM
-
+										
 /* csTimingData values in VDTimingInfoRec */
 enum {
 	timingUnknown = 0,						// unknown timing
@@ -124,8 +124,8 @@
 enum {
 	kModeValid=0,							// this display mode is optional
 	kModeSafe,								// this display mode is required; if you set this
-											// bit, you should also set the kModeValid bit
-	kModeDefault,							// this display mode is the default for the attached
+											// bit, you should also set the kModeValid bit 
+	kModeDefault,							// this display mode is the default for the attached 
 											// display; if you set this bit, you should also set
 											// the kModeSafe and kModeValid bits
 	kShowModeNow,							// show this mode in Monitors control panel; useful
@@ -156,8 +156,8 @@
 	cscSetPowerState,
 	cscPrivateControlCall,				// Takes a VDPrivateSelectorDataRec
 	cscSetMultiConnect,					// From a GDI point of view, this call should be implemented completely in the HAL and not at all in the core.
-	cscSetClutBehavior,					// Takes a VDClutBehavior
-	cscUnusedCall=127					// This call used to expend the scrn resource.  Its imbedded data contains more control info
+	cscSetClutBehavior,					// Takes a VDClutBehavior 
+	cscUnusedCall=127					// This call used to expend the scrn resource.  Its imbedded data contains more control info 
 };
 
 /* Constants for the GetNextResolution call */
@@ -174,9 +174,9 @@
 	cscGetMode=2,
 	cscGetEntries,
 	cscGetPageCnt,
-	cscGetPages=4,					// This is what C&D 2 calls it.
+	cscGetPages=4,					// This is what C&D 2 calls it. 
 	cscGetPageBase,
-	cscGetBaseAddr=5,				// This is what C&D 2 calls it.
+	cscGetBaseAddr=5,				// This is what C&D 2 calls it. 
 	cscGetGray,
 	cscGetInterrupt,
 	cscGetGamma,
@@ -186,8 +186,8 @@
 	cscGetConnection,				// return information about display capabilities of
 									// connected display
 	cscGetModeTiming,				// return scan timings data for a display mode
-	cscGetModeBaseAddress,			// Return base address information about a particular mode
-	cscGetScanProc,					// QuickTime scan chasing routine
+	cscGetModeBaseAddress,			// Return base address information about a particular mode 
+	cscGetScanProc,					// QuickTime scan chasing routine 
 	cscGetPreferredConfiguration,
 	cscGetNextResolution,
 	cscGetVideoParameters,
@@ -198,10 +198,10 @@
 	cscGetConvolution,
 	cscGetPowerState,
 	cscPrivateStatusCall,			// Takes a VDPrivateSelectorDataRec
-	cscGetDDCBlock,					// Takes a VDDDCBlockRec
+	cscGetDDCBlock,					// Takes a VDDDCBlockRec  
 	cscGetMultiConnect,				// From a GDI point of view, this call should be implemented completely in the HAL and not at all in the core.
-	cscGetClutBehavior				// Takes a VDClutBehavior
-};
+	cscGetClutBehavior				// Takes a VDClutBehavior 
+};	
 
 enum {	// VDSwitchInfo struct
 	csMode = 0,
--- macemu/SheepShaver/src/include/xpram.h
+++ sheepshaver/SheepShaver/src/include/xpram.h
@@ -37,10 +37,4 @@
 extern void SaveXPRAM(void);
 extern void ZapPRAM(void);
 
-extern bool getXPRAMat(size_t off, uint8* out);
-extern bool setXPRAMat(size_t off, uint8 byte);
-
-extern size_t XPRAMtoString( const char* symbols );
-extern char* dumpXPRAM();
-
 #endif
Only in macemu/: SheepShaver/src/kpx_cpu/dis-asm.h
--- macemu/SheepShaver/src/kpx_cpu/include/basic-cpu.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/include/basic-cpu.hpp
@@ -35,7 +35,7 @@
 	uint64 j;
 	float  f;
 	double d;
-
+	
 	// Explicit casts may be required to use those constructors
 	any_register(uint32 v = 0)	: i(v) { }
 	any_register(uint64 v)		: j(v) { }
@@ -46,6 +46,8 @@
 /**
  *		Basic CPU model
  **/
+
+struct task_struct;
 
 struct basic_cpu
 	: public task_plugin
--- macemu/SheepShaver/src/kpx_cpu/include/task-plugin.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/include/task-plugin.hpp
@@ -24,9 +24,9 @@
 #include "basic-plugin.hpp"
 
 // Forward declarations
-class task_struct;
+struct task_struct;
 class basic_kernel;
-class basic_cpu;
+struct basic_cpu;
 class program_info;
 
 // Base class for all task components
Only in macemu/: SheepShaver/src/kpx_cpu/ppc-dis.c
--- macemu/SheepShaver/src/kpx_cpu/sheepshaver_glue.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/sheepshaver_glue.cpp
@@ -18,6 +18,10 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "sysdeps.h"
 #include "cpu_emulation.h"
 #include "main.h"
@@ -58,10 +62,6 @@
 #define DEBUG 0
 #include "debug.h"
 
-extern "C" {
-#include "dis-asm.h"
-}
-
 // Emulation time statistics
 #ifndef EMUL_TIME_STATS
 #define EMUL_TIME_STATS 0
@@ -83,7 +83,7 @@
 {
 	// Start up mon in real-mode
 #if ENABLE_MON
-	const char *arg[4] = {"mon", "-m", "-r", NULL};
+	char *arg[4] = {"mon", "-m", "-r", NULL};
 	mon(3, arg);
 #endif
 }
@@ -417,7 +417,7 @@
 		cg_context.done_compile = true;
 		status = COMPILE_EPILOGUE_OK;
 		break;
-#else
+#endif
 		// Invoke NativeOp handler
 		if (!FN_field::test(opcode)) {
 			typedef void (*func_t)(dyngen_cpu_base, uint32);
@@ -429,7 +429,6 @@
 		// Otherwise, let it generate a call to execute_sheep() which
 		// will cause necessary updates to the program counter
 		break;
-#endif
 	}
 
 	default: {	// EMUL_OP
@@ -442,7 +441,7 @@
 		cg_context.done_compile = true;
 		status = COMPILE_EPILOGUE_OK;
 		break;
-#else
+#endif
 		// Invoke EmulOp handler
 		typedef void (*func_t)(dyngen_cpu_base, uint32);
 		func_t func = (func_t)nv_mem_fun(&sheepshaver_cpu::execute_emul_op).ptr();
@@ -450,7 +449,6 @@
 		cg_context.done_compile = false;
 		status = COMPILE_CODE_OK;
 		break;
-#endif
 	}
 	}
 	return status;
@@ -478,10 +476,10 @@
 	SheepVar32 trampoline = POWERPC_EXEC_RETURN;
 
 	// Prepare registers for nanokernel interrupt routine
-	WriteMacInt32(KERNEL_DATA_BASE + 0x004, gpr(1));
-	WriteMacInt32(KERNEL_DATA_BASE + 0x018, gpr(6));
+	kernel_data->v[0x004 >> 2] = htonl(gpr(1));
+	kernel_data->v[0x018 >> 2] = htonl(gpr(6));
 
-	gpr(6) = ReadMacInt32(KERNEL_DATA_BASE + 0x65c);
+	gpr(6) = ntohl(kernel_data->v[0x65c >> 2]);
 	assert(gpr(6) != 0);
 	WriteMacInt32(gpr(6) + 0x13c, gpr(7));
 	WriteMacInt32(gpr(6) + 0x144, gpr(8));
@@ -492,7 +490,7 @@
 	WriteMacInt32(gpr(6) + 0x16c, gpr(13));
 
 	gpr(1)  = KernelDataAddr;
-	gpr(7)  = ReadMacInt32(KERNEL_DATA_BASE + 0x660);
+	gpr(7)  = ntohl(kernel_data->v[0x660 >> 2]);
 	gpr(8)  = 0;
 	gpr(10) = trampoline.addr();
 	gpr(12) = trampoline.addr();
@@ -564,14 +562,14 @@
 	gpr(25) = ReadMacInt32(XLM_68K_R25);		// MSB of SR
 	gpr(26) = 0;
 	gpr(28) = 0;								// VBR
-	gpr(29) = ReadMacInt32(KERNEL_DATA_BASE + 0x1074);		// Pointer to opcode table
-	gpr(30) = ReadMacInt32(KERNEL_DATA_BASE + 0x1078);		// Address of emulator
+	gpr(29) = ntohl(kernel_data->ed.v[0x74 >> 2]);		// Pointer to opcode table
+	gpr(30) = ntohl(kernel_data->ed.v[0x78 >> 2]);		// Address of emulator
 	gpr(31) = KernelDataAddr + 0x1000;
 
 	// Push return address (points to EXEC_RETURN opcode) on stack
 	gpr(1) -= 4;
 	WriteMacInt32(gpr(1), XLM_EXEC_RETURN_OPCODE);
-
+	
 	// Rentering 68k emulator
 	WriteMacInt32(XLM_RUN_MODE, MODE_68K);
 
@@ -580,8 +578,7 @@
 
 	// Execute 68k opcode
 	uint32 opcode = ReadMacInt16(gpr(24));
-	gpr(27) = (int32)(int16)ReadMacInt16(gpr(24) + 2);
-	gpr(24) += 2;
+	gpr(27) = (int32)(int16)ReadMacInt16(gpr(24) += 2);
 	gpr(29) += opcode * 8;
 	execute(gpr(29));
 
@@ -733,28 +730,10 @@
 	ppc_cpu->dump_log();
 }
 
-static int read_mem(bfd_vma memaddr, bfd_byte *myaddr, int length, struct disassemble_info *info)
-{
-	Mac2Host_memcpy(myaddr, memaddr, length);
-	return 0;
-}
+/*
+ *  Initialize CPU emulation
+ */
 
-static void dump_disassembly(const uint32 pc, const int prefix_count, const int suffix_count)
-{
-	struct disassemble_info info;
-	INIT_DISASSEMBLE_INFO(info, stderr, fprintf);
-	info.read_memory_func = read_mem;
-
-	const int count = prefix_count + suffix_count + 1;
-	const uint32 base_addr = pc - prefix_count * 4;
-	for (int i = 0; i < count; i++) {
-		const bfd_vma addr = base_addr + i * 4;
-		fprintf(stderr, "%s0x%8llx:  ", addr == pc ? " >" : "  ", addr);
-		print_insn_ppc(addr, &info);
-		fprintf(stderr, "\n");
-	}
-}
-
 sigsegv_return_t sigsegv_handler(sigsegv_info_t *sip)
 {
 #if ENABLE_VOSF
@@ -773,29 +752,29 @@
 	// Get program counter of target CPU
 	sheepshaver_cpu * const cpu = ppc_cpu;
 	const uint32 pc = cpu->pc();
-
+	
 	// Fault in Mac ROM or RAM?
-	bool mac_fault = (pc >= ROMBase && pc < (ROMBase + ROM_AREA_SIZE)) || (pc >= RAMBase && pc < (RAMBase + RAMSize)) || (pc >= DR_CACHE_BASE && pc < (DR_CACHE_BASE + DR_CACHE_SIZE));
+	bool mac_fault = (pc >= ROMBase) && (pc < (ROMBase + ROM_AREA_SIZE)) || (pc >= RAMBase) && (pc < (RAMBase + RAMSize)) || (pc >= DR_CACHE_BASE && pc < (DR_CACHE_BASE + DR_CACHE_SIZE));
 	if (mac_fault) {
 
 		// "VM settings" during MacOS 8 installation
 		if (pc == ROMBase + 0x488160 && cpu->gpr(20) == 0xf8000000)
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
-
+	
 		// MacOS 8.5 installation
 		else if (pc == ROMBase + 0x488140 && cpu->gpr(16) == 0xf8000000)
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
-
+	
 		// MacOS 8 serial drivers on startup
 		else if (pc == ROMBase + 0x48e080 && (cpu->gpr(8) == 0xf3012002 || cpu->gpr(8) == 0xf3012000))
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
-
+	
 		// MacOS 8.1 serial drivers on startup
 		else if (pc == ROMBase + 0x48c5e0 && (cpu->gpr(20) == 0xf3012002 || cpu->gpr(20) == 0xf3012000))
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
 		else if (pc == ROMBase + 0x4a10a0 && (cpu->gpr(20) == 0xf3012002 || cpu->gpr(20) == 0xf3012000))
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
-
+	
 		// MacOS 8.6 serial drivers on startup (with DR Cache and OldWorld ROM)
 		else if ((pc - DR_CACHE_BASE) < DR_CACHE_SIZE && (cpu->gpr(16) == 0xf3012002 || cpu->gpr(16) == 0xf3012000))
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
@@ -803,8 +782,8 @@
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
 
 		// Ignore writes to the zero page
-		/*else if ((uint32)(addr - SheepMem::ZeroPage()) < (uint32)SheepMem::PageSize())
-			return SIGSEGV_RETURN_SKIP_INSTRUCTION;*/
+		else if ((uint32)(addr - SheepMem::ZeroPage()) < (uint32)SheepMem::PageSize())
+			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
 
 		// Ignore all other faults, if requested
 		if (PrefsFindBool("ignoresegv"))
@@ -818,19 +797,13 @@
 	fprintf(stderr, "  pc %p\n", sigsegv_get_fault_instruction_address(sip));
 	fprintf(stderr, "  ea %p\n", sigsegv_get_fault_address(sip));
 	dump_registers();
-	dump_log();
-	dump_disassembly(pc, 8, 8);
-
+	ppc_cpu->dump_log();
 	enter_mon();
 	QuitEmulator();
 
 	return SIGSEGV_RETURN_FAILURE;
 }
 
-/*
- *  Initialize CPU emulation
- */
-
 void init_emul_ppc(void)
 {
 	// Get pointer to KernelData in host address space
@@ -906,7 +879,7 @@
 	// NativeOp
 	native_op_trampoline = dg.gen_start();
 	func = (func_t)nv_mem_fun(&sheepshaver_cpu::execute_native_op).ptr();
-	dg.gen_invoke_CPU_T0(func);
+	dg.gen_invoke_CPU_T0(func);	
 	dg.gen_exec_return();
 	dg.gen_end();
 
@@ -964,21 +937,22 @@
 	switch (ReadMacInt32(XLM_RUN_MODE)) {
 	case MODE_68K:
 		// 68k emulator active, trigger 68k interrupt level 1
-		WriteMacInt16(ReadMacInt32(KERNEL_DATA_BASE + 0x67c), 1);
-		r->cr.set(r->cr.get() | ReadMacInt32(KERNEL_DATA_BASE + 0x674));
+		WriteMacInt16(tswap32(kernel_data->v[0x67c >> 2]), 1);
+		r->cr.set(r->cr.get() | tswap32(kernel_data->v[0x674 >> 2]));
 		break;
-
+    
 #if INTERRUPTS_IN_NATIVE_MODE
 	case MODE_NATIVE:
 		// 68k emulator inactive, in nanokernel?
 		if (r->gpr[1] != KernelDataAddr) {
 
 			// Prepare for 68k interrupt level 1
-			WriteMacInt16(ReadMacInt32(KERNEL_DATA_BASE + 0x67c), 1);
-			WriteMacInt32(ReadMacInt32(KERNEL_DATA_BASE + 0x658) + 0xdc,
-			ReadMacInt32(ReadMacInt32(KERNEL_DATA_BASE + 0x658) + 0xdc)
-						  | ReadMacInt32(KERNEL_DATA_BASE + 0x674));
-      			// Execute nanokernel interrupt routine (this will activate the 68k emulator)
+			WriteMacInt16(tswap32(kernel_data->v[0x67c >> 2]), 1);
+			WriteMacInt32(tswap32(kernel_data->v[0x658 >> 2]) + 0xdc,
+						  ReadMacInt32(tswap32(kernel_data->v[0x658 >> 2]) + 0xdc)
+						  | tswap32(kernel_data->v[0x674 >> 2]));
+      
+			// Execute nanokernel interrupt routine (this will activate the 68k emulator)
 			DisableInterrupt();
 			if (ROMType == ROMTYPE_NEWWORLD)
 				ppc_cpu->interrupt(ROMBase + 0x312b1c);
@@ -987,7 +961,7 @@
 		}
 		break;
 #endif
-
+    
 #if INTERRUPTS_IN_EMUL_OP_MODE
 	case MODE_EMUL_OP:
 		// 68k emulator active, within EMUL_OP routine, execute 68k interrupt routine directly when interrupt level is 0
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/block-cache.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/block-cache.hpp
@@ -23,6 +23,8 @@
 
 #include "block-alloc.hpp"
 
+#define GATHER_BLOCK_CACHE_STATISTICS 0
+
 template< class block_info, template<class T> class block_allocator = slow_allocator >
 class block_cache
 {
@@ -40,7 +42,7 @@
 		entry **				prev_p;
 	};
 
-	block_allocator<entry>		allocator;
+	block_allocator<entry>				allocator;
 	entry *						cache_tags[HASH_SIZE];
 	entry *						active;
 	entry *						dormant;
@@ -49,11 +51,22 @@
 		return (addr >> 2) & HASH_MASK;
 	}
 
+#if GATHER_BLOCK_CACHE_STATISTICS
+	struct {
+		uint32 searches;
+		uint32 hits;
+		uint32 misses;
+		uint32 faults;
+	} stats;
+#endif
+
 public:
 
 	block_cache();
 	~block_cache();
 
+	void print_statistics();
+
 	block_info *new_blockinfo();
 	void delete_blockinfo(block_info *bi);
 
@@ -78,6 +91,9 @@
 block_cache< block_info, block_allocator >::block_cache()
 	: active(NULL), dormant(NULL)
 {
+#if GATHER_BLOCK_CACHE_STATISTICS
+	memset(&stats, 0, sizeof(stats));
+#endif
 	initialize();
 }
 
@@ -183,25 +199,76 @@
 template< class block_info, template<class T> class block_allocator >
 block_info *block_cache< block_info, block_allocator >::find(uintptr pc)
 {
+	const uint32 cl = cacheline(pc);
+
+#if GATHER_BLOCK_CACHE_STATISTICS
+	stats.searches++;
+#endif
+
 	// Hit: return immediately
-	entry * bce = cache_tags[cacheline(pc)];
-	if (bce && bce->pc == pc)
+	entry * bce = cache_tags[cl];
+	if (bce && bce->pc == pc) {
+#if GATHER_BLOCK_CACHE_STATISTICS
+		stats.hits++;
+#endif
 		return bce;
+	}
 
 	// Miss: perform full list search and move block to front if found
 	while (bce) {
 		bce = bce->next_same_cl;
 		if (bce && bce->pc == pc) {
 			raise_in_cl_list(bce);
+#if GATHER_BLOCK_CACHE_STATISTICS
+			stats.misses++;
+#endif
 			return bce;
 		}
 	}
 
 	// Found none, will have to create a new block
+#if GATHER_BLOCK_CACHE_STATISTICS
+	stats.faults++;
+#endif
 	return NULL;
 }
 
 template< class block_info, template<class T> class block_allocator >
+void block_cache< block_info, block_allocator >::print_statistics()
+{
+#if GATHER_BLOCK_CACHE_STATISTICS
+	fprintf(stderr, "[Block Cache] Search Statistics: %9u searches, %9u hits, %9u misses, %9u faults\n",
+		stats.searches, stats.hits, stats.misses, stats.faults);
+	double hit_percent = (double)stats.hits / (double)stats.searches * 100.0,
+		miss_percent = (double)stats.misses / (double)stats.searches * 100.0,
+		fault_percent = (double)stats.faults / (double)stats.searches * 100.0;
+	fprintf(stderr, "[Block Cache] In percentages: %3.2lf%% hits, %3.2lf%% misses, %3.2lf%% faults\n",
+		hit_percent, miss_percent, fault_percent);
+	memset(&stats, 0, sizeof(stats));
+	uint32 c = 0, min = (uint32)-1, max = 0, average = 0;
+	for(uint32 cl = 0; cl < HASH_SIZE; cl++) {
+		if (cache_tags[cl] != NULL) {
+			c++;
+			entry *e = cache_tags[cl];
+			uint32 ct = 0;
+			while (e) {
+				e = e->next_same_cl;
+				ct++;
+			}
+			if (ct > max) max = ct;
+			if (ct < min) min = ct;
+			average += ct;
+		}
+	}
+	average /= c;
+	fprintf(stderr, "[Block Cache] %u of %u cache lines contain data\n",
+		c, HASH_SIZE);
+	fprintf(stderr, "[Block Cache] Line fill min: %u, max: %u, avg: %u\n",
+		min, max, average);
+#endif
+}
+
+template< class block_info, template<class T> class block_allocator >
 void block_cache< block_info, block_allocator >::remove_from_cl_list(block_info *bi)
 {
 	entry * bce = (entry *)bi;
@@ -219,7 +286,7 @@
 	if (cache_tags[cl])
 		cache_tags[cl]->prev_same_cl_p = &bce->next_same_cl;
 	bce->next_same_cl = cache_tags[cl];
-
+	
 	cache_tags[cl] = bce;
 	bce->prev_same_cl_p = &cache_tags[cl];
 }
@@ -245,11 +312,11 @@
 void block_cache< block_info, block_allocator >::add_to_active_list(block_info *bi)
 {
 	entry * bce = (entry *)bi;
-
+	
 	if (active)
 		active->prev_p = &bce->next;
 	bce->next = active;
-
+	
 	active = bce;
 	bce->prev_p = &active;
 }
@@ -258,11 +325,11 @@
 void block_cache< block_info, block_allocator >::add_to_dormant_list(block_info *bi)
 {
 	entry * bce = (entry *)bi;
-
+	
 	if (dormant)
 		dormant->prev_p = &bce->next;
 	bce->next = dormant;
-
+	
 	dormant = bce;
 	bce->prev_p = &dormant;
 }
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/amd64/dyngen-target-exec.h
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/amd64/dyngen-target-exec.h
@@ -34,7 +34,7 @@
 
 #define AREG1 "r12"
   AREG1_ID = 12,
-
+    
 #define AREG2 "r13"
   AREG2_ID = 13,
 
@@ -43,7 +43,7 @@
 
 #define AREG4 "r15"
   AREG4_ID = 15,
-
+    
 #else
 
 #define AREG1 "rbx"
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/basic-dyngen.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/basic-dyngen.cpp
@@ -147,9 +147,9 @@
 		f32_1, f32_2, f32_3, f32_4, f32_5, f32_6, f32_7, f32_8,
 		f32_9, f32_10, f32_11, f32_12, f32_13, f32_14, f32_15
 	};
+	static const uint8 prefixes[4] = { 0x66, 0x66, 0x66, 0x66 };
 
 #if defined(__x86_64__)
-	static const uint8 prefixes[4] = { 0x66, 0x66, 0x66, 0x66 };
 	/* The recommended way to pad 64bit code is to use NOPs preceded by
 	   maximally four 0x66 prefixes.  Balance the size of nops.  */
 	int i;
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/cxxdemangle.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/cxxdemangle.cpp
@@ -500,7 +500,7 @@
 demangle_qualifier PARAMS ((int));
 
 static int
-demangle_expression PARAMS ((work_stuff *, const char **, string *,
+demangle_expression PARAMS ((work_stuff *, const char **, string *, 
 			     type_kind_t));
 
 static int
@@ -1588,7 +1588,7 @@
     {
       if (**mangled == 'Q')
 	success = demangle_qualified (work, mangled, s,
-				      /*isfuncname=*/0,
+				      /*isfuncname=*/0, 
 				      /*append=*/1);
       else
 	{
@@ -3250,7 +3250,7 @@
 	    else if (**mangled == 'Q')
 	      {
 		success = demangle_qualified (work, mangled, &decl,
-					      /*isfuncnam=*/0,
+					      /*isfuncnam=*/0, 
 					      /*append=*/0);
 		if (!success)
 		  break;
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/dyngen-exec.h
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/dyngen-exec.h
@@ -71,7 +71,7 @@
 /* the symbols are considered non exported so a br immediate is generated */
 #define __hidden __attribute__((visibility("hidden")))
 #else
-#define __hidden
+#define __hidden 
 #endif
 
 #ifdef __alpha__
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/dyngen.c
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/dyngen.c
@@ -1,6 +1,6 @@
 /*
  *  Generic Dynamic compiler generator
- *
+ * 
  *  Copyright (c) 2003-2004 Fabrice Bellard
  *
  *  The COFF object format support was extracted from Kazu's QEMU port
@@ -352,8 +352,8 @@
        long  n_strx;
 #endif
    } n_un;
-   unsigned char n_type;
-   unsigned char n_sect;
+   unsigned char n_type; 
+   unsigned char n_sect; 
    short st_desc;
    unsigned long st_value;
    unsigned long st_size;
@@ -498,7 +498,7 @@
 
 /* generate op code */
 void gen_code(const char *name, const char *demangled_name,
-              host_ulong offset, host_ulong size,
+              host_ulong offset, host_ulong size, 
               FILE *outfile, int gen_switch, const char *prefix);
 void patch_relocations(FILE *outfile, const char *name, host_ulong size, host_ulong start_offset, int copy_size);
 
@@ -609,10 +609,10 @@
   } swaptest;
 
   swaptest.i = 1;
-  return (h->e_ident[EI_DATA] == ELFDATA2MSB) !=
+  return (h->e_ident[EI_DATA] == ELFDATA2MSB) != 
       (swaptest.b[0] == 0);
 }
-
+  
 void elf_swap_ehdr(elfhdr *h)
 {
     swab16s(&h->e_type);			/* Object file type */
@@ -665,7 +665,7 @@
 #endif
 }
 
-elf_shdr *find_elf_section(elf_shdr *shdr, int shnum, const char *shstr,
+elf_shdr *find_elf_section(elf_shdr *shdr, int shnum, const char *shstr, 
                                   const char *name)
 {
     int i;
@@ -690,7 +690,7 @@
 
     for(i = 0; i < ehdr.e_shnum; i++) {
         sec = &shdr[i];
-        if (sec->sh_type == type && sec->sh_info == sh_index)
+        if (sec->sh_type == type && sec->sh_info == sh_index) 
             return i;
     }
     return 0;
@@ -735,11 +735,11 @@
     elf_shdr *rodata_cst16_sec;
     uint8_t *rodata_cst16 = NULL;
     int rodata_cst16_shndx;
-
+    
     fd = open(filename, O_RDONLY);
-    if (fd < 0)
+    if (fd < 0) 
         error("can't open file '%s'", filename);
-
+    
     /* Read ELF header.  */
     if (read(fd, &ehdr, sizeof (ehdr)) != sizeof (ehdr))
         error("unable to read file header");
@@ -776,7 +776,7 @@
     /* read all section data */
     sdata = malloc(sizeof(void *) * ehdr.e_shnum);
     memset(sdata, 0, sizeof(void *) * ehdr.e_shnum);
-
+    
     for(i = 0;i < ehdr.e_shnum; i++) {
         sec = &shdr[i];
         if (sec->sh_type != SHT_NOBITS)
@@ -867,7 +867,7 @@
 
     symtab = (ElfW(Sym) *)sdata[symtab_sec - shdr];
     strtab = sdata[symtab_sec->sh_link];
-
+    
     nb_syms = symtab_sec->sh_size / sizeof(ElfW(Sym));
     if (do_swap) {
         for(i = 0, sym = symtab; i < nb_syms; i++, sym++) {
@@ -885,10 +885,8 @@
         char *demangled_name, *func_name;
         if ((demangled_name = malloc(nd)) == NULL)
             return -1;
-        if ((func_name = malloc(nf = nd)) == NULL) {
-            free(demangled_name);
+        if ((func_name = malloc(nf = nd)) == NULL)
             return -1;
-        }
 
         for(i = 0, sym = symtab; i < nb_syms; i++, sym++) {
             const char *name;
@@ -916,9 +914,6 @@
                 fprintf(outfile, "#endif\n");
             }
         }
-
-        free(func_name);
-        free(demangled_name);
     }
     return 0;
 }
@@ -947,7 +942,7 @@
 {
     char *q;
     int c, i, len;
-
+    
     if (ext_sym->e.e.e_zeroes != 0) {
         q = sym->st_name;
         for(i = 0; i < 8; i++) {
@@ -981,7 +976,7 @@
 		if (sym->st_syment->e_scnum == data_shndx &&
                     text_data >= sym->st_value &&
                     text_data < sym->st_value + sym->st_size) {
-
+                    
                     return sym->st_name;
 
 		}
@@ -1037,15 +1032,15 @@
     uint32_t *n_strtab;
     EXE_SYM *sym;
     EXE_RELOC *rel;
-
-    fd = open(filename, O_RDONLY
+	
+    fd = open(filename, O_RDONLY 
 #ifdef _WIN32
               | O_BINARY
 #endif
               );
-    if (fd < 0)
+    if (fd < 0) 
         error("can't open file '%s'", filename);
-
+    
     /* Read COFF header.  */
     if (read(fd, &fhdr, sizeof (fhdr)) != sizeof (fhdr))
         error("unable to read file header");
@@ -1058,11 +1053,11 @@
 
     /* read section headers */
     shdr = load_data(fd, sizeof(struct external_filehdr) + fhdr.f_opthdr, fhdr.f_nscns * sizeof(struct external_scnhdr));
-
+	
     /* read all section data */
     sdata = malloc(sizeof(void *) * fhdr.f_nscns);
     memset(sdata, 0, sizeof(void *) * fhdr.f_nscns);
-
+    
     const char *p;
     for(i = 0;i < fhdr.f_nscns; i++) {
         sec = &shdr[i];
@@ -1084,7 +1079,7 @@
         error("could not find .data section");
     coff_data_shndx = data_sec - shdr;
     data = sdata[coff_data_shndx];
-
+    
     coff_symtab = load_data(fd, fhdr.f_symptr, fhdr.f_nsyms*SYMESZ);
     for (i = 0, ext_sym = coff_symtab; i < nb_syms; i++, ext_sym++) {
         for(j=0;j<8;j++)
@@ -1094,8 +1089,8 @@
 
     nb_syms = fhdr.f_nsyms;
     n_strtab = load_data(fd, (fhdr.f_symptr + fhdr.f_nsyms*SYMESZ), STRTAB_SIZE);
-    strtab = load_data(fd, (fhdr.f_symptr + fhdr.f_nsyms*SYMESZ), *n_strtab);
-
+    strtab = load_data(fd, (fhdr.f_symptr + fhdr.f_nsyms*SYMESZ), *n_strtab); 
+    
     for (i = 0, ext_sym = coff_symtab; i < nb_syms; i++, ext_sym++) {
       if (strstart(ext_sym->e.e_name, ".text", NULL))
 		  text_shndx = ext_sym->e_scnum;
@@ -1140,12 +1135,12 @@
 		} else {
 			sym->st_size = 0;
 		}
-
+		
 		sym->st_type = ext_sym->e_type;
 		sym->st_shndx = ext_sym->e_scnum;
 	}
 
-
+		
     /* find text relocations, if any */
     sec = &shdr[coff_text_shndx];
     coff_relocs = load_data(fd, sec->s_relptr, sec->s_nreloc*RELSZ);
@@ -1153,7 +1148,7 @@
 
     /* set coff relocation */
     relocs = malloc(sizeof(struct coff_rel) * nb_relocs);
-    for (i = 0, ext_rel = coff_relocs, rel = relocs; i < nb_relocs;
+    for (i = 0, ext_rel = coff_relocs, rel = relocs; i < nb_relocs; 
          i++, ext_rel++, rel++) {
         memset(rel, 0, sizeof(*rel));
         rel->r_reloc = ext_rel;
@@ -1184,7 +1179,7 @@
 
 /* relocs */
 struct relocation_info *relocs;
-
+	
 /* symbols */
 EXE_SYM			*symtab;
 struct NLIST 	*symtab_std;
@@ -1204,10 +1199,10 @@
 static char *get_sym_name(EXE_SYM *sym)
 {
 	char *name = find_str_by_index(sym->n_un.n_strx);
-
+	
 	if ( sym->n_type & N_STAB ) /* Debug symbols are ignored */
 		return "debug";
-
+			
 	if(!name)
 		return name;
 	if(name[0]=='_')
@@ -1217,7 +1212,7 @@
 }
 
 /* find a section index given its segname, sectname */
-static int find_mach_sec_index(struct SECTION *section_hdr, int shnum, const char *segname,
+static int find_mach_sec_index(struct SECTION *section_hdr, int shnum, const char *segname, 
                                   const char *sectname)
 {
     int i;
@@ -1233,7 +1228,7 @@
 }
 
 /* find a section header given its segname, sectname */
-struct SECTION *find_mach_sec_hdr(struct SECTION *section_hdr, int shnum, const char *segname,
+struct SECTION *find_mach_sec_hdr(struct SECTION *section_hdr, int shnum, const char *segname, 
                                   const char *sectname)
 {
 	int index = find_mach_sec_index(section_hdr, shnum, segname, sectname);
@@ -1246,7 +1241,7 @@
 static inline void fetch_next_pair_value(struct relocation_info * rel, unsigned int *value)
 {
 	struct scattered_relocation_info * scarel;
-
+	
 	if(R_SCATTERED & rel->r_address) {
 		scarel = (struct scattered_relocation_info*)rel;
 		if(scarel->r_type != PPC_RELOC_PAIR)
@@ -1263,7 +1258,7 @@
 static const char * find_sym_with_value_and_sec_number( int value, int sectnum, int * offset )
 {
 	int i, ret = -1;
-
+	
 	for( i = 0 ; i < nb_syms; i++ )
 	{
 	    if( !(symtab[i].n_type & N_STAB) && (symtab[i].n_type & N_SECT) &&
@@ -1282,8 +1277,8 @@
 	}
 }
 
-/*
- *  Find symbol name given a (virtual) address, and a section which is of type
+/* 
+ *  Find symbol name given a (virtual) address, and a section which is of type 
  *  S_NON_LAZY_SYMBOL_POINTERS or S_LAZY_SYMBOL_POINTERS or S_SYMBOL_STUBS
  */
 static const char * find_reloc_name_in_sec_ptr(int address, struct SECTION * sec_hdr)
@@ -1294,23 +1289,23 @@
 	/* Sanity check */
 	if(!( address >= sec_hdr->addr && address < (sec_hdr->addr + sec_hdr->size) ) )
 		return (char*)0;
-
+		
 	if( sec_hdr->flags & S_SYMBOL_STUBS ){
 		size = sec_hdr->reserved2;
 		if(size == 0)
 		    error("size = 0");
-
+		
 	}
 	else if( (sec_hdr->flags & S_LAZY_SYMBOL_POINTERS) ||
 	            (sec_hdr->flags & S_NON_LAZY_SYMBOL_POINTERS) )
 		size = sizeof(unsigned long);
 	else
 		return 0;
-
+		
     /* Compute our index in toc */
 	tocindex = (address - sec_hdr->addr)/size;
 	symindex = tocdylib[sec_hdr->reserved1 + tocindex];
-
+	
 	name = get_sym_name(&symtab[symindex]);
 
 	return name;
@@ -1335,7 +1330,7 @@
 	int sectnum = rel->r_symbolnum;
 	int sectoffset;
 	unsigned int other_half=0;
-
+	
 	/* init the slide value */
 #ifdef HOST_X86_64 /* no scattered on x86_64 */
 	switch(rel->r_length)
@@ -1347,7 +1342,7 @@
 	}
 #else
 	*sslide = 0;
-
+	
 	if (R_SCATTERED & rel->r_address) {
         char *name = (char *)find_reloc_name_given_its_address(sca_rel->r_value);
 
@@ -1374,7 +1369,7 @@
 	if(rel->r_extern)
 	{
 		/* ignore debug sym */
-		if ( symtab[rel->r_symbolnum].n_type & N_STAB )
+		if ( symtab[rel->r_symbolnum].n_type & N_STAB ) 
 			return 0;
 		return get_sym_name(&symtab[rel->r_symbolnum]);
 	}
@@ -1385,7 +1380,7 @@
 
 	/* Intruction contains an offset to the symbols pointed to, in the rel->r_symbolnum section */
 	sectoffset = *(uint32_t *)(text + rel->r_address) & 0xffff;
-
+			
 	if(sectnum==0xffffff)
 		return 0;
 
@@ -1427,7 +1422,7 @@
 	/* search it in the full symbol list, if not found */
 	if(!name)
 		name = (char *)find_sym_with_value_and_sec_number(sectoffset, sectnum, sslide);
-
+	
 	return name;
 #endif
 }
@@ -1460,11 +1455,11 @@
     unsigned int i, j;
     EXE_SYM *sym;
     struct NLIST *syment;
-
+    
     fd = open(filename, O_RDONLY);
-    if (fd < 0)
+    if (fd < 0) 
         error("can't open file '%s'", filename);
-
+		
     /* Read Mach header.  */
     if (read(fd, &mach_hdr, sizeof (mach_hdr)) != sizeof (mach_hdr))
         error("unable to read file header");
@@ -1473,13 +1468,13 @@
     if (!check_mach_header(mach_hdr)) {
         error("bad Mach header");
     }
-
+    
     if (!mach_check_cputype(mach_hdr.cputype))
         error("Unsupported CPU");
-
+        
     if (mach_hdr.filetype != MH_OBJECT)
         error("Unsupported Mach Object");
-
+    
     /* read segment headers */
     for(i=0, j=sizeof(mach_hdr); i<mach_hdr.ncmds ; i++)
     {
@@ -1531,7 +1526,7 @@
     /* read all section data */
     sdata = (uint8_t **)malloc(sizeof(void *) * segment->nsects);
     memset(sdata, 0, sizeof(void *) * segment->nsects);
-
+    
     /* Load the data in section data */
     for(i = 0; i < segment->nsects; i++)
         sdata[i] = load_data(fd, section_hdr[i].offset, section_hdr[i].size);
@@ -1552,30 +1547,30 @@
     if (i == -1 || !text_sec_hdr)
         error("could not find __TEXT,__text section");
     text = sdata[i];
-
+	    
     /* Make sure dysym was loaded */
-    if(dysymtabcmd == NULL)
+    if(!(int)dysymtabcmd)
         error("could not find __DYSYMTAB segment");
-
+    
     /* read the table of content of the indirect sym */
     tocdylib = load_data( fd, dysymtabcmd->indirectsymoff, dysymtabcmd->nindirectsyms * sizeof(uint32_t) );
-
+    
     /* Make sure symtab was loaded  */
-    if(symtabcmd == NULL)
+    if(!(int)symtabcmd)
         error("could not find __SYMTAB segment");
     nb_syms = symtabcmd->nsyms;
 
     symtab_std = load_data(fd, symtabcmd->symoff, symtabcmd->nsyms * sizeof(struct NLIST));
     strtab = load_data(fd, symtabcmd->stroff, symtabcmd->strsize);
-
+	
     symtab = malloc(sizeof(EXE_SYM) * nb_syms);
-
+	
     /* Now transform the symtab, to an extended version, with the sym size, and the C name */
     for(i = 0, sym = symtab, syment = symtab_std; i < nb_syms; i++, sym++, syment++) {
         struct NLIST *sym_follow, *sym_next = 0;
         unsigned int j;
         memset(sym, 0, sizeof(*sym));
-
+		
         if ( syment->n_type & N_STAB ) /* Debug symbols are skipped */
             continue;
 
@@ -1601,7 +1596,7 @@
         else
             sym->st_size = text_sec_hdr->size - sym->st_value;
     }
-
+	
     /* Find Reloc */
     relocs = load_data(fd, text_sec_hdr->reloff, text_sec_hdr->nreloc * sizeof(struct relocation_info));
     nb_relocs = text_sec_hdr->nreloc;
@@ -1619,7 +1614,7 @@
     char demangled_buf[256];
     size_t nd = sizeof(demangled_buf);
     int status;
-
+    
     demangled = cxx_demangle(sym_name, demangled_buf, &nd, &status);
     if (!status && demangled)
         sym_name = demangled;
@@ -1628,7 +1623,7 @@
     } else if (is_op_gen_label(sym_name, &p)) {
         snprintf(name, name_size, "gen_labels[param%s]", p);
     } else if (strstart(sym_name, ".LC", NULL)) {
-        snprintf(name, name_size, "(long)(gen_const_%s())", gen_dot_prefix(sym_name));
+        snprintf(name, name_size, "(long)(gen_const_%s())", gen_dot_prefix(sym_name));	
     } else {
 #ifdef HOST_SPARC
         if (sym_name[0] == '.')
@@ -1652,9 +1647,9 @@
     int offset, min_offset, pc_offset, data_size;
     uint8_t data_allocated[1024];
     unsigned int data_index;
-
+    
     memset(data_allocated, 0, sizeof(data_allocated));
-
+    
     p = p_start;
     min_offset = p_end - p_start;
     while (p < p_start + min_offset) {
@@ -1665,22 +1660,22 @@
             if (!(insn & 0x00800000))
                         offset = -offset;
             if ((offset & 3) !=0)
-                error("%s:%04x: ldr pc offset must be 32 bit aligned",
+                error("%s:%04x: ldr pc offset must be 32 bit aligned", 
                       name, start_offset + p - p_start);
             pc_offset = p - p_start + offset + 8;
-            if (pc_offset <= (p - p_start) ||
+            if (pc_offset <= (p - p_start) || 
                 pc_offset >= (p_end - p_start))
-                error("%s:%04x: ldr pc offset must point inside the function code",
+                error("%s:%04x: ldr pc offset must point inside the function code", 
                       name, start_offset + p - p_start);
             if (pc_offset < min_offset)
                 min_offset = pc_offset;
             if (outfile) {
                 /* ldr position */
-                fprintf(outfile, "    arm_ldr_ptr->ptr = ptr() + %d;\n",
+                fprintf(outfile, "    arm_ldr_ptr->ptr = ptr() + %d;\n", 
                         p - p_start);
                 /* ldr data index */
                 data_index = ((p_end - p_start) - pc_offset - 4) >> 2;
-                fprintf(outfile, "    arm_ldr_ptr->data_ptr = arm_data_ptr + %d;\n",
+                fprintf(outfile, "    arm_ldr_ptr->data_ptr = arm_data_ptr + %d;\n", 
                         data_index);
                 fprintf(outfile, "    arm_ldr_ptr++;\n");
                 if (data_index >= sizeof(data_allocated))
@@ -1732,7 +1727,7 @@
         if (!outfile)
             printf("%s: invalid epilog\n", name);
     }
-    return p - p_start;
+    return p - p_start;	    
 }
 #endif
 
@@ -1741,7 +1736,7 @@
 
 /* generate op code */
 void gen_code(const char *name, const char *demangled_name,
-              host_ulong offset, host_ulong size,
+              host_ulong offset, host_ulong size, 
               FILE *outfile, int gen_switch, const char *prefix)
 {
     int copy_size = 0;
@@ -1788,6 +1783,7 @@
     }
     else
 #if defined(HOST_I386) || defined(HOST_X86_64)
+#if defined(CONFIG_FORMAT_COFF) || defined(CONFIG_FORMAT_MACH)
     {
         uint8_t *p;
         p = p_end - 1;
@@ -1800,6 +1796,20 @@
         }
         copy_size = p - p_start;
     }
+#else
+    {
+        int len;
+        len = p_end - p_start;
+        if (len == 0)
+            error("empty code for %s", name);
+        if (p_end[-1] == 0xc3) {
+            len--;
+        } else {
+            error("ret or jmp expected at the end of %s", name);
+        }
+        copy_size = len;
+    }
+#endif    
 #elif defined(HOST_PPC)
     {
         uint8_t *p;
@@ -1831,7 +1841,7 @@
 #endif
         if (get32((uint32_t *)p) != 0x6bfa8001)
             error("ret expected at the end of %s", name);
-        copy_size = p - p_start;
+        copy_size = p - p_start;	    
     }
 #elif defined(HOST_IA64)
     {
@@ -1895,14 +1905,14 @@
         } else {
             error("No save at the beginning of %s", name);
         }
-
+        
         /* Skip a preceeding nop, if present.  */
         if (p > p_start) {
             skip_insn = get32((uint32_t *)(p - 0x4));
             if (skip_insn == 0x01000000)
                 p -= 4;
         }
-
+        
         copy_size = p - p_start;
     }
 #elif defined(HOST_ARM)
@@ -1915,7 +1925,7 @@
             error("%s: invalid prolog", name);
         p_start += 12;
         start_offset += 12;
-        copy_size = arm_emit_ldr_info(name, start_offset, NULL, p_start, p_end,
+        copy_size = arm_emit_ldr_info(name, start_offset, NULL, p_start, p_end, 
                                       relocs, nb_relocs);
     }
 #elif defined(HOST_M68K)
@@ -1926,7 +1936,7 @@
             error("empty code for %s", name);
         // remove NOP's, probably added for alignment
         while ((get16((uint16_t *)p) == 0x4e71) &&
-               (p>p_start))
+               (p>p_start)) 
             p -= 2;
         if (get16((uint16_t *)p) != 0x4e75)
             error("rts expected at the end of %s", name);
@@ -1948,8 +1958,8 @@
 #error unsupported CPU
 #endif
 
+    
 
-
     /* compute the number of arguments by looking at the relocations */
     for(i = 0;i < MAX_ARGS; i++)
         args_present[i] = 0;
@@ -1973,7 +1983,7 @@
             }
         }
     }
-
+    
     nb_args = 0;
     while (nb_args < MAX_ARGS && args_present[nb_args])
         nb_args++;
@@ -2015,7 +2025,7 @@
                 demangled = cxx_demangle(sym_name, demangled_buf, &nd, &status);
                 if (!status && demangled)
                     sym_name = demangled;
-                if (*sym_name &&
+                if (*sym_name && 
                     !is_op_param(sym_name, NULL) &&
                     !is_op_jmp(sym_name, NULL) &&
                     !strstart(sym_name, ".LC", NULL))
@@ -2037,7 +2047,7 @@
                 if (strstart(sym_name, "__op_label", &p)) {
                     uint8_t *ptr;
                     unsigned long offset;
-
+                    
                     /* test if the variable refers to a label inside
                        the code we are generating */
 #ifdef CONFIG_FORMAT_COFF
@@ -2069,7 +2079,7 @@
                         /* try to find a matching relocation */
                         reloc_shndx = find_reloc(sym->st_shndx);
                         if (reloc_shndx) {
-                            nb_relocs1 = shdr[reloc_shndx].sh_size /
+                            nb_relocs1 = shdr[reloc_shndx].sh_size / 
                                 shdr[reloc_shndx].sh_entsize;
                             rel = (ELF_RELOC *)sdata[reloc_shndx];
                             for(j = 0; j < nb_relocs1; j++) {
@@ -2081,7 +2091,7 @@
                             }
                         }
                     }
-#endif
+#endif                    
 
                     if (val >= start_offset && val < start_offset + copy_size) {
                         n = strtol(p, NULL, 10);
@@ -2136,7 +2146,7 @@
 
 		slide = offset - start_offset;
 
-		if (!(offset >= start_offset && offset < start_offset + size))
+		if (!(offset >= start_offset && offset < start_offset + size)) 
 			continue;  /* not in our range */
 
 		sym_name = get_reloc_name(rel, &sslide);
@@ -2169,7 +2179,7 @@
 						slide, final_sym_name, slide);
 				}
 				else {
-					fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (%s + %d);\n",
+					fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (%s + %d);\n", 
 						slide, final_sym_name, sslide);
 				}
 				break;
@@ -2205,11 +2215,11 @@
 			type = ELF32_R_TYPE(rel->r_info);
 			switch(type) {
 			case R_386_32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					rel->r_offset - start_offset, final_sym_name, addend);
 				break;
 			case R_386_PC32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d;\n", 
 					rel->r_offset - start_offset, final_sym_name, rel->r_offset - start_offset, addend);
 				break;
 			default:
@@ -2232,11 +2242,11 @@
 			type = rel->r_type;
 			switch(type) {
 			case DIR32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					rel->r_offset - start_offset, final_sym_name, addend);
 				break;
 			case DISP32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d -4;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d -4;\n", 
 					rel->r_offset - start_offset, final_sym_name, rel->r_offset - start_offset, addend);
 				break;
 			default:
@@ -2259,7 +2269,6 @@
 
 	for (i = 0, rel = relocs, local16 = 0; i < nb_relocs; i++, rel++) {
 		unsigned int isym, usesym, offset, length, pcrel, type;
-		int adjustment = 0;
 
 		isym = rel->r_symbolnum;
 		usesym = rel->r_extern;
@@ -2270,13 +2279,13 @@
 
 		if (usesym && (symtab[isym].n_type & N_STAB))
 			continue; /* don't handle STAB (debug sym) */
-
-		if (!(offset >= start_offset && offset < start_offset + size))
+                    
+		if (!(offset >= start_offset && offset < start_offset + size)) 
 			continue;  /* not in our range */
 
 		if (length > 3)
 			error("unsupported %d-bit relocation", 8 * (1 << length));
-
+                    
 		bytecount = (1 << length);
 		bitlength = 8 * bytecount;
 		slide = offset - start_offset;
@@ -2284,15 +2293,15 @@
 		if (!usesym) {
 			// local reloc
 			sslide = get32((uint32_t *)(text + offset)) + rel->r_address + 4;
-			if ( literal16_sec_hdr
-				&& sslide >= literal16_sec_hdr->addr
+			if ( literal16_sec_hdr 
+				&& sslide >= literal16_sec_hdr->addr 
 				&& sslide + 16 <= literal16_sec_hdr->addr + literal16_sec_hdr->size ) {
 				sprintf(final_sym_name, "literal16_%d", ++local16);
 				print_data(outfile, final_sym_name, literal16 + sslide - literal16_sec_hdr->addr, 16);
 				fprintf(outfile, "    static uint8 *data_p_%d = NULL;\n", local16);
 				fprintf(outfile, "    if (data_p_%d == NULL)\n", local16);
 				fprintf(outfile, "        data_p_%d = copy_data(%s, %d);\n", local16, final_sym_name, 16);
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (int32_t)((long)data_p_%d - (long)(code_ptr() + %d + %d));\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (int32_t)((long)data_p_%d - (long)(code_ptr() + %d + %d));\n", 
 						slide, local16, slide, bytecount);
 			} else {
 				fprintf(outfile, "/* #warning relocation not handled in %s (section %d, offset 0x%x, length 0x%x, %s, type 0x%x) */\n",
@@ -2316,29 +2325,17 @@
 		}
 
 		get_reloc_expr(final_sym_name, sizeof(final_sym_name), sym_name);
-
-		switch (type) {
-			case X86_64_RELOC_SIGNED_1:		// Signed displacement with a -1 added.
-				adjustment = -1;
-				type = X86_64_RELOC_SIGNED;
-				break;
-			case X86_64_RELOC_SIGNED_2:		// Signed displacement with a -2 added.
-				adjustment = -2;
-				type = X86_64_RELOC_SIGNED;
-				break;
-			case X86_64_RELOC_SIGNED_4:		// Signed displacement with a -4 added.
-				adjustment = -4;
-				type = X86_64_RELOC_SIGNED;
-				break;
-		}
-
+                    
 		if (pcrel || is_op_gen_label(sym_name, &p)) {
 			switch (type) {
 			case X86_64_RELOC_UNSIGNED:     // for absolute addresses
 			case X86_64_RELOC_SIGNED:		// for signed 32-bit displacement
 			case X86_64_RELOC_BRANCH:		// a CALL/JMP instruction with 32-bit displacement
-				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (int%d_t)((long)%s - (long)(code_ptr() + %d + %d)) + %d;\n",
-					bitlength, slide, bitlength, final_sym_name, slide, bytecount, sslide + adjustment);
+			case X86_64_RELOC_SIGNED_1:     // for signed 32-bit displacement with a -1 addend
+			case X86_64_RELOC_SIGNED_2:     // for signed 32-bit displacement with a -2 addend
+			case X86_64_RELOC_SIGNED_4:     // for signed 32-bit displacement with a -4 addend
+				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (int%d_t)((long)%s - (long)(code_ptr() + %d + %d)) + %d;\n", 
+					bitlength, slide, bitlength, final_sym_name, slide, bytecount, sslide);
 				break;
 			default:
 				error("unsupported x86_64 relocation (%d) in %s\n", type, sym_name);
@@ -2346,18 +2343,18 @@
 		} else {
 			switch (type) {
 			case X86_64_RELOC_UNSIGNED:     // for absolute addresses
-				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (uint%d_t)%s + %d;\n",
+				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (uint%d_t)%s + %d;\n", 
 					bitlength, slide, bitlength, final_sym_name, sslide);
 				break;
 			case X86_64_RELOC_SIGNED:		// for signed 32-bit displacement
-				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (int%d_t)%s + %d;\n",
-					bitlength, slide, bitlength, final_sym_name, sslide + adjustment);
+				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (int%d_t)%s + %d;\n", 
+					bitlength, slide, bitlength, final_sym_name, sslide);
 				break;
 			default:
 				error("unsupported x86_64 relocation (%d) in %s\n", type, sym_name);
 			}
 		}
-	}
+	}                
 #elif defined (CONFIG_FORMAT_ELF)
 	char final_sym_name[256];
 	const char *sym_name;
@@ -2396,7 +2393,7 @@
 				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (int32_t)%s + %d;\n", slide, final_sym_name, addend);
 				break;
 			case R_X86_64_PC32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d;\n", 
 					slide, final_sym_name, slide, addend);
 				break;
 			default:
@@ -2405,7 +2402,7 @@
 		}
 	}
 #else
-#error unsupport object format for HOST_X86_64
+#error unsupport object format for HOST_X86_64 
 #endif
 #elif defined(HOST_PPC)
 #ifdef CONFIG_FORMAT_ELF
@@ -2432,24 +2429,24 @@
 			addend = rel->r_addend;
 			switch(type) {
 			case R_PPC_ADDR32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_PPC_ADDR16_LO:
-				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d);\n",
+				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d);\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_PPC_ADDR16_HI:
-				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d) >> 16;\n",
+				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d) >> 16;\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_PPC_ADDR16_HA:
-				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d + 0x8000) >> 16;\n",
+				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d + 0x8000) >> 16;\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_PPC_REL24:
 				/* warning: must be at 32 MB distancy */
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (*(uint32_t *)(code_ptr() + %d) & ~0x03fffffc) | ((%s - (long)(code_ptr() + %d) + %d) & 0x03fffffc);\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (*(uint32_t *)(code_ptr() + %d) & ~0x03fffffc) | ((%s - (long)(code_ptr() + %d) + %d) & 0x03fffffc);\n", 
 					slide, slide, final_sym_name, slide, addend);
 				break;
 			default:
@@ -2486,15 +2483,15 @@
 		}
 
 		slide = offset - start_offset;
-
-		if (!(offset >= start_offset && offset < start_offset + size))
+		
+		if (!(offset >= start_offset && offset < start_offset + size)) 
 			continue;  /* not in our range */
 
 		sym_name = get_reloc_name(rel, &sslide);
-
+	
 		if(usesym && (symtab[isym].n_type & N_STAB))
 			continue; /* don't handle STAB (debug sym) */
-
+					
 		if (sym_name && is_op_jmp(sym_name, &p)) {
 			int n;
 			n = strtol(p, NULL, 10);
@@ -2502,7 +2499,7 @@
 				n, slide);
 			continue; /* Nothing more to do */
 		}
-
+	
 		if(!sym_name)
 		{
 			fprintf(outfile, "/* #warning relocation not handled in %s (value 0x%x, %s, offset 0x%x, length 0x%x, %s, type 0x%x) */\n",
@@ -2517,7 +2514,7 @@
 			if (!is_op_param(sym_name, &p)) {
 				fprintf(outfile, "{\n");
 				fprintf(outfile, "    uint32_t imm = *(uint32_t *)(code_ptr() + %d) & 0x3fffffc;\n", slide);
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (*(uint32_t *)(code_ptr() + %d) & ~0x03fffffc) | ((imm + ((long)%s - (long)code_ptr()) + %d) & 0x03fffffc);\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (*(uint32_t *)(code_ptr() + %d) & ~0x03fffffc) | ((imm + ((long)%s - (long)code_ptr()) + %d) & 0x03fffffc);\n", 
 					slide, slide, final_sym_name, sslide );
 				fprintf(outfile, "}\n");
 			} else {
@@ -2526,15 +2523,15 @@
 			}
 			break;
 		case PPC_RELOC_HI16:
-			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d) >> 16;\n",
+			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d) >> 16;\n", 
 				slide, final_sym_name, sslide);
 			break;
 		case PPC_RELOC_LO16:
-			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d);\n",
+			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d);\n", 
 				slide, final_sym_name, sslide);
 			break;
 		case PPC_RELOC_HA16:
-			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d + 0x8000) >> 16;\n",
+			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d + 0x8000) >> 16;\n", 
 				slide, final_sym_name, sslide);
 			break;
 		default:
@@ -2560,15 +2557,15 @@
 			addend = rel->r_addend;
 			switch(type) {
 			case R_390_32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_390_16:
-				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = %s + %d;\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_390_8:
-				fprintf(outfile, "    *(uint8_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint8_t *)(code_ptr() + %d) = %s + %d;\n", 
 					slide, final_sym_name, addend);
 				break;
 			default:
@@ -2674,7 +2671,7 @@
 			addend = rel->r_addend;
 			switch(type) {
 			case R_SPARC_32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					rel->r_offset - start_offset, final_sym_name, addend);
 				break;
 			case R_SPARC_HI22:
@@ -2789,11 +2786,11 @@
 			addend = get32((uint32_t *)(text + rel->r_offset));
 			switch(type) {
 			case R_ARM_ABS32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					rel->r_offset - start_offset, final_sym_name, addend);
 				break;
 			case R_ARM_PC24:
-				fprintf(outfile, "    arm_reloc_pc24((uint32_t *)(code_ptr() + %d), 0x%x, %s);\n",
+				fprintf(outfile, "    arm_reloc_pc24((uint32_t *)(code_ptr() + %d), 0x%x, %s);\n", 
 					rel->r_offset - start_offset, addend, final_sym_name);
 				break;
 			default:
@@ -2818,12 +2815,12 @@
 			switch(type) {
 			case R_68K_32:
 				fprintf(outfile, "    /* R_68K_32 RELOC, offset %x */\n", rel->r_offset) ;
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %#x;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %#x;\n", 
 					rel->r_offset - start_offset, final_sym_name, addend );
 				break;
 			case R_68K_PC32:
 				fprintf(outfile, "    /* R_68K_PC32 RELOC, offset %x */\n", rel->r_offset);
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %#x) + %#x;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %#x) + %#x;\n", 
 					rel->r_offset - start_offset, final_sym_name, rel->r_offset - start_offset, /*sym->st_value+*/ addend);
 				break;
 			default:
@@ -2890,10 +2887,8 @@
 		char *demangled_name, *func_name;
 		if ((demangled_name = malloc(nd)) == NULL)
 			return -1;
-		if ((func_name = malloc(nf = nd)) == NULL) {
-			free(demangled_name);
+		if ((func_name = malloc(nf = nd)) == NULL)
 			return -1;
-		}
 
 		fprintf(outfile, "#ifndef DEFINE_CST\n");
 		fprintf(outfile, "#define DEFINE_CST(NAME, VALUE)\n");
@@ -2942,24 +2937,20 @@
 				demangled_name = cxx_demangle(name, demangled_name, &nd, &status);
 				if (status == 0 && strstart(demangled_name, OP_PREFIX, NULL)) {
 					/* get real function name */
-					char *p = strchr(demangled_name, '(');
-					if (p && !strstart(p, "()::label", NULL)) {
-						int func_name_length = p - demangled_name;
-						if (nd > nf) {
-							char *new_func_name;
-							nf = nd;
-							if ((new_func_name = realloc(func_name, nf)) == NULL) {
-								free(func_name);
-								return -1;
-							}
-							func_name = new_func_name;
-						}
-						strncpy(func_name, demangled_name, func_name_length);
-						func_name[func_name_length] = '\0';
-						/* emit code generator */
+						char *p = strchr(demangled_name, '(');
+						if (p && !strstart(p, "()::label", NULL)) {
+							int func_name_length = p - demangled_name;
+							if (nd > nf) {
+								nf = nd;
+								if ((func_name = realloc(func_name, nf)) == NULL)
+									return -1;
+								}
+							strncpy(func_name, demangled_name, func_name_length);
+							func_name[func_name_length] = '\0';
+							/* emit code generator */
 #if defined(CONFIG_FORMAT_ELF) || defined(CONFIG_FORMAT_COFF)
-						if (sym->st_shndx != text_shndx)
-							error("invalid section for opcode (%s:0x%x)", name, sym->st_shndx);
+							if (sym->st_shndx != text_shndx)
+								error("invalid section for opcode (%s:0x%x)", name, sym->st_shndx);
 #endif
 						gen_code(func_name, demangled_name, sym->st_value, sym->st_size, outfile, 3, NULL);
 					}
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/jit-cache.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/jit-cache.cpp
@@ -76,7 +76,8 @@
 		tcode_start = NULL;
 		return false;
 	}
-
+	
+  done:
 	D(bug("basic_jit_cache: Translation cache: %d KB at %p\n", cache_size / 1024, tcode_start));
 	code_start = tcode_start;
 	code_p = code_start;
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/ppc/jit-target-cache.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/ppc/jit-target-cache.hpp
@@ -29,7 +29,7 @@
 
     p = start & ~(MIN_CACHE_LINE_SIZE - 1);
     stop = (stop + MIN_CACHE_LINE_SIZE - 1) & ~(MIN_CACHE_LINE_SIZE - 1);
-
+    
     for (p = start; p < stop; p += MIN_CACHE_LINE_SIZE) {
         asm volatile ("dcbst 0,%0" : : "r"(p) : "memory");
     }
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/x86/codegen_x86.h
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/x86/codegen_x86.h
@@ -15,7 +15,7 @@
  *    Gwenole Beauchesne
  *
  *  Basilisk II (C) 1997-2008 Christian Bauer
- *
+ *  
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
@@ -72,7 +72,7 @@
 /* Define to optimize absolute addresses for RIP relative addressing.  */
 #ifndef X86_RIP_RELATIVE_ADDR
 #define X86_RIP_RELATIVE_ADDR	1
-#endif
+#endif 
 
 
 /* --- Macros -------------------------------------------------------------- */
@@ -206,11 +206,11 @@
 #define _rC(R)		((R) & 0xf0)
 #define _rR(R)		((R) & 0x0f)
 #define _rN(R)		((R) & 0x07)
-#define _rXP(R)		(((R) > 0 && _rR(R) > 7) ? 1 : 0)
+#define _rXP(R)		((R) > 0 && _rR(R) > 7)
 #else
 #define _rN(R)		((R) & 0x07)
 #define _rR(R)		(int(R))
-#define _rXP(R)		((_rR(R) > 7 && _rR(R) < 16) ? 1 : 0)
+#define _rXP(R)		(_rR(R) > 7 && _rR(R) < 16)
 #endif
 
 #if !defined(_ASM_SAFETY) || ! X86_FLAT_REGISTERS
@@ -495,7 +495,7 @@
 /* --- REX prefixes -------------------------------------------------------- */
 
 #define _VOID()			((void)0)
-#define _BIT(X)			((X) ? 1 : 0)
+#define _BIT(X)			(!!(X))
 #define _d64(W,R,X,B)		(_B(0x40|(W)<<3|(R)<<2|(X)<<1|(B)))
 
 #define __REXwrxb(L,W,R,X,B)	((W|R|X|B) || (L) ? _d64(W,R,X,B) : _VOID())
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-config.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-config.hpp
@@ -63,6 +63,18 @@
 
 
 /**
+ *	PPC_MIPS_COUNTER
+ *
+ *		Define to 1 to enable the MIPS counter, which is useful for
+ *      performance measurements.
+ **/
+
+#ifndef PPC_MIPS_COUNTER
+#define PPC_MIPS_COUNTER 1
+#endif
+
+
+/**
  *	PPC_ENABLE_JIT
  *
  *		Define to 1 if dynamic translation is used. This requires
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-cpu.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-cpu.cpp
@@ -123,6 +123,7 @@
 void powerpc_cpu::init_registers()
 {
 	assert((((uintptr)&vr(0)) % 16) == 0);
+	memset(&_regs, 0, sizeof(_regs));
 	for (int i = 0; i < 32; i++) {
 		gpr(i) = 0;
 		fpr(i) = 0;
@@ -231,7 +232,7 @@
 }
 #endif
 
-/*#if ENABLE_MON
+#if ENABLE_MON
 static uint32 mon_read_byte_ppc(uintptr addr)
 {
 	return *((uint8 *)addr);
@@ -242,7 +243,7 @@
 	uint8 *m = (uint8 *)addr;
 	*m = b;
 }
-#endif*/
+#endif
 
 void powerpc_cpu::initialize()
 {
@@ -527,7 +528,7 @@
 		spcflags().clear(SPCFLAG_CPU_ENTER_MON);
 #if ENABLE_MON
 		// Start up mon in real-mode
-		const char *arg[] = {
+		char *arg[] = {
 			"mon",
 #ifdef SHEEPSHAVER
 			"-m",
@@ -548,6 +549,7 @@
 	// which is aligned at least on 4-byte boundaries
 	const int n = ((uintptr)sbi) & 3;
 	sbi = (block_info *)(((uintptr)sbi) & ~3L);
+	const uint32 bpc = sbi->pc;
 
 	const uint32 tpc = sbi->li[n].jmp_pc;
 	block_info *tbi = my_block_cache.find(tpc);
@@ -563,6 +565,12 @@
 void powerpc_cpu::execute(uint32 entry)
 {
 	bool invalidated_cache = false;
+#if PPC_MIPS_COUNTER
+	unsigned long retired = 0, retired_ovf = 0;
+	double start, snap;
+	static uint32 mips_prints = 0;
+	start = snap = sys_time();
+#endif
 	pc() = entry;
 #if PPC_EXECUTE_DUMP_STATE
 	const bool dump_state = true;
@@ -602,13 +610,15 @@
 				// Compile new block
 				bi = compile_block(pc());
 			}
+			goto return_site;
 		}
 #endif
 #if PPC_DECODE_CACHE
-		block_info *bi = my_block_cache.find(pc());
-		if (bi != NULL)
-			goto pdi_execute;
 		for (;;) {
+			block_info *bi = my_block_cache.find(pc());
+			if (bi != NULL)
+				goto pdi_execute;
+		  pdi_compile:
 #if PPC_PROFILE_COMPILE_TIME
 			compile_count++;
 			clock_t start_time;
@@ -618,6 +628,7 @@
 			bi->init(pc());
 
 			// Predecode a new block
+		  pdi_decode:
 			block_info::decode_info *di;
 			const instr_info_t *ii;
 			uint32 dpc;
@@ -673,18 +684,45 @@
 			// Execute all cached blocks
 		  pdi_execute:
 			for (;;) {
+#if PPC_MIPS_COUNTER
+				retired += bi->size;
+#endif
 				const int r = bi->size % 4;
 				di = bi->di + r;
 				int n = (bi->size + 3) / 4;
 				switch (r) {
 				case 0: do {
-						di += 4;
-						di[-4].execute(this, di[-4].opcode);
+				        di += 4;
+				        di[-4].execute(this, di[-4].opcode);
 				case 3: di[-3].execute(this, di[-3].opcode);
 				case 2: di[-2].execute(this, di[-2].opcode);
 				case 1: di[-1].execute(this, di[-1].opcode);
 					} while (--n > 0);
 				}
+#if PPC_MIPS_COUNTER
+				if (retired > (1 << 27)) {
+					double now = sys_time(),
+					       diff = now - snap;
+					if (diff > 1.0) {
+						double mips = (double)(retired + retired_ovf) / 1e6;
+						fprintf(stderr, "%3.5lf MIPS @ %0.3lfs\n", mips / diff, now - start);
+						mips_prints++;
+						if (mips_prints == 5) {
+							mips_prints = 0;
+							my_block_cache.print_statistics();
+						}
+						retired_ovf = 0;
+						retired = 0;
+						snap = now;
+					} else {
+						// We should wait until we hit the *next* 134,217,728
+						// instructions. It's too soon to print a new MIPS
+						// count.
+						retired_ovf += retired;
+						retired = 0;
+					}
+				}
+#endif
 
 				if (!spcflags().empty()) {
 					if (!check_spcflags())
@@ -702,9 +740,9 @@
 					break;
 			}
 		}
-#else
-		goto do_interpret;
+		goto return_site;
 #endif
+		goto do_interpret;
 	}
 #endif
   do_interpret:
@@ -719,8 +757,37 @@
 		if (is_logging())
 			record_step(opcode);
 #endif
-		assert(ii->execute.ptr() != 0);
+		//assert(ii->execute.ptr() != 0);
 		ii->execute(this, opcode);
+
+#if PPC_MIPS_COUNTER
+		retired++;
+
+		if (retired > (1 << 27)) {
+			double now = sys_time(),
+			       diff = now - snap;
+			if (diff > 1.0) {
+				double mips = (double)(retired + retired_ovf) / 1e6;
+				fprintf(stderr, "%3.5lf MIPS @ %0.3lfs\n", mips / diff, now - start);
+#if PPC_DECODE_CACHE
+				mips_prints++;
+				if (mips_prints == 5) {
+					mips_prints = 0;
+					my_block_cache.print_statistics();
+				}
+#endif
+				retired_ovf = 0;
+				retired = 0;
+				snap = now;
+			} else {
+				// We should wait until we hit the *next* 134,217,728
+				// instructions. It's too soon to print a new MIPS
+				// count.
+				retired_ovf += retired;
+				retired = 0;
+			}
+		}
+#endif
 #if PPC_EXECUTE_DUMP_STATE
 		if (dump_state)
 			dump_registers();
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-cpu.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-cpu.hpp
@@ -29,7 +29,7 @@
 #include "cpu/ppc/ppc-bitfields.hpp"
 #include "cpu/ppc/ppc-blockinfo.hpp"
 #include "cpu/ppc/ppc-registers.hpp"
-#if PPC_ENABLE_JIT
+#if PPC_ENABLE_JIT 
 #include "cpu/ppc/ppc-jit.hpp"
 #endif
 #include "cpu/ppc/ppc-instructions.hpp"
@@ -98,12 +98,12 @@
 	uint32 pc() const			{ return regs().pc; }
 	void increment_pc(int o)	{ pc() += o; }
 
-	friend class pc_operand;
-	friend class lr_operand;
-	friend class ctr_operand;
-	friend class cr_operand;
-	template< class field > friend class xer_operand;
-	template< class field > friend class fpscr_operand;
+	friend struct pc_operand;
+	friend struct lr_operand;
+	friend struct ctr_operand;
+	friend struct cr_operand;
+	template< class field > friend struct xer_operand;
+	template< class field > friend struct fpscr_operand;
 
 public:
 
@@ -288,7 +288,7 @@
 
 	// Interrupts handling
 	void trigger_interrupt();
-
+	
 	// Set VALUE to register ID
 	void set_register(int id, any_register const & value);
 
@@ -353,7 +353,7 @@
 
 	// Block lookup table
 	typedef powerpc_block_info block_info;
-	block_cache< block_info, lazy_allocator > my_block_cache;
+	block_cache< block_info, slow_allocator > my_block_cache;
 
 #if PPC_DECODE_CACHE
 	// Decode Cache
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-dyngen-ops.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-dyngen-ops.cpp
@@ -27,19 +27,6 @@
 #include "cpu/ppc/ppc-registers.hpp"
 #include "cpu/ppc/ppc-operations.hpp"
 
-#if defined(__GNUC__)
-// Force inlining under newer versions of GCC.
-static inline uint64 vm_read_memory_8(vm_addr_t addr) __attribute__((always_inline));
-static inline void vm_write_memory_8(vm_addr_t addr, uint64 value) __attribute__((always_inline));
-static inline uint64 vm_do_read_memory_8(uint64 *a) __attribute__((always_inline));
-static inline void vm_do_write_memory_8(uint64 *a, uint64 v) __attribute__((always_inline));
-static inline uint64 generic_bswap_64(uint64 x) __attribute__((always_inline));
-static inline uint32 fp_store_single_convert(uint64 v) __attribute__((always_inline));
-#define INLINE inline __attribute__((always_inline))
-#else
-#define INLINE inline
-#endif
-
 // We need at least 4 general purpose registers
 register struct powerpc_cpu *CPU asm(REG_CPU);
 #define DYNGEN_DEFINE_GLOBAL_REGISTER(REG) \
@@ -82,38 +69,38 @@
  **/
 
 struct powerpc_dyngen_helper {
-	static INLINE uint32 get_pc()				{ return CPU->pc(); }
-	static INLINE void set_pc(uint32 value)		{ CPU->pc() = value; }
-	static INLINE void inc_pc(int32 offset)		{ CPU->pc() += offset; }
-	static INLINE uint32 get_lr()				{ return CPU->lr(); }
-	static INLINE void set_lr(uint32 value)		{ CPU->lr() = value; }
-	static INLINE uint32 get_ctr()				{ return CPU->ctr(); }
-	static INLINE void set_ctr(uint32 value)	{ CPU->ctr() = value; }
-	static INLINE uint32 get_cr()				{ return CPU->cr().get(); }
-	static INLINE void set_cr(uint32 value)		{ CPU->cr().set(value); }
-	static INLINE uint32 get_fpscr()			{ return CPU->fpscr(); }
-	static INLINE void set_fpscr(uint32 value)	{ CPU->fpscr() = value; }
-	static INLINE uint32 get_xer()				{ return CPU->xer().get(); }
-	static INLINE void set_xer(uint32 value)	{ CPU->xer().set(value); }
-	static INLINE uint32 get_vrsave()			{ return CPU->vrsave(); }
-	static INLINE void set_vrsave(uint32 value)	{ CPU->vrsave() = value; }
-	static INLINE uint32 get_vscr()				{ return CPU->vscr().get(); }
-	static INLINE void set_vscr(uint32 value)	{ CPU->vscr().set(value); }
-	static INLINE void record(int crf, int32 v)	{ CPU->record_cr(crf, v); }
-	static INLINE powerpc_cr_register & cr()	{ return CPU->cr(); }
-	static INLINE powerpc_xer_register & xer()	{ return CPU->xer(); }
-	static INLINE powerpc_spcflags & spcflags()	{ return CPU->spcflags(); }
-	static INLINE void set_cr(int crfd, int v)	{ CPU->cr().set(crfd, v); }
-	static INLINE powerpc_registers *regs()		{ return &CPU->regs(); }
+	static inline uint32 get_pc()				{ return CPU->pc(); }
+	static inline void set_pc(uint32 value)		{ CPU->pc() = value; }
+	static inline void inc_pc(int32 offset)		{ CPU->pc() += offset; }
+	static inline uint32 get_lr()				{ return CPU->lr(); }
+	static inline void set_lr(uint32 value)		{ CPU->lr() = value; }
+	static inline uint32 get_ctr()				{ return CPU->ctr(); }
+	static inline void set_ctr(uint32 value)	{ CPU->ctr() = value; }
+	static inline uint32 get_cr()				{ return CPU->cr().get(); }
+	static inline void set_cr(uint32 value)		{ CPU->cr().set(value); }
+	static inline uint32 get_fpscr()			{ return CPU->fpscr(); }
+	static inline void set_fpscr(uint32 value)	{ CPU->fpscr() = value; }
+	static inline uint32 get_xer()				{ return CPU->xer().get(); }
+	static inline void set_xer(uint32 value)	{ CPU->xer().set(value); }
+	static inline uint32 get_vrsave()			{ return CPU->vrsave(); }
+	static inline void set_vrsave(uint32 value)	{ CPU->vrsave() = value; }
+	static inline uint32 get_vscr()				{ return CPU->vscr().get(); }
+	static inline void set_vscr(uint32 value)	{ CPU->vscr().set(value); }
+	static inline void record(int crf, int32 v)	{ CPU->record_cr(crf, v); }
+	static inline powerpc_cr_register & cr()	{ return CPU->cr(); }
+	static inline powerpc_xer_register & xer()	{ return CPU->xer(); }
+	static inline powerpc_spcflags & spcflags()	{ return CPU->spcflags(); }
+	static inline void set_cr(int crfd, int v)	{ CPU->cr().set(crfd, v); }
+	static inline powerpc_registers *regs()		{ return &CPU->regs(); }
 
 #ifndef REG_T3
-	static INLINE uintptr & reg_T3()			{ return CPU->codegen.reg_T3; }
+	static inline uintptr & reg_T3()			{ return CPU->codegen.reg_T3; }
 #endif
 //#ifndef REG_F3
-	static INLINE powerpc_fpr & reg_F3()		{ return CPU->codegen.reg_F3; }
+	static inline powerpc_fpr & reg_F3()		{ return CPU->codegen.reg_F3; }
 //#endif
 
-	static INLINE powerpc_block_info *find_block(uint32 pc) { return CPU->my_block_cache.fast_find(pc); }
+	static inline powerpc_block_info *find_block(uint32 pc) { return CPU->my_block_cache.fast_find(pc); }
 };
 
 // Semantic action templates
@@ -636,7 +623,7 @@
  **/
 
 template< int bo >
-static INLINE void do_prep_branch_bo(void)
+static inline void do_prep_branch_bo(void)
 {
 	bool ctr_ok = true;
 	bool cond_ok = true;
@@ -696,7 +683,7 @@
 	dyngen_barrier();
 }
 
-static INLINE void do_execute_branch_1(uint32 tpc)
+static inline void do_execute_branch_1(uint32 tpc)
 {
 	powerpc_dyngen_helper::set_pc(tpc);
 }
@@ -711,7 +698,7 @@
 	do_execute_branch_1(PARAM1);
 }
 
-static INLINE void do_execute_branch_2(uint32 tpc, uint32 npc)
+static inline void do_execute_branch_2(uint32 tpc, uint32 npc)
 {
 	powerpc_dyngen_helper::set_pc(T1 ? tpc : npc);
 	dyngen_barrier();
@@ -1385,7 +1372,7 @@
  **/
 
 template< int N >
-static INLINE void do_lmw(void)
+static inline void do_lmw(void)
 {
 	CPU->gpr(N) = vm_read_memory_4(T0);
 	T0 += 4;
@@ -1393,21 +1380,20 @@
 }
 
 template<>
-INLINE void do_lmw<31>(void)
+inline void do_lmw<31>(void)
 {
 	CPU->gpr(31) = vm_read_memory_4(T0);
 }
 
 template<>
-INLINE void do_lmw<32>(void)
+inline void do_lmw<32>(void)
 {
 	for (uint32 r = PARAM1, ad = T0; r <= 31; r++, ad += 4)
 		CPU->gpr(r) = vm_read_memory_4(ad);
-	dyngen_barrier();
 }
 
 template< int N >
-static INLINE void do_stmw(void)
+static inline void do_stmw(void)
 {
 	vm_write_memory_4(T0, CPU->gpr(N));
 	T0 += 4;
@@ -1415,17 +1401,16 @@
 }
 
 template<>
-INLINE void do_stmw<31>(void)
+inline void do_stmw<31>(void)
 {
 	vm_write_memory_4(T0, CPU->gpr(31));
 }
 
 template<>
-INLINE void do_stmw<32>(void)
+inline void do_stmw<32>(void)
 {
 	for (uint32 r = PARAM1, ad = T0; r <= 31; r++, ad += 4)
 		vm_write_memory_4(ad, CPU->gpr(r));
-	dyngen_barrier();
 }
 
 #define im 32
@@ -1452,7 +1437,7 @@
 void OPPROTO op_load_ad_V##REG##_VR##N(void)	\
 {												\
 	reg_V##REG = (uintptr)&CPU->vr(N);			\
-}
+}												
 #define DEFINE_REG(N)							\
 DEFINE_OP(D,N);									\
 DEFINE_OP(0,N);									\
@@ -1533,48 +1518,48 @@
 #define VNONE op_VNONE
 struct op_VNONE {
 	typedef null_operand type;
-	static INLINE uint32 get(powerpc_vr const & v, int i) { return 0; }
-	static INLINE void set(powerpc_vr const & v, int i, uint32) { }
+	static inline uint32 get(powerpc_vr const & v, int i) { return 0; }
+	static inline void set(powerpc_vr const & v, int i, uint32) { }
 };
 
 #define V16QI op_V16QI
 struct op_V16QI {
 	typedef uint8 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.b[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.b[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.b[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.b[i] = x; }
 };
 
 #define V8HI op_V8HI
 struct op_V8HI {
 	typedef uint16 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.h[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.h[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.h[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.h[i] = x; }
 };
 
 #define V4SI op_V4SI
 struct op_V4SI {
 	typedef uint32 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.w[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.w[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.w[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.w[i] = x; }
 };
 
 #define V2DI op_V2DI
 struct op_V2DI {
 	typedef uint64 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.j[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.j[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.j[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.j[i] = x; }
 };
 
 #define V4SF op_V4SF
 struct op_V4SF {
 	typedef float type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.f[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.f[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.f[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.f[i] = x; }
 };
 
 template< class OP, class VX, class VA, class VB, class VC, int N >
 struct do_vector_execute {
-	static INLINE void apply() {
+	static inline void apply() {
 		do_vector_execute<OP, VX, VA, VB, VC, N - 1>::apply();
 		VX::set(
 			VD, N,
@@ -1587,7 +1572,7 @@
 
 template< class OP, class VX, class VA, class VB, class VC >
 struct do_vector_execute<OP, VX, VA, VB, VC, 0> {
-	static INLINE void apply() {
+	static inline void apply() {
 		VX::set(
 			VD, 0, op_apply<typename VX::type, OP, typename VA::type, typename VB::type, typename VC::type>::apply(
 				VA::get(V0, 0),
@@ -1598,7 +1583,7 @@
 
 template< class OP, class VX, class VA, class VB = VNONE, class VC = VNONE >
 struct vector_execute {
-	static INLINE void apply() {
+	static inline void apply() {
 		do_vector_execute<OP, VX, VA, VB, VC, (16 / sizeof(typename VX::type)) - 1>::apply();
 	}
 };
@@ -1626,7 +1611,7 @@
 #if defined(__i386__) && defined(__SSE__)
 // Workaround gcc 3.2.2 miscompilation that inserts SSE instructions
 struct op_do_vnmsubfp {
-	static INLINE float apply(float x, float y, float z) {
+	static inline float apply(float x, float y, float z) {
 //		return 0. - ((x * z) - y);
 		return y - (x * z);
 	}
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-dyngen.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-dyngen.cpp
@@ -259,7 +259,7 @@
 #undef _
 	default: abort();
 	}
-
+	
 	if (BO_CONDITIONAL_BRANCH(bo) || BO_DECREMENT_CTR(bo)) {
 		// two-way branches
 		if (direct_chaining)
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-execute.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-execute.cpp
@@ -67,7 +67,7 @@
 	disass_ppc(stdout, pc(), opcode);
 
 	// Start up mon in real-mode
-	const char *arg[4] = {"mon", "-m", "-r", NULL};
+	char *arg[4] = {"mon", "-m", "-r", NULL};
 	mon(3, arg);
 #endif
 	abort();
@@ -92,6 +92,16 @@
 	}
 }
 
+static inline int native_to_ppc_rounding_mode(int round)
+{
+	switch (round) {
+	case FE_TONEAREST:	return 0;
+	case FE_TOWARDZERO:	return 1;
+	case FE_UPWARD:		return 2;
+	case FE_DOWNWARD:	return 3;
+	}
+}
+
 /**
  *	Helper class to compute the overflow/carry condition
  *
@@ -521,7 +531,7 @@
 		if (!FPSCR_VE_field::test(fpscr()))
 			fp_classify(d);
 	}
-
+	
 	// Set CR1 (FX, FEX, VX, VOX) if instruction has Rc set
 	if (Rc::test(opcode))
 		record_cr1();
@@ -1223,7 +1233,7 @@
 void powerpc_cpu::execute_mftbr(uint32 opcode)
 {
 	uint32 tbr = TBR::get(this, opcode);
-	uint32 d = 0;
+	uint32 d;
 	switch (tbr) {
 	case 268: d = (uint32)get_tb_ticks(); break;
 	case 269: d = (get_tb_ticks() >> 32); break;
@@ -1620,6 +1630,7 @@
 	typename VA::type const & vA = VA::const_ref(this, opcode);
 	typename VB::type const & vB = VB::const_ref(this, opcode);
 	typename VD::type & vD = VD::ref(this, opcode);
+	const int n_elements = 16 / VD::element_size;
 
 	const int sh = SH::get(this, opcode);
 	if (SD < 0) {
@@ -1689,7 +1700,7 @@
 	typename VB::type const & vB = VB::const_ref(this, opcode);
 	typename VD::type & vD = VD::ref(this, opcode);
 	typename VD::element_type d;
-
+	
 	switch (SZ) {
 	case 1: // vsum
 		d = VB::get_element(vB, 3);
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-registers.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-registers.hpp
@@ -225,7 +225,7 @@
 	static inline int GPR(int r) { return GPR_BASE + r; }
 	static inline int FPR(int r) { return FPR_BASE + r; }
 	static void interrupt_copy(powerpc_registers &oregs, powerpc_registers const &iregs);
-
+	
 	uint32 gpr[32];				// General-Purpose Registers
 	powerpc_fpr fpr[32];		// Floating-Point Registers
 	powerpc_vr vr[32];			// Vector Registers
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-translate.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-translate.cpp
@@ -95,7 +95,7 @@
 			target == TARGET_POWERPC ? "d" : "x",
 			start, start + length - 1);
 
-	const char *arg[] = {"mon",
+	char *arg[] = {"mon",
 #ifdef SHEEPSHAVER
 				   "-m",
 #endif
@@ -880,7 +880,8 @@
 			case PPC_I(SUBFIC):
 				dg.gen_subfc_T0_im(val);
 				break;
-			default: abort();
+			  defautl:
+				abort();
 			}
 			dg.gen_store_T0_GPR(rD_field::extract(opcode));
 			break;
@@ -1492,7 +1493,7 @@
 			goto do_invoke;
 		  do_illegal:
 			func = (func_t)nv_mem_fun(&powerpc_cpu::execute_illegal).ptr();
-			goto do_invoke;
+			goto do_invoke;	
 		  do_invoke:
 #if PPC_PROFILE_GENERIC_CALLS
 			if (ii->mnemo <= PPC_I(MAX)) {
Only in macemu/: SheepShaver/src/kpx_cpu/src/cpu/vm.cc
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/vm.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/vm.hpp
@@ -21,119 +21,78 @@
 #ifndef VM_H
 #define VM_H
 
-
-#ifdef i386
-
-#ifndef ___X86___
-#define ___X86___
-#endif
-
-#elif defined __x86_64__
-
-#ifndef ___X86___
-#define ___X86___
-#endif
-
-#endif
-
-#ifdef ___X86___
-#ifdef WORDS_BIGENDIAN
-#undef WORDS_BIGENDIAN
-#endif
-#else
-#warning non-x86 computers are currently unsupported in some parts of this
-#endif
-#ifndef __APPLE__
-#warning non-mac computers are currently unsupported in some parts of this
-#endif
 ///
 ///		Optimized memory accessors
 ///
 
-/*#if defined(__i386__) || defined(__powerpc__) || defined(__ppc__) || defined(__m68k__) || defined(__x86_64__)*/
-#define VM_CAN_ACCESS_UNALIGNED
-/*#endif*/
+#if defined(__i386__) || defined(__powerpc__) || defined(__ppc__) || defined(__m68k__) || defined(__x86_64__)
+# define VM_CAN_ACCESS_UNALIGNED
+#endif
 
 #ifdef WORDS_BIGENDIAN
 
-/*#ifdef VM_CAN_ACCESS_UNALIGNED
+#ifdef VM_CAN_ACCESS_UNALIGNED
 
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_2
-#define VM_OPTIMIZED_MEMORY_ACCESS_2*/
+#define VM_OPTIMIZED_MEMORY_ACCESS_2
 static inline uint32 vm_do_read_memory_2(uint16 *a) { return *a; }
 static inline void vm_do_write_memory_2(uint16 *a, uint32 v) { *a = v; }
-/*#endif
+#endif
 
-
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_4
-#define VM_OPTIMIZED_MEMORY_ACCESS_4*/
+#define VM_OPTIMIZED_MEMORY_ACCESS_4
 static inline uint32 vm_do_read_memory_4(uint32 *a) { return *a; }
 static inline void vm_do_write_memory_4(uint32 *a, uint32 v) { *a = v; }
-/*#endif
+#endif
 
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_8
-#define VM_OPTIMIZED_MEMORY_ACCESS_8*/
+#define VM_OPTIMIZED_MEMORY_ACCESS_8
 static inline uint64 vm_do_read_memory_8(uint64 *a) { return *a; }
 static inline void vm_do_write_memory_8(uint64 *a, uint64 v) { *a = v; }
-/*#endif
+#endif
 
-#endif  VM_CAN_ACCESS_UNALIGNED*/
+#endif /* VM_CAN_ACCESS_UNALIGNED */
 
 #else
 
-/*#ifdef VM_CAN_ACCESS_UNALIGNED
+#ifdef VM_CAN_ACCESS_UNALIGNED
 
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_2
 #define VM_OPTIMIZED_MEMORY_ACCESS_2
 static inline uint32 vm_do_read_memory_2(uint16 *a) { return bswap_16(*a); }
-static inline void vm_do_write_memory_2(uint16 *a, uint32 v) { *a = bswap_16(v); }*/
+static inline void vm_do_write_memory_2(uint16 *a, uint32 v) { *a = bswap_16(v); }
+#endif
 
-#define vm_do_read_memory_2(a) (uint32)bswap_16(*((uint16 *)a))
-#define vm_do_write_memory_2(a, v) *((uint16 *)a) = bswap_16((uint16)v)
-
-/*#endif
-
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_4
 #define VM_OPTIMIZED_MEMORY_ACCESS_4
 static inline uint32 vm_do_read_memory_4(uint32 *a) { return bswap_32(*a); }
-static inline void vm_do_write_memory_4(uint32 *a, uint32 v) { *a = bswap_32(v); }*/
+static inline void vm_do_write_memory_4(uint32 *a, uint32 v) { *a = bswap_32(v); }
+#endif
 
-#define vm_do_read_memory_4(a) bswap_32(*(uint32 *)a)
-#define vm_do_write_memory_4(a, v) *(uint32 *)a = bswap_32((uint32)v)
-
-/*#endif
-
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_8
 #define VM_OPTIMIZED_MEMORY_ACCESS_8
 static inline uint64 vm_do_read_memory_8(uint64 *a) { return bswap_64(*a); }
-static inline void vm_do_write_memory_8(uint64 *a, uint64 v) { *a = bswap_64(v); }*/
+static inline void vm_do_write_memory_8(uint64 *a, uint64 v) { *a = bswap_64(v); }
+#endif
 
-#define vm_do_read_memory_8(a) bswap_64(*(uint64 *)a)
-#define vm_do_write_memory_8(a, v) *(uint64 *)a = bswap_64((uint64)v)
+#endif /* VM_CAN_ACCESS_UNALIGNED */
 
-/*#endif
+#endif /* WORDS_BIGENDIAN */
 
-#endif  VM_CAN_ACCESS_UNALIGNED*/
-
-#endif  /* WORDS_BIGENDIAN */
-
 ///
 ///		Generic core memory accessors
 ///
 
-#define vm_do_read_memory_1(a) (uint32)*(uint8 *)a
-#define vm_do_write_memory_1(a, v) *(uint8 *)a = (uint8)v
-
-/*static inline uint32 vm_do_read_memory_1(uint8 *a)
+static inline uint32 vm_do_read_memory_1(uint8 *a)
 {
 	return *a;
 }
 static inline void vm_do_write_memory_1(uint8 *a, uint32 v)
 {
 	*a = v;
-}*/
+}
 
-/*#ifndef VM_OPTIMIZED_MEMORY_ACCESS_2
+#ifndef VM_OPTIMIZED_MEMORY_ACCESS_2
 static inline uint32 vm_do_read_memory_2(uint16 *a)
 {
 	uint8 * b = (uint8 *)a;
@@ -190,288 +149,146 @@
 	b[6] = v >> 8;
 	b[7] = v;
 }
-#endif*/
+#endif
 
-#ifdef WORDS_BIGENDIAN
-/*#ifndef VM_OPTIMIZED_MEMORY_ACCESS_2_REVERSED*/
+#ifndef VM_OPTIMIZED_MEMORY_ACCESS_2_REVERSED
 static inline uint32 vm_do_read_memory_2_reversed(uint16 *a)
 {
-	return bswap_16(*a);
+	uint8 * b = (uint8 *)a;
+	return b[0] | (b[1] << 8);
 }
 static inline void vm_do_write_memory_2_reversed(uint16 *a, uint32 v)
 {
-	*a = bswap_16((uint16)v);
+	uint8 * b = (uint8 *)a;
+	b[0] = v;
+	b[1] = v >> 8;
 }
-/*#endif
+#endif
 
-#ifndef VM_OPTIMIZED_MEMORY_ACCESS_4_REVERSED*/
+#ifndef VM_OPTIMIZED_MEMORY_ACCESS_4_REVERSED
 static inline uint32 vm_do_read_memory_4_reversed(uint32 *a)
 {
-	return bswap_32(*a);
+	uint8 * b = (uint8 *)a;
+	return b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
 }
 static inline void vm_do_write_memory_4_reversed(uint32 *a, uint32 v)
 {
-	*a = bswap_32(v);
+	uint8 * b = (uint8 *)a;
+	b[0] = v;
+	b[1] = v >> 8;
+	b[2] = v >> 16;
+	b[3] = v >> 24;
 }
-/*#endif*/
-static inline uint64 vm_do_read_memory_8_reversed(uint64 * a)
-{
-	return bswap_64(*a);
-}
-static inline void vm_do_write_memory_8_reversed(uint64 * a, uint64 v)
-{
-	*a = bswap_64(v);
-}
-#else
-
-#define vm_do_read_memory_2_reversed(a) (uint32)*(uint16 *)a
-#define vm_do_write_memory_2_reversed(a, v) *(uint16 *)a = (uint16)v
-#define vm_do_read_memory_4_reversed(a) *(uint32 *)a
-#define vm_do_write_memory_4_reversed(a, v) *(uint32 *)a = (uint32)v
-#define vm_do_read_memory_8_reversed(a) *(uint64 *)a
-#define vm_do_write_memory_8_reversed(a, v) *(uint64 *)a = (uint64)v
-
-/*static inline uint32 vm_do_read_memory_2_reversed(uint16 * a)
-{
-	return *a;
-}
-static inline void vm_do_write_memory_2_reversed(uint16 * a, uint32 v)
-{
-	*a = (uint16)v;
-}
-static inline uint32 vm_do_read_memory_4_reversed(uint32 * a)
-{
-	return *a;
-}
-static inline void vm_do_write_memory_4_reversed(uint32 * a, uint32 v)
-{
-	*a = v;
-}
-static inline uint64 vm_do_read_memory_8_reversed(uint64 * a)
-{
-	return *a;
-}
-static inline void vm_do_write_memory_8_reversed(uint64 * a, uint64 v)
-{
-	*a = v;
-}*/
-
 #endif
+
 ///
 ///		Actual memory accessors visible to CPU through virtual addresses
 ///
 
 typedef uintptr vm_addr_t;
 
-/*#if REAL_ADDRESSING
-const uintptr VMBaseDiff = 8192;
+#if REAL_ADDRESSING
+const uintptr VMBaseDiff = 0;
 #elif DIRECT_ADDRESSING
 #ifdef NATMEM_OFFSET
 const uintptr VMBaseDiff = NATMEM_OFFSET;
 #endif
-// Wrap address to 32-bit if we are not using 33-bit addressing space
-#if defined(SHEEPSHAVER) && SIZEOF_VOID_P == 8
-#define vm_wrap_address(ADDR) (uintptr)(uint32)(ADDR)
 #endif
-#else
-const uintptr VMBaseDiff = 0x100000000;
-#endif*/
-extern uintptr VMBaseDiff;
-extern uint32 address_size;
-extern uint8 * sheep_mem;
-void vm_ini(uint8 * mem);
-void setSize(uint32 size);
-void init_sheep_mem(uint8 * mem);
 #ifndef vm_wrap_address
 #define vm_wrap_address(ADDR) (ADDR)
 #endif
-#define sheep_base 0x60000000
-#define page_size 4096
-#define NULL_PAGE 0x59000000
-#define NULL_PAGE_SIZE 0x3000
-#define KERNEL_DATA_BASE  0x68ffe000	// Address of Kernel Data
-#define KERNEL_DATA2_BASE  0x5fffe000	// Alternate address of Kernel Data
-#define KERNEL_AREA_SIZE  0x2000		// Size of Kernel Data area
-#define KERNEL_DATA(a) ((a & 0xFFFFE000) == KERNEL_DATA_BASE)
-#define KERNEL_DATA2(a) ((a & 0xFFFFE000) == KERNEL_DATA2_BASE)
-#define KERNEL(a) (KERNEL_DATA(a) || KERNEL_DATA2(a))
-#define in_sheep_mem(addr) ((addr >= sheep_base) && (addr <= (sheep_base + page_size)))
-#define HIMEM(a) ((in_sheep_mem(a))||(KERNEL(a)))
-#define too_big(addr) ((addr >= address_size)&&(!(HIMEM(addr))))
-#define ZERO too_big
-/*too_big(addr) is so we don't crash on too big addresses*/
-#define NO_WRITE ZERO
-/*NO_WRITE is from when I incorrectly disabled writing to the Kernel Data section*/
-/*#if REAL_ADDRESSING || DIRECT_ADDRESSING*/
-extern uint8 /*gZeroPage[0x3000],*/ gKernelData[0x2000];
+
+#if REAL_ADDRESSING || DIRECT_ADDRESSING
 static inline uint8 * vm_do_get_real_address(vm_addr_t addr)
 {
-/*#ifdef __APPLE__
-#ifdef __x86_64__*/
-
-	/*if (a < 0x3000) return &gZeroPage[a];
-	else*/ if (KERNEL(addr)) {
-		return (uint8 *)vm_wrap_address((gKernelData + (addr & 0x1fff)));
-	}
-	else if (in_sheep_mem(addr)) {
-		return (uint8 *)vm_wrap_address((sheep_mem + (addr - sheep_base)));
-	}
-	/*else if (too_big((uint32)addr)) {
-		printf("address too big: 0x%08x\n", addr);
-	}*/
-/*#elif defined i386
-#endif*/
-	/*else*/
 	return (uint8 *)vm_wrap_address(VMBaseDiff + addr);
-
 }
 static inline vm_addr_t vm_do_get_virtual_address(uint8 *addr)
 {
-	if ((addr >= gKernelData) && (addr <= gKernelData + 0x2000)) {
-		return KERNEL_DATA_BASE + addr - gKernelData;
-	}
-	/*else*/
-		return vm_wrap_address((uintptr)addr - VMBaseDiff);
+	return vm_wrap_address((uintptr)addr - VMBaseDiff);
 }
-/*#define vm_do_get_virtual_address(addr) ((vm_addr_t)addr)*/
 static inline uint32 vm_read_memory_1(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_1(vm_do_get_real_address(addr));
+	uint8 * const m = vm_do_get_real_address(addr);
+	return vm_do_read_memory_1(m);
 }
 static inline uint32 vm_read_memory_2(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_2((uint16 *)vm_do_get_real_address(addr));
+	uint16 * const m = (uint16 *)vm_do_get_real_address(addr);
+	return vm_do_read_memory_2(m);
 }
 static inline uint32 vm_read_memory_4(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_4((uint32 *)vm_do_get_real_address(addr));
+	uint32 * const m = (uint32 *)vm_do_get_real_address(addr);
+	return vm_do_read_memory_4(m);
 }
 static inline uint64 vm_read_memory_8(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_8((uint64 *)vm_do_get_real_address(addr));
+	uint64 * const m = (uint64 *)vm_do_get_real_address(addr);
+	return vm_do_read_memory_8(m);
 }
 #define vm_read_memory_1_reversed vm_read_memory_1
 static inline uint32 vm_read_memory_2_reversed(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_2_reversed((uint16 *)vm_do_get_real_address(addr));
+	uint16 * const m = (uint16 *)vm_do_get_real_address(addr);
+	return vm_do_read_memory_2_reversed(m);
 }
 static inline uint32 vm_read_memory_4_reversed(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_4_reversed((uint32 *)vm_do_get_real_address(addr));
+	uint32 * const m = (uint32 *)vm_do_get_real_address(addr);
+	return vm_do_read_memory_4_reversed(m);
 }
-static inline uint64 vm_read_memory_8_reversed(vm_addr_t addr)
-{
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_8_reversed((uint64 *)vm_do_get_real_address(addr));
-}
 static inline void vm_write_memory_1(vm_addr_t addr, uint32 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_1(vm_do_get_real_address(addr), value);
+	uint8 * const m = vm_do_get_real_address(addr);
+	vm_do_write_memory_1(m, value);
 }
 static inline void vm_write_memory_2(vm_addr_t addr, uint32 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_2((uint16 *)vm_do_get_real_address(addr), value);
+	uint16 * const m = (uint16 *)vm_do_get_real_address(addr);
+	vm_do_write_memory_2(m, value);
 }
 static inline void vm_write_memory_4(vm_addr_t addr, uint32 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_4((uint32 *)vm_do_get_real_address(addr), value);
+	uint32 * const m = (uint32 *)vm_do_get_real_address(addr);
+	vm_do_write_memory_4(m, value);
 }
 static inline void vm_write_memory_8(vm_addr_t addr, uint64 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_8((uint64 *)vm_do_get_real_address(addr), value);
+	uint64 * const m = (uint64 *)vm_do_get_real_address(addr);
+	vm_do_write_memory_8(m, value);
 }
 #define vm_write_memory_1_reversed vm_write_memory_1
 static inline void vm_write_memory_2_reversed(vm_addr_t addr, uint32 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_2_reversed((uint16 *)vm_do_get_real_address(addr), value);
+	uint16 * const m = (uint16 *)vm_do_get_real_address(addr);
+	vm_do_write_memory_2_reversed(m, value);
 }
 static inline void vm_write_memory_4_reversed(vm_addr_t addr, uint32 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_4_reversed((uint32 *)vm_do_get_real_address(addr), value);
+	uint32 * const m = (uint32 *)vm_do_get_real_address(addr);
+	vm_do_write_memory_4_reversed(m, value);
 }
-static inline void vm_write_memory_8_reversed(vm_addr_t addr, uint64 value)
-{
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_8_reversed((uint64 *)vm_do_get_real_address(addr), value);
-}
 static inline void *vm_memset(vm_addr_t addr, int c, size_t n)
 {
-	if (NO_WRITE(addr)) {
-		return NULL;/*just ignore invalid writes*/
-	}
-	return memset((uint8 *)vm_do_get_real_address(addr), c, n);
+	uint8 * const m = (uint8 *)vm_do_get_real_address(addr);
+	return memset(m, c, n);
 }
 #ifdef __cplusplus
 static inline void *vm_memcpy(void *dest, vm_addr_t src, size_t n)
 {
-	if (ZERO(src)) {
-		return memset(dest, 0, n);
-	}
-	else {
-		return memcpy(dest, vm_do_get_real_address(src), n);
-	}
+	return memcpy(dest, vm_do_get_real_address(src), n);
 }
 static inline void *vm_memcpy(vm_addr_t dest, const void *src, size_t n)
 {
-	if (NO_WRITE(dest)) {
-		return NULL;
-	}
-	/*else*/
-		return memcpy(vm_do_get_real_address(dest), src, n);
+	return memcpy(vm_do_get_real_address(dest), src, n);
 }
 #endif
 static inline void *vm_memcpy(vm_addr_t dest, vm_addr_t src, size_t n)
 {
-	if (NO_WRITE(dest)) {
-		return NULL;
-	}
-	else if (ZERO(src)) {
-		return memset(vm_do_get_real_address(dest), 0, n);
-	}
-	/*else*/
-		return memcpy(vm_do_get_real_address(dest), vm_do_get_real_address(src), n);
+	return memcpy(vm_do_get_real_address(dest), vm_do_get_real_address(src), n);
 }
-/*#endif*/
+#endif
 
 #endif /* VM_H */
 
--- macemu/SheepShaver/src/kpx_cpu/src/mathlib/ieeefp-i386.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/mathlib/ieeefp-i386.cpp
@@ -23,6 +23,10 @@
  *  CPU features
  */
 
+#ifdef _MSC_VER
+#include <float.h>
+#endif
+
 /* XXX: duplicate from cpu/ppc/ppc-dyngen.cpp! */
 static uint32 cpu_features = 0;
 
@@ -36,27 +40,73 @@
 static unsigned int x86_cpuid(void)
 {
 	int fl1, fl2;
+	const unsigned int id_flag = 0x00200000;
 
 	/* See if we can use cpuid. On AMD64 we always can.  */
-	__asm__ ("pushfl; pushfl; popl %0; movl %0,%1; xorl %2,%0;"
-			 "pushl %0; popfl; pushfl; popl %0; popfl"
-			 : "=&r" (fl1), "=&r" (fl2)
-			 : "i" (0x00200000));
-	if (((fl1 ^ fl2) & 0x00200000) == 0)
+#ifdef _MSC_VER
+	__asm {
+		mov edx, id_flag;
+		pushfd;                         /* Save %eflags to restore later.  */
+		pushfd;                         /* Push second copy, for manipulation.  */
+		pop ebx;                        /* Pop it into post_change.  */
+		mov eax, ebx;                   /* Save copy in pre_change.   */
+		xor ebx, edx;                   /* Tweak bit in post_change.  */
+		push ebx;                       /* Push tweaked copy... */
+		popfd;                          /* ... and pop it into eflags.  */
+		pushfd;                         /* Did it change?  Push new %eflags... */
+		pop ebx;                        /* ... and pop it into post_change.  */
+		popfd;                          /* Restore original value.  */
+		mov fl1, eax;
+		mov fl2, ebx;
+	}
+#else
+	asm ("pushfl\n\t"          /* Save %eflags to restore later.  */
+		 "pushfl\n\t"          /* Push second copy, for manipulation.  */
+		 "popl %1\n\t"         /* Pop it into post_change.  */
+		 "movl %1,%0\n\t"      /* Save copy in pre_change.   */
+		 "xorl %2,%1\n\t"      /* Tweak bit in post_change.  */
+		 "pushl %1\n\t"        /* Push tweaked copy... */
+		 "popfl\n\t"           /* ... and pop it into %eflags.  */
+		 "pushfl\n\t"          /* Did it change?  Push new %eflags... */
+		 "popl %1\n\t"         /* ... and pop it into post_change.  */
+		 "popfl"               /* Restore original value.  */
+		 : "=&r" (fl1), "=&r" (fl2)
+		 : "ir" (id_flag));
+#endif
+	if (((fl1 ^ fl2) & id_flag) == 0)
 		return (0);
 
 	/* Host supports cpuid.  See if cpuid gives capabilities, try
 	   CPUID(0).  Preserve %ebx and %ecx; cpuid insn clobbers these, we
 	   don't need their CPUID values here, and %ebx may be the PIC
 	   register.  */
+#ifdef _MSC_VER
+	__asm {
+		xor ecx, ecx;
+		xor eax, eax;
+		cpuid;
+		mov fl1, eax;
+	}
+#else
 	__asm__ ("push %%ecx ; push %%ebx ; cpuid ; pop %%ebx ; pop %%ecx"
 			 : "=a" (fl1) : "0" (0) : "edx", "cc");
+#endif
 	if (fl1 == 0)
 		return (0);
 
 	/* Invoke CPUID(1), return %edx; caller can examine bits to
 	   determine what's supported.  */
+#ifdef _MSC_VER
+	__asm {
+		xor ecx, ecx;
+		xor ebx, ebx;
+		mov eax, 1;
+		cpuid;
+		mov fl2, edx;
+	}
+#else
 	__asm__ ("push %%ecx ; push %%ebx ; cpuid ; pop %%ebx ; pop %%ecx" : "=d" (fl2) : "a" (1) : "cc");
+#endif
 
 	return fl2;
 }
@@ -79,18 +129,22 @@
 // Get current rounding direction
 int fegetround(void)
 {
+#ifdef _MSC_VER
+	return _status87() & _MCW_RC;
+#else
 	unsigned short cw;
-
 	__asm__ __volatile__("fnstcw %0" : "=m" (*&cw));
-
 	return cw & 0xc00;
+#endif
 }
 
 // Set the rounding direction represented by ROUND
 int fesetround(int round)
 {
-	unsigned short cw;
-
+#ifdef _MSC_VER
+	_control87(round, _MCW_RC);
+#else
+	uint16 cw;
 	if ((round & ~0xc00) != 0)
 		return 1;
 
@@ -106,6 +160,7 @@
 		xcw |= round << 3;
 		__asm__ __volatile__("ldmxcsr %0" : : "m" (*&xcw));
 	}
+#endif
 
 	return 0;
 }
--- macemu/SheepShaver/src/kpx_cpu/src/mathlib/mathlib-i386.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/mathlib/mathlib-i386.cpp
@@ -24,6 +24,10 @@
 #define HAVE_TRUNC
 double trunc(double x)
 {
+#ifdef _MSC_VER
+	/* FIXME: This is probably semantically wrong, and it's slow. */
+	return (double)((long long)x);
+#else
 	volatile unsigned short int cw;
 	volatile unsigned short int cwtmp;
 	double value;
@@ -34,5 +38,11 @@
 	__asm__ __volatile__("frndint" : "=t" (value) : "0" (x));
 	__asm__ __volatile__("fldcw %0" : : "m" (cw));
 	return value;
+#endif
+}
+
+float truncf(float x)
+{
+	return (float)trunc((float)x);
 }
 #endif
--- macemu/SheepShaver/src/kpx_cpu/src/mathlib/mathlib.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/mathlib/mathlib.cpp
@@ -88,6 +88,7 @@
 int mathlib_fpclassifyl(long double x)
 {
 	unimplemented("fpclassifyl");
+	return -1;
 }
 
 
@@ -114,6 +115,7 @@
 int mathlib_signbitl(long double x)
 {
 	unimplemented("signbitl");
+	return -1;
 }
 
 
@@ -191,7 +193,7 @@
 float mathlib_roundf(float x)
 {
 	int32 i0, j0;
-	static const float huge = 1.0e30;
+	static const float huge = 1.0e30f;
 
 	MATHLIB_GET_FLOAT_WORD (i0, x);
 	j0 = ((i0 >> 23) & 0xff) - 0x7f;
--- macemu/SheepShaver/src/kpx_cpu/src/test/test-powerpc.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/test/test-powerpc.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-// NOTE: Results file md5sum: 3e29432abb6e21e625a2eef8cf2f0840 ($Revision$)
+// NOTE: Results file md5sum: 3e29432abb6e21e625a2eef8cf2f0840 ($Revision: 1.35 $)
 
 #include <vector>
 #include <limits>
@@ -38,8 +38,8 @@
 #if EMU_KHEPERIX
 #include "sysdeps.h"
 #include "vm_alloc.h"
-/*#include "cpu/ppc/ppc-cpu.hpp"
-#include "cpu/ppc/ppc-instructions.hpp"*/
+#include "cpu/ppc/ppc-cpu.hpp"
+#include "cpu/ppc/ppc-instructions.hpp"
 #endif
 
 #if EMU_MICROLIB
@@ -64,14 +64,14 @@
 typedef int BOOL;
 #endif
 
-/*#if EMU_QEMU
+#if EMU_QEMU
 extern "C" {
 #include "target-ppc/cpu.h"
 extern void tb_flush();
-}*/
+}
 typedef uint32_t uint32;
 typedef uintptr_t uintptr;
-/*#endif*/
+#endif
 
 // Disassemblers needed for debugging purposes
 #if ENABLE_MON
@@ -176,7 +176,7 @@
 
     p = start & ~(MIN_CACHE_LINE_SIZE - 1);
     stop = (stop + MIN_CACHE_LINE_SIZE - 1) & ~(MIN_CACHE_LINE_SIZE - 1);
-
+    
     for (p = start; p < stop; p += MIN_CACHE_LINE_SIZE) {
         asm volatile ("dcbst 0,%0" : : "r"(p) : "memory");
     }
@@ -193,18 +193,12 @@
 }
 #endif
 
-/*#if EMU_KHEPERIX
-// Wrappers when building from SheepShaver tree*/
+#if EMU_KHEPERIX
+// Wrappers when building from SheepShaver tree
 #ifdef SHEEPSHAVER
-uint32 ROMBase = 0x40800000;
 int64 TimebaseSpeed = 25000000;	// Default:  25 MHz
 uint32 PVR = 0x000c0000;		// Default: 7400 (with AltiVec)
 
-bool PrefsFindBool(const char *name)
-{
-	return false;
-}
-
 uint64 GetTicks_usec(void)
 {
 	return clock();
@@ -214,12 +208,12 @@
 {
 }
 
-/*#if PPC_ENABLE_JIT && PPC_REENTRANT_JIT
+#if PPC_ENABLE_JIT && PPC_REENTRANT_JIT
 void init_emul_op_trampolines(basic_dyngen & dg)
 {
 }
-#endif*/
 #endif
+#endif
 
 struct powerpc_cpu_base
 	: public powerpc_cpu
@@ -987,7 +981,7 @@
 	const uint32 emul_rd = get_gpr(RD);
 	const uint32 emul_xer = emul_get_xer();
 	const uint32 emul_cr = emul_get_cr();
-
+	
 	++tests;
 
 	bool ok = native_rd == emul_rd
--- macemu/SheepShaver/src/macos_util.cpp
+++ sheepshaver/SheepShaver/src/macos_util.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "cpu_emulation.h"
 #include "main.h"
 #include "sony.h"
@@ -179,7 +179,7 @@
 
 	if (ReadMacInt32(XLM_RUN_MODE) == MODE_EMUL_OP) {
 		M68kRegisters r;
-
+	
 		// Find shared library
 		static const uint8 proc1_template[] = {
 			0x55, 0x8f,							// subq.l	#2,a7
@@ -203,7 +203,7 @@
 		D(bug(" GetSharedLibrary: ret %d, connection ID %ld, main %p\n", (int16)r.d[0], conn_id.value(), main_addr.value()));
 		if (r.d[0])
 			return 0;
-
+	
 		// Find symbol
 		static const uint8 proc2_template[] = {
 			0x55, 0x8f,					// subq.l	#2,a7
@@ -324,13 +324,7 @@
 	// This code is taken from glibc 2.2
 
 	// Convert to number of seconds elapsed since 1-Jan-1904
-#ifdef WIN32
 	struct tm *local = localtime(&t);
-#else
-	struct tm result;
-	localtime_r(&t, &result);
-	struct tm *local = &result;
-#endif
 	const int TM_EPOCH_YEAR = 1900;
 	const int MAC_EPOCH_YEAR = 1904;
 	int a4 = ((local->tm_year + TM_EPOCH_YEAR) >> 2) - !(local->tm_year & 3);
@@ -342,17 +336,6 @@
 	int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);
 	uint32 days = local->tm_yday + 365 * (local->tm_year - 4) + intervening_leap_days;
 	return local->tm_sec + 60 * (local->tm_min + 60 * (local->tm_hour + 24 * days));
-}
-
-
-/*
- *  Convert MacOS time to time_t (seconds since 1.1.1970)
- */
-
-time_t MacTimeToTime(uint32 t)
-{
-	// simply subtract number of seconds between 1.1.1904 and 1.1.1970
-	return t - 2082826800;
 }
 
 
--- macemu/SheepShaver/src/main.cpp
+++ sheepshaver/SheepShaver/src/main.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include "main.h"
 #include "version.h"
@@ -44,13 +44,13 @@
 #include "macos_util.h"
 #include "rom_patches.h"
 #include "user_strings.h"
-#include "CrossPlatform/vm_alloc.h"
-#include "CrossPlatform/sigsegv.h"
+#include "vm_alloc.h"
+#include "sigsegv.h"
 #include "thunks.h"
 
 #define DEBUG 0
 #include "debug.h"
-extern uint8 gKernelData[];
+
 #ifdef ENABLE_MON
 #include "mon.h"
 
@@ -133,7 +133,7 @@
 	SCSIInit();
 
 	// Init external file system
-	ExtFSInit();
+	ExtFSInit(); 
 
 	// Init ADB
 	ADBInit();
@@ -164,62 +164,63 @@
 	}
 
 	// Initialize Kernel Data
-	memset(gKernelData, 0, sizeof(KernelData));
+	KernelData *kernel_data = (KernelData *)Mac2HostAddr(KERNEL_DATA_BASE);
+	memset(kernel_data, 0, sizeof(KernelData));
 	if (ROMType == ROMTYPE_NEWWORLD) {
 		uint32 of_dev_tree = SheepMem::Reserve(4 * sizeof(uint32));
 		Mac_memset(of_dev_tree, 0, 4 * sizeof(uint32));
 		uint32 vector_lookup_tbl = SheepMem::Reserve(128);
 		uint32 vector_mask_tbl = SheepMem::Reserve(64);
-		Mac_memset(KERNEL_DATA_BASE + 0xb80, 0x3d, 0x80);
+		memset((uint8 *)kernel_data + 0xb80, 0x3d, 0x80);
 		Mac_memset(vector_lookup_tbl, 0, 128);
 		Mac_memset(vector_mask_tbl, 0, 64);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xb80, ROMBase);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xb84, of_dev_tree);			// OF device tree base
-		WriteMacInt32(KERNEL_DATA_BASE + 0xb90, vector_lookup_tbl);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xb94, vector_mask_tbl);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xb98, ROMBase);				// OpenPIC base
-		WriteMacInt32(KERNEL_DATA_BASE + 0xbb0, 0);						// ADB base
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc20, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc24, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc30, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc34, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc38, 0x00010020);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc3c, 0x00200001);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc40, 0x00010000);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc50, RAMBase);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc54, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf60, PVR);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf64, CPUClockSpeed);			// clock-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf68, BusClockSpeed);			// bus-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf6c, TimebaseSpeed);			// timebase-frequency
+		kernel_data->v[0xb80 >> 2] = htonl(ROMBase);
+		kernel_data->v[0xb84 >> 2] = htonl(of_dev_tree);			// OF device tree base
+		kernel_data->v[0xb90 >> 2] = htonl(vector_lookup_tbl);
+		kernel_data->v[0xb94 >> 2] = htonl(vector_mask_tbl);
+		kernel_data->v[0xb98 >> 2] = htonl(ROMBase);				// OpenPIC base
+		kernel_data->v[0xbb0 >> 2] = htonl(0);						// ADB base
+		kernel_data->v[0xc20 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc24 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc30 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc34 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc38 >> 2] = htonl(0x00010020);
+		kernel_data->v[0xc3c >> 2] = htonl(0x00200001);
+		kernel_data->v[0xc40 >> 2] = htonl(0x00010000);
+		kernel_data->v[0xc50 >> 2] = htonl(RAMBase);
+		kernel_data->v[0xc54 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xf60 >> 2] = htonl(PVR);
+		kernel_data->v[0xf64 >> 2] = htonl(CPUClockSpeed);			// clock-frequency
+		kernel_data->v[0xf68 >> 2] = htonl(BusClockSpeed);			// bus-frequency
+		kernel_data->v[0xf6c >> 2] = htonl(TimebaseSpeed);			// timebase-frequency
 	} else if (ROMType == ROMTYPE_GOSSAMER) {
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc80, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc84, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc90, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc94, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc98, 0x00010020);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc9c, 0x00200001);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xca0, 0x00010000);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xcb0, RAMBase);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xcb4, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf60, PVR);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf64, CPUClockSpeed);			// clock-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf68, BusClockSpeed);			// bus-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf6c, TimebaseSpeed);			// timebase-frequency
+		kernel_data->v[0xc80 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc84 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc90 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc94 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc98 >> 2] = htonl(0x00010020);
+		kernel_data->v[0xc9c >> 2] = htonl(0x00200001);
+		kernel_data->v[0xca0 >> 2] = htonl(0x00010000);
+		kernel_data->v[0xcb0 >> 2] = htonl(RAMBase);
+		kernel_data->v[0xcb4 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xf60 >> 2] = htonl(PVR);
+		kernel_data->v[0xf64 >> 2] = htonl(CPUClockSpeed);			// clock-frequency
+		kernel_data->v[0xf68 >> 2] = htonl(BusClockSpeed);			// bus-frequency
+		kernel_data->v[0xf6c >> 2] = htonl(TimebaseSpeed);			// timebase-frequency
 	} else {
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc80, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc84, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc90, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc94, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc98, 0x00010020);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc9c, 0x00200001);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xca0, 0x00010000);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xcb0, RAMBase);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xcb4, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf80, PVR);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf84, CPUClockSpeed);			// clock-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf88, BusClockSpeed);			// bus-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf8c, TimebaseSpeed);			// timebase-frequency
+		kernel_data->v[0xc80 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc84 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc90 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc94 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc98 >> 2] = htonl(0x00010020);
+		kernel_data->v[0xc9c >> 2] = htonl(0x00200001);
+		kernel_data->v[0xca0 >> 2] = htonl(0x00010000);
+		kernel_data->v[0xcb0 >> 2] = htonl(RAMBase);
+		kernel_data->v[0xcb4 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xf80 >> 2] = htonl(PVR);
+		kernel_data->v[0xf84 >> 2] = htonl(CPUClockSpeed);			// clock-frequency
+		kernel_data->v[0xf88 >> 2] = htonl(BusClockSpeed);			// bus-frequency
+		kernel_data->v[0xf8c >> 2] = htonl(TimebaseSpeed);			// timebase-frequency
 	}
 
 	// Initialize extra low memory
@@ -230,8 +231,8 @@
 	WriteMacInt32(XLM_PVR, PVR);									// Theoretical PVR
 	WriteMacInt32(XLM_BUS_CLOCK, BusClockSpeed);					// For DriverServicesLib patch
 	WriteMacInt16(XLM_EXEC_RETURN_OPCODE, M68K_EXEC_RETURN);		// For Execute68k() (RTS from the executed 68k code will jump here and end 68k mode)
-	WriteMacInt32(XLM_ZERO_PAGE, /*SheepMem::ZeroPage()*//*0*/NULL_PAGE);	// Pointer to read-only page with all bits set to 0
-#if !EMULATED_PPC
+	WriteMacInt32(XLM_ZERO_PAGE, SheepMem::ZeroPage());				// Pointer to read-only page with all bits set to 0
+#if !defined(EMULATED_PPC)
 #ifdef SYSTEM_CLOBBERS_R2
 	WriteMacInt32(XLM_TOC, (uint32)TOC);							// TOC pointer of emulator
 #endif
--- macemu/SheepShaver/src/name_registry.cpp
+++ sheepshaver/SheepShaver/src/name_registry.cpp
@@ -20,7 +20,7 @@
 
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "name_registry.h"
 #include "main.h"
 #include "macos_util.h"
Only in macemu/: SheepShaver/src/pict.c
--- macemu/SheepShaver/src/prefs.cpp
+++ sheepshaver/SheepShaver/src/prefs.cpp
@@ -23,7 +23,7 @@
 #include <stdio.h>
 #include <ctype.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "sys.h"
 #include "prefs.h"
 
@@ -382,15 +382,12 @@
 void LoadPrefsFromStream(FILE *f)
 {
 	char line[256];
-	while(fgets(line, sizeof(line), f)) {
-		// Remove newline, if present
+	while(fgets(line, 255, f)) {
+		// Read line
 		int len = strlen(line);
-		if (len > 0 && line[len-1] == '\n') {
-			line[len-1] = '\0';
-			len--;
-		}
 		if (len == 0)
 			continue;
+		line[len-1] = 0;
 
 		// Comments begin with "#" or ";"
 		if (line[0] == '#' || line[0] == ';')
@@ -398,12 +395,11 @@
 
 		// Terminate string after keyword
 		char *p = line;
-		while (*p && !isspace(*p)) p++;
-		if (*p != '\0')
-			*p++ = 0;
+		while (!isspace(*p)) p++;
+		*p++ = 0;
 
 		// Skip whitespace until value
-		while (*p && isspace(*p)) p++;
+		while (isspace(*p)) p++;
 		char *keyword = line;
 		char *value = p;
 		int32 i = atol(value);
--- macemu/SheepShaver/src/prefs_items.cpp
+++ sheepshaver/SheepShaver/src/prefs_items.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include "sys.h"
 #include "prefs.h"
--- macemu/SheepShaver/src/rom_patches.cpp
+++ sheepshaver/SheepShaver/src/rom_patches.cpp
@@ -26,7 +26,7 @@
 
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "rom_patches.h"
 #include "main.h"
 #include "prefs.h"
@@ -60,10 +60,9 @@
 
 // Other ROM addresses
 const uint32 CHECK_LOAD_PATCH_SPACE = 0x2fcf00;
-const uint32 ZERO_SCRAP_PATCH_SPACE = 0x2fcf80;
-const uint32 PUT_SCRAP_PATCH_SPACE = 0x2fcfc0;
-const uint32 GET_SCRAP_PATCH_SPACE = 0x2fd100;
-const uint32 ADDR_MAP_PATCH_SPACE = 0x2fd140;
+const uint32 PUT_SCRAP_PATCH_SPACE = 0x2fcf80;
+const uint32 GET_SCRAP_PATCH_SPACE = 0x2fcfc0;
+const uint32 ADDR_MAP_PATCH_SPACE = 0x2fd100;
 
 // Global variables
 int ROMType;				// ROM type
@@ -156,7 +155,7 @@
 		// CHRP compressed ROM image
 		uint32 image_offset, image_size;
 		bool decode_info_ok = false;
-
+		
 		char *s = strstr((char *)data, "constant lzss-offset");
 		if (s != NULL) {
 			// Probably a plain LZSS compressed ROM image
@@ -177,11 +176,11 @@
 				}
 			}
 		}
-
+		
 		// No valid information to decode the ROM found?
 		if (!decode_info_ok)
 			return false;
-
+		
 		// Check signature, this could be a parcels-based ROM image
 		uint32 rom_signature = ntohl(*(uint32 *)(data + image_offset));
 		if (rom_signature == FOURCC('p','r','c','l')) {
@@ -665,6 +664,23 @@
 
 
 /*
+ *  Copy PowerPC code to ROM image and reverse bytes if necessary
+ */
+
+static inline void memcpy_powerpc_code(void *dst, const void *src, size_t len)
+{
+#ifdef WORDS_BIGENDIAN
+	(void)memcpy(dst, src, len);
+#else
+	uint32 *d = (uint32 *)dst;
+	uint32 *s = (uint32 *)src;
+	for (int i = 0; i < len/4; i++)
+		d[i] = htonl(s[i]);
+#endif
+}
+
+
+/*
  *  Install ROM patches (RAMBase and KernelDataAddr must be set)
  */
 
@@ -697,8 +713,6 @@
 	// Check that other ROM addresses point to really free regions
 	if (!check_rom_patch_space(CHECK_LOAD_PATCH_SPACE, 0x40))
 		return false;
-	if (!check_rom_patch_space(ZERO_SCRAP_PATCH_SPACE, 0x40))
-		return false;
 	if (!check_rom_patch_space(PUT_SCRAP_PATCH_SPACE, 0x40))
 		return false;
 	if (!check_rom_patch_space(GET_SCRAP_PATCH_SPACE, 0x40))
@@ -1012,7 +1026,7 @@
 	if ((base = find_rom_data(0x310000, 0x320000, pm_check_dat, sizeof(pm_check_dat))) == 0) return false;
 	D(bug("pm_check %08lx\n", base));
 	lp = (uint32 *)(ROMBaseHost + base);
-
+	
 	static const int spr_check_list[] = {
 		952 /* mmcr0 */, 953 /* pmc1 */, 954 /* pmc2 */, 955 /* sia */,
 		956 /* mmcr1 */, 957 /* pmc3 */, 958 /* pmc4 */, 959 /* sda */
@@ -1081,7 +1095,7 @@
 	*lp++ = htonl(POWERPC_ILLEGAL);
 	*lp = htonl(POWERPC_ILLEGAL);
 
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	// Install EMUL_RETURN, EXEC_RETURN, EXEC_NATIVE and EMUL_OP opcodes
 	lp = (uint32 *)(ROMBaseHost + 0x380000 + (M68K_EMUL_RETURN << 3));
 	*lp++ = htonl(POWERPC_EMUL_OP);
@@ -2281,16 +2295,6 @@
 		*wp++ = htons((level1_int - 12) >> 16);
 		*wp = htons((level1_int - 12) & 0xffff);
 	}
-
-	// Patch ZeroScrap() for clipboard exchange with host OS
-	uint32 zero_scrap = find_rom_trap(0xa9fc);	// ZeroScrap()
-	wp = (uint16 *)(ROMBaseHost + ZERO_SCRAP_PATCH_SPACE);
-	*wp++ = htons(M68K_EMUL_OP_ZERO_SCRAP);
-	*wp++ = htons(M68K_JMP);
-	*wp++ = htons((ROMBase + zero_scrap) >> 16);
-	*wp++ = htons((ROMBase + zero_scrap) & 0xffff);
-	base = ROMBase + ReadMacInt32(ROMBase + 0x22);
-	WriteMacInt32(base + 4 * (0xa9fc & 0x3ff), ZERO_SCRAP_PATCH_SPACE);
 
 	// Patch PutScrap() for clipboard exchange with host OS
 	uint32 put_scrap = find_rom_trap(0xa9fe);	// PutScrap()
--- macemu/SheepShaver/src/rsrc_patches.cpp
+++ sheepshaver/SheepShaver/src/rsrc_patches.cpp
@@ -22,7 +22,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "rsrc_patches.h"
 #include "cpu_emulation.h"
 #include "emul_op.h"
@@ -627,7 +627,7 @@
 
 	if (type == FOURCC('D','R','V','R') && strncmp(&name[1], ".AFPTranslator", name[0]) == 0) {
 		D(bug(" DRVR .AFPTranslator found\n"));
-
+		
 		// Don't access ROM85 as it it was a pointer to a ROM version number (8.0, 8.1)
 		static const uint8 dat[] = {0x3a, 0x2e, 0x00, 0x0a, 0x55, 0x4f, 0x3e, 0xb8, 0x02, 0x8e, 0x30, 0x1f, 0x48, 0xc0, 0x24, 0x40, 0x20, 0x40};
 		base = find_rsrc_data(p, size, dat, sizeof(dat));
@@ -935,7 +935,7 @@
 	D(bug(" GetResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_RES_LIB_TOC, ReadMacInt32(tvec + 4));
 	WriteMacInt32(XLM_GET_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -952,7 +952,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" Get1Resource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_GET_1_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_1_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -969,7 +969,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" GetIndResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_GET_IND_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_IND_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -986,7 +986,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" Get1IndResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_GET_1_IND_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_1_IND_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -1003,7 +1003,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" RGetResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_R_GET_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_R_GET_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -1020,7 +1020,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" GetNamedResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_GET_NAMED_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_NAMED_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -1037,7 +1037,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" Get1NamedResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_GET_1_NAMED_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_1_NAMED_RESOURCE));
 #else
 #ifdef __BEOS__
--- macemu/SheepShaver/src/scsi.cpp
+++ sheepshaver/SheepShaver/src/scsi.cpp
@@ -27,7 +27,7 @@
 #include <stdio.h>
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "cpu_emulation.h"
 #include "main.h"
 #include "user_strings.h"
@@ -115,11 +115,10 @@
 		switch (cmd) {
 			case scInc:
 				WriteMacInt32(tib - 8, ptr + len);
-				// fall through to scNoInc
 			case scNoInc:
-				if ((sg_index > 0) && (Mac2HostAddr(ptr) == sg_ptr[sg_index-1] + sg_len[sg_index-1])) {
+				if ((sg_index > 0) && (Mac2HostAddr(ptr) == sg_ptr[sg_index-1] + sg_len[sg_index-1]))
 					sg_len[sg_index-1] += len;				// Merge to previous entry
-				} else {
+				else {
 					if (sg_index == SG_TABLE_SIZE) {
 						ErrorAlert(GetString(STR_SCSI_SG_FULL_ERR));
 						return -108;
@@ -209,20 +208,21 @@
 		return scSequenceErr;
 
 	// ID valid?
-	if (id < 0 || id > 7)
-		return scBadParmsErr;
+	if (id >= 0 && id <= 7) {
+		target_id = id;
 
-	// Target present?
-	target_id = id;
-	if (!scsi_is_target_present(target_id)) {
-		phase = PH_FREE;
-		fake_status = 0x0000;	// Bus free
-		return scCommErr;
+		// Target present?
+		if (scsi_is_target_present(target_id)) {
+			phase = PH_SELECTED;
+			fake_status = 0x006a;			// Target selected, command phase
+			return 0;
+		}
 	}
 
-	phase = PH_SELECTED;
-	fake_status = 0x006a;		// Target selected, command phase
-	return 0;
+	// Error
+	phase = PH_FREE;
+	fake_status = 0x0000;		// Bus free
+	return scCommErr;
 }
 
 
--- macemu/SheepShaver/src/serial.cpp
+++ sheepshaver/SheepShaver/src/serial.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "main.h"
 #include "macos_util.h"
 #include "serial.h"
@@ -244,7 +244,7 @@
 				WriteMacInt16(pb + csParam + 6, 0x0616);
 				res = noErr;
 				break;
-
+	
 			default:
 				res = the_port->status(pb, dce, code);
 				break;
--- macemu/SheepShaver/src/sony.cpp
+++ sheepshaver/SheepShaver/src/sony.cpp
@@ -28,7 +28,7 @@
  *    Technote FL 24: "Don't Look at ioPosOffset for Devices"
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <string.h>
 #include <vector>
@@ -115,6 +115,7 @@
 	void *fh;			// Floppy driver file handle
 	bool to_be_mounted;	// Flag: drive must be mounted in accRun
 	bool read_only;		// Flag: force write protection
+	uint32 tag_buffer;	// Mac address of tag buffer
 	uint32 status;		// Mac address of drive status record
 };
 
@@ -282,6 +283,7 @@
 
 		info->num = FindFreeDriveNumber(1);
 		info->to_be_mounted = false;
+		info->tag_buffer = 0;
 
 		if (info->fh) {
 
@@ -300,9 +302,9 @@
 			WriteMacInt8(info->status + dsSides, 0xff);
 			WriteMacInt8(info->status + dsTwoSideFmt, 0xff);
 			WriteMacInt8(info->status + dsNewIntf, 0xff);
-			WriteMacInt8(info->status + dsMFMDrive, 0xff);	// SuperDrive (0 = 400/800K GCR drive)
-			WriteMacInt8(info->status + dsMFMDisk, 0xff);	// MFM (0 = GCR)
-			WriteMacInt8(info->status + dsTwoMegFmt, 0xff);	// 1.44MB (0 = 720K)
+			WriteMacInt8(info->status + dsMFMDrive, 0xff);
+			WriteMacInt8(info->status + dsMFMDisk, 0xff);
+			WriteMacInt8(info->status + dsTwoMegFmt, 0xff);
 
 			// Disk in drive?
 			if (SysIsDiskInserted(info->fh)) {
@@ -387,10 +389,10 @@
 
 	// General codes
 	switch (code) {
-		case 1:		// KillIO (not supported)
+		case 1:		// KillIO
 			return set_dsk_err(-1);
 
-		case 9:		// Track cache control (ignore, assume that host OS does the caching)
+		case 9:		// Track cache
 			return set_dsk_err(noErr);
 
 		case 65:	// Periodic action (accRun, "insert" disks on startup)
@@ -409,30 +411,30 @@
 	// Drive-specific codes
 	int16 err = noErr;
 	switch (code) {
-		case 5:			// Verify disk
-			if (ReadMacInt8(info->status + dsDiskInPlace) <= 0) {
-				err = offLinErr;
-			}
+		case 5:		// Verify disk
+			if (ReadMacInt8(info->status + dsDiskInPlace) <= 0)
+				err = verErr;
 			break;
 
-		case 6:			// Format disk
-			if (info->read_only) {
+		case 6:		// Format disk
+			if (info->read_only)
 				err = wPrErr;
-			} else if (ReadMacInt8(info->status + dsDiskInPlace) > 0) {
+			else if (ReadMacInt8(info->status + dsDiskInPlace) > 0) {
 				if (!SysFormat(info->fh))
 					err = writErr;
 			} else
 				err = offLinErr;
 			break;
 
-		case 7:			// Eject
+		case 7:		// Eject
 			if (ReadMacInt8(info->status + dsDiskInPlace) > 0) {
 				SysEject(info->fh);
 				WriteMacInt8(info->status + dsDiskInPlace, 0);
 			}
 			break;
 
-		case 8:			// Set tag buffer (ignore, not supported)
+		case 8:		// Set tag buffer
+			info->tag_buffer = ReadMacInt32(pb + csParam);
 			break;
 
 		case 21:		// Get drive icon
@@ -444,26 +446,18 @@
 			break;
 
 		case 23:		// Get drive info
-			if (info->num == 1) {
-				WriteMacInt32(pb + csParam, 0x0004);	// Internal SuperDrive
-			} else {
-				WriteMacInt32(pb + csParam, 0x0104);	// External SuperDrive
-			}
+			if (info->num == 1)
+				WriteMacInt32(pb + csParam, 0x0004);	// Internal drive
+			else
+				WriteMacInt32(pb + csParam, 0x0104);	// External drive
 			break;
 
-//		case 0x4350:	// Enable/disable retries ('CP') (not supported)
-//			break;
-
-//		case 0x4744:	// Get raw track data ('GD') (not supported)
-//			break;
-
-		case 0x5343:	// Format and write to disk ('SC') in one pass, used by DiskCopy to speed things up
-			if (!ReadMacInt8(info->status + dsDiskInPlace)) {
+		case 0x5343:	// Format and write to disk ('SC'), used by DiskCopy
+			if (!ReadMacInt8(info->status + dsDiskInPlace))
 				err = offLinErr;
-			} else if (info->read_only) {
+			else if (info->read_only)
 				err = wPrErr;
-			} else {
-				// Assume that the disk is already formatted and only write the data
+			else {
 				void *data = Mac2HostAddr(ReadMacInt32(pb + csParam + 2));
 				size_t actual = Sys_write(info->fh, data, 0, 2880*512);
 				if (actual != 2880*512)
@@ -497,44 +491,30 @@
 
 	int16 err = noErr;
 	switch (code) {
-		case 6:			// Return list of supported disk formats
-			if (ReadMacInt16(pb + csParam) > 0) {	// At least one entry requested?
+		case 6:		// Return format list
+			if (ReadMacInt16(pb + csParam) > 0) {
 				uint32 adr = ReadMacInt32(pb + csParam + 2);
-				WriteMacInt16(pb + csParam, 1);		// 1 format supported
+				WriteMacInt16(pb + csParam, 1);		// 1 format
 				WriteMacInt32(adr, 2880);			// 2880 sectors
-				WriteMacInt32(adr + 4, 0xd2120050);	// DD, 2 heads, 18 secs/track, 80 tracks
-
-				// Upper byte of format flags:
-				//  bit #7: number of tracks, sectors, and heads is valid
-				//  bit #6: current disk has this format
-				//  bit #5: <unused>
-				//  bit #4: double density
-				//  bits #3..#0: number of heads
-			} else {
+				WriteMacInt32(adr + 4, 0xd2120050);	// 2 heads, 18 secs/track, 80 tracks
+			} else
 				err = paramErr;
-			}
 			break;
 
-		case 8:			// Get drive status
+		case 8:		// Get drive status
 			Mac2Mac_memcpy(pb + csParam, info->status, 22);
 			break;
 
-		case 10:		// Get disk type and MFM info
-			WriteMacInt32(pb + csParam, ReadMacInt32(info->status + dsMFMDrive) & 0xffffff00 | 0xfe);	// 0xfe = SWIM2 controller
+		case 10:	// Get disk type
+			WriteMacInt32(pb + csParam, ReadMacInt32(info->status + dsMFMDrive) & 0xffffff00 | 0xfe);
 			break;
 
-//		case 0x4350:	// Measure disk speed at a given track ('CP') (not supported)
-//			break;
-
-		case 0x4456:	// Duplicator (DiskCopy) version supported ('DV'), enables the 'SC' control code above
-			WriteMacInt16(pb + csParam, 0x0410);	// Version 4.1 and later
+		case 0x4456: // Duplicator version supported ('DV')
+			WriteMacInt16(pb + csParam, 0x0410);
 			break;
 
-//		case 0x5250:	// Get floppy info record ('RP') (not supported)
-//			break;
-
-		case 0x5343:	// Get address header format byte ('SC')
-			WriteMacInt8(pb + csParam, 0x02);	// 500 kbit/s (HD) MFM
+		case 0x5343: // Get address header format byte ('SC')
+			WriteMacInt8(pb + csParam, 0x22);	// 512 bytes/sector
 			break;
 
 		default:
--- macemu/SheepShaver/src/thunks.cpp
+++ sheepshaver/SheepShaver/src/thunks.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "thunks.h"
 #include "emul_op.h"
 #include "cpu_emulation.h"
@@ -50,7 +50,7 @@
  *  Return the fake PowerPC opcode to handle specified native code
  */
 
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 uint32 NativeOpcode(int selector)
 {
 	uint32 opcode;
@@ -110,7 +110,7 @@
  *  Generate PowerPC thunks for GetResource() replacements
  */
 
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 static uint32 get_resource_func;
 static uint32 get_1_resource_func;
 static uint32 get_ind_resource_func;
@@ -260,7 +260,7 @@
 
 bool ThunksInit(void)
 {
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	for (int i = 0; i < NATIVE_OP_MAX; i++) {
 		uintptr base = SheepMem::Reserve(16);
 		WriteMacInt32(base + 0, base + 8);
--- macemu/SheepShaver/src/timer.cpp
+++ sheepshaver/SheepShaver/src/timer.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "timer.h"
 #include "macos_util.h"
 #include "main.h"
@@ -62,7 +62,7 @@
 #ifdef PRECISE_TIMING_BEOS
 static thread_id timer_thread = -1;
 static bool thread_active = true;
-static const tm_time_t wakeup_time_max = 0x7fffffffffffffff;
+static const tm_time_t wakeup_time_max = 0x7fffffffffffffff; 
 static volatile tm_time_t wakeup_time = wakeup_time_max;
 static sem_id wakeup_time_sem = -1;
 static int32 timer_func(void *arg);
@@ -272,7 +272,7 @@
 	resume_thread(timer_thread);
 #elif PRECISE_TIMING_MACH
 	pthread_t pthread;
-
+	
 	host_get_clock_service(mach_host_self(), REALTIME_CLOCK, &system_clock);
 	semaphore_create(mach_task_self(), &wakeup_time_sem, SYNC_POLICY_FIFO, 1);
 
@@ -324,7 +324,7 @@
 	while (desc) {
 		TMDesc *next = desc->next;
 		delete desc;
-		desc = next;
+		desc = desc->next;
 	}
 	tmDescList = NULL;
 }
@@ -339,7 +339,7 @@
 	D(bug("InsTime %08lx, trap %04x\n", tm, trap));
 	WriteMacInt16((uint32)tm + qType, ReadMacInt16((uint32)tm + qType) & 0x1fff | (trap << 4) & 0x6000);
 	if (find_desc(tm))
-		printf("WARNING: InsTime(%08x): Task re-inserted\n", tm);
+		printf("WARNING: InsTime(%08lx): Task re-inserted\n", tm);
 	else {
 		TMDesc *desc = new TMDesc;
 		desc->task = tm;
@@ -361,7 +361,7 @@
 	// Find descriptor
 	TMDesc *desc = find_desc(tm);
 	if (!desc) {
-		printf("WARNING: RmvTime(%08x): Descriptor not found\n", tm);
+		printf("WARNING: RmvTime(%08lx): Descriptor not found\n", tm);
 		return 0;
 	}
 
@@ -436,7 +436,7 @@
 	// Find descriptor
 	TMDesc *desc = find_desc(tm);
 	if (!desc) {
-		printf("FATAL: PrimeTime(%08x): Descriptor not found\n", tm);
+		printf("FATAL: PrimeTime(%08lx): Descriptor not found\n", tm);
 		return 0;
 	}
 
@@ -558,13 +558,13 @@
 {
 	timer_thread = mach_thread_self();
 	timer_thread_active = true;
-
+	
 	while (timer_thread_active) {
 		clock_sleep(system_clock, TIME_ABSOLUTE, wakeup_time, NULL);
 		semaphore_wait(wakeup_time_sem);
-
+	   
 		tm_time_t system_time;
-
+		
 		timer_current_time(system_time);
 		if (timer_cmp_time(wakeup_time, system_time) < 0) {
 			wakeup_time = wakeup_time_max;
--- macemu/SheepShaver/src/user_strings.cpp
+++ sheepshaver/SheepShaver/src/user_strings.cpp
@@ -30,7 +30,7 @@
  *   - error messages that only go to the shell ("FATAL"/"WARNING", those are really debugging messages)
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "user_strings.h"
 
 #ifdef __BEOS__
@@ -172,7 +172,6 @@
 
 	{STR_WINDOW_TITLE, "SheepShaver"},
 	{STR_WINDOW_TITLE_FROZEN, "SheepShaver *** FROZEN ***"},
-	{STR_WINDOW_TITLE_GRABBED, "SheepShaver (mouse grabbed, press Ctrl-F5 to release)"},
 	{STR_WINDOW_MENU, "SheepShaver"},
 	{STR_WINDOW_ITEM_ABOUT, "About SheepShaver" ELLIPSIS},
 	{STR_WINDOW_ITEM_REFRESH, "Refresh Rate"},
--- macemu/SheepShaver/src/video.cpp
+++ sheepshaver/SheepShaver/src/video.cpp
@@ -26,7 +26,7 @@
 #include <stdio.h>
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "video.h"
 #include "video_defs.h"
 #include "main.h"
@@ -63,9 +63,9 @@
 /*
  *  Driver local variables
  */
-/*VidLocals vre_data;*/
-VidLocals *private_data = /*&vre_data*/NULL;	// Pointer to driver local variables (there is only one display, so this is ok)
 
+VidLocals *private_data = NULL;	// Pointer to driver local variables (there is only one display, so this is ok)
+
 static long save_conf_id = APPLE_W_640x480;
 static long save_conf_mode = APPLE_8_BIT;
 
@@ -110,10 +110,10 @@
 /*
  *  Tell whether window/screen is activated or not (for mouse/keyboard polling)
  */
-
+ 
 bool VideoActivated(void)
 {
-	return video_activated;
+	return video_activated;	
 }
 
 
@@ -125,7 +125,7 @@
 {
 	if (display_type == DIS_WINDOW) {
 		uint8 *screen = (uint8 *)private_data->saveBaseAddr;
-		uint32 row_bytes = VModes[cur_mode].viRowBytes;
+		uint32 row_bytes = VModes[cur_mode].viRowBytes;	
 		uint32 y2size = VModes[cur_mode].viYsize;
 		uint32 x2size = VModes[cur_mode].viXsize;
 		for (int j=0;j<ysize;j++) {
@@ -213,6 +213,8 @@
 
 static int16 set_gamma(VidLocals *csSave, uint32 gamma)
 {
+	return paramErr;
+
 	if (gamma == 0) { // Build linear ramp, 256 entries
 
 		// Allocate new table, if necessary
@@ -245,7 +247,7 @@
 		int data_width = ReadMacInt16(gamma + gDataWidth);
 		if (data_width > 8)
 			return paramErr;
-		int data_cnt = ReadMacInt16(gamma + gDataCnt);
+		int data_cnt = ReadMacInt16(gamma + gDataWidth);
 		if (data_cnt != (1 << data_width))
 			return paramErr;
 
@@ -283,7 +285,7 @@
 			return video_mode_change(csSave, param);
 
 		case cscSetEntries: {							// SetEntries
-			D(bug("SetEntries\n"));
+			D(bug("SetEntries\n"));					
 			if (VModes[cur_mode].viAppleMode > APPLE_8_BIT) return controlErr;
 			uint32 s_pal = ReadMacInt32(param + csTable);
 			uint16 start = ReadMacInt16(param + csStart);
@@ -366,7 +368,7 @@
 		case cscSetGamma: {							// SetGamma
 			uint32 user_table = ReadMacInt32(param + csGTable);
 			D(bug("SetGamma %08x\n", user_table));
-			return set_gamma(csSave, user_table);
+			return set_gamma(csSave, ReadMacInt32(user_table));
 		}
 
 		case cscGrayPage: {							// GrayPage
@@ -453,6 +455,9 @@
 				return controlErr;
 			uint32 bitmap = ReadMacInt32(bmhandle);
 
+			if (!video_can_change_cursor())
+				return controlErr;
+
 			// Get cursor data even on a screen, to set the right cursor image when switching back to a window.
 			// Hotspot is stale, but will be fixed by the next call to DrawHardwareCursor, which is likely to
 			// occur immediately hereafter.
@@ -466,9 +471,6 @@
 				changed = true;
 			}
 
-			// Set new cursor image
-			if (!video_can_change_cursor())
-				return controlErr;
 			if (changed)
 				video_set_cursor();
 
@@ -634,7 +636,7 @@
 			return noErr;
 
 		case cscGetEntries: {						// GetEntries
-			D(bug("GetEntries\n"));
+			D(bug("GetEntries\n"));	
 			uint32 d_pal = ReadMacInt32(param + csTable);
 			uint16 start = ReadMacInt16(param + csStart);
 			uint16 count = ReadMacInt16(param + csCount);
@@ -697,7 +699,7 @@
 		case cscGetGamma:							// GetGamma
 			D(bug("GetGamma\n"));
 			WriteMacInt32(param, (uint32)csSave->gammaTable);
-			return noErr;
+			return statusErr;
 
 		case cscGetDefaultMode:						// GetDefaultMode
 			D(bug("GetDefaultMode\n"));
@@ -709,7 +711,7 @@
 			WriteMacInt32(param + csData, csSave->saveData);
 			WriteMacInt16(param + csPage, csSave->savePage);
 			WriteMacInt32(param + csBaseAddr, csSave->saveBaseAddr);
-
+			
 			D(bug("return: mode:%04x ID:%08lx page:%04x ", ReadMacInt16(param + csMode),
 				ReadMacInt32(param + csData), ReadMacInt16(param + csPage)));
 			D(bug("base adress %08lx\n", ReadMacInt32(param + csBaseAddr)));
@@ -824,7 +826,7 @@
 				ReadMacInt32(param + csDisplayModeID),
 				ReadMacInt16(param + csDepthMode)));
 
-			// find right video mode
+			// find right video mode						
 			for (int i=0; VModes[i].viType!=DIS_INVALID; i++) {
 				if ((ReadMacInt16(param + csDepthMode) == VModes[i].viAppleMode) &&
 					(ReadMacInt32(param + csDisplayModeID) == VModes[i].viAppleID)) {
@@ -842,42 +844,42 @@
 					WriteMacInt32(vpb + vpVRes, 0x00480000);	// vert res of the device (ppi)
 					switch (VModes[i].viAppleMode) {
 						case APPLE_1_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0);
+							WriteMacInt16(vpb + vpPixelType, 0); 
 							WriteMacInt16(vpb + vpPixelSize, 1);
 							WriteMacInt16(vpb + vpCmpCount, 1);
 							WriteMacInt16(vpb + vpCmpSize, 1);
 							WriteMacInt32(param + csDeviceType, 0); // CLUT
 							break;
 						case APPLE_2_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0);
+							WriteMacInt16(vpb + vpPixelType, 0); 
 							WriteMacInt16(vpb + vpPixelSize, 2);
 							WriteMacInt16(vpb + vpCmpCount, 1);
 							WriteMacInt16(vpb + vpCmpSize, 2);
 							WriteMacInt32(param + csDeviceType, 0); // CLUT
 							break;
 						case APPLE_4_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0);
+							WriteMacInt16(vpb + vpPixelType, 0); 
 							WriteMacInt16(vpb + vpPixelSize, 4);
 							WriteMacInt16(vpb + vpCmpCount, 1);
 							WriteMacInt16(vpb + vpCmpSize, 4);
 							WriteMacInt32(param + csDeviceType, 0); // CLUT
 							break;
 						case APPLE_8_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0);
+							WriteMacInt16(vpb + vpPixelType, 0); 
 							WriteMacInt16(vpb + vpPixelSize, 8);
 							WriteMacInt16(vpb + vpCmpCount, 1);
 							WriteMacInt16(vpb + vpCmpSize, 8);
 							WriteMacInt32(param + csDeviceType, 0); // CLUT
 							break;
 						case APPLE_16_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0x10);
+							WriteMacInt16(vpb + vpPixelType, 0x10); 
 							WriteMacInt16(vpb + vpPixelSize, 16);
 							WriteMacInt16(vpb + vpCmpCount, 3);
 							WriteMacInt16(vpb + vpCmpSize, 5);
 							WriteMacInt32(param + csDeviceType, 2); // DIRECT
 							break;
 						case APPLE_32_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0x10);
+							WriteMacInt16(vpb + vpPixelType, 0x10); 
 							WriteMacInt16(vpb + vpPixelSize, 32);
 							WriteMacInt16(vpb + vpCmpCount, 3);
 							WriteMacInt16(vpb + vpCmpSize, 8);
@@ -1045,7 +1047,7 @@
 				err = -1;
 				break;
 			}
-			Host2Mac_memcpy(private_data->regEntryID, commandContents + 2, 16);	// DriverInitInfo.deviceEntry
+			Mac2Mac_memcpy(private_data->regEntryID, commandContents + 2, 16);	// DriverInitInfo.deviceEntry
 			private_data->interruptsEnabled = false;	// Disable interrupts
 			break;
 
--- macemu/SheepShaver/src/xpram.cpp
+++ sheepshaver/SheepShaver/src/xpram.cpp
@@ -25,26 +25,14 @@
 
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "xpram.h"
 
 
 // Extended parameter RAM
 uint8 XPRAM[XPRAM_SIZE];
 
-char* xpramStr = { 0 };
 
-char* dumpXPRAM()
-{
-	if ( !xpramStr || strlen( xpramStr ) < 1 )
-	{
-		xpramStr = (char*)malloc( 1 << 16 );
-	}
-
-	XPRAMtoString( xpramStr );
-	return xpramStr;
-}
-
 /*
  *  Initialize XPRAM
  */
@@ -67,71 +55,4 @@
 {
 	// Save XPRAM to settings file
 	SaveXPRAM();
-}
-
-size_t XPRAMtoString( const char* buf )
-{
-	char* b = (char*)buf;
-	size_t len;
-
-	*b = '\n'; b++;
-	const char* str = "XPRAM";
-	len = strlen( str );
-	memcpy( b, str, len );
-	b += len;
-	*b = '\n'; b++;
-	*b = '\n'; b++;
-
-	char s[256];
-	for ( size_t offset = 0; offset < XPRAM_SIZE; offset += 16 ) {
-		sprintf( s, "    %08x", offset );
-		len = strlen( s );
-		memcpy( b, s, len );
-		b += len;
-		*b = ' '; b++;
-		*b = ' '; b++;
-
-		//char ascii[17];
-		for ( size_t bytePos = 0; bytePos < 16; bytePos++ )
-		{
-			uint8 symbol = XPRAM[offset + bytePos];
-			//if ( symbol >= 32 && symbol < 128 )
-			//	ascii[bytePos] = (char)symbol;
-			//else
-			//	ascii[bytePos] = ' ';
-			sprintf( s, "%02x", symbol );
-			len = strlen( s );
-			memcpy( b, s, len );
-			b += len;
-			*b = ' '; b++;
-		}
-		//*b = ' '; b++;
-		//memcpy( b, ascii, 16 );
-		//b += 16;
-
-		*b = '\n'; b++;
-	}
-
-	*b = 0;
-	return b - buf;
-}
-
-bool getXPRAMat(size_t off, uint8* out)
-{
-	if ( !out )
-		return false;
-	if ( off >= XPRAM_SIZE )
-		return false;
-
-	*out = XPRAM[ off ];
-	return true;
-}
-
-bool setXPRAMat(size_t off, uint8 byte)
-{
-	if ( off >= XPRAM_SIZE )
-		return false;
-
-	XPRAM[ off ] = byte;
-	return true;
 }
Only in macemu/: bintrailingspacechars-sed-bsd.sh
Only in macemu/: build--basiliskii
Only in macemu/: build--sheepshaver
