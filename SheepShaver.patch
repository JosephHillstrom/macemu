--- macemu/SheepShaver/src/Unix/Linux/NetDriver/sheep_net.c
+++ sheepshaver/SheepShaver/src/Unix/Linux/NetDriver/sheep_net.c
@@ -240,7 +220,7 @@
 {
 	/* Unregister driver */
 	misc_deregister(&sheep_net_device);
-	printk("sheep net: driver removed\n");
+	D(bug("Sheep net driver removed\n"));
 }
 
 
@@ -268,9 +248,12 @@
 	memset(v, 0, sizeof(struct SheepVars));
 	skb_queue_head_init(&v->queue);
 	init_waitqueue_head(&v->wait);
-	v->fake_addr[0] = 'v'; /* "SheepShaver" */
-	v->fake_addr[1] = 'r'; /*          ^ ^  */
-	get_random_bytes(&v->fake_addr[2], 4);
+	v->fake_addr[0] = 0xfe;
+	v->fake_addr[1] = 0xfd;
+	v->fake_addr[2] = 0xde;
+	v->fake_addr[3] = 0xad;
+	v->fake_addr[4] = 0xbe;
+	v->fake_addr[5] = 0xef;
 
 	/* Put our stuff where we will be able to find it later */
 	f->private_data = (void *)v;
@@ -601,7 +569,7 @@
 
 			/* Allocate socket */
 #ifdef LINUX_26
-			v->skt = compat_sk_alloc(dev_net(v->ether), GFP_USER, 1, &sheep_proto);
+			v->skt = sk_alloc(dev_net(v->ether), GFP_USER, 1, &sheep_proto);
 #else
 			v->skt = sk_alloc(0, GFP_USER, 1);
 #endif
--- macemu/SheepShaver/src/Unix/ether_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/ether_unix.cpp
@@ -230,7 +193,7 @@
 
 bool ether_init(void)
 {
-	int val;
+	int val, nonblock = 1;
 	char str[256];
 
 	// Do nothing if no Ethernet device specified
@@ -355,7 +288,6 @@
 
 	// Set nonblocking I/O
 #ifdef USE_FIONBIO
-	int nonblock = 1;
 	if (ioctl(fd, FIONBIO, &nonblock) < 0) {
 		sprintf(str, GetString(STR_BLOCKING_NET_SOCKET_WARN), strerror(errno));
 		WarningAlert(str);
@@ -379,17 +311,3 @@
 		ether_addr[3] = p >> 16;
 		ether_addr[4] = p >> 8;
 		ether_addr[5] = p;
 #ifdef HAVE_SLIRP
 	} else if (net_if_type == NET_IF_SLIRP) {
 		ether_addr[0] = 0x52;
 		ether_addr[1] = 0x54;
 		ether_addr[2] = 0x00;
 		ether_addr[3] = 0x12;
 		ether_addr[4] = 0x34;
 		ether_addr[5] = 0x56;
+	} else {
+#elif defined __linux
+		struct ifreq ifr;
+		int r, sock;
+		memset(&ifr, 0, sizeof(ifr));
+		sock = socket(PF_INET, SOCK_DGRAM, 0);
+		strcpy(ifr.ifr_name, net_if_name);
+		r = ioctl(sock, SIOCGIFHWADDR, &ifr);
+		if (r == -1)
+			perror("ioctl(SIOCGIFHWADDR)");
+		else
+			memcpy(ether_addr, ifr.ifr_hwaddr.sa_data, 6);
+		close(sock);
+#else
+		ioctl(fd, SIOCGIFADDR, &ether_addr);
 #endif
-	} else
-		ioctl(fd, SIOCGIFADDR, ether_addr);
-	D(bug("Ethernet address %02x %02x %02x %02x %02x %02x\n", ether_addr[0], ether_addr[1], ether_addr[2], ether_addr[3], ether_addr[4], ether_addr[5]));
+	}
+	D(bug("Ethernet address %02x:%02x:%02x:%02x:%02x:%02x\n", ether_addr[0], ether_addr[1], ether_addr[2], ether_addr[3], ether_addr[4], ether_addr[5]));
 
 	// Start packet reception thread
 	if (!start_thread())
--- macemu/SheepShaver/src/Unix/user_strings_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/user_strings_unix.cpp
@@ -84,6 +83,7 @@
 	{STR_VOSF_INIT_ERR, "Cannot initialize Video on SEGV signals."},
 
 	{STR_OPEN_WINDOW_ERR, "Cannot open Mac window."},
+	{STR_WINDOW_TITLE_GRABBED, "SheepShaver (mouse grabbed, press Ctrl-F5 to release)"},
 
 	{STR_NO_B2_EXE_FOUND, "Could not start %s (%s)."},
 
--- macemu/SheepShaver/src/Unix/user_strings_unix.h
+++ sheepshaver/SheepShaver/src/Unix/user_strings_unix.h
@@ -78,6 +77,7 @@
 	STR_MOUSEWHEELLINES_CTRL,
 
 	STR_OPEN_WINDOW_ERR,
+	STR_WINDOW_TITLE_GRABBED,
 
 	STR_NO_B2_EXE_FOUND
 };
--- macemu/SheepShaver/src/Windows/clip_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/clip_windows.cpp
@@ -21,6 +21,8 @@
 #include "sysdeps.h"
 
 #include <vector>
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
 
 #include "macos_util.h"
 #include "clip.h"
--- macemu/SheepShaver/src/Windows/sysdeps.h
+++ sheepshaver/SheepShaver/src/Windows/sysdeps.h
@@ -32,22 +32,59 @@
 #error "You don't have ANSI C header files."
 #endif
 
+#ifdef _MSC_VER
+#ifdef _M_IX86
+#define __i386__ 1
+#endif
+#ifdef _M_X64
+#define __x86_64__ 1
+#endif
+#endif
+
 #include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifndef _MSC_VER
 #include <stdint.h>
+#endif
+#include <inttypes.h>
 #include <string.h>
 #include <time.h>
 #ifdef __WIN32__
+#define NOMINMAX
+#define WINVER 0x0501
+#define _WIN32_WINNT 0x0501
+#include <winsock2.h>
 #include <windows.h>
 #endif
 #include <sys/types.h>
+#include <sys/timeb.h>
+#include <math.h>
 
+#ifdef _MSC_VER
+#define snprintf _snprintf
+#define O_ACCMODE 0x0003
+typedef size_t ssize_t;
+#include <float.h>
+extern double round(double x);
+extern float roundf(float x);
+extern double trunc(double x);
+extern float truncf(float x);
+#endif
 
+inline double sys_time()
+{
+    struct _timeb tb;
+    _ftime(&tb);
+	return (double)tb.time + ((double)tb.millitm / 1000.0);
+}
+
 // Define for external components
 #define SHEEPSHAVER 1
 #define POWERPC_ROM 1
+#ifndef EMULATED_PPC
 #define EMULATED_PPC 1
+#endif
 #define CONFIG_WIN32 1
 
 // Use Direct Addressing mode
@@ -148,6 +185,21 @@
 #endif
 #endif
 
+#if defined(_MSC_VER) && 0
+#define opt_bswap_16 _byteswap_ushort
+#define opt_bswap_32 do_opt_bswap_32
+static inline uint32 do_opt_bswap_32(uint32 x)
+{
+	uint32 v;
+	__asm {
+		mov eax, x;
+		bswap eax;
+		mov v, eax;
+	}
+	return v;
+}
+#endif
+
 #ifdef  opt_bswap_16
 #undef  bswap_16
 #define bswap_16 opt_bswap_16
@@ -178,12 +230,16 @@
 }
 
 #if defined(__i386__)
+#if defined(_MSC_VER) && 0
+#define opt_bswap_64 _byteswap_uint64
+#else
 #define opt_bswap_64 do_opt_bswap_64
 static inline uint64 do_opt_bswap_64(uint64 x)
 {
   return (bswap_32(x >> 32) | (((uint64)bswap_32((uint32)x)) << 32));
 }
 #endif
+#endif
 
 #ifdef  opt_bswap_64
 #undef  bswap_64
@@ -315,7 +371,20 @@
 
 #endif /* __GNUC__ */
 
+#ifdef _MSC_VER
+#define HAVE_TEST_AND_SET 1
+static inline LONG testandset(volatile LONG *p)
+{
+	assert(*p >= 0 && *p <= 1);
+	return InterlockedExchange(p, 1);
+}
+#endif /* _MSC_VER */
+
+#ifdef _MSC_VER
+typedef volatile LONG spinlock_t;
+#else
 typedef volatile int spinlock_t;
+#endif
 
 static const spinlock_t SPIN_LOCK_UNLOCKED = 0;
 
@@ -394,7 +463,9 @@
 // Misc platform specific definitions
 #ifdef __WIN32__
 typedef int64 loff_t;
-#endif
+#define ATTRIBUTE_PACKED
+#else
 #define ATTRIBUTE_PACKED __attribute__((__packed__))
+#endif
 
 #endif
--- macemu/SheepShaver/src/Windows/timer_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/timer_windows.cpp
@@ -20,6 +20,9 @@
 
 #include "sysdeps.h"
 
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
 #include "main.h"
 #include "macos_util.h"
 #include "timer.h"
--- macemu/SheepShaver/src/Windows/user_strings_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/user_strings_windows.cpp
@@ -45,6 +45,7 @@
 	{STR_VOSF_INIT_ERR, "Cannot initialize Video on SEGV signals."},
 
 	{STR_OPEN_WINDOW_ERR, "Cannot open Mac window."},
+	{STR_WINDOW_TITLE_GRABBED, "SheepShaver (mouse grabbed, press Ctrl-F5 to release)"},
 	{STR_NO_WIN32_NT_4, "SheepShaver does not run on Windows NT versions less than 4.0"},
 
 	{STR_PREFS_MENU_FILE_GTK, "/_File"},
--- macemu/SheepShaver/src/Windows/user_strings_windows.h
+++ sheepshaver/SheepShaver/src/Windows/user_strings_windows.h
@@ -39,6 +39,7 @@
 	STR_KEYCODE_FILE_WARN,
 	STR_KEYCODE_VENDOR_WARN,
 	STR_OPEN_WINDOW_ERR,
+	STR_WINDOW_TITLE_GRABBED,
 	STR_NO_WIN32_NT_4,
 
 	STR_PREFS_MENU_FILE_GTK,
--- macemu/SheepShaver/src/include/ether_defs.h
+++ sheepshaver/SheepShaver/src/include/ether_defs.h
@@ -27,7 +27,7 @@
 #define PACKED__
 #elif defined __GNUC__
 #define PACKED__ __attribute__ ((packed))
-#elif defined __sgi
+#elif defined(__sgi) || defined(_MSC_VER)
 #define PRAGMA_PACK_SUPPORTED 1
 #define PACKED__
 #else
--- macemu/SheepShaver/src/kpx_cpu/include/basic-cpu.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/include/basic-cpu.hpp
@@ -46,6 +46,8 @@
 /**
  *		Basic CPU model
  **/
+
+struct task_struct;
 
 struct basic_cpu
 	: public task_plugin
--- macemu/SheepShaver/src/kpx_cpu/sheepshaver_glue.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/sheepshaver_glue.cpp
@@ -18,6 +18,10 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "sysdeps.h"
 #include "cpu_emulation.h"
 #include "main.h"
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/block-cache.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/block-cache.hpp
@@ -23,6 +23,8 @@
 
 #include "block-alloc.hpp"
 
+#define GATHER_BLOCK_CACHE_STATISTICS 0
+
 template< class block_info, template<class T> class block_allocator = slow_allocator >
 class block_cache
 {
@@ -49,11 +51,22 @@
 		return (addr >> 2) & HASH_MASK;
 	}
 
+#if GATHER_BLOCK_CACHE_STATISTICS
+	struct {
+		uint32 searches;
+		uint32 hits;
+		uint32 misses;
+		uint32 faults;
+	} stats;
+#endif
+
 public:
 
 	block_cache();
 	~block_cache();
 
+	void print_statistics();
+
 	block_info *new_blockinfo();
 	void delete_blockinfo(block_info *bi);
 
@@ -78,6 +91,9 @@
 block_cache< block_info, block_allocator >::block_cache()
 	: active(NULL), dormant(NULL)
 {
+#if GATHER_BLOCK_CACHE_STATISTICS
+	memset(&stats, 0, sizeof(stats));
+#endif
 	initialize();
 }
 
@@ -183,25 +199,76 @@
 template< class block_info, template<class T> class block_allocator >
 block_info *block_cache< block_info, block_allocator >::find(uintptr pc)
 {
+	const uint32 cl = cacheline(pc);
+
+#if GATHER_BLOCK_CACHE_STATISTICS
+	stats.searches++;
+#endif
+
 	// Hit: return immediately
-	entry * bce = cache_tags[cacheline(pc)];
-	if (bce && bce->pc == pc)
+	entry * bce = cache_tags[cl];
+	if (bce && bce->pc == pc) {
+#if GATHER_BLOCK_CACHE_STATISTICS
+		stats.hits++;
+#endif
 		return bce;
+	}
 
 	// Miss: perform full list search and move block to front if found
 	while (bce) {
 		bce = bce->next_same_cl;
 		if (bce && bce->pc == pc) {
 			raise_in_cl_list(bce);
+#if GATHER_BLOCK_CACHE_STATISTICS
+			stats.misses++;
+#endif
 			return bce;
 		}
 	}
 
 	// Found none, will have to create a new block
+#if GATHER_BLOCK_CACHE_STATISTICS
+	stats.faults++;
+#endif
 	return NULL;
 }
 
 template< class block_info, template<class T> class block_allocator >
+void block_cache< block_info, block_allocator >::print_statistics()
+{
+#if GATHER_BLOCK_CACHE_STATISTICS
+	fprintf(stderr, "[Block Cache] Search Statistics: %9u searches, %9u hits, %9u misses, %9u faults\n",
+		stats.searches, stats.hits, stats.misses, stats.faults);
+	double hit_percent = (double)stats.hits / (double)stats.searches * 100.0,
+		miss_percent = (double)stats.misses / (double)stats.searches * 100.0,
+		fault_percent = (double)stats.faults / (double)stats.searches * 100.0;
+	fprintf(stderr, "[Block Cache] In percentages: %3.2lf%% hits, %3.2lf%% misses, %3.2lf%% faults\n",
+		hit_percent, miss_percent, fault_percent);
+	memset(&stats, 0, sizeof(stats));
+	uint32 c = 0, min = (uint32)-1, max = 0, average = 0;
+	for(uint32 cl = 0; cl < HASH_SIZE; cl++) {
+		if (cache_tags[cl] != NULL) {
+			c++;
+			entry *e = cache_tags[cl];
+			uint32 ct = 0;
+			while (e) {
+				e = e->next_same_cl;
+				ct++;
+			}
+			if (ct > max) max = ct;
+			if (ct < min) min = ct;
+			average += ct;
+		}
+	}
+	average /= c;
+	fprintf(stderr, "[Block Cache] %u of %u cache lines contain data\n",
+		c, HASH_SIZE);
+	fprintf(stderr, "[Block Cache] Line fill min: %u, max: %u, avg: %u\n",
+		min, max, average);
+#endif
+}
+
+template< class block_info, template<class T> class block_allocator >
 void block_cache< block_info, block_allocator >::remove_from_cl_list(block_info *bi)
 {
 	entry * bce = (entry *)bi;
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/basic-dyngen.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/basic-dyngen.cpp
@@ -147,9 +147,9 @@
 		f32_1, f32_2, f32_3, f32_4, f32_5, f32_6, f32_7, f32_8,
 		f32_9, f32_10, f32_11, f32_12, f32_13, f32_14, f32_15
 	};
+	static const uint8 prefixes[4] = { 0x66, 0x66, 0x66, 0x66 };
 
 #if defined(__x86_64__)
-	static const uint8 prefixes[4] = { 0x66, 0x66, 0x66, 0x66 };
 	/* The recommended way to pad 64bit code is to use NOPs preceded by
 	   maximally four 0x66 prefixes.  Balance the size of nops.  */
 	int i;
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/x86/codegen_x86.h
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/x86/codegen_x86.h
@@ -206,11 +206,11 @@
 #define _rC(R)		((R) & 0xf0)
 #define _rR(R)		((R) & 0x0f)
 #define _rN(R)		((R) & 0x07)
-#define _rXP(R)		(((R) > 0 && _rR(R) > 7) ? 1 : 0)
+#define _rXP(R)		((R) > 0 && _rR(R) > 7)
 #else
 #define _rN(R)		((R) & 0x07)
 #define _rR(R)		(int(R))
-#define _rXP(R)		((_rR(R) > 7 && _rR(R) < 16) ? 1 : 0)
+#define _rXP(R)		(_rR(R) > 7 && _rR(R) < 16)
 #endif
 
 #if !defined(_ASM_SAFETY) || ! X86_FLAT_REGISTERS
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-config.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-config.hpp
@@ -63,6 +63,18 @@
 
 
 /**
+ *	PPC_MIPS_COUNTER
+ *
+ *		Define to 1 to enable the MIPS counter, which is useful for
+ *      performance measurements.
+ **/
+
+#ifndef PPC_MIPS_COUNTER
+#define PPC_MIPS_COUNTER 1
+#endif
+
+
+/**
  *	PPC_ENABLE_JIT
  *
  *		Define to 1 if dynamic translation is used. This requires
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-cpu.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-cpu.cpp
@@ -123,6 +123,7 @@
 void powerpc_cpu::init_registers()
 {
 	assert((((uintptr)&vr(0)) % 16) == 0);
+	memset(&_regs, 0, sizeof(_regs));
 	for (int i = 0; i < 32; i++) {
 		gpr(i) = 0;
 		fpr(i) = 0;
@@ -548,6 +549,7 @@
 	// which is aligned at least on 4-byte boundaries
 	const int n = ((uintptr)sbi) & 3;
 	sbi = (block_info *)(((uintptr)sbi) & ~3L);
+	const uint32 bpc = sbi->pc;
 
 	const uint32 tpc = sbi->li[n].jmp_pc;
 	block_info *tbi = my_block_cache.find(tpc);
@@ -563,6 +565,12 @@
 void powerpc_cpu::execute(uint32 entry)
 {
 	bool invalidated_cache = false;
+#if PPC_MIPS_COUNTER
+	unsigned long retired = 0, retired_ovf = 0;
+	double start, snap;
+	static uint32 mips_prints = 0;
+	start = snap = sys_time();
+#endif
 	pc() = entry;
 #if PPC_EXECUTE_DUMP_STATE
 	const bool dump_state = true;
@@ -602,13 +610,15 @@
 				// Compile new block
 				bi = compile_block(pc());
 			}
+			goto return_site;
 		}
 #endif
 #if PPC_DECODE_CACHE
-		block_info *bi = my_block_cache.find(pc());
-		if (bi != NULL)
-			goto pdi_execute;
 		for (;;) {
+			block_info *bi = my_block_cache.find(pc());
+			if (bi != NULL)
+				goto pdi_execute;
+		  pdi_compile:
 #if PPC_PROFILE_COMPILE_TIME
 			compile_count++;
 			clock_t start_time;
@@ -618,6 +628,7 @@
 			bi->init(pc());
 
 			// Predecode a new block
+		  pdi_decode:
 			block_info::decode_info *di;
 			const instr_info_t *ii;
 			uint32 dpc;
@@ -673,18 +684,45 @@
 			// Execute all cached blocks
 		  pdi_execute:
 			for (;;) {
+#if PPC_MIPS_COUNTER
+				retired += bi->size;
+#endif
 				const int r = bi->size % 4;
 				di = bi->di + r;
 				int n = (bi->size + 3) / 4;
 				switch (r) {
 				case 0: do {
-						di += 4;
-						di[-4].execute(this, di[-4].opcode);
+				        di += 4;
+				        di[-4].execute(this, di[-4].opcode);
 				case 3: di[-3].execute(this, di[-3].opcode);
 				case 2: di[-2].execute(this, di[-2].opcode);
 				case 1: di[-1].execute(this, di[-1].opcode);
 					} while (--n > 0);
 				}
+#if PPC_MIPS_COUNTER
+				if (retired > (1 << 27)) {
+					double now = sys_time(),
+					       diff = now - snap;
+					if (diff > 1.0) {
+						double mips = (double)(retired + retired_ovf) / 1e6;
+						fprintf(stderr, "%3.5lf MIPS @ %0.3lfs\n", mips / diff, now - start);
+						mips_prints++;
+						if (mips_prints == 5) {
+							mips_prints = 0;
+							my_block_cache.print_statistics();
+						}
+						retired_ovf = 0;
+						retired = 0;
+						snap = now;
+					} else {
+						// We should wait until we hit the *next* 134,217,728
+						// instructions. It's too soon to print a new MIPS
+						// count.
+						retired_ovf += retired;
+						retired = 0;
+					}
+				}
+#endif
 
 				if (!spcflags().empty()) {
 					if (!check_spcflags())
@@ -702,9 +740,9 @@
 					break;
 			}
 		}
-#else
-		goto do_interpret;
+		goto return_site;
 #endif
+		goto do_interpret;
 	}
 #endif
   do_interpret:
@@ -719,8 +757,37 @@
 		if (is_logging())
 			record_step(opcode);
 #endif
-		assert(ii->execute.ptr() != 0);
+		//assert(ii->execute.ptr() != 0);
 		ii->execute(this, opcode);
+
+#if PPC_MIPS_COUNTER
+		retired++;
+
+		if (retired > (1 << 27)) {
+			double now = sys_time(),
+			       diff = now - snap;
+			if (diff > 1.0) {
+				double mips = (double)(retired + retired_ovf) / 1e6;
+				fprintf(stderr, "%3.5lf MIPS @ %0.3lfs\n", mips / diff, now - start);
+#if PPC_DECODE_CACHE
+				mips_prints++;
+				if (mips_prints == 5) {
+					mips_prints = 0;
+					my_block_cache.print_statistics();
+				}
+#endif
+				retired_ovf = 0;
+				retired = 0;
+				snap = now;
+			} else {
+				// We should wait until we hit the *next* 134,217,728
+				// instructions. It's too soon to print a new MIPS
+				// count.
+				retired_ovf += retired;
+				retired = 0;
+			}
+		}
+#endif
 #if PPC_EXECUTE_DUMP_STATE
 		if (dump_state)
 			dump_registers();
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-dyngen-ops.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-dyngen-ops.cpp
@@ -82,38 +69,38 @@
  **/
 
 struct powerpc_dyngen_helper {
-	static INLINE uint32 get_pc()				{ return CPU->pc(); }
-	static INLINE void set_pc(uint32 value)		{ CPU->pc() = value; }
-	static INLINE void inc_pc(int32 offset)		{ CPU->pc() += offset; }
-	static INLINE uint32 get_lr()				{ return CPU->lr(); }
-	static INLINE void set_lr(uint32 value)		{ CPU->lr() = value; }
-	static INLINE uint32 get_ctr()				{ return CPU->ctr(); }
-	static INLINE void set_ctr(uint32 value)	{ CPU->ctr() = value; }
-	static INLINE uint32 get_cr()				{ return CPU->cr().get(); }
-	static INLINE void set_cr(uint32 value)		{ CPU->cr().set(value); }
-	static INLINE uint32 get_fpscr()			{ return CPU->fpscr(); }
-	static INLINE void set_fpscr(uint32 value)	{ CPU->fpscr() = value; }
-	static INLINE uint32 get_xer()				{ return CPU->xer().get(); }
-	static INLINE void set_xer(uint32 value)	{ CPU->xer().set(value); }
-	static INLINE uint32 get_vrsave()			{ return CPU->vrsave(); }
-	static INLINE void set_vrsave(uint32 value)	{ CPU->vrsave() = value; }
-	static INLINE uint32 get_vscr()				{ return CPU->vscr().get(); }
-	static INLINE void set_vscr(uint32 value)	{ CPU->vscr().set(value); }
-	static INLINE void record(int crf, int32 v)	{ CPU->record_cr(crf, v); }
-	static INLINE powerpc_cr_register & cr()	{ return CPU->cr(); }
-	static INLINE powerpc_xer_register & xer()	{ return CPU->xer(); }
-	static INLINE powerpc_spcflags & spcflags()	{ return CPU->spcflags(); }
-	static INLINE void set_cr(int crfd, int v)	{ CPU->cr().set(crfd, v); }
-	static INLINE powerpc_registers *regs()		{ return &CPU->regs(); }
+	static inline uint32 get_pc()				{ return CPU->pc(); }
+	static inline void set_pc(uint32 value)		{ CPU->pc() = value; }
+	static inline void inc_pc(int32 offset)		{ CPU->pc() += offset; }
+	static inline uint32 get_lr()				{ return CPU->lr(); }
+	static inline void set_lr(uint32 value)		{ CPU->lr() = value; }
+	static inline uint32 get_ctr()				{ return CPU->ctr(); }
+	static inline void set_ctr(uint32 value)	{ CPU->ctr() = value; }
+	static inline uint32 get_cr()				{ return CPU->cr().get(); }
+	static inline void set_cr(uint32 value)		{ CPU->cr().set(value); }
+	static inline uint32 get_fpscr()			{ return CPU->fpscr(); }
+	static inline void set_fpscr(uint32 value)	{ CPU->fpscr() = value; }
+	static inline uint32 get_xer()				{ return CPU->xer().get(); }
+	static inline void set_xer(uint32 value)	{ CPU->xer().set(value); }
+	static inline uint32 get_vrsave()			{ return CPU->vrsave(); }
+	static inline void set_vrsave(uint32 value)	{ CPU->vrsave() = value; }
+	static inline uint32 get_vscr()				{ return CPU->vscr().get(); }
+	static inline void set_vscr(uint32 value)	{ CPU->vscr().set(value); }
+	static inline void record(int crf, int32 v)	{ CPU->record_cr(crf, v); }
+	static inline powerpc_cr_register & cr()	{ return CPU->cr(); }
+	static inline powerpc_xer_register & xer()	{ return CPU->xer(); }
+	static inline powerpc_spcflags & spcflags()	{ return CPU->spcflags(); }
+	static inline void set_cr(int crfd, int v)	{ CPU->cr().set(crfd, v); }
+	static inline powerpc_registers *regs()		{ return &CPU->regs(); }
 
 #ifndef REG_T3
-	static INLINE uintptr & reg_T3()			{ return CPU->codegen.reg_T3; }
+	static inline uintptr & reg_T3()			{ return CPU->codegen.reg_T3; }
 #endif
 //#ifndef REG_F3
-	static INLINE powerpc_fpr & reg_F3()		{ return CPU->codegen.reg_F3; }
+	static inline powerpc_fpr & reg_F3()		{ return CPU->codegen.reg_F3; }
 //#endif
 
-	static INLINE powerpc_block_info *find_block(uint32 pc) { return CPU->my_block_cache.fast_find(pc); }
+	static inline powerpc_block_info *find_block(uint32 pc) { return CPU->my_block_cache.fast_find(pc); }
 };
 
 // Semantic action templates
@@ -636,7 +623,7 @@
  **/
 
 template< int bo >
-static INLINE void do_prep_branch_bo(void)
+static inline void do_prep_branch_bo(void)
 {
 	bool ctr_ok = true;
 	bool cond_ok = true;
@@ -696,7 +683,7 @@
 	dyngen_barrier();
 }
 
-static INLINE void do_execute_branch_1(uint32 tpc)
+static inline void do_execute_branch_1(uint32 tpc)
 {
 	powerpc_dyngen_helper::set_pc(tpc);
 }
@@ -711,7 +698,7 @@
 	do_execute_branch_1(PARAM1);
 }
 
-static INLINE void do_execute_branch_2(uint32 tpc, uint32 npc)
+static inline void do_execute_branch_2(uint32 tpc, uint32 npc)
 {
 	powerpc_dyngen_helper::set_pc(T1 ? tpc : npc);
 	dyngen_barrier();
@@ -1385,7 +1372,7 @@
  **/
 
 template< int N >
-static INLINE void do_lmw(void)
+static inline void do_lmw(void)
 {
 	CPU->gpr(N) = vm_read_memory_4(T0);
 	T0 += 4;
@@ -1533,48 +1518,48 @@
 #define VNONE op_VNONE
 struct op_VNONE {
 	typedef null_operand type;
-	static INLINE uint32 get(powerpc_vr const & v, int i) { return 0; }
-	static INLINE void set(powerpc_vr const & v, int i, uint32) { }
+	static inline uint32 get(powerpc_vr const & v, int i) { return 0; }
+	static inline void set(powerpc_vr const & v, int i, uint32) { }
 };
 
 #define V16QI op_V16QI
 struct op_V16QI {
 	typedef uint8 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.b[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.b[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.b[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.b[i] = x; }
 };
 
 #define V8HI op_V8HI
 struct op_V8HI {
 	typedef uint16 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.h[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.h[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.h[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.h[i] = x; }
 };
 
 #define V4SI op_V4SI
 struct op_V4SI {
 	typedef uint32 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.w[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.w[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.w[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.w[i] = x; }
 };
 
 #define V2DI op_V2DI
 struct op_V2DI {
 	typedef uint64 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.j[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.j[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.j[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.j[i] = x; }
 };
 
 #define V4SF op_V4SF
 struct op_V4SF {
 	typedef float type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.f[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.f[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.f[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.f[i] = x; }
 };
 
 template< class OP, class VX, class VA, class VB, class VC, int N >
 struct do_vector_execute {
-	static INLINE void apply() {
+	static inline void apply() {
 		do_vector_execute<OP, VX, VA, VB, VC, N - 1>::apply();
 		VX::set(
 			VD, N,
@@ -1587,7 +1572,7 @@
 
 template< class OP, class VX, class VA, class VB, class VC >
 struct do_vector_execute<OP, VX, VA, VB, VC, 0> {
-	static INLINE void apply() {
+	static inline void apply() {
 		VX::set(
 			VD, 0, op_apply<typename VX::type, OP, typename VA::type, typename VB::type, typename VC::type>::apply(
 				VA::get(V0, 0),
@@ -1598,7 +1583,7 @@
 
 template< class OP, class VX, class VA, class VB = VNONE, class VC = VNONE >
 struct vector_execute {
-	static INLINE void apply() {
+	static inline void apply() {
 		do_vector_execute<OP, VX, VA, VB, VC, (16 / sizeof(typename VX::type)) - 1>::apply();
 	}
 };
@@ -1626,7 +1611,7 @@
 #if defined(__i386__) && defined(__SSE__)
 // Workaround gcc 3.2.2 miscompilation that inserts SSE instructions
 struct op_do_vnmsubfp {
-	static INLINE float apply(float x, float y, float z) {
+	static inline float apply(float x, float y, float z) {
 //		return 0. - ((x * z) - y);
 		return y - (x * z);
 	}
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-execute.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-execute.cpp
@@ -92,6 +92,16 @@
 	}
 }
 
+static inline int native_to_ppc_rounding_mode(int round)
+{
+	switch (round) {
+	case FE_TONEAREST:	return 0;
+	case FE_TOWARDZERO:	return 1;
+	case FE_UPWARD:		return 2;
+	case FE_DOWNWARD:	return 3;
+	}
+}
+
 /**
  *	Helper class to compute the overflow/carry condition
  *
@@ -1620,6 +1630,7 @@
 	typename VA::type const & vA = VA::const_ref(this, opcode);
 	typename VB::type const & vB = VB::const_ref(this, opcode);
 	typename VD::type & vD = VD::ref(this, opcode);
+	const int n_elements = 16 / VD::element_size;
 
 	const int sh = SH::get(this, opcode);
 	if (SD < 0) {
--- macemu/SheepShaver/src/kpx_cpu/src/mathlib/ieeefp-i386.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/mathlib/ieeefp-i386.cpp
@@ -23,6 +23,10 @@
  *  CPU features
  */
 
+#ifdef _MSC_VER
+#include <float.h>
+#endif
+
 /* XXX: duplicate from cpu/ppc/ppc-dyngen.cpp! */
 static uint32 cpu_features = 0;
 
@@ -36,27 +40,73 @@
 static unsigned int x86_cpuid(void)
 {
 	int fl1, fl2;
+	const unsigned int id_flag = 0x00200000;
 
 	/* See if we can use cpuid. On AMD64 we always can.  */
-	__asm__ ("pushfl; pushfl; popl %0; movl %0,%1; xorl %2,%0;"
-			 "pushl %0; popfl; pushfl; popl %0; popfl"
-			 : "=&r" (fl1), "=&r" (fl2)
-			 : "i" (0x00200000));
-	if (((fl1 ^ fl2) & 0x00200000) == 0)
+#ifdef _MSC_VER
+	__asm {
+		mov edx, id_flag;
+		pushfd;                         /* Save %eflags to restore later.  */
+		pushfd;                         /* Push second copy, for manipulation.  */
+		pop ebx;                        /* Pop it into post_change.  */
+		mov eax, ebx;                   /* Save copy in pre_change.   */
+		xor ebx, edx;                   /* Tweak bit in post_change.  */
+		push ebx;                       /* Push tweaked copy... */
+		popfd;                          /* ... and pop it into eflags.  */
+		pushfd;                         /* Did it change?  Push new %eflags... */
+		pop ebx;                        /* ... and pop it into post_change.  */
+		popfd;                          /* Restore original value.  */
+		mov fl1, eax;
+		mov fl2, ebx;
+	}
+#else
+	asm ("pushfl\n\t"          /* Save %eflags to restore later.  */
+		 "pushfl\n\t"          /* Push second copy, for manipulation.  */
+		 "popl %1\n\t"         /* Pop it into post_change.  */
+		 "movl %1,%0\n\t"      /* Save copy in pre_change.   */
+		 "xorl %2,%1\n\t"      /* Tweak bit in post_change.  */
+		 "pushl %1\n\t"        /* Push tweaked copy... */
+		 "popfl\n\t"           /* ... and pop it into %eflags.  */
+		 "pushfl\n\t"          /* Did it change?  Push new %eflags... */
+		 "popl %1\n\t"         /* ... and pop it into post_change.  */
+		 "popfl"               /* Restore original value.  */
+		 : "=&r" (fl1), "=&r" (fl2)
+		 : "ir" (id_flag));
+#endif
+	if (((fl1 ^ fl2) & id_flag) == 0)
 		return (0);
 
 	/* Host supports cpuid.  See if cpuid gives capabilities, try
 	   CPUID(0).  Preserve %ebx and %ecx; cpuid insn clobbers these, we
 	   don't need their CPUID values here, and %ebx may be the PIC
 	   register.  */
+#ifdef _MSC_VER
+	__asm {
+		xor ecx, ecx;
+		xor eax, eax;
+		cpuid;
+		mov fl1, eax;
+	}
+#else
 	__asm__ ("push %%ecx ; push %%ebx ; cpuid ; pop %%ebx ; pop %%ecx"
 			 : "=a" (fl1) : "0" (0) : "edx", "cc");
+#endif
 	if (fl1 == 0)
 		return (0);
 
 	/* Invoke CPUID(1), return %edx; caller can examine bits to
 	   determine what's supported.  */
+#ifdef _MSC_VER
+	__asm {
+		xor ecx, ecx;
+		xor ebx, ebx;
+		mov eax, 1;
+		cpuid;
+		mov fl2, edx;
+	}
+#else
 	__asm__ ("push %%ecx ; push %%ebx ; cpuid ; pop %%ebx ; pop %%ecx" : "=d" (fl2) : "a" (1) : "cc");
+#endif
 
 	return fl2;
 }
@@ -79,18 +129,22 @@
 // Get current rounding direction
 int fegetround(void)
 {
+#ifdef _MSC_VER
+	return _status87() & _MCW_RC;
+#else
 	unsigned short cw;
-
 	__asm__ __volatile__("fnstcw %0" : "=m" (*&cw));
-
 	return cw & 0xc00;
+#endif
 }
 
 // Set the rounding direction represented by ROUND
 int fesetround(int round)
 {
-	unsigned short cw;
-
+#ifdef _MSC_VER
+	_control87(round, _MCW_RC);
+#else
+	uint16 cw;
 	if ((round & ~0xc00) != 0)
 		return 1;
 
@@ -106,6 +160,7 @@
 		xcw |= round << 3;
 		__asm__ __volatile__("ldmxcsr %0" : : "m" (*&xcw));
 	}
+#endif
 
 	return 0;
 }
--- macemu/SheepShaver/src/kpx_cpu/src/mathlib/mathlib-i386.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/mathlib/mathlib-i386.cpp
@@ -24,6 +24,10 @@
 #define HAVE_TRUNC
 double trunc(double x)
 {
+#ifdef _MSC_VER
+	/* FIXME: This is probably semantically wrong, and it's slow. */
+	return (double)((long long)x);
+#else
 	volatile unsigned short int cw;
 	volatile unsigned short int cwtmp;
 	double value;
@@ -34,5 +38,11 @@
 	__asm__ __volatile__("frndint" : "=t" (value) : "0" (x));
 	__asm__ __volatile__("fldcw %0" : : "m" (cw));
 	return value;
+#endif
+}
+
+float truncf(float x)
+{
+	return (float)trunc((float)x);
 }
 #endif
--- macemu/SheepShaver/src/kpx_cpu/src/mathlib/mathlib.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/mathlib/mathlib.cpp
@@ -88,6 +88,7 @@
 int mathlib_fpclassifyl(long double x)
 {
 	unimplemented("fpclassifyl");
+	return -1;
 }
 
 
@@ -114,6 +115,7 @@
 int mathlib_signbitl(long double x)
 {
 	unimplemented("signbitl");
+	return -1;
 }
 
 
@@ -191,7 +193,7 @@
 float mathlib_roundf(float x)
 {
 	int32 i0, j0;
-	static const float huge = 1.0e30;
+	static const float huge = 1.0e30f;
 
 	MATHLIB_GET_FLOAT_WORD (i0, x);
 	j0 = ((i0 >> 23) & 0xff) - 0x7f;
--- macemu/SheepShaver/src/rom_patches.cpp
+++ sheepshaver/SheepShaver/src/rom_patches.cpp
@@ -665,6 +664,23 @@
 
 
 /*
+ *  Copy PowerPC code to ROM image and reverse bytes if necessary
+ */
+
+static inline void memcpy_powerpc_code(void *dst, const void *src, size_t len)
+{
+#ifdef WORDS_BIGENDIAN
+	(void)memcpy(dst, src, len);
+#else
+	uint32 *d = (uint32 *)dst;
+	uint32 *s = (uint32 *)src;
+	for (int i = 0; i < len/4; i++)
+		d[i] = htonl(s[i]);
+#endif
+}
+
+
+/*
  *  Install ROM patches (RAMBase and KernelDataAddr must be set)
  */
 
--- macemu/SheepShaver/src/video.cpp
+++ sheepshaver/SheepShaver/src/video.cpp
@@ -366,7 +368,7 @@
 		case cscSetGamma: {							// SetGamma
 			uint32 user_table = ReadMacInt32(param + csGTable);
 			D(bug("SetGamma %08x\n", user_table));
-			return set_gamma(csSave, user_table);
+			return set_gamma(csSave, ReadMacInt32(user_table));
 		}
 
 		case cscGrayPage: {							// GrayPage
