--- macemu/SheepShaver/src/EthernetDriverFull.i
+++ sheepshaver/SheepShaver/src/EthernetDriverFull.i
@@ -1,9 +1,9 @@
 	0x4a, 0x6f, 0x79, 0x21, 0x70, 0x65, 0x66, 0x66, 0x70, 0x77, 0x70, 0x63, 0x00, 0x00, 0x00, 0x01, 
-	0xd1, 0x9b, 0x81, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0xbe, 0xee, 0x26, 0xe2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 	0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0x28, 0xa4, 0x00, 0x00, 0x28, 0xa4, 0x00, 0x00, 0x28, 0xa4, 0x00, 0x00, 0x02, 0x20, 
+	0x00, 0x00, 0x26, 0xe0, 0x00, 0x00, 0x26, 0xe0, 0x00, 0x00, 0x26, 0xe0, 0x00, 0x00, 0x02, 0x20, 
 	0x00, 0x04, 0x04, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x08, 
-	0x00, 0x00, 0x04, 0xd8, 0x00, 0x00, 0x03, 0x34, 0x00, 0x00, 0x2a, 0xd0, 0x02, 0x01, 0x04, 0x00, 
+	0x00, 0x00, 0x04, 0xd8, 0x00, 0x00, 0x03, 0x34, 0x00, 0x00, 0x29, 0x00, 0x02, 0x01, 0x04, 0x00, 
 	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 	0x00, 0x00, 0x01, 0x96, 0x00, 0x00, 0x00, 0x80, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
 	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
@@ -32,288 +32,273 @@
 	0x00, 0x6b, 0x00, 0x00, 0x01, 0x4c, 0x00, 0x01, 0x02, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x01, 0x3c, 
 	0x00, 0x01, 0x02, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x01, 0x04, 0x00, 0x01, 0x02, 0x00, 0x00, 0x9f, 
 	0x00, 0x00, 0x01, 0x0c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x38, 0x60, 0x00, 0x00, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x38, 0x62, 0x02, 0x44, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x00, 0x28, 0xc0, 0x80, 0x40, 0x28, 0x08, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x21, 0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 
-	0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x80, 0x01, 0x00, 0x08, 
-	0x7c, 0x08, 0x03, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 
+	0x38, 0x60, 0x00, 0x00, 0x4e, 0x80, 0x00, 0x20, 0x38, 0x62, 0x02, 0x44, 0x4e, 0x80, 0x00, 0x20, 
+	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 
+	0x80, 0x00, 0x28, 0xc0, 0x80, 0x40, 0x28, 0x08, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x21, 
+	0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 
+	0x4e, 0x80, 0x00, 0x20, 0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 
 	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x00, 0x28, 0xc4, 0x80, 0x40, 0x28, 0x08, 
 	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x21, 0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 
-	0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x80, 0x01, 0x00, 0x08, 
-	0x7c, 0x08, 0x03, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x00, 0x28, 0xb0, 0x80, 0x40, 0x28, 0x08, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x21, 0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 
-	0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x80, 0x01, 0x00, 0x08, 
-	0x7c, 0x08, 0x03, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 
+	0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x4e, 0x80, 0x00, 0x20, 
+	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 
+	0x80, 0x00, 0x28, 0xb0, 0x80, 0x40, 0x28, 0x08, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x21, 
+	0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 
+	0x4e, 0x80, 0x00, 0x20, 0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 
 	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x00, 0x28, 0xb4, 0x80, 0x40, 0x28, 0x08, 
 	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x21, 0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 
-	0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x80, 0x01, 0x00, 0x08, 
-	0x7c, 0x08, 0x03, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x00, 0x28, 0xb8, 0x80, 0x40, 0x28, 0x08, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x21, 0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 
-	0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x80, 0x01, 0x00, 0x08, 
-	0x7c, 0x08, 0x03, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 
+	0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x4e, 0x80, 0x00, 0x20, 
+	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 
+	0x80, 0x00, 0x28, 0xb8, 0x80, 0x40, 0x28, 0x08, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x21, 
+	0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 
+	0x4e, 0x80, 0x00, 0x20, 0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x41, 0x00, 0x0c, 
 	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x00, 0x28, 0xbc, 0x80, 0x40, 0x28, 0x08, 
 	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x21, 0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 
-	0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x80, 0x01, 0x00, 0x08, 
-	0x7c, 0x08, 0x03, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x85, 0x23, 0x78, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x60, 0x1b, 0x78, 
-	0x7c, 0x04, 0x03, 0x78, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x62, 0x00, 0xfc, 0x48, 0x00, 0x23, 0xd5, 
+	0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x4e, 0x80, 0x00, 0x20, 
+	0x7c, 0x08, 0x02, 0xa6, 0x38, 0xa4, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x38, 0x03, 0x00, 0x00, 
+	0x94, 0x21, 0xff, 0xc0, 0x7c, 0x04, 0x03, 0x78, 0x80, 0x62, 0x00, 0xfc, 0x48, 0x00, 0x22, 0xfd, 
 	0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
-	0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xe2, 0x05, 0x00, 0x3b, 0xa2, 0x02, 0xde, 
-	0x3b, 0xc2, 0x02, 0x62, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0x1f, 0x00, 0x00, 
-	0x2c, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x01, 0x48, 0x00, 0x02, 0x68, 
-	0x38, 0x00, 0x00, 0x00, 0x38, 0x82, 0x02, 0x6f, 0x7f, 0xc3, 0xf3, 0x78, 0x90, 0x1f, 0x00, 0x00, 
-	0x48, 0x00, 0x22, 0x61, 0x90, 0x62, 0x00, 0xfc, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x02, 0x40, 0x38, 0x82, 0x02, 0x77, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x22, 0x41, 0x90, 0x62, 0x00, 0xf8, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x02, 0x20, 0x38, 0x82, 0x02, 0x7e, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x22, 0x21, 0x90, 0x62, 0x00, 0xf4, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x02, 0x00, 0x38, 0x82, 0x02, 0x87, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x22, 0x01, 0x90, 0x62, 0x00, 0xf0, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0xe0, 0x38, 0x82, 0x02, 0x8e, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x21, 0xe1, 0x90, 0x62, 0x00, 0xec, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0xc0, 0x38, 0x82, 0x02, 0x96, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x21, 0xc1, 0x90, 0x62, 0x00, 0xe8, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0xa0, 0x38, 0x82, 0x02, 0x9c, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x21, 0xa1, 0x90, 0x62, 0x00, 0xe4, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0x80, 0x38, 0x82, 0x02, 0xa2, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x21, 0x81, 0x90, 0x62, 0x00, 0xe0, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0x60, 0x38, 0x82, 0x02, 0xab, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x21, 0x61, 0x90, 0x62, 0x00, 0xdc, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0x40, 0x38, 0x82, 0x02, 0xb8, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x21, 0x41, 0x90, 0x62, 0x00, 0xd8, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0x20, 0x38, 0x82, 0x02, 0xc4, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x21, 0x21, 0x90, 0x62, 0x00, 0xd4, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0x00, 0x38, 0x82, 0x02, 0xcc, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x21, 0x01, 0x90, 0x62, 0x00, 0xd0, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0xe0, 0x38, 0x82, 0x02, 0xd4, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x20, 0xe1, 0x90, 0x62, 0x00, 0xcc, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0xc0, 0x38, 0x82, 0x02, 0xef, 0x7f, 0xa3, 0xeb, 0x78, 
-	0x48, 0x00, 0x20, 0xc1, 0x90, 0x62, 0x00, 0xc8, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0xa0, 0x38, 0x82, 0x03, 0x01, 0x7f, 0xa3, 0xeb, 0x78, 
-	0x48, 0x00, 0x20, 0xa1, 0x90, 0x62, 0x00, 0xc4, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x80, 0x38, 0x82, 0x03, 0x13, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x20, 0x81, 0x90, 0x62, 0x00, 0xc0, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x60, 0x38, 0x82, 0x03, 0x21, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x20, 0x61, 0x90, 0x62, 0x00, 0xbc, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x40, 0x38, 0x82, 0x03, 0x30, 0x7f, 0xc3, 0xf3, 0x78, 
-	0x48, 0x00, 0x20, 0x41, 0x90, 0x62, 0x00, 0xb8, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x20, 0x38, 0x00, 0x00, 0x00, 0x38, 0x62, 0x02, 0x5c, 
-	0x90, 0x02, 0x01, 0x00, 0x4b, 0xff, 0xfc, 0x0d, 0x38, 0x00, 0x00, 0x01, 0x38, 0x60, 0x00, 0x01, 
-	0x90, 0x1f, 0x00, 0x00, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0xa1, 0xff, 0xf4, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x93, 0xe1, 0xff, 0xfc, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 
-	0x4b, 0xff, 0xfd, 0x41, 0x54, 0x7f, 0x06, 0x3e, 0x80, 0x62, 0x00, 0x40, 0x4b, 0xff, 0xfb, 0x25, 
-	0x2c, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x08, 0x3b, 0xe0, 0x00, 0x00, 0x57, 0xe3, 0x06, 0x3e, 
-	0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 0x83, 0xe1, 0xff, 0xfc, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xc2, 0x05, 0x00, 0x3b, 0x82, 0x02, 0xde, 
+	0x3b, 0xa2, 0x02, 0x62, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0x1e, 0x00, 0x00, 
+	0x2c, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x01, 0x48, 0x00, 0x02, 0xac, 
+	0x3b, 0xe0, 0x00, 0x00, 0x38, 0x82, 0x02, 0x6f, 0x7f, 0xa3, 0xeb, 0x78, 0x93, 0xfe, 0x00, 0x00, 
+	0x48, 0x00, 0x21, 0xc1, 0x90, 0x62, 0x00, 0xfc, 0x80, 0x02, 0x00, 0xfc, 0x28, 0x00, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x02, 0x80, 0x7f, 0xa3, 0xeb, 0x78, 
+	0x38, 0x82, 0x02, 0x77, 0x48, 0x00, 0x21, 0x9d, 0x90, 0x62, 0x00, 0xf8, 0x80, 0x02, 0x00, 0xf8, 
+	0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x02, 0x5c, 
+	0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x02, 0x7e, 0x48, 0x00, 0x21, 0x79, 0x90, 0x62, 0x00, 0xf4, 
+	0x80, 0x02, 0x00, 0xf4, 0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 
+	0x48, 0x00, 0x02, 0x38, 0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x02, 0x87, 0x48, 0x00, 0x21, 0x55, 
+	0x90, 0x62, 0x00, 0xf0, 0x80, 0x02, 0x00, 0xf0, 0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
+	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x02, 0x14, 0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x02, 0x8e, 
+	0x48, 0x00, 0x21, 0x31, 0x90, 0x62, 0x00, 0xec, 0x80, 0x02, 0x00, 0xec, 0x28, 0x00, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0xf0, 0x7f, 0xa3, 0xeb, 0x78, 
+	0x38, 0x82, 0x02, 0x96, 0x48, 0x00, 0x21, 0x0d, 0x90, 0x62, 0x00, 0xe8, 0x80, 0x02, 0x00, 0xe8, 
+	0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0xcc, 
+	0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x02, 0x9c, 0x48, 0x00, 0x20, 0xe9, 0x90, 0x62, 0x00, 0xe4, 
+	0x80, 0x02, 0x00, 0xe4, 0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 
+	0x48, 0x00, 0x01, 0xa8, 0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x02, 0xa2, 0x48, 0x00, 0x20, 0xc5, 
+	0x90, 0x62, 0x00, 0xe0, 0x80, 0x02, 0x00, 0xe0, 0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
+	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0x84, 0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x02, 0xab, 
+	0x48, 0x00, 0x20, 0xa1, 0x90, 0x62, 0x00, 0xdc, 0x80, 0x02, 0x00, 0xdc, 0x28, 0x00, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0x60, 0x7f, 0xa3, 0xeb, 0x78, 
+	0x38, 0x82, 0x02, 0xb8, 0x48, 0x00, 0x20, 0x7d, 0x90, 0x62, 0x00, 0xd8, 0x80, 0x02, 0x00, 0xd8, 
+	0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0x3c, 
+	0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x02, 0xc4, 0x48, 0x00, 0x20, 0x59, 0x90, 0x62, 0x00, 0xd4, 
+	0x80, 0x02, 0x00, 0xd4, 0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 
+	0x48, 0x00, 0x01, 0x18, 0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x02, 0xcc, 0x48, 0x00, 0x20, 0x35, 
+	0x90, 0x62, 0x00, 0xd0, 0x80, 0x02, 0x00, 0xd0, 0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
+	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0xf4, 0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x02, 0xd4, 
+	0x48, 0x00, 0x20, 0x11, 0x90, 0x62, 0x00, 0xcc, 0x80, 0x02, 0x00, 0xcc, 0x28, 0x00, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0xd0, 0x7f, 0x83, 0xe3, 0x78, 
+	0x38, 0x82, 0x02, 0xef, 0x48, 0x00, 0x1f, 0xed, 0x90, 0x62, 0x00, 0xc8, 0x80, 0x02, 0x00, 0xc8, 
+	0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0xac, 
+	0x7f, 0x83, 0xe3, 0x78, 0x38, 0x82, 0x03, 0x01, 0x48, 0x00, 0x1f, 0xc9, 0x90, 0x62, 0x00, 0xc4, 
+	0x80, 0x02, 0x00, 0xc4, 0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 
+	0x48, 0x00, 0x00, 0x88, 0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x03, 0x13, 0x48, 0x00, 0x1f, 0xa5, 
+	0x90, 0x62, 0x00, 0xc0, 0x80, 0x02, 0x00, 0xc0, 0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
+	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x64, 0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x82, 0x03, 0x21, 
+	0x48, 0x00, 0x1f, 0x81, 0x90, 0x62, 0x00, 0xbc, 0x80, 0x02, 0x00, 0xbc, 0x28, 0x00, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x40, 0x7f, 0xa3, 0xeb, 0x78, 
+	0x38, 0x82, 0x03, 0x30, 0x48, 0x00, 0x1f, 0x5d, 0x90, 0x62, 0x00, 0xb8, 0x80, 0x02, 0x00, 0xb8, 
+	0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x1c, 
+	0x93, 0xe2, 0x01, 0x00, 0x38, 0x62, 0x02, 0x5c, 0x4b, 0xff, 0xfc, 0x29, 0x38, 0x00, 0x00, 0x01, 
+	0x38, 0x60, 0x00, 0x01, 0x90, 0x1e, 0x00, 0x00, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 
+	0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 
+	0x93, 0xe1, 0xff, 0xfc, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x4b, 0xff, 0xfd, 0x05, 
+	0x54, 0x7f, 0x06, 0x3e, 0x80, 0x62, 0x00, 0x40, 0x4b, 0xff, 0xfb, 0x79, 0x2c, 0x03, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x08, 0x3b, 0xe0, 0x00, 0x00, 0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 
+	0x57, 0xe3, 0x06, 0x3e, 0x83, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
 	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x02, 0x01, 0x00, 
-	0x28, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x0c, 0x38, 0x62, 0x03, 0x3d, 0x48, 0x00, 0x22, 0xa5, 
+	0x28, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x0c, 0x38, 0x62, 0x03, 0x3d, 0x48, 0x00, 0x21, 0x51, 
 	0x38, 0x62, 0x05, 0x00, 0x38, 0x00, 0x00, 0x00, 0x90, 0x03, 0x00, 0x00, 0x80, 0x01, 0x00, 0x48, 
-	0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x4b, 0xff, 0xff, 0xb5, 
-	0x4b, 0xff, 0xfa, 0xf1, 0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x93, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7f, 0x1b, 0x78, 0x7c, 0xc9, 0x33, 0x78, 
-	0x39, 0x02, 0x05, 0x00, 0x7c, 0xea, 0x3b, 0x78, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 
+	0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 
+	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x4b, 0xff, 0xff, 0xb9, 0x4b, 0xff, 0xfb, 0x3d, 
+	0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
+	0x93, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xe3, 0x00, 0x00, 0x39, 0x26, 0x00, 0x00, 
+	0x39, 0x02, 0x05, 0x00, 0x39, 0x47, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 
 	0x80, 0x08, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x14, 0x38, 0x62, 0x03, 0x7c, 
-	0x48, 0x00, 0x22, 0x21, 0x38, 0x60, 0x00, 0x06, 0x48, 0x00, 0x00, 0x68, 0x80, 0x1f, 0x00, 0x14, 
-	0x28, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x54, 
-	0x80, 0x62, 0x00, 0xc0, 0x7c, 0x87, 0x23, 0x78, 0x7c, 0xa8, 0x2b, 0x78, 0x7f, 0xe6, 0xfb, 0x78, 
-	0x38, 0x82, 0x01, 0x00, 0x38, 0xa0, 0x00, 0x38, 0x48, 0x00, 0x20, 0x89, 0x2c, 0x03, 0x00, 0x00, 
-	0x41, 0x82, 0x00, 0x08, 0x48, 0x00, 0x00, 0x2c, 0x80, 0x9f, 0x00, 0x14, 0x38, 0x00, 0x00, 0x00, 
-	0x38, 0x60, 0x00, 0x00, 0x93, 0xe4, 0x00, 0x18, 0x90, 0x04, 0x00, 0x04, 0x90, 0x04, 0x00, 0x08, 
-	0xb0, 0x04, 0x00, 0x0c, 0x90, 0x04, 0x00, 0x10, 0x90, 0x04, 0x00, 0x14, 0x90, 0x04, 0x00, 0x34, 
-	0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 0x83, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x48, 0x00, 0x20, 0xdd, 0x38, 0x60, 0x00, 0x06, 0x48, 0x00, 0x00, 0x64, 0x80, 0x1f, 0x00, 0x14, 
+	0x28, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x50, 
+	0x80, 0x62, 0x00, 0xc0, 0x38, 0xe4, 0x00, 0x00, 0x39, 0x05, 0x00, 0x00, 0x38, 0xdf, 0x00, 0x00, 
+	0x38, 0x82, 0x01, 0x00, 0x38, 0xa0, 0x00, 0x34, 0x48, 0x00, 0x1f, 0x75, 0x2c, 0x03, 0x00, 0x00, 
+	0x41, 0x82, 0x00, 0x08, 0x48, 0x00, 0x00, 0x28, 0x80, 0x9f, 0x00, 0x14, 0x38, 0x00, 0x00, 0x00, 
+	0x38, 0x60, 0x00, 0x00, 0x93, 0xe4, 0x00, 0x14, 0x90, 0x04, 0x00, 0x04, 0x90, 0x04, 0x00, 0x08, 
+	0xb0, 0x04, 0x00, 0x0c, 0x90, 0x04, 0x00, 0x10, 0x90, 0x04, 0x00, 0x30, 0x80, 0x01, 0x00, 0x58, 
+	0x38, 0x21, 0x00, 0x50, 0x83, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
 	0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7c, 0x1b, 0x78, 0x38, 0x82, 0x05, 0x00, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0x04, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 
-	0x40, 0x82, 0x00, 0x14, 0x38, 0x62, 0x03, 0xad, 0x48, 0x00, 0x21, 0x69, 0x38, 0x60, 0x00, 0x06, 
-	0x48, 0x00, 0x00, 0xb8, 0x83, 0xbc, 0x00, 0x14, 0x28, 0x1d, 0x00, 0x00, 0x40, 0x82, 0x00, 0x88, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0xa4, 0x48, 0x00, 0x00, 0x7c, 0x38, 0x63, 0x00, 0x04, 
-	0x4b, 0xff, 0xfa, 0xb1, 0x83, 0xdd, 0x00, 0x34, 0x3b, 0xfe, 0x00, 0x04, 0x48, 0x00, 0x00, 0x20, 
-	0x7f, 0xe3, 0xfb, 0x78, 0x38, 0x9e, 0x00, 0x04, 0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x20, 0xd5, 
-	0x2c, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x14, 0x83, 0xde, 0x00, 0x00, 0x28, 0x1e, 0x00, 0x00, 
-	0x40, 0x82, 0xff, 0xe0, 0x48, 0x00, 0x00, 0x40, 0x38, 0x9d, 0x00, 0x34, 0x48, 0x00, 0x00, 0x30, 
-	0x60, 0x00, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x7c, 0x00, 0xf0, 0x40, 0x40, 0x82, 0x00, 0x1c, 
-	0x80, 0x1e, 0x00, 0x00, 0x7f, 0xc3, 0xf3, 0x78, 0x90, 0x04, 0x00, 0x00, 0x48, 0x00, 0x1e, 0x65, 
-	0x48, 0x00, 0x00, 0x14, 0x60, 0x00, 0x00, 0x00, 0x7c, 0x04, 0x03, 0x78, 0x28, 0x04, 0x00, 0x00, 
-	0x40, 0x82, 0xff, 0xd4, 0x80, 0x7d, 0x00, 0x34, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0xff, 0x80, 
-	0x38, 0x00, 0x00, 0x00, 0x7f, 0x85, 0xe3, 0x78, 0x90, 0x1d, 0x00, 0x34, 0x38, 0x82, 0x01, 0x00, 
-	0x80, 0x62, 0x00, 0xbc, 0x48, 0x00, 0x1e, 0xad, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 
-	0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x38, 0xc2, 0x05, 0x00, 0x7c, 0x69, 0x1b, 0x78, 0x7c, 0x85, 0x23, 0x78, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x06, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 
-	0x40, 0x82, 0x00, 0x14, 0x38, 0x62, 0x03, 0xdf, 0x48, 0x00, 0x20, 0x69, 0x38, 0x60, 0x00, 0x06, 
-	0x48, 0x00, 0x01, 0x8c, 0x81, 0x09, 0x00, 0x14, 0x28, 0x08, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x06, 0x48, 0x00, 0x01, 0x78, 0x80, 0xc5, 0x00, 0x14, 0x88, 0x06, 0x00, 0x0d, 
-	0x2c, 0x00, 0x00, 0x0e, 0x41, 0x82, 0x01, 0x30, 0x40, 0x80, 0x00, 0x1c, 0x2c, 0x00, 0x00, 0x01, 
-	0x41, 0x82, 0x00, 0x48, 0x40, 0x80, 0x01, 0x38, 0x2c, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x20, 
-	0x48, 0x00, 0x01, 0x2c, 0x2c, 0x00, 0x00, 0x86, 0x41, 0x82, 0x01, 0x1c, 0x40, 0x80, 0x01, 0x20, 
-	0x2c, 0x00, 0x00, 0x83, 0x41, 0x82, 0x00, 0x24, 0x48, 0x00, 0x01, 0x14, 0x38, 0xc2, 0x04, 0xf4, 
-	0x7c, 0xa3, 0x2b, 0x78, 0x80, 0x86, 0x00, 0x00, 0x38, 0x04, 0x00, 0x01, 0x90, 0x06, 0x00, 0x00, 
-	0x48, 0x00, 0x08, 0x31, 0x48, 0x00, 0x01, 0x04, 0x80, 0x65, 0x00, 0x0c, 0x80, 0xc3, 0x00, 0x00, 
-	0x28, 0x06, 0x00, 0x31, 0x41, 0x81, 0x00, 0xb8, 0x38, 0x62, 0x04, 0x10, 0x54, 0xc0, 0x10, 0x3a, 
-	0x7c, 0x63, 0x00, 0x2e, 0x7c, 0x69, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 0x38, 0xe2, 0x04, 0xf0, 
-	0x7d, 0x03, 0x43, 0x78, 0x7d, 0x24, 0x4b, 0x78, 0x80, 0xc7, 0x00, 0x00, 0x38, 0x06, 0x00, 0x01, 
-	0x90, 0x07, 0x00, 0x00, 0x48, 0x00, 0x1a, 0xad, 0x48, 0x00, 0x00, 0xc0, 0x7d, 0x03, 0x43, 0x78, 
-	0x7d, 0x24, 0x4b, 0x78, 0x48, 0x00, 0x0e, 0x8d, 0x48, 0x00, 0x00, 0xb0, 0x7d, 0x03, 0x43, 0x78, 
-	0x7d, 0x24, 0x4b, 0x78, 0x48, 0x00, 0x10, 0x8d, 0x48, 0x00, 0x00, 0xa0, 0x7d, 0x03, 0x43, 0x78, 
-	0x7d, 0x24, 0x4b, 0x78, 0x48, 0x00, 0x11, 0x9d, 0x48, 0x00, 0x00, 0x90, 0x7d, 0x03, 0x43, 0x78, 
-	0x7d, 0x24, 0x4b, 0x78, 0x48, 0x00, 0x13, 0x7d, 0x48, 0x00, 0x00, 0x80, 0x7d, 0x03, 0x43, 0x78, 
-	0x7d, 0x24, 0x4b, 0x78, 0x48, 0x00, 0x14, 0x1d, 0x48, 0x00, 0x00, 0x70, 0x7d, 0x03, 0x43, 0x78, 
-	0x7d, 0x24, 0x4b, 0x78, 0x48, 0x00, 0x16, 0x2d, 0x48, 0x00, 0x00, 0x60, 0x7d, 0x03, 0x43, 0x78, 
-	0x7d, 0x24, 0x4b, 0x78, 0x48, 0x00, 0x17, 0x7d, 0x48, 0x00, 0x00, 0x50, 0x7d, 0x03, 0x43, 0x78, 
-	0x7d, 0x24, 0x4b, 0x78, 0x48, 0x00, 0x18, 0xad, 0x48, 0x00, 0x00, 0x40, 0x7d, 0x03, 0x43, 0x78, 
-	0x7d, 0x24, 0x4b, 0x78, 0x38, 0xe0, 0x00, 0x12, 0x39, 0x00, 0x00, 0x00, 0x48, 0x00, 0x0c, 0x95, 
-	0x48, 0x00, 0x00, 0x28, 0x7d, 0x03, 0x43, 0x78, 0x7d, 0x24, 0x4b, 0x78, 0x48, 0x00, 0x00, 0xd5, 
-	0x48, 0x00, 0x00, 0x18, 0x48, 0x00, 0x02, 0xcd, 0x48, 0x00, 0x00, 0x10, 0x80, 0x62, 0x00, 0xf4, 
-	0x7c, 0xa4, 0x2b, 0x78, 0x48, 0x00, 0x1c, 0x9d, 0x38, 0xa2, 0x04, 0xfc, 0x38, 0x60, 0x00, 0x00, 
-	0x80, 0x85, 0x00, 0x00, 0x38, 0x04, 0x00, 0x01, 0x90, 0x05, 0x00, 0x00, 0x80, 0x01, 0x00, 0x48, 
-	0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0xc1, 0xff, 0xf8, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7e, 0x1b, 0x78, 0x90, 0x01, 0x00, 0x08, 
-	0x94, 0x21, 0xff, 0xc0, 0x48, 0x00, 0x00, 0x4c, 0x80, 0x62, 0x00, 0xd8, 0x7f, 0xc4, 0xf3, 0x78, 
-	0x48, 0x00, 0x1c, 0x51, 0x28, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x18, 0x80, 0x62, 0x00, 0xe0, 
-	0x7f, 0xc4, 0xf3, 0x78, 0x7f, 0xe5, 0xfb, 0x78, 0x48, 0x00, 0x1c, 0x89, 0x48, 0x00, 0x00, 0x24, 
-	0x80, 0x62, 0x00, 0xf4, 0x7f, 0xe4, 0xfb, 0x78, 0x48, 0x00, 0x1c, 0x29, 0x80, 0x62, 0x00, 0xd0, 
-	0x7f, 0xc4, 0xf3, 0x78, 0x38, 0xa0, 0x00, 0x00, 0x48, 0x00, 0x1c, 0x69, 0x48, 0x00, 0x00, 0x18, 
-	0x80, 0x62, 0x00, 0xe8, 0x7f, 0xc4, 0xf3, 0x78, 0x48, 0x00, 0x1c, 0x09, 0x7c, 0x7f, 0x1b, 0x79, 
-	0x40, 0x82, 0xff, 0xa8, 0x38, 0x60, 0x00, 0x00, 0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 
-	0x7c, 0x08, 0x03, 0xa6, 0xbb, 0xc1, 0xff, 0xf8, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0xbe, 0x2b, 0x78, 0x7c, 0x7c, 0x1b, 0x78, 
-	0x7c, 0x9d, 0x23, 0x78, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x83, 0xe5, 0x00, 0x0c, 
-	0x80, 0x1f, 0x00, 0x00, 0x2c, 0x00, 0x4f, 0x03, 0x41, 0x82, 0x01, 0x04, 0x40, 0x80, 0x00, 0x10, 
-	0x2c, 0x00, 0x4f, 0x02, 0x40, 0x80, 0x00, 0x14, 0x48, 0x00, 0x01, 0x2c, 0x2c, 0x00, 0x6c, 0x0a, 
-	0x41, 0x82, 0x00, 0x88, 0x48, 0x00, 0x01, 0x20, 0x80, 0x9e, 0x00, 0x08, 0x28, 0x04, 0x00, 0x00, 
-	0x41, 0x82, 0x00, 0x18, 0x80, 0x64, 0x00, 0x0c, 0x80, 0x04, 0x00, 0x10, 0x7c, 0x03, 0x00, 0x50, 
-	0x28, 0x00, 0x00, 0x04, 0x41, 0x82, 0x00, 0x10, 0x38, 0x00, 0x00, 0x16, 0x90, 0x1f, 0x00, 0x10, 
-	0x48, 0x00, 0x01, 0x5c, 0x80, 0x63, 0x00, 0x00, 0x3c, 0x03, 0x00, 0x01, 0x28, 0x00, 0xff, 0xff, 
-	0x41, 0x82, 0x00, 0x14, 0x20, 0x03, 0x00, 0x08, 0x7c, 0x00, 0x00, 0x34, 0x54, 0x00, 0xd9, 0x7e, 
-	0x90, 0x1c, 0x00, 0x10, 0x38, 0x00, 0x00, 0x00, 0x90, 0x1e, 0x00, 0x08, 0x80, 0x62, 0x00, 0xf4, 
-	0x48, 0x00, 0x1b, 0x41, 0x80, 0x1c, 0x00, 0x10, 0x2c, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x10, 
-	0x38, 0x00, 0x00, 0x08, 0x90, 0x1f, 0x00, 0x14, 0x48, 0x00, 0x00, 0xb8, 0x38, 0x00, 0x00, 0x01, 
-	0x90, 0x1f, 0x00, 0x14, 0x48, 0x00, 0x00, 0xac, 0x80, 0x62, 0x00, 0xf0, 0x80, 0x9e, 0x00, 0x08, 
-	0x48, 0x00, 0x1b, 0x11, 0x7c, 0x64, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x10, 0x38, 0x00, 0x00, 0x0c, 
-	0x90, 0x1f, 0x00, 0x10, 0x48, 0x00, 0x00, 0xe8, 0x80, 0xc4, 0x00, 0x14, 0x38, 0x00, 0x00, 0x01, 
-	0x7f, 0x83, 0xe3, 0x78, 0x38, 0xa0, 0x00, 0x01, 0x98, 0x06, 0x00, 0x0d, 0x48, 0x00, 0x03, 0x65, 
-	0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x10, 0x38, 0x00, 0x00, 0x0c, 0x90, 0x1f, 0x00, 0x10, 
-	0x48, 0x00, 0x00, 0xbc, 0x80, 0x9e, 0x00, 0x08, 0x90, 0x64, 0x00, 0x08, 0x80, 0x1c, 0x00, 0x08, 
-	0x60, 0x00, 0x00, 0x08, 0x90, 0x1c, 0x00, 0x08, 0x48, 0x00, 0x00, 0x48, 0x80, 0x9e, 0x00, 0x08, 
-	0x28, 0x04, 0x00, 0x00, 0x41, 0x82, 0x00, 0x18, 0x80, 0x64, 0x00, 0x0c, 0x80, 0x04, 0x00, 0x10, 
+	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xa0, 0x80, 0x04, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x14, 0x38, 0x62, 0x03, 0xad, 0x48, 0x00, 0x20, 0x35, 0x38, 0x60, 0x00, 0x06, 
+	0x48, 0x00, 0x00, 0xb0, 0x83, 0xdc, 0x00, 0x14, 0x28, 0x1e, 0x00, 0x00, 0x40, 0x82, 0x00, 0x80, 
+	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x9c, 0x48, 0x00, 0x00, 0x74, 0x38, 0x63, 0x00, 0x04, 
+	0x4b, 0xff, 0xfa, 0xd1, 0x83, 0xbe, 0x00, 0x30, 0x3b, 0xfd, 0x00, 0x04, 0x48, 0x00, 0x00, 0x20, 
+	0x38, 0x7f, 0x00, 0x00, 0x38, 0x9d, 0x00, 0x04, 0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x1f, 0xb9, 
+	0x2c, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x14, 0x83, 0xbd, 0x00, 0x00, 0x28, 0x1d, 0x00, 0x00, 
+	0x40, 0x82, 0xff, 0xe0, 0x48, 0x00, 0x00, 0x38, 0x38, 0x9e, 0x00, 0x30, 0x48, 0x00, 0x00, 0x28, 
+	0x80, 0x04, 0x00, 0x00, 0x7c, 0x00, 0xe8, 0x40, 0x40, 0x82, 0x00, 0x18, 0x80, 0x1d, 0x00, 0x00, 
+	0x7f, 0xa3, 0xeb, 0x78, 0x90, 0x04, 0x00, 0x00, 0x48, 0x00, 0x1d, 0xa1, 0x48, 0x00, 0x00, 0x10, 
+	0x7c, 0x04, 0x03, 0x78, 0x28, 0x04, 0x00, 0x00, 0x40, 0x82, 0xff, 0xd8, 0x80, 0x7e, 0x00, 0x30, 
+	0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0xff, 0x88, 0x38, 0x00, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 
+	0x90, 0x1e, 0x00, 0x30, 0x38, 0x82, 0x01, 0x00, 0x80, 0x62, 0x00, 0xbc, 0x48, 0x00, 0x1d, 0xcd, 
+	0x80, 0x01, 0x00, 0x68, 0x38, 0x21, 0x00, 0x60, 0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 
+	0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 0x38, 0xc2, 0x05, 0x00, 0x39, 0x03, 0x00, 0x00, 
+	0x38, 0xa4, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x06, 0x00, 0x00, 
+	0x2c, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x14, 0x38, 0x62, 0x03, 0xdf, 0x48, 0x00, 0x1f, 0x41, 
+	0x38, 0x60, 0x00, 0x06, 0x48, 0x00, 0x01, 0x70, 0x80, 0x08, 0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 
+	0x7c, 0x03, 0x03, 0x78, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x06, 0x48, 0x00, 0x01, 0x58, 
+	0x80, 0x85, 0x00, 0x14, 0x88, 0x04, 0x00, 0x0d, 0x2c, 0x00, 0x00, 0x0e, 0x41, 0x82, 0x01, 0x0c, 
+	0x40, 0x80, 0x00, 0x1c, 0x2c, 0x00, 0x00, 0x01, 0x41, 0x82, 0x00, 0x48, 0x40, 0x80, 0x01, 0x18, 
+	0x2c, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x20, 0x48, 0x00, 0x01, 0x0c, 0x2c, 0x00, 0x00, 0x86, 
+	0x41, 0x82, 0x00, 0xf4, 0x40, 0x80, 0x01, 0x00, 0x2c, 0x00, 0x00, 0x83, 0x41, 0x82, 0x00, 0x24, 
+	0x48, 0x00, 0x00, 0xf4, 0x38, 0xc2, 0x04, 0xf4, 0x7c, 0xa3, 0x2b, 0x78, 0x80, 0x86, 0x00, 0x00, 
+	0x38, 0x04, 0x00, 0x01, 0x90, 0x06, 0x00, 0x00, 0x48, 0x00, 0x07, 0xf1, 0x48, 0x00, 0x00, 0xe4, 
+	0x80, 0x85, 0x00, 0x0c, 0x80, 0x04, 0x00, 0x00, 0x28, 0x00, 0x00, 0x31, 0x7c, 0x06, 0x03, 0x78, 
+	0x41, 0x81, 0x00, 0x94, 0x38, 0x82, 0x04, 0x10, 0x54, 0x00, 0x10, 0x3a, 0x7c, 0x84, 0x00, 0x2e, 
+	0x7c, 0x89, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 0x38, 0xe2, 0x04, 0xf0, 0x7d, 0x04, 0x43, 0x78, 
+	0x80, 0xc7, 0x00, 0x00, 0x38, 0x06, 0x00, 0x01, 0x90, 0x07, 0x00, 0x00, 0x48, 0x00, 0x1a, 0x19, 
+	0x48, 0x00, 0x00, 0xa0, 0x7d, 0x04, 0x43, 0x78, 0x48, 0x00, 0x0e, 0x01, 0x48, 0x00, 0x00, 0x94, 
+	0x7d, 0x04, 0x43, 0x78, 0x48, 0x00, 0x10, 0x05, 0x48, 0x00, 0x00, 0x88, 0x7d, 0x04, 0x43, 0x78, 
+	0x48, 0x00, 0x11, 0x11, 0x48, 0x00, 0x00, 0x7c, 0x7d, 0x04, 0x43, 0x78, 0x48, 0x00, 0x12, 0xf9, 
+	0x48, 0x00, 0x00, 0x70, 0x7d, 0x04, 0x43, 0x78, 0x48, 0x00, 0x13, 0x9d, 0x48, 0x00, 0x00, 0x64, 
+	0x7d, 0x04, 0x43, 0x78, 0x48, 0x00, 0x15, 0xcd, 0x48, 0x00, 0x00, 0x58, 0x7d, 0x04, 0x43, 0x78, 
+	0x48, 0x00, 0x17, 0x1d, 0x48, 0x00, 0x00, 0x4c, 0x7d, 0x04, 0x43, 0x78, 0x48, 0x00, 0x18, 0x4d, 
+	0x48, 0x00, 0x00, 0x40, 0x38, 0x88, 0x00, 0x00, 0x38, 0xe0, 0x00, 0x12, 0x39, 0x00, 0x00, 0x00, 
+	0x48, 0x00, 0x0c, 0x39, 0x48, 0x00, 0x00, 0x2c, 0x7d, 0x04, 0x43, 0x78, 0x48, 0x00, 0x00, 0xd5, 
+	0x48, 0x00, 0x00, 0x20, 0x38, 0x68, 0x00, 0x00, 0x38, 0x85, 0x00, 0x00, 0x48, 0x00, 0x02, 0xc9, 
+	0x48, 0x00, 0x00, 0x10, 0x80, 0x62, 0x00, 0xf4, 0x7c, 0xa4, 0x2b, 0x78, 0x48, 0x00, 0x1b, 0xf1, 
+	0x38, 0xa2, 0x04, 0xfc, 0x38, 0x60, 0x00, 0x00, 0x80, 0x85, 0x00, 0x00, 0x38, 0x04, 0x00, 0x01, 
+	0x90, 0x05, 0x00, 0x00, 0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 
+	0x4e, 0x80, 0x00, 0x20, 0xbf, 0xc1, 0xff, 0xf8, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7e, 0x1b, 0x78, 
+	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x48, 0x00, 0x00, 0x4c, 0x80, 0x62, 0x00, 0xd8, 
+	0x7f, 0xc4, 0xf3, 0x78, 0x48, 0x00, 0x1b, 0xa9, 0x2c, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x18, 
+	0x80, 0x62, 0x00, 0xe0, 0x38, 0x9e, 0x00, 0x00, 0x38, 0xbf, 0x00, 0x00, 0x48, 0x00, 0x1b, 0xcd, 
+	0x48, 0x00, 0x00, 0x24, 0x80, 0x62, 0x00, 0xf4, 0x7f, 0xe4, 0xfb, 0x78, 0x48, 0x00, 0x1b, 0x81, 
+	0x80, 0x62, 0x00, 0xd0, 0x38, 0x9e, 0x00, 0x00, 0x38, 0xa0, 0x00, 0x00, 0x48, 0x00, 0x1b, 0xad, 
+	0x48, 0x00, 0x00, 0x18, 0x80, 0x62, 0x00, 0xe8, 0x7f, 0xc4, 0xf3, 0x78, 0x48, 0x00, 0x1b, 0x61, 
+	0x7c, 0x7f, 0x1b, 0x79, 0x40, 0x82, 0xff, 0xa8, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 
+	0x38, 0x60, 0x00, 0x00, 0xbb, 0xc1, 0xff, 0xf8, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
+	0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xc5, 0x00, 0x00, 0x3b, 0x83, 0x00, 0x00, 
+	0x7c, 0x9d, 0x23, 0x78, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xa0, 0x83, 0xe5, 0x00, 0x0c, 
+	0x80, 0x1f, 0x00, 0x00, 0x2c, 0x00, 0x4f, 0x03, 0x41, 0x82, 0x01, 0x0c, 0x40, 0x80, 0x00, 0x10, 
+	0x2c, 0x00, 0x4f, 0x02, 0x40, 0x80, 0x00, 0x14, 0x48, 0x00, 0x01, 0x34, 0x2c, 0x00, 0x6c, 0x0a, 
+	0x41, 0x82, 0x00, 0x8c, 0x48, 0x00, 0x01, 0x28, 0x80, 0x1e, 0x00, 0x08, 0x28, 0x00, 0x00, 0x00, 
+	0x7c, 0x04, 0x03, 0x78, 0x41, 0x82, 0x00, 0x18, 0x80, 0x64, 0x00, 0x0c, 0x80, 0x04, 0x00, 0x10, 
 	0x7c, 0x03, 0x00, 0x50, 0x28, 0x00, 0x00, 0x04, 0x41, 0x82, 0x00, 0x10, 0x38, 0x00, 0x00, 0x16, 
-	0x90, 0x1f, 0x00, 0x10, 0x48, 0x00, 0x00, 0x78, 0x38, 0x00, 0x00, 0x01, 0x90, 0x1c, 0x00, 0x14, 
-	0x48, 0x00, 0x00, 0x10, 0x38, 0x00, 0x00, 0x16, 0x90, 0x1f, 0x00, 0x10, 0x48, 0x00, 0x00, 0x60, 
-	0x38, 0x00, 0x00, 0x00, 0x7f, 0xc5, 0xf3, 0x78, 0x90, 0x1f, 0x00, 0x0c, 0x48, 0x00, 0x00, 0x1c, 
-	0x80, 0x65, 0x00, 0x0c, 0x80, 0x05, 0x00, 0x10, 0x80, 0x9f, 0x00, 0x0c, 0x7c, 0x03, 0x00, 0x50, 
-	0x7c, 0x04, 0x02, 0x14, 0x90, 0x1f, 0x00, 0x0c, 0x80, 0xa5, 0x00, 0x08, 0x28, 0x05, 0x00, 0x00, 
-	0x40, 0x82, 0xff, 0xe0, 0x38, 0x60, 0x00, 0x00, 0x38, 0x00, 0x00, 0x81, 0x90, 0x7f, 0x00, 0x10, 
-	0x7f, 0xa4, 0xeb, 0x78, 0x7f, 0xc5, 0xf3, 0x78, 0x80, 0x7e, 0x00, 0x14, 0x98, 0x03, 0x00, 0x0d, 
-	0x80, 0x62, 0x00, 0xd4, 0x48, 0x00, 0x1a, 0x6d, 0x48, 0x00, 0x00, 0x20, 0x80, 0x7e, 0x00, 0x14, 
-	0x38, 0x00, 0x00, 0x82, 0x7f, 0xa4, 0xeb, 0x78, 0x7f, 0xc5, 0xf3, 0x78, 0x98, 0x03, 0x00, 0x0d, 
-	0x80, 0x62, 0x00, 0xd4, 0x48, 0x00, 0x1a, 0x4d, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 
-	0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x9e, 0x23, 0x78, 0x7c, 0x7d, 0x1b, 0x78, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x83, 0xe4, 0x00, 0x0c, 0x88, 0x1f, 0x00, 0x00, 
-	0x54, 0x00, 0x07, 0xbd, 0x41, 0x82, 0x00, 0x14, 0x80, 0x62, 0x00, 0xd0, 0x7f, 0xa4, 0xeb, 0x78, 
-	0x38, 0xa0, 0x00, 0x01, 0x48, 0x00, 0x19, 0xfd, 0x88, 0x1f, 0x00, 0x00, 0x54, 0x00, 0x07, 0xff, 
-	0x41, 0x82, 0x00, 0x34, 0x80, 0x62, 0x00, 0xd0, 0x38, 0x9d, 0xff, 0xc0, 0x38, 0xa0, 0x00, 0x01, 
-	0x48, 0x00, 0x19, 0xe1, 0x88, 0x1f, 0x00, 0x00, 0x7f, 0xa4, 0xeb, 0x78, 0x7f, 0xc5, 0xf3, 0x78, 
-	0x54, 0x00, 0x07, 0xfa, 0x98, 0x1f, 0x00, 0x00, 0x80, 0x62, 0x00, 0xd4, 0x48, 0x00, 0x19, 0xc5, 
-	0x48, 0x00, 0x00, 0x10, 0x80, 0x62, 0x00, 0xf4, 0x7f, 0xc4, 0xf3, 0x78, 0x48, 0x00, 0x19, 0x65, 
-	0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x54, 0x63, 0x04, 0x3e, 0x2c, 0x03, 0x05, 0xdd, 0x41, 0x80, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 
-	0x4e, 0x80, 0x00, 0x20, 0x2c, 0x03, 0x00, 0xff, 0x40, 0x82, 0x00, 0x18, 0x54, 0x80, 0x04, 0x3e, 
-	0x2c, 0x00, 0x00, 0xff, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x04, 0x4e, 0x80, 0x00, 0x20, 
-	0x2c, 0x03, 0x00, 0xaa, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x03, 0x4e, 0x80, 0x00, 0x20, 
-	0x2c, 0x03, 0x00, 0xff, 0x38, 0x60, 0x00, 0x05, 0x4d, 0x81, 0x00, 0x20, 0x38, 0x60, 0x00, 0x01, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x90, 0x1f, 0x00, 0x10, 0x48, 0x00, 0x01, 0x60, 0x80, 0x63, 0x00, 0x00, 0x3c, 0x03, 0x00, 0x01, 
+	0x28, 0x00, 0xff, 0xff, 0x41, 0x82, 0x00, 0x14, 0x20, 0x03, 0x00, 0x08, 0x7c, 0x00, 0x00, 0x34, 
+	0x54, 0x00, 0xd9, 0x7e, 0x90, 0x1c, 0x00, 0x10, 0x38, 0x00, 0x00, 0x00, 0x90, 0x1e, 0x00, 0x08, 
+	0x80, 0x62, 0x00, 0xf4, 0x48, 0x00, 0x1a, 0x99, 0x80, 0x1c, 0x00, 0x10, 0x2c, 0x00, 0x00, 0x00, 
+	0x41, 0x82, 0x00, 0x10, 0x38, 0x00, 0x00, 0x08, 0x90, 0x1f, 0x00, 0x14, 0x48, 0x00, 0x00, 0xbc, 
+	0x38, 0x00, 0x00, 0x01, 0x90, 0x1f, 0x00, 0x14, 0x48, 0x00, 0x00, 0xb0, 0x80, 0x9e, 0x00, 0x08, 
+	0x80, 0x62, 0x00, 0xf0, 0x48, 0x00, 0x1a, 0x69, 0x28, 0x03, 0x00, 0x00, 0x38, 0x83, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x10, 0x38, 0x00, 0x00, 0x0c, 0x90, 0x1f, 0x00, 0x10, 0x48, 0x00, 0x00, 0xe8, 
+	0x80, 0xc3, 0x00, 0x14, 0x38, 0x00, 0x00, 0x01, 0x38, 0x7c, 0x00, 0x00, 0x38, 0xa0, 0x00, 0x01, 
+	0x98, 0x06, 0x00, 0x0d, 0x48, 0x00, 0x03, 0x45, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x10, 
+	0x38, 0x00, 0x00, 0x0c, 0x90, 0x1f, 0x00, 0x10, 0x48, 0x00, 0x00, 0xbc, 0x80, 0x9e, 0x00, 0x08, 
+	0x90, 0x64, 0x00, 0x08, 0x80, 0x1c, 0x00, 0x08, 0x60, 0x00, 0x00, 0x08, 0x90, 0x1c, 0x00, 0x08, 
+	0x48, 0x00, 0x00, 0x48, 0x80, 0x9e, 0x00, 0x08, 0x28, 0x04, 0x00, 0x00, 0x41, 0x82, 0x00, 0x18, 
+	0x80, 0x64, 0x00, 0x0c, 0x80, 0x04, 0x00, 0x10, 0x7c, 0x03, 0x00, 0x50, 0x28, 0x00, 0x00, 0x04, 
+	0x41, 0x82, 0x00, 0x10, 0x38, 0x00, 0x00, 0x16, 0x90, 0x1f, 0x00, 0x10, 0x48, 0x00, 0x00, 0x78, 
+	0x38, 0x00, 0x00, 0x16, 0x90, 0x1f, 0x00, 0x10, 0x48, 0x00, 0x00, 0x6c, 0x38, 0x00, 0x00, 0x16, 
+	0x90, 0x1f, 0x00, 0x10, 0x48, 0x00, 0x00, 0x60, 0x38, 0x00, 0x00, 0x00, 0x38, 0xbe, 0x00, 0x00, 
+	0x90, 0x1f, 0x00, 0x0c, 0x48, 0x00, 0x00, 0x1c, 0x80, 0x65, 0x00, 0x0c, 0x80, 0x05, 0x00, 0x10, 
+	0x80, 0x9f, 0x00, 0x0c, 0x7c, 0x03, 0x00, 0x50, 0x7c, 0x04, 0x02, 0x14, 0x90, 0x1f, 0x00, 0x0c, 
+	0x80, 0xa5, 0x00, 0x08, 0x28, 0x05, 0x00, 0x00, 0x40, 0x82, 0xff, 0xe0, 0x38, 0x60, 0x00, 0x00, 
+	0x38, 0x00, 0x00, 0x81, 0x90, 0x7f, 0x00, 0x10, 0x38, 0x9d, 0x00, 0x00, 0x38, 0xbe, 0x00, 0x00, 
+	0x80, 0x7e, 0x00, 0x14, 0x98, 0x03, 0x00, 0x0d, 0x80, 0x62, 0x00, 0xd4, 0x48, 0x00, 0x19, 0xad, 
+	0x48, 0x00, 0x00, 0x20, 0x80, 0x7e, 0x00, 0x14, 0x38, 0x00, 0x00, 0x82, 0x38, 0x9d, 0x00, 0x00, 
+	0x38, 0xbe, 0x00, 0x00, 0x98, 0x03, 0x00, 0x0d, 0x80, 0x62, 0x00, 0xd4, 0x48, 0x00, 0x19, 0x8d, 
+	0x80, 0x01, 0x00, 0x68, 0x38, 0x21, 0x00, 0x60, 0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 
+	0x4e, 0x80, 0x00, 0x20, 0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xc4, 0x00, 0x00, 
+	0x3b, 0xa3, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x83, 0xe4, 0x00, 0x0c, 
+	0x88, 0x1f, 0x00, 0x00, 0x54, 0x00, 0x07, 0xbd, 0x41, 0x82, 0x00, 0x14, 0x80, 0x62, 0x00, 0xd0, 
+	0x38, 0x9d, 0x00, 0x00, 0x38, 0xa0, 0x00, 0x01, 0x48, 0x00, 0x19, 0x41, 0x88, 0x1f, 0x00, 0x00, 
+	0x54, 0x00, 0x07, 0xff, 0x41, 0x82, 0x00, 0x34, 0x80, 0x62, 0x00, 0xd0, 0x38, 0x9d, 0xff, 0xc0, 
+	0x38, 0xa0, 0x00, 0x01, 0x48, 0x00, 0x19, 0x25, 0x88, 0x1f, 0x00, 0x00, 0x38, 0x9d, 0x00, 0x00, 
+	0x38, 0xbe, 0x00, 0x00, 0x54, 0x00, 0x07, 0xfa, 0x98, 0x1f, 0x00, 0x00, 0x80, 0x62, 0x00, 0xd4, 
+	0x48, 0x00, 0x19, 0x09, 0x48, 0x00, 0x00, 0x10, 0x80, 0x62, 0x00, 0xf4, 0x7f, 0xc4, 0xf3, 0x78, 
+	0x48, 0x00, 0x18, 0xbd, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0xa1, 0xff, 0xf4, 
+	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x54, 0x63, 0x04, 0x3e, 0x2c, 0x03, 0x05, 0xdd, 
+	0x41, 0x80, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x4e, 0x80, 0x00, 0x20, 0x2c, 0x03, 0x00, 0xff, 
+	0x40, 0x82, 0x00, 0x18, 0x54, 0x80, 0x04, 0x3e, 0x2c, 0x00, 0x00, 0xff, 0x40, 0x82, 0x00, 0x0c, 
+	0x38, 0x60, 0x00, 0x04, 0x4e, 0x80, 0x00, 0x20, 0x2c, 0x03, 0x00, 0xaa, 0x40, 0x82, 0x00, 0x0c, 
+	0x38, 0x60, 0x00, 0x03, 0x4e, 0x80, 0x00, 0x20, 0x2c, 0x03, 0x00, 0xff, 0x41, 0x81, 0x00, 0x0c, 
+	0x38, 0x60, 0x00, 0x01, 0x4e, 0x80, 0x00, 0x20, 0x38, 0x60, 0x00, 0x05, 0x4e, 0x80, 0x00, 0x20, 
 	0x88, 0x03, 0x00, 0x00, 0x54, 0x00, 0x07, 0xff, 0x41, 0x82, 0x00, 0x30, 0x80, 0x83, 0x00, 0x00, 
 	0x3c, 0x04, 0x00, 0x01, 0x28, 0x00, 0xff, 0xff, 0x40, 0x82, 0x00, 0x18, 0xa0, 0x03, 0x00, 0x04, 
 	0x28, 0x00, 0xff, 0xff, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x02, 0x4e, 0x80, 0x00, 0x20, 
 	0x38, 0x60, 0x00, 0x01, 0x4e, 0x80, 0x00, 0x20, 0x38, 0x60, 0x00, 0x00, 0x4e, 0x80, 0x00, 0x20, 
-	0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7f, 0x1b, 0x78, 0x7c, 0x9d, 0x23, 0x78, 
+	0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xe3, 0x00, 0x00, 0x3b, 0xa4, 0x00, 0x00, 
 	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0xa3, 0x00, 0x14, 0x88, 0x05, 0x00, 0x0c, 
 	0x28, 0x00, 0x00, 0x01, 0x40, 0x82, 0x00, 0x44, 0x80, 0x65, 0x00, 0x04, 0x57, 0xa4, 0x04, 0x3e, 
 	0x80, 0x05, 0x00, 0x08, 0x7c, 0x03, 0x00, 0x50, 0x7c, 0x00, 0x20, 0x00, 0x41, 0x80, 0x00, 0x2c, 
 	0x38, 0x00, 0x00, 0x00, 0x98, 0x05, 0x00, 0x0d, 0x80, 0x7f, 0x00, 0x14, 0x80, 0x03, 0x00, 0x04, 
 	0x90, 0x1f, 0x00, 0x0c, 0x80, 0x7f, 0x00, 0x14, 0x80, 0x03, 0x00, 0x04, 0x7c, 0x00, 0x22, 0x14, 
 	0x90, 0x1f, 0x00, 0x10, 0x48, 0x00, 0x00, 0x9c, 0x83, 0xdf, 0x00, 0x08, 0x38, 0x00, 0x00, 0x00, 
-	0x7f, 0xe4, 0xfb, 0x78, 0x90, 0x1f, 0x00, 0x08, 0x80, 0x62, 0x00, 0xf4, 0x48, 0x00, 0x18, 0x25, 
-	0x28, 0x1e, 0x00, 0x00, 0x7f, 0xdf, 0xf3, 0x78, 0x41, 0x82, 0x00, 0x38, 0x80, 0x7e, 0x00, 0x14, 
+	0x38, 0x9f, 0x00, 0x00, 0x90, 0x1f, 0x00, 0x08, 0x80, 0x62, 0x00, 0xf4, 0x48, 0x00, 0x17, 0x91, 
+	0x28, 0x1e, 0x00, 0x00, 0x3b, 0xfe, 0x00, 0x00, 0x41, 0x82, 0x00, 0x38, 0x80, 0x7e, 0x00, 0x14, 
 	0x88, 0x03, 0x00, 0x0c, 0x28, 0x00, 0x00, 0x01, 0x40, 0x82, 0x00, 0x28, 0x80, 0x63, 0x00, 0x04, 
 	0x57, 0xa0, 0x04, 0x3e, 0x80, 0x9e, 0x00, 0x0c, 0x7c, 0x63, 0x20, 0x50, 0x7c, 0x03, 0x00, 0x00, 
 	0x41, 0x80, 0x00, 0x10, 0x7c, 0x00, 0x20, 0x50, 0x90, 0x1e, 0x00, 0x0c, 0x48, 0x00, 0x00, 0x44, 
-	0x57, 0xbe, 0x04, 0x3e, 0x38, 0x80, 0x00, 0x03, 0x7f, 0xc3, 0xf3, 0x78, 0x4b, 0xff, 0xf4, 0x35, 
+	0x57, 0xbe, 0x04, 0x3e, 0x38, 0x80, 0x00, 0x03, 0x38, 0x7e, 0x00, 0x00, 0x4b, 0xff, 0xf4, 0x65, 
 	0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x18, 0x80, 0x62, 0x00, 0xf4, 0x7f, 0xe4, 0xfb, 0x78, 
-	0x48, 0x00, 0x17, 0xc1, 0x3b, 0xe0, 0x00, 0x00, 0x48, 0x00, 0x00, 0x18, 0x93, 0xe3, 0x00, 0x08, 
+	0x48, 0x00, 0x17, 0x2d, 0x3b, 0xe0, 0x00, 0x00, 0x48, 0x00, 0x00, 0x18, 0x93, 0xe3, 0x00, 0x08, 
 	0x7c, 0x7f, 0x1b, 0x78, 0x80, 0x03, 0x00, 0x10, 0x7c, 0x00, 0xf2, 0x14, 0x90, 0x03, 0x00, 0x10, 
-	0x7f, 0xe3, 0xfb, 0x78, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0x7c, 0x08, 0x03, 0xa6, 
-	0xbb, 0xa1, 0xff, 0xf4, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x01, 0xff, 0xe0, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7e, 0x1b, 0x78, 0x7c, 0x9f, 0x23, 0x78, 
-	0x7c, 0xb8, 0x2b, 0x78, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0x90, 0x80, 0x64, 0x00, 0x0c, 
-	0x80, 0x03, 0x00, 0x00, 0x28, 0x00, 0x00, 0x07, 0x41, 0x82, 0x00, 0x14, 0x80, 0x62, 0x00, 0xf4, 
-	0x48, 0x00, 0x17, 0x51, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0xc4, 0x83, 0x63, 0x00, 0x04, 
-	0x80, 0x03, 0x00, 0x08, 0x2c, 0x1b, 0x00, 0x08, 0x7f, 0x83, 0x02, 0x14, 0x41, 0x82, 0x00, 0x28, 
-	0x40, 0x80, 0x00, 0x10, 0x2c, 0x1b, 0x00, 0x06, 0x41, 0x82, 0x00, 0x14, 0x48, 0x00, 0x00, 0x28, 
-	0x2c, 0x1b, 0x00, 0x0d, 0x41, 0x82, 0x00, 0x18, 0x48, 0x00, 0x00, 0x1c, 0xa3, 0x5e, 0x00, 0x0c, 
+	0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0x7f, 0xe3, 0xfb, 0x78, 0xbb, 0xa1, 0xff, 0xf4, 
+	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0xbf, 0x01, 0xff, 0xe0, 0x7c, 0x08, 0x02, 0xa6, 
+	0x3b, 0xc3, 0x00, 0x00, 0x3b, 0xe4, 0x00, 0x00, 0x7c, 0xb8, 0x2b, 0x78, 0x90, 0x01, 0x00, 0x08, 
+	0x94, 0x21, 0xff, 0x90, 0x80, 0x64, 0x00, 0x0c, 0x80, 0x03, 0x00, 0x00, 0x28, 0x00, 0x00, 0x07, 
+	0x41, 0x82, 0x00, 0x18, 0x80, 0x62, 0x00, 0xf4, 0x7f, 0xe4, 0xfb, 0x78, 0x48, 0x00, 0x16, 0xc1, 
+	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x01, 0xc0, 0x80, 0x83, 0x00, 0x04, 0x80, 0x03, 0x00, 0x08, 
+	0x2c, 0x04, 0x00, 0x08, 0x3b, 0x64, 0x00, 0x00, 0x7f, 0x83, 0x02, 0x14, 0x41, 0x82, 0x00, 0x28, 
+	0x40, 0x80, 0x00, 0x10, 0x2c, 0x04, 0x00, 0x06, 0x41, 0x82, 0x00, 0x14, 0x48, 0x00, 0x00, 0x28, 
+	0x2c, 0x04, 0x00, 0x0d, 0x41, 0x82, 0x00, 0x18, 0x48, 0x00, 0x00, 0x1c, 0xa3, 0x5e, 0x00, 0x0c, 
 	0x48, 0x00, 0x00, 0x18, 0xa3, 0x5c, 0x00, 0x06, 0x48, 0x00, 0x00, 0x10, 0xa3, 0x5c, 0x00, 0x06, 
 	0x48, 0x00, 0x00, 0x08, 0xa3, 0x5e, 0x00, 0x0c, 0x80, 0x62, 0x00, 0xcc, 0x7f, 0xe4, 0xfb, 0x78, 
-	0x48, 0x00, 0x16, 0xf1, 0x54, 0x79, 0x04, 0x3e, 0xa0, 0x7e, 0x00, 0x0c, 0x7f, 0x44, 0xd3, 0x78, 
-	0x4b, 0xff, 0xfd, 0xa1, 0x54, 0x7d, 0x04, 0x3e, 0x2c, 0x1d, 0x00, 0x02, 0x41, 0x82, 0x00, 0x8c, 
+	0x48, 0x00, 0x16, 0x5d, 0x54, 0x79, 0x04, 0x3e, 0xa0, 0x7e, 0x00, 0x0c, 0x7f, 0x44, 0xd3, 0x78, 
+	0x4b, 0xff, 0xfd, 0xa9, 0x54, 0x7d, 0x04, 0x3e, 0x2c, 0x1d, 0x00, 0x02, 0x41, 0x82, 0x00, 0x84, 
 	0x40, 0x80, 0x00, 0x14, 0x2c, 0x1d, 0x00, 0x00, 0x41, 0x82, 0x00, 0x1c, 0x40, 0x80, 0x00, 0x24, 
-	0x48, 0x00, 0x00, 0x78, 0x2c, 0x1d, 0x00, 0x04, 0x41, 0x82, 0x00, 0x58, 0x40, 0x80, 0x00, 0x6c, 
-	0x48, 0x00, 0x00, 0x30, 0x7f, 0x59, 0xd3, 0x78, 0x3b, 0x00, 0x00, 0x0e, 0x48, 0x00, 0x00, 0x64, 
+	0x48, 0x00, 0x00, 0x70, 0x2c, 0x1d, 0x00, 0x04, 0x41, 0x82, 0x00, 0x50, 0x40, 0x80, 0x00, 0x64, 
+	0x48, 0x00, 0x00, 0x2c, 0x3b, 0x3a, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x0e, 0x48, 0x00, 0x00, 0x5c, 
 	0x2c, 0x18, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x11, 0x41, 0x82, 0x00, 0x0c, 0x3b, 0x20, 0x00, 0x00, 
-	0x48, 0x00, 0x00, 0x50, 0x38, 0x19, 0x00, 0x03, 0x54, 0x19, 0x04, 0x3e, 0x48, 0x00, 0x00, 0x44, 
-	0x2c, 0x18, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x16, 0x41, 0x82, 0x00, 0x0c, 0x3b, 0x20, 0x00, 0x00, 
-	0x48, 0x00, 0x00, 0x30, 0x38, 0x19, 0x00, 0x08, 0x54, 0x19, 0x04, 0x3e, 0x48, 0x00, 0x00, 0x24, 
-	0x2c, 0x18, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x0e, 0x41, 0x82, 0x00, 0x18, 0x3b, 0x20, 0x00, 0x00, 
-	0x48, 0x00, 0x00, 0x10, 0x48, 0x00, 0x00, 0x0c, 0x3b, 0x00, 0x00, 0x0e, 0x7f, 0x59, 0xd3, 0x78, 
-	0x7f, 0x84, 0xe3, 0x78, 0x7f, 0x65, 0xdb, 0x78, 0x38, 0x61, 0x00, 0x38, 0x48, 0x00, 0x17, 0x85, 
-	0x7f, 0xe3, 0xfb, 0x78, 0x7f, 0x04, 0xc3, 0x78, 0x4b, 0xff, 0xfd, 0x89, 0x7c, 0x7f, 0x1b, 0x79, 
-	0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x94, 0x80, 0x9f, 0x00, 0x0c, 
-	0x2c, 0x1d, 0x00, 0x02, 0xb3, 0x24, 0x00, 0x0c, 0x80, 0x01, 0x00, 0x38, 0x90, 0x04, 0x00, 0x00, 
-	0xa0, 0x01, 0x00, 0x3c, 0xb0, 0x04, 0x00, 0x04, 0x41, 0x82, 0x00, 0x70, 0x40, 0x80, 0x00, 0x10, 
-	0x2c, 0x1d, 0x00, 0x01, 0x40, 0x80, 0x00, 0x14, 0x48, 0x00, 0x00, 0x60, 0x2c, 0x1d, 0x00, 0x04, 
-	0x40, 0x80, 0x00, 0x58, 0x48, 0x00, 0x00, 0x1c, 0x9b, 0x44, 0x00, 0x0e, 0x38, 0x00, 0x00, 0x03, 
-	0xa0, 0x7e, 0x00, 0x0c, 0x98, 0x64, 0x00, 0x0f, 0x98, 0x04, 0x00, 0x10, 0x48, 0x00, 0x00, 0x3c, 
-	0x9b, 0x44, 0x00, 0x0e, 0x38, 0x00, 0x00, 0x03, 0x28, 0x1b, 0x00, 0x0d, 0xa0, 0x7e, 0x00, 0x0c, 
-	0x98, 0x64, 0x00, 0x0f, 0x98, 0x04, 0x00, 0x10, 0x41, 0x80, 0x00, 0x0c, 0x38, 0x61, 0x00, 0x40, 
-	0x48, 0x00, 0x00, 0x08, 0x38, 0x7e, 0x00, 0x2c, 0x80, 0x03, 0x00, 0x00, 0x90, 0x04, 0x00, 0x11, 
-	0x88, 0x03, 0x00, 0x04, 0x98, 0x04, 0x00, 0x15, 0x7f, 0xe3, 0xfb, 0x78, 0x80, 0x01, 0x00, 0x78, 
-	0x38, 0x21, 0x00, 0x70, 0xbb, 0x01, 0xff, 0xe0, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
-	0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7d, 0x1b, 0x78, 0x3b, 0xe2, 0x02, 0x5c, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x83, 0xc3, 0x00, 0x0c, 0xa0, 0x1e, 0x00, 0x0c, 
-	0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x18, 0x80, 0x62, 0x00, 0xcc, 0x7f, 0xa4, 0xeb, 0x78, 
-	0x48, 0x00, 0x15, 0x41, 0x38, 0x03, 0xff, 0xf2, 0xb0, 0x1e, 0x00, 0x0c, 0x80, 0x1f, 0x00, 0x00, 
-	0x7f, 0xa3, 0xeb, 0x78, 0x90, 0x1e, 0x00, 0x06, 0xa0, 0x1f, 0x00, 0x04, 0xb0, 0x1e, 0x00, 0x0a, 
-	0x4b, 0xff, 0xf1, 0x31, 0x80, 0x62, 0x00, 0xf4, 0x7f, 0xa4, 0xeb, 0x78, 0x48, 0x00, 0x15, 0x15, 
-	0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x21, 0xff, 0xe4, 0x7c, 0x08, 0x02, 0xa6, 0x54, 0xb9, 0x04, 0x3e, 0x7c, 0x7b, 0x1b, 0x78, 
-	0x2c, 0x19, 0x00, 0x02, 0x7c, 0x9c, 0x23, 0x78, 0x7c, 0xdd, 0x33, 0x78, 0x90, 0x01, 0x00, 0x08, 
-	0x94, 0x21, 0xff, 0xa0, 0x41, 0x82, 0x00, 0x38, 0x40, 0x80, 0x00, 0x10, 0x2c, 0x19, 0x00, 0x01, 
-	0x40, 0x80, 0x00, 0x14, 0x48, 0x00, 0x00, 0x28, 0x2c, 0x19, 0x00, 0x04, 0x40, 0x80, 0x00, 0x20, 
-	0x48, 0x00, 0x00, 0x10, 0x3b, 0xe0, 0x00, 0x08, 0x3b, 0xc0, 0x00, 0x11, 0x48, 0x00, 0x00, 0x18, 
-	0x3b, 0xe0, 0x00, 0x0d, 0x3b, 0xc0, 0x00, 0x16, 0x48, 0x00, 0x00, 0x0c, 0x3b, 0xe0, 0x00, 0x08, 
-	0x3b, 0xc0, 0x00, 0x0e, 0x80, 0x1b, 0x00, 0x08, 0x54, 0x00, 0x07, 0x39, 0x41, 0x82, 0x00, 0x48, 
-	0x2c, 0x1d, 0x00, 0x00, 0x40, 0x82, 0x00, 0x40, 0x80, 0x1b, 0x00, 0x14, 0x2c, 0x00, 0x00, 0x00, 
-	0x40, 0x82, 0x00, 0x10, 0x80, 0x1c, 0x00, 0x0c, 0x7c, 0x00, 0xf2, 0x14, 0x90, 0x1c, 0x00, 0x0c, 
-	0x38, 0xc2, 0x04, 0xe4, 0x7f, 0x85, 0xe3, 0x78, 0x80, 0x62, 0x00, 0xe4, 0x80, 0x86, 0x00, 0x00, 
-	0x38, 0x04, 0x00, 0x01, 0x90, 0x06, 0x00, 0x00, 0x80, 0x9b, 0x00, 0x18, 0x48, 0x00, 0x14, 0x95, 
-	0x48, 0x00, 0x01, 0x2c, 0x57, 0xe3, 0x08, 0x3c, 0x38, 0x80, 0x00, 0x03, 0x3b, 0x43, 0x00, 0x18, 
-	0x7f, 0x43, 0xd3, 0x78, 0x4b, 0xff, 0xf0, 0x8d, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x24, 
-	0x80, 0x62, 0x00, 0xf4, 0x7f, 0x84, 0xe3, 0x78, 0x48, 0x00, 0x14, 0x19, 0x38, 0x82, 0x04, 0xd8, 
-	0x80, 0x64, 0x00, 0x00, 0x38, 0x03, 0x00, 0x01, 0x90, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0xf0, 
+	0x48, 0x00, 0x00, 0x48, 0x3b, 0x39, 0x00, 0x03, 0x48, 0x00, 0x00, 0x40, 0x2c, 0x18, 0x00, 0x00, 
+	0x3b, 0x00, 0x00, 0x16, 0x41, 0x82, 0x00, 0x0c, 0x3b, 0x20, 0x00, 0x00, 0x48, 0x00, 0x00, 0x2c, 
+	0x3b, 0x39, 0x00, 0x08, 0x48, 0x00, 0x00, 0x24, 0x2c, 0x18, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x0e, 
+	0x41, 0x82, 0x00, 0x18, 0x3b, 0x20, 0x00, 0x00, 0x48, 0x00, 0x00, 0x10, 0x48, 0x00, 0x00, 0x0c, 
+	0x3b, 0x00, 0x00, 0x0e, 0x3b, 0x3a, 0x00, 0x00, 0x38, 0x9c, 0x00, 0x00, 0x38, 0xbb, 0x00, 0x00, 
+	0x38, 0x61, 0x00, 0x38, 0x48, 0x00, 0x16, 0xbd, 0x38, 0x7f, 0x00, 0x00, 0x38, 0x98, 0x00, 0x00, 
+	0x4b, 0xff, 0xfd, 0x91, 0x7c, 0x7f, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 
+	0x48, 0x00, 0x00, 0x94, 0x80, 0x9f, 0x00, 0x0c, 0x2c, 0x1d, 0x00, 0x02, 0xb3, 0x24, 0x00, 0x0c, 
+	0x80, 0x01, 0x00, 0x38, 0x90, 0x04, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x3c, 0xb0, 0x04, 0x00, 0x04, 
+	0x41, 0x82, 0x00, 0x70, 0x40, 0x80, 0x00, 0x10, 0x2c, 0x1d, 0x00, 0x01, 0x40, 0x80, 0x00, 0x14, 
+	0x48, 0x00, 0x00, 0x60, 0x2c, 0x1d, 0x00, 0x04, 0x40, 0x80, 0x00, 0x58, 0x48, 0x00, 0x00, 0x1c, 
+	0x9b, 0x44, 0x00, 0x0e, 0x38, 0x00, 0x00, 0x03, 0xa0, 0x7e, 0x00, 0x0c, 0x98, 0x64, 0x00, 0x0f, 
+	0x98, 0x04, 0x00, 0x10, 0x48, 0x00, 0x00, 0x3c, 0x9b, 0x44, 0x00, 0x0e, 0x38, 0x00, 0x00, 0x03, 
+	0x28, 0x1b, 0x00, 0x0d, 0xa0, 0x7e, 0x00, 0x0c, 0x98, 0x64, 0x00, 0x0f, 0x98, 0x04, 0x00, 0x10, 
+	0x41, 0x80, 0x00, 0x0c, 0x38, 0x61, 0x00, 0x40, 0x48, 0x00, 0x00, 0x08, 0x38, 0x7e, 0x00, 0x28, 
+	0x80, 0x03, 0x00, 0x00, 0x90, 0x04, 0x00, 0x11, 0x88, 0x03, 0x00, 0x04, 0x98, 0x04, 0x00, 0x15, 
+	0x7f, 0xe3, 0xfb, 0x78, 0x80, 0x01, 0x00, 0x78, 0x38, 0x21, 0x00, 0x70, 0xbb, 0x01, 0xff, 0xe0, 
+	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 
+	0x7c, 0x7d, 0x1b, 0x78, 0x3b, 0xe2, 0x02, 0x5c, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 
+	0x83, 0xc3, 0x00, 0x0c, 0xa0, 0x1e, 0x00, 0x0c, 0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x18, 
+	0x80, 0x62, 0x00, 0xcc, 0x7f, 0xa4, 0xeb, 0x78, 0x48, 0x00, 0x14, 0xb5, 0x38, 0x03, 0xff, 0xf2, 
+	0xb0, 0x1e, 0x00, 0x0c, 0x80, 0x1f, 0x00, 0x00, 0x7f, 0xa3, 0xeb, 0x78, 0x90, 0x1e, 0x00, 0x06, 
+	0xa0, 0x1f, 0x00, 0x04, 0xb0, 0x1e, 0x00, 0x0a, 0x4b, 0xff, 0xf1, 0x81, 0x80, 0x62, 0x00, 0xf4, 
+	0x7f, 0xa4, 0xeb, 0x78, 0x48, 0x00, 0x14, 0x89, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 
+	0xbb, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0xbf, 0x21, 0xff, 0xe4, 
+	0x7c, 0x08, 0x02, 0xa6, 0x54, 0xb9, 0x04, 0x3e, 0x3b, 0x63, 0x00, 0x00, 0x2c, 0x19, 0x00, 0x02, 
+	0x3b, 0x84, 0x00, 0x00, 0x3b, 0xa6, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xa0, 
+	0x41, 0x82, 0x00, 0x38, 0x40, 0x80, 0x00, 0x10, 0x2c, 0x19, 0x00, 0x01, 0x40, 0x80, 0x00, 0x14, 
+	0x48, 0x00, 0x00, 0x28, 0x2c, 0x19, 0x00, 0x04, 0x40, 0x80, 0x00, 0x20, 0x48, 0x00, 0x00, 0x10, 
+	0x3b, 0xe0, 0x00, 0x08, 0x3b, 0xc0, 0x00, 0x11, 0x48, 0x00, 0x00, 0x18, 0x3b, 0xe0, 0x00, 0x0d, 
+	0x3b, 0xc0, 0x00, 0x16, 0x48, 0x00, 0x00, 0x0c, 0x3b, 0xe0, 0x00, 0x08, 0x3b, 0xc0, 0x00, 0x0e, 
+	0x80, 0x1b, 0x00, 0x08, 0x54, 0x00, 0x07, 0x39, 0x41, 0x82, 0x00, 0x3c, 0x2c, 0x1d, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x34, 0x80, 0x1c, 0x00, 0x0c, 0x7f, 0x85, 0xe3, 0x78, 0x38, 0x82, 0x04, 0xe4, 
+	0x7c, 0x00, 0xf2, 0x14, 0x90, 0x1c, 0x00, 0x0c, 0x80, 0x64, 0x00, 0x00, 0x38, 0x03, 0x00, 0x01, 
+	0x90, 0x04, 0x00, 0x00, 0x80, 0x9b, 0x00, 0x14, 0x80, 0x62, 0x00, 0xe4, 0x48, 0x00, 0x14, 0x0d, 
+	0x48, 0x00, 0x01, 0x20, 0x57, 0xe3, 0x08, 0x3c, 0x38, 0x80, 0x00, 0x03, 0x3b, 0x43, 0x00, 0x18, 
+	0x38, 0x7a, 0x00, 0x00, 0x4b, 0xff, 0xf0, 0xdd, 0x28, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x24, 
+	0x80, 0x62, 0x00, 0xf4, 0x7f, 0x84, 0xe3, 0x78, 0x48, 0x00, 0x13, 0xa5, 0x38, 0x82, 0x04, 0xd8, 
+	0x80, 0x64, 0x00, 0x00, 0x38, 0x03, 0x00, 0x01, 0x90, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0xe4, 
 	0x80, 0xc3, 0x00, 0x14, 0x38, 0xe0, 0x00, 0x01, 0x38, 0xa0, 0x00, 0x08, 0x38, 0x80, 0x00, 0x18, 
 	0x38, 0x1f, 0x00, 0x18, 0x98, 0xe6, 0x00, 0x0d, 0x2c, 0x19, 0x00, 0x03, 0x80, 0xe3, 0x00, 0x0c, 
 	0x90, 0xa7, 0x00, 0x00, 0x80, 0xa3, 0x00, 0x10, 0x7c, 0xa5, 0xd2, 0x14, 0x90, 0xa3, 0x00, 0x10, 
@@ -325,371 +310,357 @@
 	0x88, 0x08, 0x00, 0x0e, 0xb0, 0x05, 0x00, 0x06, 0x88, 0x08, 0x00, 0x0f, 0xb0, 0x04, 0x00, 0x06, 
 	0x40, 0x82, 0x00, 0x24, 0x80, 0x08, 0x00, 0x11, 0x90, 0x05, 0x00, 0x08, 0x88, 0x08, 0x00, 0x15, 
 	0x98, 0x05, 0x00, 0x0c, 0x80, 0x08, 0x00, 0x11, 0x90, 0x04, 0x00, 0x08, 0x88, 0x08, 0x00, 0x15, 
-	0x98, 0x04, 0x00, 0x0c, 0x80, 0x1b, 0x00, 0x14, 0x2c, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x10, 
-	0x80, 0x1c, 0x00, 0x0c, 0x7c, 0x00, 0xf2, 0x14, 0x90, 0x1c, 0x00, 0x0c, 0x38, 0xc2, 0x04, 0xe8, 
-	0x7c, 0x65, 0x1b, 0x78, 0x80, 0x62, 0x00, 0xe4, 0x80, 0x86, 0x00, 0x00, 0x38, 0x04, 0x00, 0x01, 
-	0x90, 0x06, 0x00, 0x00, 0x80, 0x9b, 0x00, 0x18, 0x48, 0x00, 0x13, 0x69, 0x80, 0x01, 0x00, 0x68, 
-	0x38, 0x21, 0x00, 0x60, 0xbb, 0x21, 0xff, 0xe4, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
-	0xbe, 0x21, 0xff, 0xc4, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7f, 0x1b, 0x78, 0x90, 0x01, 0x00, 0x08, 
-	0x94, 0x21, 0xff, 0x80, 0x83, 0xc3, 0x00, 0x0c, 0xa3, 0xbe, 0x00, 0x0c, 0x2c, 0x1d, 0x05, 0xdd, 
-	0x41, 0x80, 0x00, 0x0c, 0x7f, 0xa3, 0xeb, 0x78, 0x48, 0x00, 0x00, 0x0c, 0x8b, 0xbe, 0x00, 0x0e, 
-	0x88, 0x7e, 0x00, 0x0f, 0x7f, 0xa4, 0xeb, 0x78, 0x4b, 0xff, 0xf9, 0x89, 0x7c, 0x60, 0x1b, 0x78, 
-	0x7f, 0xc3, 0xf3, 0x78, 0x7c, 0x1c, 0x03, 0x78, 0x4b, 0xff, 0xf9, 0xd9, 0x83, 0x42, 0x01, 0x00, 
-	0x38, 0x80, 0x00, 0x01, 0x57, 0xa0, 0xfe, 0xfe, 0x7c, 0x7b, 0x1b, 0x78, 0x7f, 0xf2, 0xfb, 0x78, 
-	0x57, 0x96, 0x04, 0x3e, 0x57, 0xb5, 0x07, 0xfe, 0x7c, 0x94, 0x00, 0x30, 0x57, 0xb3, 0xe7, 0x3a, 
-	0x3b, 0x20, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x00, 0x3a, 0xe0, 0x00, 0x00, 0x48, 0x00, 0x01, 0x6c, 
-	0x80, 0x1a, 0x00, 0x04, 0x28, 0x00, 0x00, 0x00, 0x41, 0x82, 0x01, 0x50, 0x80, 0x1a, 0x00, 0x08, 
-	0x54, 0x03, 0x07, 0x7b, 0x41, 0x82, 0x00, 0x10, 0x57, 0xa3, 0x04, 0x3e, 0x28, 0x03, 0x00, 0xff, 
-	0x40, 0x81, 0x00, 0xac, 0xa0, 0x7a, 0x00, 0x0c, 0x57, 0xa4, 0x04, 0x3e, 0x7c, 0x04, 0x18, 0x40, 
-	0x40, 0x82, 0x00, 0x74, 0x54, 0x03, 0x07, 0xff, 0x41, 0x82, 0x00, 0x94, 0x88, 0xde, 0x00, 0x11, 
-	0x88, 0x9a, 0x00, 0x2c, 0x88, 0xbe, 0x00, 0x12, 0x7c, 0xc4, 0x22, 0x78, 0x88, 0x7a, 0x00, 0x2d, 
-	0x54, 0x87, 0x06, 0x3e, 0x88, 0x9e, 0x00, 0x13, 0x7c, 0xa5, 0x1a, 0x78, 0x88, 0x7a, 0x00, 0x2e, 
-	0x7c, 0xe7, 0x2b, 0x78, 0x88, 0xde, 0x00, 0x14, 0x88, 0xba, 0x00, 0x2f, 0x7c, 0x83, 0x1a, 0x78, 
-	0x54, 0xe7, 0x06, 0x3e, 0x88, 0x9e, 0x00, 0x15, 0x7c, 0xe7, 0x1b, 0x78, 0x88, 0x7a, 0x00, 0x30, 
-	0x7c, 0xc5, 0x2a, 0x78, 0x54, 0xe7, 0x06, 0x3e, 0x7c, 0xe5, 0x2b, 0x78, 0x7c, 0x83, 0x1a, 0x78, 
-	0x54, 0xa7, 0x06, 0x3e, 0x7c, 0xe3, 0x1b, 0x78, 0x54, 0x67, 0x06, 0x3f, 0x41, 0x82, 0x00, 0x30, 
-	0x48, 0x00, 0x00, 0xb8, 0x2c, 0x16, 0x00, 0x01, 0x41, 0x82, 0x00, 0x0c, 0x2c, 0x16, 0x00, 0x03, 
-	0x40, 0x82, 0x00, 0xa8, 0x2c, 0x15, 0x00, 0x00, 0x41, 0x82, 0x00, 0xa0, 0x38, 0x7a, 0x00, 0x1c, 
-	0x7c, 0x73, 0x18, 0x2e, 0x7c, 0x63, 0xa0, 0x39, 0x41, 0x82, 0x00, 0x90, 0x2c, 0x1b, 0x00, 0x01, 
-	0x40, 0x82, 0x00, 0x54, 0x54, 0x00, 0x07, 0xbd, 0x41, 0x82, 0x00, 0x4c, 0x82, 0x3a, 0x00, 0x34, 
-	0x48, 0x00, 0x00, 0x30, 0x60, 0x00, 0x00, 0x00, 0x7f, 0xc3, 0xf3, 0x78, 0x38, 0x91, 0x00, 0x04, 
-	0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x13, 0x8d, 0x2c, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x10, 
-	0x38, 0x11, 0x00, 0x04, 0x48, 0x00, 0x00, 0x18, 0x60, 0x00, 0x00, 0x00, 0x82, 0x31, 0x00, 0x00, 
-	0x28, 0x11, 0x00, 0x00, 0x40, 0x82, 0xff, 0xd4, 0x38, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
-	0x41, 0x82, 0x00, 0x38, 0x28, 0x19, 0x00, 0x00, 0x41, 0x82, 0x00, 0x24, 0x80, 0x62, 0x00, 0xec, 
-	0x7e, 0x44, 0x93, 0x78, 0x48, 0x00, 0x11, 0x4d, 0x7c, 0x64, 0x1b, 0x78, 0x7f, 0x23, 0xcb, 0x78, 
-	0x7f, 0x05, 0xc3, 0x78, 0x7e, 0xe6, 0xbb, 0x78, 0x4b, 0xff, 0xfc, 0x49, 0x7f, 0x59, 0xd3, 0x78, 
-	0x7f, 0x98, 0xe3, 0x78, 0x7f, 0x77, 0xdb, 0x78, 0x80, 0x62, 0x00, 0xb8, 0x7f, 0x44, 0xd3, 0x78, 
-	0x48, 0x00, 0x11, 0x21, 0x7c, 0x7a, 0x1b, 0x78, 0x28, 0x1a, 0x00, 0x00, 0x40, 0x82, 0xfe, 0x94, 
-	0x28, 0x19, 0x00, 0x00, 0x41, 0x82, 0x00, 0x1c, 0x7f, 0x23, 0xcb, 0x78, 0x7f, 0xe4, 0xfb, 0x78, 
-	0x7f, 0x05, 0xc3, 0x78, 0x7e, 0xe6, 0xbb, 0x78, 0x4b, 0xff, 0xfc, 0x09, 0x48, 0x00, 0x00, 0x20, 
-	0x80, 0x62, 0x00, 0xf4, 0x7f, 0xe4, 0xfb, 0x78, 0x48, 0x00, 0x10, 0xe9, 0x38, 0x82, 0x04, 0xdc, 
-	0x80, 0x64, 0x00, 0x00, 0x38, 0x03, 0x00, 0x01, 0x90, 0x04, 0x00, 0x00, 0x80, 0x01, 0x00, 0x88, 
-	0x38, 0x21, 0x00, 0x80, 0xba, 0x21, 0xff, 0xc4, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
-	0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x9f, 0x23, 0x78, 0x7c, 0x7d, 0x1b, 0x78, 
-	0x38, 0xc2, 0x04, 0xec, 0x38, 0x80, 0x00, 0x00, 0x7f, 0xe3, 0xfb, 0x78, 0x90, 0x01, 0x00, 0x08, 
+	0x98, 0x04, 0x00, 0x0c, 0x80, 0x1c, 0x00, 0x0c, 0x7c, 0x65, 0x1b, 0x78, 0x38, 0x82, 0x04, 0xe8, 
+	0x7c, 0x00, 0xf2, 0x14, 0x90, 0x1c, 0x00, 0x0c, 0x80, 0x64, 0x00, 0x00, 0x38, 0x03, 0x00, 0x01, 
+	0x90, 0x04, 0x00, 0x00, 0x80, 0x9b, 0x00, 0x14, 0x80, 0x62, 0x00, 0xe4, 0x48, 0x00, 0x12, 0xed, 
+	0x80, 0x01, 0x00, 0x68, 0x38, 0x21, 0x00, 0x60, 0xbb, 0x21, 0xff, 0xe4, 0x7c, 0x08, 0x03, 0xa6, 
+	0x4e, 0x80, 0x00, 0x20, 0xbe, 0x41, 0xff, 0xc8, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7c, 0x1b, 0x78, 
+	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0x70, 0x82, 0xc3, 0x00, 0x0c, 0xa0, 0x16, 0x00, 0x0c, 
+	0x2c, 0x00, 0x05, 0xdd, 0x7c, 0x12, 0x03, 0x78, 0x41, 0x80, 0x00, 0x0c, 0x7e, 0x43, 0x93, 0x78, 
+	0x48, 0x00, 0x00, 0x0c, 0x8a, 0x56, 0x00, 0x0e, 0x88, 0x76, 0x00, 0x0f, 0x7e, 0x44, 0x93, 0x78, 
+	0x4b, 0xff, 0xf9, 0xb9, 0x38, 0x03, 0x00, 0x00, 0x38, 0x76, 0x00, 0x00, 0x7c, 0x15, 0x03, 0x78, 
+	0x4b, 0xff, 0xfa, 0x01, 0x56, 0x40, 0x06, 0x3e, 0x82, 0x62, 0x01, 0x00, 0x56, 0x44, 0xfe, 0xfe, 
+	0x7c, 0x00, 0x36, 0x70, 0x38, 0xa0, 0x00, 0x01, 0x3a, 0x83, 0x00, 0x00, 0x56, 0xba, 0x04, 0x3e, 
+	0x56, 0x5b, 0x04, 0x3e, 0x56, 0x59, 0x07, 0xfe, 0x7c, 0xb8, 0x20, 0x30, 0x54, 0x17, 0x10, 0x3a, 
+	0x3b, 0xe0, 0x00, 0x00, 0x3b, 0xc0, 0x00, 0x00, 0x3b, 0xa0, 0x00, 0x00, 0x48, 0x00, 0x01, 0x4c, 
+	0x80, 0x13, 0x00, 0x04, 0x28, 0x00, 0x00, 0x00, 0x41, 0x82, 0x01, 0x30, 0x80, 0x13, 0x00, 0x08, 
+	0x54, 0x03, 0x07, 0x7b, 0x41, 0x82, 0x00, 0x0c, 0x28, 0x1b, 0x00, 0xff, 0x40, 0x81, 0x00, 0x98, 
+	0xa0, 0x73, 0x00, 0x0c, 0x7c, 0x1b, 0x18, 0x40, 0x40, 0x82, 0x00, 0x64, 0x54, 0x03, 0x07, 0xff, 
+	0x41, 0x82, 0x00, 0x84, 0x88, 0x96, 0x00, 0x11, 0x88, 0x73, 0x00, 0x28, 0x88, 0xd6, 0x00, 0x12, 
+	0x7c, 0x87, 0x1a, 0x78, 0x88, 0xb3, 0x00, 0x29, 0x88, 0x96, 0x00, 0x13, 0x7c, 0xc5, 0x2a, 0x78, 
+	0x88, 0x73, 0x00, 0x2a, 0x7c, 0xe7, 0x2b, 0x78, 0x88, 0xd6, 0x00, 0x14, 0x7c, 0x83, 0x1a, 0x78, 
+	0x88, 0xb3, 0x00, 0x2b, 0x7c, 0xe7, 0x1b, 0x78, 0x88, 0x96, 0x00, 0x15, 0x88, 0x73, 0x00, 0x2c, 
+	0x7c, 0xc5, 0x2a, 0x78, 0x7c, 0xe7, 0x2b, 0x78, 0x7c, 0x83, 0x1a, 0x78, 0x7c, 0xe7, 0x1b, 0x78, 
+	0x54, 0xe3, 0x06, 0x3f, 0x41, 0x82, 0x00, 0x30, 0x48, 0x00, 0x00, 0xb0, 0x2c, 0x1a, 0x00, 0x01, 
+	0x41, 0x82, 0x00, 0x0c, 0x2c, 0x1a, 0x00, 0x03, 0x40, 0x82, 0x00, 0xa0, 0x2c, 0x19, 0x00, 0x00, 
+	0x41, 0x82, 0x00, 0x98, 0x38, 0x73, 0x00, 0x18, 0x7c, 0x77, 0x18, 0x2e, 0x7c, 0x63, 0xc0, 0x39, 
+	0x41, 0x82, 0x00, 0x88, 0x2c, 0x14, 0x00, 0x01, 0x40, 0x82, 0x00, 0x4c, 0x54, 0x00, 0x07, 0xbd, 
+	0x41, 0x82, 0x00, 0x44, 0x82, 0x53, 0x00, 0x30, 0x48, 0x00, 0x00, 0x28, 0x38, 0x76, 0x00, 0x00, 
+	0x38, 0x92, 0x00, 0x04, 0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x12, 0xed, 0x2c, 0x03, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x0c, 0x38, 0x12, 0x00, 0x04, 0x48, 0x00, 0x00, 0x14, 0x82, 0x52, 0x00, 0x00, 
+	0x28, 0x12, 0x00, 0x00, 0x40, 0x82, 0xff, 0xd8, 0x38, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
+	0x41, 0x82, 0x00, 0x38, 0x28, 0x1f, 0x00, 0x00, 0x41, 0x82, 0x00, 0x24, 0x80, 0x62, 0x00, 0xec, 
+	0x7f, 0x84, 0xe3, 0x78, 0x48, 0x00, 0x10, 0xf9, 0x38, 0x83, 0x00, 0x00, 0x38, 0x7f, 0x00, 0x00, 
+	0x38, 0xbe, 0x00, 0x00, 0x38, 0xdd, 0x00, 0x00, 0x4b, 0xff, 0xfc, 0x75, 0x3b, 0xf3, 0x00, 0x00, 
+	0x3b, 0xd5, 0x00, 0x00, 0x3b, 0xb4, 0x00, 0x00, 0x80, 0x62, 0x00, 0xb8, 0x7e, 0x64, 0x9b, 0x78, 
+	0x48, 0x00, 0x10, 0xcd, 0x7c, 0x73, 0x1b, 0x78, 0x28, 0x13, 0x00, 0x00, 0x40, 0x82, 0xfe, 0xb4, 
+	0x28, 0x1f, 0x00, 0x00, 0x41, 0x82, 0x00, 0x1c, 0x38, 0x7f, 0x00, 0x00, 0x38, 0x9c, 0x00, 0x00, 
+	0x38, 0xbe, 0x00, 0x00, 0x38, 0xdd, 0x00, 0x00, 0x4b, 0xff, 0xfc, 0x35, 0x48, 0x00, 0x00, 0x20, 
+	0x80, 0x62, 0x00, 0xf4, 0x7f, 0x84, 0xe3, 0x78, 0x48, 0x00, 0x10, 0x95, 0x38, 0x82, 0x04, 0xdc, 
+	0x80, 0x64, 0x00, 0x00, 0x38, 0x03, 0x00, 0x01, 0x90, 0x04, 0x00, 0x00, 0x80, 0x01, 0x00, 0x98, 
+	0x38, 0x21, 0x00, 0x90, 0xba, 0x41, 0xff, 0xc8, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
+	0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xc4, 0x00, 0x00, 0x3b, 0xa3, 0x00, 0x00, 
+	0x38, 0xc2, 0x04, 0xec, 0x38, 0x7e, 0x00, 0x00, 0x38, 0x80, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 
 	0x94, 0x21, 0xff, 0xb0, 0x80, 0xa6, 0x00, 0x00, 0x38, 0x05, 0x00, 0x01, 0x90, 0x06, 0x00, 0x00, 
-	0x4b, 0xff, 0xec, 0xf1, 0x7c, 0x7e, 0x1b, 0x79, 0x41, 0x82, 0x00, 0x2c, 0x80, 0x7e, 0x00, 0x0c, 
-	0x7f, 0xa4, 0xeb, 0x78, 0x7f, 0xe5, 0xfb, 0x78, 0x48, 0x00, 0x11, 0xc9, 0x80, 0x1e, 0x00, 0x10, 
-	0x7f, 0xc3, 0xf3, 0x78, 0x7c, 0x00, 0xfa, 0x14, 0x90, 0x1e, 0x00, 0x10, 0x4b, 0xff, 0xfd, 0x65, 
+	0x4b, 0xff, 0xed, 0x61, 0x7c, 0x7f, 0x1b, 0x79, 0x41, 0x82, 0x00, 0x2c, 0x80, 0x7f, 0x00, 0x0c, 
+	0x38, 0x9d, 0x00, 0x00, 0x38, 0xbe, 0x00, 0x00, 0x48, 0x00, 0x11, 0x39, 0x80, 0x1f, 0x00, 0x10, 
+	0x38, 0x7f, 0x00, 0x00, 0x7c, 0x00, 0xf2, 0x14, 0x90, 0x1f, 0x00, 0x10, 0x4b, 0xff, 0xfd, 0x79, 
 	0x48, 0x00, 0x00, 0x14, 0x38, 0x82, 0x04, 0xe0, 0x80, 0x64, 0x00, 0x00, 0x38, 0x03, 0x00, 0x01, 
 	0x90, 0x04, 0x00, 0x00, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0xa1, 0xff, 0xf4, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 0x28, 0x05, 0x00, 0x00, 0x7c, 0x9c, 0x23, 0x78, 
-	0x39, 0x22, 0x04, 0xf8, 0x7c, 0xdd, 0x33, 0x78, 0x7c, 0xfe, 0x3b, 0x78, 0x7d, 0x1f, 0x43, 0x78, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0x69, 0x00, 0x00, 0x38, 0x03, 0x00, 0x01, 
-	0x90, 0x09, 0x00, 0x00, 0x41, 0x82, 0x00, 0x10, 0x80, 0x62, 0x00, 0xf4, 0x7c, 0xa4, 0x2b, 0x78, 
-	0x48, 0x00, 0x0f, 0xf1, 0x38, 0x60, 0x00, 0x10, 0x38, 0x80, 0x00, 0x03, 0x4b, 0xff, 0xec, 0x45, 
-	0x7c, 0x65, 0x1b, 0x79, 0x41, 0x82, 0x00, 0x40, 0x80, 0x65, 0x00, 0x14, 0x38, 0xc0, 0x00, 0x83, 
-	0x38, 0x00, 0x00, 0x05, 0x7f, 0x84, 0xe3, 0x78, 0x98, 0xc3, 0x00, 0x0d, 0x80, 0x65, 0x00, 0x10, 
-	0x90, 0x03, 0x00, 0x00, 0x93, 0xa3, 0x00, 0x04, 0x93, 0xc3, 0x00, 0x08, 0x93, 0xe3, 0x00, 0x0c, 
-	0x80, 0x65, 0x00, 0x10, 0x38, 0x03, 0x00, 0x10, 0x90, 0x05, 0x00, 0x10, 0x80, 0x62, 0x00, 0xd4, 
-	0x48, 0x00, 0x0f, 0xf1, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0x81, 0xff, 0xf0, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0xbe, 0x2b, 0x78, 0x7c, 0x9d, 0x23, 0x78, 
+	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 
+	0x28, 0x05, 0x00, 0x00, 0x3b, 0x84, 0x00, 0x00, 0x39, 0x22, 0x04, 0xf8, 0x3b, 0xa6, 0x00, 0x00, 
+	0x3b, 0xc7, 0x00, 0x00, 0x3b, 0xe8, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 
+	0x80, 0x69, 0x00, 0x00, 0x38, 0x03, 0x00, 0x01, 0x90, 0x09, 0x00, 0x00, 0x41, 0x82, 0x00, 0x10, 
+	0x80, 0x62, 0x00, 0xf4, 0x7c, 0xa4, 0x2b, 0x78, 0x48, 0x00, 0x0f, 0xa5, 0x38, 0x60, 0x00, 0x10, 
+	0x38, 0x80, 0x00, 0x03, 0x4b, 0xff, 0xec, 0xbd, 0x7c, 0x65, 0x1b, 0x79, 0x41, 0x82, 0x00, 0x40, 
+	0x80, 0x65, 0x00, 0x14, 0x38, 0xc0, 0x00, 0x83, 0x38, 0x00, 0x00, 0x05, 0x38, 0x9c, 0x00, 0x00, 
+	0x98, 0xc3, 0x00, 0x0d, 0x80, 0x65, 0x00, 0x10, 0x90, 0x03, 0x00, 0x00, 0x93, 0xa3, 0x00, 0x04, 
+	0x93, 0xc3, 0x00, 0x08, 0x93, 0xe3, 0x00, 0x0c, 0x80, 0x65, 0x00, 0x10, 0x38, 0x03, 0x00, 0x10, 
+	0x90, 0x05, 0x00, 0x10, 0x80, 0x62, 0x00, 0xd4, 0x48, 0x00, 0x0f, 0x91, 0x80, 0x01, 0x00, 0x58, 
+	0x38, 0x21, 0x00, 0x50, 0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
+	0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xc5, 0x00, 0x00, 0x3b, 0xa4, 0x00, 0x00, 
 	0x7c, 0xdf, 0x33, 0x78, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0x65, 0x00, 0x14, 
 	0x88, 0x03, 0x00, 0x0c, 0x28, 0x00, 0x00, 0x01, 0x41, 0x82, 0x00, 0x28, 0x80, 0x62, 0x00, 0xf4, 
-	0x7f, 0xc4, 0xf3, 0x78, 0x48, 0x00, 0x0f, 0x4d, 0x38, 0x60, 0x00, 0x10, 0x38, 0x80, 0x00, 0x03, 
-	0x4b, 0xff, 0xeb, 0xa1, 0x7c, 0x7e, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x24, 0x48, 0x00, 0x00, 0x58, 
+	0x7f, 0xc4, 0xf3, 0x78, 0x48, 0x00, 0x0f, 0x09, 0x38, 0x60, 0x00, 0x10, 0x38, 0x80, 0x00, 0x03, 
+	0x4b, 0xff, 0xec, 0x21, 0x7c, 0x7e, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x24, 0x48, 0x00, 0x00, 0x58, 
 	0x80, 0x9e, 0x00, 0x08, 0x28, 0x04, 0x00, 0x00, 0x41, 0x82, 0x00, 0x14, 0x80, 0x62, 0x00, 0xf4, 
-	0x48, 0x00, 0x0f, 0x21, 0x38, 0x00, 0x00, 0x00, 0x90, 0x1e, 0x00, 0x08, 0x80, 0x7e, 0x00, 0x14, 
-	0x38, 0xc0, 0x00, 0x83, 0x38, 0x00, 0x00, 0x06, 0x7f, 0xa4, 0xeb, 0x78, 0x7f, 0xc5, 0xf3, 0x78, 
+	0x48, 0x00, 0x0e, 0xdd, 0x38, 0x00, 0x00, 0x00, 0x90, 0x1e, 0x00, 0x08, 0x80, 0x7e, 0x00, 0x14, 
+	0x38, 0xc0, 0x00, 0x83, 0x38, 0x00, 0x00, 0x06, 0x38, 0x9d, 0x00, 0x00, 0x38, 0xbe, 0x00, 0x00, 
 	0x98, 0xc3, 0x00, 0x0d, 0x80, 0x7e, 0x00, 0x0c, 0x90, 0x03, 0x00, 0x00, 0x93, 0xe3, 0x00, 0x04, 
 	0x80, 0x7e, 0x00, 0x0c, 0x38, 0x03, 0x00, 0x08, 0x90, 0x1e, 0x00, 0x10, 0x80, 0x62, 0x00, 0xd4, 
-	0x48, 0x00, 0x0f, 0x31, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0xa1, 0xff, 0xf4, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x01, 0xff, 0xe0, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x78, 0x1b, 0x78, 0x7c, 0x99, 0x23, 0x78, 
-	0x3b, 0xe2, 0x02, 0x5c, 0x7c, 0xba, 0x2b, 0x78, 0x3b, 0xa0, 0x00, 0x00, 0x3b, 0x80, 0x00, 0x0e, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xa0, 0x80, 0x03, 0x00, 0x04, 0x28, 0x00, 0x00, 0x00, 
-	0x41, 0x82, 0x00, 0x4c, 0x80, 0x18, 0x00, 0x08, 0x38, 0x60, 0x00, 0x02, 0x54, 0x00, 0x07, 0xff, 
-	0x41, 0x82, 0x00, 0x08, 0x38, 0x60, 0x00, 0x07, 0xa0, 0x18, 0x00, 0x0c, 0x7c, 0x7d, 0x1b, 0x78, 
-	0x2c, 0x00, 0x00, 0xaa, 0x40, 0x82, 0x00, 0x0c, 0x3b, 0x80, 0x00, 0x16, 0x48, 0x00, 0x00, 0x20, 
-	0x2c, 0x00, 0x00, 0xfe, 0x40, 0x81, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0xff, 0x40, 0x82, 0x00, 0x0c, 
-	0x3b, 0x80, 0x00, 0x11, 0x48, 0x00, 0x00, 0x08, 0x3b, 0x80, 0x00, 0x0e, 0x3b, 0xdd, 0x00, 0x58, 
-	0x38, 0x80, 0x00, 0x01, 0x7f, 0xc3, 0xf3, 0x78, 0x4b, 0xff, 0xea, 0x99, 0x7c, 0x7b, 0x1b, 0x79, 
-	0x40, 0x82, 0x00, 0x24, 0x7f, 0x03, 0xc3, 0x78, 0x7f, 0x24, 0xcb, 0x78, 0x7f, 0x45, 0xd3, 0x78, 
-	0x38, 0xc0, 0x00, 0x00, 0x38, 0xe0, 0x00, 0x04, 0x39, 0x00, 0x00, 0x0c, 0x4b, 0xff, 0xfd, 0xe5, 
-	0x48, 0x00, 0x01, 0x44, 0x80, 0x7b, 0x00, 0x14, 0x38, 0x80, 0x00, 0x83, 0x38, 0xc0, 0x00, 0x03, 
-	0x38, 0xa0, 0x00, 0x02, 0x38, 0x00, 0x05, 0x00, 0x98, 0x83, 0x00, 0x0d, 0x38, 0x80, 0x00, 0x04, 
-	0x80, 0x7b, 0x00, 0x0c, 0x90, 0xc3, 0x00, 0x00, 0x90, 0xa3, 0x00, 0x20, 0x90, 0x03, 0x00, 0x34, 
-	0x90, 0xa3, 0x00, 0x3c, 0x80, 0x18, 0x00, 0x04, 0x90, 0x03, 0x00, 0x18, 0x80, 0x18, 0x00, 0x10, 
-	0x2c, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x08, 0x38, 0x80, 0x00, 0x00, 0x7c, 0x80, 0x07, 0x34, 
-	0x39, 0x20, 0x00, 0x00, 0x90, 0x03, 0x00, 0x10, 0x39, 0x00, 0xff, 0xff, 0x38, 0xe0, 0x00, 0x01, 
-	0x20, 0xdc, 0x05, 0xea, 0x7c, 0xbd, 0x00, 0xd0, 0x38, 0x9d, 0x00, 0x06, 0x38, 0x00, 0x00, 0x4c, 
-	0x91, 0x23, 0x00, 0x14, 0x28, 0x1d, 0x00, 0x00, 0x91, 0x23, 0x00, 0x24, 0x91, 0x03, 0x00, 0x28, 
-	0x91, 0x23, 0x00, 0x2c, 0x91, 0x03, 0x00, 0x30, 0x91, 0x23, 0x00, 0x48, 0x90, 0xe3, 0x00, 0x08, 
-	0x90, 0xc3, 0x00, 0x04, 0x90, 0xa3, 0x00, 0x1c, 0x90, 0x83, 0x00, 0x0c, 0x90, 0x03, 0x00, 0x38, 
-	0x80, 0xbb, 0x00, 0x0c, 0x80, 0x83, 0x00, 0x38, 0x80, 0x1f, 0x00, 0x00, 0x7c, 0x85, 0x22, 0x14, 
-	0x90, 0x04, 0x00, 0x00, 0xa0, 0x1f, 0x00, 0x04, 0xb0, 0x04, 0x00, 0x04, 0x41, 0x82, 0x00, 0x28, 
-	0xa0, 0x18, 0x00, 0x0c, 0xb0, 0x04, 0x00, 0x06, 0x80, 0x18, 0x00, 0x08, 0x54, 0x00, 0x07, 0xff, 
-	0x41, 0x82, 0x00, 0x14, 0x80, 0x18, 0x00, 0x2c, 0x90, 0x04, 0x00, 0x08, 0x88, 0x18, 0x00, 0x30, 
-	0x98, 0x04, 0x00, 0x0c, 0x38, 0x00, 0x00, 0x06, 0x3c, 0x80, 0x00, 0x01, 0x90, 0x03, 0x00, 0x40, 
-	0x38, 0x1d, 0x00, 0x52, 0x38, 0xe0, 0xff, 0xff, 0x38, 0xc4, 0xff, 0xff, 0x7f, 0x44, 0xd3, 0x78, 
-	0x90, 0x03, 0x00, 0x44, 0x80, 0xbb, 0x00, 0x0c, 0x80, 0x03, 0x00, 0x44, 0x7c, 0xe5, 0x01, 0x2e, 
-	0x80, 0x63, 0x00, 0x44, 0x80, 0xbb, 0x00, 0x0c, 0x38, 0x03, 0x00, 0x04, 0x7c, 0xc5, 0x03, 0x2e, 
-	0x80, 0x1b, 0x00, 0x10, 0x7c, 0x00, 0xf2, 0x14, 0x90, 0x1b, 0x00, 0x10, 0x80, 0x62, 0x00, 0xf4, 
-	0x48, 0x00, 0x0c, 0xe1, 0x80, 0x62, 0x00, 0xd4, 0x7f, 0x24, 0xcb, 0x78, 0x7f, 0x65, 0xdb, 0x78, 
-	0x48, 0x00, 0x0d, 0x21, 0x80, 0x01, 0x00, 0x68, 0x38, 0x21, 0x00, 0x60, 0xbb, 0x01, 0xff, 0xe0, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7a, 0x1b, 0x78, 0x7c, 0x9d, 0x23, 0x78, 
-	0x3b, 0x82, 0x02, 0x5c, 0x7c, 0xbe, 0x2b, 0x78, 0x38, 0x60, 0x00, 0x12, 0x38, 0x80, 0x00, 0x03, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x83, 0x65, 0x00, 0x0c, 0x4b, 0xff, 0xe8, 0xe5, 
-	0x7c, 0x7f, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x24, 0x7f, 0x43, 0xd3, 0x78, 0x7f, 0xa4, 0xeb, 0x78, 
-	0x7f, 0xc5, 0xf3, 0x78, 0x38, 0xc0, 0x00, 0x31, 0x38, 0xe0, 0x00, 0x04, 0x39, 0x00, 0x00, 0x0c, 
-	0x4b, 0xff, 0xfc, 0x31, 0x48, 0x00, 0x00, 0xb0, 0x80, 0xbf, 0x00, 0x14, 0x38, 0xc0, 0x00, 0x83, 
-	0x38, 0x80, 0x00, 0x32, 0x38, 0x60, 0x00, 0x06, 0x38, 0x00, 0x00, 0x0c, 0x98, 0xc5, 0x00, 0x0d, 
-	0x80, 0xbf, 0x00, 0x10, 0x90, 0x85, 0x00, 0x00, 0x90, 0x65, 0x00, 0x04, 0x90, 0x05, 0x00, 0x08, 
-	0x80, 0x7f, 0x00, 0x10, 0x38, 0x03, 0x00, 0x12, 0x90, 0x1f, 0x00, 0x10, 0x80, 0x1b, 0x00, 0x04, 
-	0x28, 0x00, 0x00, 0x02, 0x41, 0x82, 0x00, 0x0c, 0x28, 0x00, 0x00, 0x01, 0x40, 0x82, 0x00, 0x2c, 
-	0x80, 0x9c, 0x00, 0x00, 0x80, 0x7f, 0x00, 0x0c, 0x80, 0x05, 0x00, 0x08, 0x7c, 0x83, 0x01, 0x2e, 
-	0x80, 0x65, 0x00, 0x08, 0xa0, 0xbc, 0x00, 0x04, 0x80, 0x9f, 0x00, 0x0c, 0x38, 0x03, 0x00, 0x04, 
-	0x7c, 0xa4, 0x03, 0x2e, 0x48, 0x00, 0x00, 0x24, 0x7f, 0x43, 0xd3, 0x78, 0x7f, 0xa4, 0xeb, 0x78, 
-	0x7f, 0xc5, 0xf3, 0x78, 0x38, 0xc0, 0x00, 0x31, 0x38, 0xe0, 0x00, 0x09, 0x39, 0x00, 0x00, 0x00, 
-	0x4b, 0xff, 0xfb, 0xa1, 0x48, 0x00, 0x00, 0x20, 0x80, 0x62, 0x00, 0xf4, 0x7f, 0xc4, 0xf3, 0x78, 
-	0x48, 0x00, 0x0b, 0xc1, 0x80, 0x62, 0x00, 0xd4, 0x7f, 0xa4, 0xeb, 0x78, 0x7f, 0xe5, 0xfb, 0x78, 
-	0x48, 0x00, 0x0c, 0x01, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0x41, 0xff, 0xe8, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7a, 0x1b, 0x78, 0x7c, 0xbc, 0x2b, 0x78, 
+	0x48, 0x00, 0x0e, 0xd9, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0xa1, 0xff, 0xf4, 
+	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0xbf, 0x21, 0xff, 0xe4, 0x7c, 0x08, 0x02, 0xa6, 
+	0x7c, 0x79, 0x1b, 0x78, 0x7c, 0x9a, 0x23, 0x78, 0x3b, 0xe2, 0x02, 0x5c, 0x3b, 0x65, 0x00, 0x00, 
+	0x3b, 0xc0, 0x00, 0x00, 0x3b, 0xa0, 0x00, 0x0e, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xa0, 
+	0x80, 0x03, 0x00, 0x04, 0x28, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x50, 0x80, 0x19, 0x00, 0x08, 
+	0x54, 0x00, 0x07, 0xff, 0x41, 0x82, 0x00, 0x0c, 0x38, 0x00, 0x00, 0x07, 0x48, 0x00, 0x00, 0x08, 
+	0x38, 0x00, 0x00, 0x02, 0xa0, 0x79, 0x00, 0x0c, 0x7c, 0x1e, 0x03, 0x78, 0x2c, 0x03, 0x00, 0xaa, 
+	0x40, 0x82, 0x00, 0x0c, 0x3b, 0xa0, 0x00, 0x16, 0x48, 0x00, 0x00, 0x20, 0x2c, 0x03, 0x00, 0xfe, 
+	0x40, 0x81, 0x00, 0x0c, 0x2c, 0x03, 0x00, 0xff, 0x40, 0x82, 0x00, 0x0c, 0x3b, 0xa0, 0x00, 0x11, 
+	0x48, 0x00, 0x00, 0x08, 0x3b, 0xa0, 0x00, 0x0e, 0x38, 0x80, 0x00, 0x01, 0x38, 0x7e, 0x00, 0x58, 
+	0x4b, 0xff, 0xeb, 0x21, 0x7c, 0x7c, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x24, 0x38, 0x79, 0x00, 0x00, 
+	0x38, 0x9a, 0x00, 0x00, 0x38, 0xbb, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x00, 0x38, 0xe0, 0x00, 0x04, 
+	0x39, 0x00, 0x00, 0x0c, 0x4b, 0xff, 0xfd, 0xf5, 0x48, 0x00, 0x01, 0x4c, 0x80, 0x7c, 0x00, 0x14, 
+	0x38, 0xc0, 0x00, 0x83, 0x38, 0xa0, 0x00, 0x03, 0x38, 0x80, 0x00, 0x02, 0x38, 0x00, 0x05, 0x00, 
+	0x98, 0xc3, 0x00, 0x0d, 0x80, 0x7c, 0x00, 0x0c, 0x90, 0xa3, 0x00, 0x00, 0x90, 0x83, 0x00, 0x20, 
+	0x90, 0x03, 0x00, 0x34, 0x90, 0x83, 0x00, 0x3c, 0x80, 0x19, 0x00, 0x04, 0x90, 0x03, 0x00, 0x18, 
+	0x80, 0x19, 0x00, 0x10, 0x2c, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x0c, 0x38, 0x00, 0x00, 0x00, 
+	0x48, 0x00, 0x00, 0x08, 0x38, 0x00, 0x00, 0x04, 0x7c, 0x00, 0x07, 0x34, 0x39, 0x20, 0x00, 0x00, 
+	0x90, 0x03, 0x00, 0x10, 0x39, 0x00, 0xff, 0xff, 0x38, 0xe0, 0x00, 0x01, 0x20, 0xdd, 0x05, 0xea, 
+	0x7c, 0xbe, 0x00, 0xd0, 0x38, 0x9e, 0x00, 0x06, 0x38, 0x00, 0x00, 0x4c, 0x91, 0x23, 0x00, 0x14, 
+	0x28, 0x1e, 0x00, 0x00, 0x91, 0x23, 0x00, 0x24, 0x91, 0x03, 0x00, 0x28, 0x91, 0x23, 0x00, 0x2c, 
+	0x91, 0x03, 0x00, 0x30, 0x91, 0x23, 0x00, 0x48, 0x90, 0xe3, 0x00, 0x08, 0x90, 0xc3, 0x00, 0x04, 
+	0x90, 0xa3, 0x00, 0x1c, 0x90, 0x83, 0x00, 0x0c, 0x90, 0x03, 0x00, 0x38, 0x80, 0xbc, 0x00, 0x0c, 
+	0x80, 0x83, 0x00, 0x38, 0x80, 0x1f, 0x00, 0x00, 0x7c, 0x85, 0x22, 0x14, 0x90, 0x04, 0x00, 0x00, 
+	0xa0, 0x1f, 0x00, 0x04, 0xb0, 0x04, 0x00, 0x04, 0x41, 0x82, 0x00, 0x28, 0xa0, 0x19, 0x00, 0x0c, 
+	0xb0, 0x04, 0x00, 0x06, 0x80, 0x19, 0x00, 0x08, 0x54, 0x00, 0x07, 0xff, 0x41, 0x82, 0x00, 0x14, 
+	0x80, 0x19, 0x00, 0x28, 0x90, 0x04, 0x00, 0x08, 0x88, 0x19, 0x00, 0x2c, 0x98, 0x04, 0x00, 0x0c, 
+	0x38, 0x00, 0x00, 0x06, 0x3c, 0x80, 0x00, 0x01, 0x90, 0x03, 0x00, 0x40, 0x38, 0x1e, 0x00, 0x52, 
+	0x38, 0xe0, 0xff, 0xff, 0x38, 0xc4, 0xff, 0xff, 0x38, 0x9b, 0x00, 0x00, 0x90, 0x03, 0x00, 0x44, 
+	0x80, 0xbc, 0x00, 0x0c, 0x80, 0x03, 0x00, 0x44, 0x7c, 0xe5, 0x01, 0x2e, 0x80, 0x63, 0x00, 0x44, 
+	0x80, 0xbc, 0x00, 0x0c, 0x38, 0x03, 0x00, 0x04, 0x7c, 0xc5, 0x03, 0x2e, 0x80, 0x1c, 0x00, 0x10, 
+	0x7c, 0x7e, 0x02, 0x14, 0x38, 0x03, 0x00, 0x58, 0x90, 0x1c, 0x00, 0x10, 0x80, 0x62, 0x00, 0xf4, 
+	0x48, 0x00, 0x0c, 0x9d, 0x80, 0x62, 0x00, 0xd4, 0x38, 0x9a, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 
+	0x48, 0x00, 0x0c, 0xc9, 0x80, 0x01, 0x00, 0x68, 0x38, 0x21, 0x00, 0x60, 0xbb, 0x21, 0xff, 0xe4, 
+	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0xbf, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x02, 0xa6, 
+	0x3b, 0x43, 0x00, 0x00, 0x3b, 0xa4, 0x00, 0x00, 0x3b, 0x82, 0x02, 0x5c, 0x3b, 0xc5, 0x00, 0x00, 
+	0x38, 0x60, 0x00, 0x12, 0x38, 0x80, 0x00, 0x03, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 
+	0x83, 0x65, 0x00, 0x0c, 0x4b, 0xff, 0xe9, 0x6d, 0x7c, 0x7f, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x24, 
+	0x38, 0x7a, 0x00, 0x00, 0x38, 0x9d, 0x00, 0x00, 0x38, 0xbe, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x31, 
+	0x38, 0xe0, 0x00, 0x04, 0x39, 0x00, 0x00, 0x0c, 0x4b, 0xff, 0xfc, 0x41, 0x48, 0x00, 0x00, 0xb0, 
+	0x80, 0xbf, 0x00, 0x14, 0x38, 0xc0, 0x00, 0x83, 0x38, 0x80, 0x00, 0x32, 0x38, 0x60, 0x00, 0x06, 
+	0x38, 0x00, 0x00, 0x0c, 0x98, 0xc5, 0x00, 0x0d, 0x80, 0xbf, 0x00, 0x10, 0x90, 0x85, 0x00, 0x00, 
+	0x90, 0x65, 0x00, 0x04, 0x90, 0x05, 0x00, 0x08, 0x80, 0x7f, 0x00, 0x10, 0x38, 0x03, 0x00, 0x12, 
+	0x90, 0x1f, 0x00, 0x10, 0x80, 0x1b, 0x00, 0x04, 0x28, 0x00, 0x00, 0x02, 0x41, 0x82, 0x00, 0x0c, 
+	0x28, 0x00, 0x00, 0x01, 0x40, 0x82, 0x00, 0x2c, 0x80, 0x9c, 0x00, 0x00, 0x80, 0x7f, 0x00, 0x0c, 
+	0x80, 0x05, 0x00, 0x08, 0x7c, 0x83, 0x01, 0x2e, 0x80, 0x65, 0x00, 0x08, 0xa0, 0xbc, 0x00, 0x04, 
+	0x80, 0x9f, 0x00, 0x0c, 0x38, 0x03, 0x00, 0x04, 0x7c, 0xa4, 0x03, 0x2e, 0x48, 0x00, 0x00, 0x24, 
+	0x38, 0x7a, 0x00, 0x00, 0x38, 0x9d, 0x00, 0x00, 0x38, 0xbe, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x31, 
+	0x38, 0xe0, 0x00, 0x09, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xfb, 0xb1, 0x48, 0x00, 0x00, 0x20, 
+	0x80, 0x62, 0x00, 0xf4, 0x7f, 0xc4, 0xf3, 0x78, 0x48, 0x00, 0x0b, 0x85, 0x80, 0x62, 0x00, 0xd4, 
+	0x38, 0x9d, 0x00, 0x00, 0x38, 0xbf, 0x00, 0x00, 0x48, 0x00, 0x0b, 0xb1, 0x80, 0x01, 0x00, 0x58, 
+	0x38, 0x21, 0x00, 0x50, 0xbb, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
+	0xbf, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0x43, 0x00, 0x00, 0x3b, 0x85, 0x00, 0x00, 
 	0x3b, 0xe2, 0x02, 0x5c, 0x7c, 0x9b, 0x23, 0x78, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 
-	0x80, 0x03, 0x00, 0x04, 0x80, 0xc5, 0x00, 0x0c, 0x28, 0x00, 0x00, 0x00, 0x83, 0xc6, 0x00, 0x04, 
-	0x41, 0x82, 0x00, 0x18, 0x38, 0xc0, 0x00, 0x01, 0x38, 0xe0, 0x00, 0x03, 0x39, 0x00, 0x00, 0x00, 
-	0x4b, 0xff, 0xfb, 0x21, 0x48, 0x00, 0x01, 0x8c, 0xa0, 0x06, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0x02, 
-	0x40, 0x82, 0x00, 0x10, 0x80, 0x06, 0x00, 0x08, 0x28, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x24, 
-	0x7f, 0x43, 0xd3, 0x78, 0x7f, 0x64, 0xdb, 0x78, 0x7f, 0x85, 0xe3, 0x78, 0x38, 0xc0, 0x00, 0x01, 
-	0x38, 0xe0, 0x00, 0x07, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xfa, 0xe9, 0x48, 0x00, 0x01, 0x54, 
-	0x28, 0x1e, 0x00, 0xfe, 0x41, 0x81, 0x00, 0x20, 0x57, 0xc0, 0x07, 0xff, 0x41, 0x82, 0x00, 0x18, 
-	0x38, 0xc0, 0x00, 0x01, 0x38, 0xe0, 0x00, 0x01, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xfa, 0xc5, 
-	0x48, 0x00, 0x01, 0x30, 0x57, 0xc3, 0x04, 0x3e, 0x7c, 0x64, 0x1b, 0x78, 0x4b, 0xff, 0xf1, 0xa5, 
-	0x54, 0x60, 0x04, 0x3e, 0x2c, 0x00, 0x00, 0x05, 0x40, 0x82, 0x00, 0x24, 0x7f, 0x43, 0xd3, 0x78, 
-	0x7f, 0x64, 0xdb, 0x78, 0x7f, 0x85, 0xe3, 0x78, 0x38, 0xc0, 0x00, 0x01, 0x38, 0xe0, 0x00, 0x01, 
-	0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xfa, 0x8d, 0x48, 0x00, 0x00, 0xf8, 0x38, 0x60, 0x00, 0x20, 
-	0x38, 0x80, 0x00, 0x03, 0x4b, 0xff, 0xe7, 0x0d, 0x7c, 0x7d, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x24, 
-	0x7f, 0x43, 0xd3, 0x78, 0x7f, 0x64, 0xdb, 0x78, 0x7f, 0x85, 0xe3, 0x78, 0x38, 0xc0, 0x00, 0x01, 
-	0x38, 0xe0, 0x00, 0x04, 0x39, 0x00, 0x00, 0x0c, 0x4b, 0xff, 0xfa, 0x59, 0x48, 0x00, 0x00, 0xc4, 
-	0x80, 0x7d, 0x00, 0x14, 0x38, 0x80, 0x00, 0x83, 0x38, 0x00, 0x00, 0x04, 0x38, 0xe0, 0x00, 0x04, 
-	0x38, 0xc0, 0x00, 0x08, 0x7c, 0x09, 0x03, 0xa6, 0x98, 0x83, 0x00, 0x0d, 0x38, 0xa0, 0x00, 0x00, 
-	0x38, 0x80, 0x00, 0x18, 0x7c, 0xa3, 0x2b, 0x78, 0x81, 0x1d, 0x00, 0x0c, 0x90, 0xe8, 0x00, 0x00, 
-	0x93, 0xc8, 0x00, 0x04, 0x90, 0xc8, 0x00, 0x08, 0x90, 0x88, 0x00, 0x0c, 0x90, 0xa8, 0x00, 0x10, 
-	0x90, 0xa8, 0x00, 0x14, 0x80, 0x9d, 0x00, 0x0c, 0x80, 0x1f, 0x00, 0x00, 0x90, 0x04, 0x00, 0x18, 
-	0xa0, 0x1f, 0x00, 0x04, 0xb0, 0x04, 0x00, 0x1c, 0xb3, 0xc4, 0x00, 0x1e, 0x80, 0x9d, 0x00, 0x0c, 
-	0x38, 0x04, 0x00, 0x20, 0x90, 0x1d, 0x00, 0x10, 0x38, 0x03, 0x00, 0x1c, 0x38, 0x63, 0x00, 0x04, 
-	0x7c, 0xba, 0x01, 0x2e, 0x42, 0x00, 0xff, 0xf4, 0x28, 0x1e, 0x00, 0xfe, 0x41, 0x81, 0x00, 0x10, 
-	0x80, 0x1a, 0x00, 0x28, 0x64, 0x00, 0x80, 0x00, 0x90, 0x1a, 0x00, 0x28, 0x38, 0x00, 0x00, 0x03, 
-	0x7f, 0x84, 0xe3, 0x78, 0x90, 0x1a, 0x00, 0x04, 0xb3, 0xda, 0x00, 0x0c, 0x80, 0x1a, 0x00, 0x08, 
-	0x54, 0x00, 0x00, 0x3c, 0x90, 0x1a, 0x00, 0x08, 0x80, 0x62, 0x00, 0xf4, 0x48, 0x00, 0x09, 0xd5, 
-	0x80, 0x62, 0x00, 0xd4, 0x7f, 0x64, 0xdb, 0x78, 0x7f, 0xa5, 0xeb, 0x78, 0x48, 0x00, 0x0a, 0x15, 
+	0x80, 0x03, 0x00, 0x04, 0x80, 0x65, 0x00, 0x0c, 0x28, 0x00, 0x00, 0x00, 0x83, 0xc3, 0x00, 0x04, 
+	0x41, 0x82, 0x00, 0x24, 0x38, 0x7a, 0x00, 0x00, 0x38, 0x9b, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 
+	0x38, 0xc0, 0x00, 0x01, 0x38, 0xe0, 0x00, 0x03, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xfb, 0x2d, 
+	0x48, 0x00, 0x01, 0x90, 0xa0, 0x03, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0x02, 0x40, 0x82, 0x00, 0x10, 
+	0x80, 0x03, 0x00, 0x08, 0x28, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x24, 0x38, 0x7a, 0x00, 0x00, 
+	0x38, 0x9b, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x01, 0x38, 0xe0, 0x00, 0x07, 
+	0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xfa, 0xf5, 0x48, 0x00, 0x01, 0x58, 0x28, 0x1e, 0x00, 0xfe, 
+	0x41, 0x81, 0x00, 0x2c, 0x57, 0xc0, 0x07, 0xff, 0x41, 0x82, 0x00, 0x24, 0x38, 0x7a, 0x00, 0x00, 
+	0x38, 0x9b, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x01, 0x38, 0xe0, 0x00, 0x01, 
+	0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xfa, 0xc5, 0x48, 0x00, 0x01, 0x28, 0x57, 0xc3, 0x04, 0x3e, 
+	0x38, 0x83, 0x00, 0x00, 0x4b, 0xff, 0xf1, 0xf5, 0x54, 0x60, 0x04, 0x3e, 0x2c, 0x00, 0x00, 0x05, 
+	0x40, 0x82, 0x00, 0x24, 0x38, 0x7a, 0x00, 0x00, 0x38, 0x9b, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 
+	0x38, 0xc0, 0x00, 0x01, 0x38, 0xe0, 0x00, 0x01, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xfa, 0x8d, 
+	0x48, 0x00, 0x00, 0xf0, 0x38, 0x60, 0x00, 0x20, 0x38, 0x80, 0x00, 0x03, 0x4b, 0xff, 0xe7, 0x85, 
+	0x7c, 0x7d, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x24, 0x38, 0x7a, 0x00, 0x00, 0x38, 0x9b, 0x00, 0x00, 
+	0x38, 0xbc, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x01, 0x38, 0xe0, 0x00, 0x04, 0x39, 0x00, 0x00, 0x0c, 
+	0x4b, 0xff, 0xfa, 0x59, 0x48, 0x00, 0x00, 0xbc, 0x80, 0x9d, 0x00, 0x14, 0x38, 0xc0, 0x00, 0x83, 
+	0x38, 0xa0, 0x00, 0x04, 0x38, 0x60, 0x00, 0x08, 0x38, 0x00, 0x00, 0x18, 0x7c, 0xa9, 0x03, 0xa6, 
+	0x98, 0xc4, 0x00, 0x0d, 0x38, 0x80, 0x00, 0x00, 0x38, 0xda, 0x00, 0x00, 0x80, 0xfd, 0x00, 0x0c, 
+	0x90, 0xa7, 0x00, 0x00, 0x93, 0xc7, 0x00, 0x04, 0x90, 0x67, 0x00, 0x08, 0x90, 0x07, 0x00, 0x0c, 
+	0x90, 0x87, 0x00, 0x10, 0x90, 0x87, 0x00, 0x14, 0x80, 0x7d, 0x00, 0x0c, 0x80, 0x1f, 0x00, 0x00, 
+	0x90, 0x03, 0x00, 0x18, 0xa0, 0x1f, 0x00, 0x04, 0xb0, 0x03, 0x00, 0x1c, 0xb3, 0xc3, 0x00, 0x1e, 
+	0x80, 0x7d, 0x00, 0x0c, 0x38, 0x03, 0x00, 0x20, 0x90, 0x1d, 0x00, 0x10, 0x90, 0x86, 0x00, 0x18, 
+	0x38, 0xc6, 0x00, 0x04, 0x42, 0x00, 0xff, 0xf8, 0x28, 0x1e, 0x00, 0xfe, 0x41, 0x81, 0x00, 0x10, 
+	0x80, 0x1a, 0x00, 0x24, 0x64, 0x00, 0x80, 0x00, 0x90, 0x1a, 0x00, 0x24, 0x38, 0x00, 0x00, 0x03, 
+	0x38, 0x9c, 0x00, 0x00, 0x90, 0x1a, 0x00, 0x04, 0xb3, 0xda, 0x00, 0x0c, 0x80, 0x1a, 0x00, 0x08, 
+	0x54, 0x00, 0x00, 0x3c, 0x90, 0x1a, 0x00, 0x08, 0x80, 0x62, 0x00, 0xf4, 0x48, 0x00, 0x09, 0x91, 
+	0x80, 0x62, 0x00, 0xd4, 0x38, 0x9b, 0x00, 0x00, 0x38, 0xbd, 0x00, 0x00, 0x48, 0x00, 0x09, 0xbd, 
 	0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7c, 0x1b, 0x78, 0x7c, 0x9d, 0x23, 0x78, 
-	0x7c, 0xbe, 0x2b, 0x78, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0x03, 0x00, 0x04, 
-	0x28, 0x00, 0x00, 0x03, 0x41, 0x82, 0x00, 0x18, 0x38, 0xc0, 0x00, 0x02, 0x38, 0xe0, 0x00, 0x03, 
-	0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf9, 0x3d, 0x48, 0x00, 0x00, 0x58, 0x38, 0x00, 0x00, 0x00, 
-	0x38, 0xa0, 0x00, 0x00, 0x90, 0x1c, 0x00, 0x04, 0xb0, 0x1c, 0x00, 0x0c, 0x80, 0x62, 0x00, 0xd0, 
-	0x48, 0x00, 0x09, 0xa1, 0x3b, 0xfd, 0xff, 0xc0, 0x80, 0x62, 0x00, 0xd0, 0x38, 0xa0, 0x00, 0x00, 
-	0x7f, 0xe4, 0xfb, 0x78, 0x48, 0x00, 0x09, 0x8d, 0x80, 0x62, 0x00, 0xdc, 0x7f, 0xe4, 0xfb, 0x78, 
-	0x38, 0xa0, 0x00, 0x86, 0x38, 0xc0, 0x00, 0x03, 0x48, 0x00, 0x09, 0xc9, 0x7f, 0x83, 0xe3, 0x78, 
-	0x7f, 0xa4, 0xeb, 0x78, 0x7f, 0xc5, 0xf3, 0x78, 0x38, 0xc0, 0x00, 0x02, 0x4b, 0xff, 0xf9, 0x95, 
-	0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x21, 0xff, 0xe4, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0xbd, 0x2b, 0x78, 0x7c, 0x7b, 0x1b, 0x78, 
-	0x7c, 0x9c, 0x23, 0x78, 0x38, 0xe0, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xa0, 
-	0x81, 0x05, 0x00, 0x0c, 0x80, 0x03, 0x00, 0x04, 0x80, 0xc8, 0x00, 0x04, 0x28, 0x00, 0x00, 0x03, 
-	0x83, 0xc8, 0x00, 0x08, 0x7f, 0xe8, 0x32, 0x14, 0xa0, 0xdf, 0x00, 0x00, 0x41, 0x82, 0x00, 0x18, 
-	0x38, 0xc0, 0x00, 0x1b, 0x38, 0xe0, 0x00, 0x03, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf8, 0x75, 
-	0x48, 0x00, 0x01, 0xbc, 0x80, 0x08, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0x02, 0x41, 0x82, 0x00, 0x7c, 
-	0x40, 0x80, 0x00, 0xc0, 0x2c, 0x00, 0x00, 0x01, 0x40, 0x80, 0x00, 0x08, 0x48, 0x00, 0x00, 0xb4, 
-	0xa0, 0x1b, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0xfe, 0x41, 0x81, 0x00, 0x58, 0x54, 0xc0, 0x07, 0xff, 
-	0x41, 0x82, 0x00, 0x30, 0x28, 0x1e, 0x00, 0x02, 0x40, 0x82, 0x00, 0x28, 0x54, 0xc4, 0xe7, 0x3a, 
-	0x38, 0x60, 0x00, 0x01, 0x7c, 0xbb, 0x22, 0x14, 0x54, 0xc0, 0xfe, 0xfe, 0x80, 0x85, 0x00, 0x1c, 
-	0x7c, 0x60, 0x00, 0x30, 0x7c, 0x80, 0x03, 0x78, 0x90, 0x05, 0x00, 0x1c, 0x48, 0x00, 0x00, 0x78, 
-	0x54, 0xc0, 0x04, 0x3f, 0x40, 0x82, 0x00, 0x14, 0x80, 0x1b, 0x00, 0x08, 0x60, 0x00, 0x00, 0x04, 
-	0x90, 0x1b, 0x00, 0x08, 0x48, 0x00, 0x00, 0x60, 0x38, 0xe0, 0x00, 0x01, 0x48, 0x00, 0x00, 0x58, 
-	0x38, 0xe0, 0x00, 0x07, 0x48, 0x00, 0x00, 0x50, 0xa0, 0x1b, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0xaa, 
-	0x40, 0x82, 0x00, 0x38, 0x80, 0x1b, 0x00, 0x08, 0x54, 0x00, 0x07, 0xff, 0x41, 0x82, 0x00, 0x0c, 
-	0x38, 0xe0, 0x00, 0x13, 0x48, 0x00, 0x00, 0x30, 0x80, 0x1f, 0x00, 0x00, 0x90, 0x1b, 0x00, 0x2c, 
-	0x88, 0x1f, 0x00, 0x04, 0x98, 0x1b, 0x00, 0x30, 0x80, 0x1b, 0x00, 0x08, 0x60, 0x00, 0x00, 0x01, 
-	0x90, 0x1b, 0x00, 0x08, 0x48, 0x00, 0x00, 0x10, 0x38, 0xe0, 0x00, 0x01, 0x48, 0x00, 0x00, 0x08, 
-	0x38, 0xe0, 0x00, 0x07, 0x2c, 0x07, 0x00, 0x00, 0x41, 0x82, 0x00, 0x20, 0x7f, 0x63, 0xdb, 0x78, 
-	0x7f, 0x84, 0xe3, 0x78, 0x7f, 0xa5, 0xeb, 0x78, 0x38, 0xc0, 0x00, 0x1b, 0x39, 0x00, 0x00, 0x00, 
-	0x4b, 0xff, 0xf7, 0x81, 0x48, 0x00, 0x00, 0xc8, 0x3b, 0x5e, 0x00, 0x0c, 0x38, 0x80, 0x00, 0x03, 
-	0x7f, 0x43, 0xd3, 0x78, 0x4b, 0xff, 0xe3, 0xfd, 0x7c, 0x79, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x24, 
-	0x7f, 0x63, 0xdb, 0x78, 0x7f, 0x84, 0xe3, 0x78, 0x7f, 0xa5, 0xeb, 0x78, 0x38, 0xc0, 0x00, 0x1b, 
-	0x38, 0xe0, 0x00, 0x04, 0x39, 0x00, 0x00, 0x0c, 0x4b, 0xff, 0xf7, 0x49, 0x48, 0x00, 0x00, 0x90, 
-	0x80, 0x79, 0x00, 0x14, 0x38, 0x00, 0x00, 0x83, 0x7f, 0x45, 0xd3, 0x78, 0x38, 0x80, 0x00, 0x00, 
-	0x98, 0x03, 0x00, 0x0d, 0x83, 0x59, 0x00, 0x10, 0x7f, 0x43, 0xd3, 0x78, 0x48, 0x00, 0x08, 0xe5, 
-	0x38, 0x60, 0x00, 0x1c, 0x20, 0x1e, 0x00, 0x00, 0x90, 0x7a, 0x00, 0x00, 0x7c, 0x60, 0x01, 0x10, 
-	0x38, 0x00, 0x00, 0x0c, 0x7c, 0x00, 0x18, 0x38, 0x2c, 0x1e, 0x00, 0x00, 0x93, 0xda, 0x00, 0x08, 
-	0x90, 0x1a, 0x00, 0x04, 0x80, 0x79, 0x00, 0x10, 0x38, 0x03, 0x00, 0x0c, 0x90, 0x19, 0x00, 0x10, 
-	0x41, 0x82, 0x00, 0x14, 0x80, 0x79, 0x00, 0x10, 0x7f, 0xe4, 0xfb, 0x78, 0x7f, 0xc5, 0xf3, 0x78, 
-	0x48, 0x00, 0x08, 0x61, 0x80, 0x19, 0x00, 0x10, 0x7f, 0xa4, 0xeb, 0x78, 0x7c, 0x00, 0xf2, 0x14, 
-	0x90, 0x19, 0x00, 0x10, 0x80, 0x62, 0x00, 0xf4, 0x48, 0x00, 0x06, 0xf9, 0x80, 0x62, 0x00, 0xd4, 
-	0x7f, 0x84, 0xe3, 0x78, 0x7f, 0x25, 0xcb, 0x78, 0x48, 0x00, 0x07, 0x39, 0x80, 0x01, 0x00, 0x68, 
+	0x4e, 0x80, 0x00, 0x20, 0xbf, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xa3, 0x00, 0x00, 
+	0x3b, 0xc4, 0x00, 0x00, 0x3b, 0xe5, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 
+	0x80, 0x03, 0x00, 0x04, 0x28, 0x00, 0x00, 0x03, 0x41, 0x82, 0x00, 0x24, 0x38, 0x7d, 0x00, 0x00, 
+	0x38, 0x9e, 0x00, 0x00, 0x38, 0xbf, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x02, 0x38, 0xe0, 0x00, 0x03, 
+	0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf9, 0x45, 0x48, 0x00, 0x00, 0x58, 0x38, 0x00, 0x00, 0x00, 
+	0x38, 0x9e, 0x00, 0x00, 0x90, 0x1d, 0x00, 0x04, 0x38, 0xa0, 0x00, 0x00, 0xb0, 0x1d, 0x00, 0x0c, 
+	0x80, 0x62, 0x00, 0xd0, 0x48, 0x00, 0x09, 0x45, 0x80, 0x62, 0x00, 0xd0, 0x38, 0x9e, 0xff, 0xc0, 
+	0x38, 0xa0, 0x00, 0x00, 0x48, 0x00, 0x09, 0x35, 0x80, 0x62, 0x00, 0xdc, 0x38, 0x9e, 0xff, 0xc0, 
+	0x38, 0xa0, 0x00, 0x86, 0x38, 0xc0, 0x00, 0x03, 0x48, 0x00, 0x09, 0x61, 0x38, 0x7d, 0x00, 0x00, 
+	0x38, 0x9e, 0x00, 0x00, 0x38, 0xbf, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x02, 0x4b, 0xff, 0xf9, 0x95, 
+	0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0xa1, 0xff, 0xf4, 0x7c, 0x08, 0x03, 0xa6, 
+	0x4e, 0x80, 0x00, 0x20, 0xbf, 0x21, 0xff, 0xe4, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xa5, 0x00, 0x00, 
+	0x3b, 0x63, 0x00, 0x00, 0x3b, 0x84, 0x00, 0x00, 0x38, 0xe0, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 
+	0x94, 0x21, 0xff, 0xa0, 0x80, 0xa5, 0x00, 0x0c, 0x80, 0x03, 0x00, 0x04, 0x80, 0x65, 0x00, 0x04, 
+	0x28, 0x00, 0x00, 0x03, 0x83, 0xc5, 0x00, 0x08, 0x7c, 0x65, 0x1a, 0x14, 0xa0, 0x83, 0x00, 0x00, 
+	0x7c, 0x7f, 0x1b, 0x78, 0x41, 0x82, 0x00, 0x24, 0x38, 0x7b, 0x00, 0x00, 0x38, 0x9c, 0x00, 0x00, 
+	0x38, 0xbd, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x1b, 0x38, 0xe0, 0x00, 0x03, 0x39, 0x00, 0x00, 0x00, 
+	0x4b, 0xff, 0xf8, 0x79, 0x48, 0x00, 0x01, 0xc8, 0x80, 0x05, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0x02, 
+	0x41, 0x82, 0x00, 0x84, 0x40, 0x80, 0x00, 0xc8, 0x2c, 0x00, 0x00, 0x01, 0x40, 0x80, 0x00, 0x08, 
+	0x48, 0x00, 0x00, 0xbc, 0xa0, 0x1b, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0xfe, 0x41, 0x81, 0x00, 0x60, 
+	0x54, 0x80, 0x07, 0xff, 0x41, 0x82, 0x00, 0x38, 0x28, 0x1e, 0x00, 0x02, 0x40, 0x82, 0x00, 0x30, 
+	0x54, 0x83, 0x06, 0x3e, 0x54, 0x80, 0xfe, 0xfe, 0x7c, 0x64, 0x36, 0x70, 0x38, 0x60, 0x00, 0x01, 
+	0x54, 0x84, 0x10, 0x3a, 0x7c, 0x60, 0x00, 0x30, 0x7c, 0x9b, 0x22, 0x14, 0x80, 0x64, 0x00, 0x18, 
+	0x7c, 0x60, 0x03, 0x78, 0x90, 0x04, 0x00, 0x18, 0x48, 0x00, 0x00, 0x78, 0x28, 0x04, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x14, 0x80, 0x1b, 0x00, 0x08, 0x60, 0x00, 0x00, 0x04, 0x90, 0x1b, 0x00, 0x08, 
+	0x48, 0x00, 0x00, 0x60, 0x38, 0xe0, 0x00, 0x01, 0x48, 0x00, 0x00, 0x58, 0x38, 0xe0, 0x00, 0x07, 
+	0x48, 0x00, 0x00, 0x50, 0xa0, 0x1b, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0xaa, 0x40, 0x82, 0x00, 0x38, 
+	0x80, 0x1b, 0x00, 0x08, 0x54, 0x00, 0x07, 0xff, 0x41, 0x82, 0x00, 0x0c, 0x38, 0xe0, 0x00, 0x13, 
+	0x48, 0x00, 0x00, 0x30, 0x80, 0x1f, 0x00, 0x00, 0x90, 0x1b, 0x00, 0x28, 0x88, 0x1f, 0x00, 0x04, 
+	0x98, 0x1b, 0x00, 0x2c, 0x80, 0x1b, 0x00, 0x08, 0x60, 0x00, 0x00, 0x01, 0x90, 0x1b, 0x00, 0x08, 
+	0x48, 0x00, 0x00, 0x10, 0x38, 0xe0, 0x00, 0x01, 0x48, 0x00, 0x00, 0x08, 0x38, 0xe0, 0x00, 0x07, 
+	0x2c, 0x07, 0x00, 0x00, 0x41, 0x82, 0x00, 0x20, 0x38, 0x7b, 0x00, 0x00, 0x38, 0x9c, 0x00, 0x00, 
+	0x38, 0xbd, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x1b, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf7, 0x7d, 
+	0x48, 0x00, 0x00, 0xcc, 0x3b, 0x5e, 0x00, 0x0c, 0x38, 0x80, 0x00, 0x03, 0x38, 0x7a, 0x00, 0x00, 
+	0x4b, 0xff, 0xe4, 0x71, 0x7c, 0x79, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x24, 0x38, 0x7b, 0x00, 0x00, 
+	0x38, 0x9c, 0x00, 0x00, 0x38, 0xbd, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x1b, 0x38, 0xe0, 0x00, 0x04, 
+	0x39, 0x00, 0x00, 0x0c, 0x4b, 0xff, 0xf7, 0x45, 0x48, 0x00, 0x00, 0x94, 0x80, 0x79, 0x00, 0x14, 
+	0x38, 0x00, 0x00, 0x83, 0x38, 0xba, 0x00, 0x00, 0x38, 0x80, 0x00, 0x00, 0x98, 0x03, 0x00, 0x0d, 
+	0x83, 0x59, 0x00, 0x10, 0x7f, 0x43, 0xd3, 0x78, 0x48, 0x00, 0x08, 0x55, 0x38, 0x00, 0x00, 0x1c, 
+	0x2c, 0x1e, 0x00, 0x00, 0x90, 0x1a, 0x00, 0x00, 0x93, 0xda, 0x00, 0x08, 0x41, 0x82, 0x00, 0x0c, 
+	0x38, 0x00, 0x00, 0x0c, 0x48, 0x00, 0x00, 0x08, 0x38, 0x00, 0x00, 0x00, 0x90, 0x1a, 0x00, 0x04, 
+	0x2c, 0x1e, 0x00, 0x00, 0x80, 0x79, 0x00, 0x10, 0x38, 0x03, 0x00, 0x0c, 0x90, 0x19, 0x00, 0x10, 
+	0x41, 0x82, 0x00, 0x14, 0x80, 0x79, 0x00, 0x10, 0x38, 0x9f, 0x00, 0x00, 0x38, 0xbe, 0x00, 0x00, 
+	0x48, 0x00, 0x07, 0xd1, 0x80, 0x19, 0x00, 0x10, 0x38, 0x9d, 0x00, 0x00, 0x7c, 0x00, 0xf2, 0x14, 
+	0x90, 0x19, 0x00, 0x10, 0x80, 0x62, 0x00, 0xf4, 0x48, 0x00, 0x06, 0xa5, 0x80, 0x62, 0x00, 0xd4, 
+	0x38, 0x9c, 0x00, 0x00, 0x38, 0xb9, 0x00, 0x00, 0x48, 0x00, 0x06, 0xd1, 0x80, 0x01, 0x00, 0x68, 
 	0x38, 0x21, 0x00, 0x60, 0xbb, 0x21, 0xff, 0xe4, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
-	0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7c, 0x1b, 0x78, 0x7c, 0xbe, 0x2b, 0x78, 
-	0x7c, 0x9d, 0x23, 0x78, 0x3b, 0xe0, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 
-	0x80, 0xe5, 0x00, 0x0c, 0x80, 0x03, 0x00, 0x04, 0x80, 0xc7, 0x00, 0x04, 0x28, 0x00, 0x00, 0x03, 
-	0x81, 0x07, 0x00, 0x08, 0x7c, 0xc7, 0x32, 0x14, 0x41, 0x82, 0x00, 0x18, 0x38, 0xc0, 0x00, 0x15, 
-	0x38, 0xe0, 0x00, 0x03, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf6, 0x59, 0x48, 0x00, 0x00, 0xf4, 
-	0x2c, 0x08, 0x00, 0x01, 0x40, 0x82, 0x00, 0x58, 0x88, 0x86, 0x00, 0x00, 0x54, 0x80, 0x07, 0xff, 
-	0x41, 0x82, 0x00, 0x44, 0x28, 0x04, 0x00, 0xff, 0x41, 0x82, 0x00, 0x3c, 0xa0, 0x1c, 0x00, 0x0c, 
-	0x2c, 0x00, 0x00, 0xfe, 0x41, 0x81, 0x00, 0x28, 0x54, 0x83, 0xe7, 0x3a, 0x54, 0x80, 0xfe, 0xfe, 
-	0x7c, 0x9c, 0x1a, 0x14, 0x38, 0x60, 0x00, 0x01, 0x7c, 0x60, 0x00, 0x30, 0x80, 0x64, 0x00, 0x1c, 
-	0x7c, 0x60, 0x00, 0x78, 0x90, 0x04, 0x00, 0x1c, 0x48, 0x00, 0x00, 0x60, 0x3b, 0xe0, 0x00, 0x07, 
-	0x48, 0x00, 0x00, 0x58, 0x3b, 0xe0, 0x00, 0x01, 0x48, 0x00, 0x00, 0x50, 0x2c, 0x08, 0x00, 0x05, 
-	0x40, 0x82, 0x00, 0x48, 0xa0, 0x1c, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0xaa, 0x40, 0x82, 0x00, 0x38, 
-	0x80, 0x1c, 0x00, 0x08, 0x54, 0x00, 0x07, 0xff, 0x41, 0x82, 0x00, 0x24, 0x7c, 0xc4, 0x33, 0x78, 
-	0x7d, 0x05, 0x43, 0x78, 0x38, 0x7c, 0x00, 0x2c, 0x48, 0x00, 0x07, 0xf9, 0x2c, 0x03, 0x00, 0x00, 
-	0x41, 0x82, 0x00, 0x18, 0x3b, 0xe0, 0x00, 0x01, 0x48, 0x00, 0x00, 0x10, 0x3b, 0xe0, 0x00, 0x01, 
-	0x48, 0x00, 0x00, 0x08, 0x3b, 0xe0, 0x00, 0x07, 0x2c, 0x1f, 0x00, 0x00, 0x41, 0x82, 0x00, 0x24, 
-	0x7f, 0x83, 0xe3, 0x78, 0x7f, 0xa4, 0xeb, 0x78, 0x7f, 0xc5, 0xf3, 0x78, 0x7f, 0xe7, 0xfb, 0x78, 
-	0x38, 0xc0, 0x00, 0x15, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf5, 0x89, 0x48, 0x00, 0x00, 0x24, 
-	0x80, 0x1c, 0x00, 0x08, 0x7f, 0x83, 0xe3, 0x78, 0x7f, 0xa4, 0xeb, 0x78, 0x7f, 0xc5, 0xf3, 0x78, 
-	0x38, 0xc0, 0x00, 0x15, 0x54, 0x00, 0x00, 0x3c, 0x90, 0x1c, 0x00, 0x08, 0x4b, 0xff, 0xf6, 0x15, 
-	0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7a, 0x1b, 0x78, 0x7c, 0xbc, 0x2b, 0x78, 
-	0x7c, 0x9b, 0x23, 0x78, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0x65, 0x00, 0x0c, 
-	0x80, 0x03, 0x00, 0x08, 0x7f, 0xa3, 0x02, 0x14, 0x7f, 0xa3, 0xeb, 0x78, 0x4b, 0xff, 0xec, 0x65, 
-	0x2c, 0x03, 0x00, 0x01, 0x41, 0x82, 0x00, 0x24, 0x7f, 0x43, 0xd3, 0x78, 0x7f, 0x64, 0xdb, 0x78, 
-	0x7f, 0x85, 0xe3, 0x78, 0x38, 0xc0, 0x00, 0x1d, 0x38, 0xe0, 0x00, 0x01, 0x39, 0x00, 0x00, 0x00, 
-	0x4b, 0xff, 0xf4, 0xf1, 0x48, 0x00, 0x00, 0xd4, 0x83, 0xfa, 0x00, 0x34, 0x48, 0x00, 0x00, 0x2c, 
-	0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x9f, 0x00, 0x04, 0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x07, 0x05, 
-	0x2c, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x10, 0x38, 0x1f, 0x00, 0x04, 0x48, 0x00, 0x00, 0x18, 
-	0x60, 0x00, 0x00, 0x00, 0x83, 0xff, 0x00, 0x00, 0x28, 0x1f, 0x00, 0x00, 0x40, 0x82, 0xff, 0xd4, 
-	0x38, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x24, 0x7f, 0x43, 0xd3, 0x78, 
-	0x7f, 0x64, 0xdb, 0x78, 0x7f, 0x85, 0xe3, 0x78, 0x38, 0xc0, 0x00, 0x1d, 0x38, 0xe0, 0x00, 0x01, 
-	0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf4, 0x8d, 0x48, 0x00, 0x00, 0x70, 0x7f, 0xa3, 0xeb, 0x78, 
-	0x4b, 0xff, 0xe0, 0x21, 0x38, 0x60, 0x00, 0x06, 0x48, 0x00, 0x04, 0x49, 0x80, 0x1d, 0x00, 0x00, 
-	0x7c, 0x7e, 0x1b, 0x78, 0x38, 0x60, 0x00, 0x0c, 0x90, 0x1e, 0x00, 0x00, 0xa0, 0x1d, 0x00, 0x04, 
-	0xb0, 0x1e, 0x00, 0x04, 0x48, 0x00, 0x04, 0x2d, 0x7c, 0x7f, 0x1b, 0x78, 0x7f, 0xc4, 0xf3, 0x78, 
-	0x38, 0x7f, 0x00, 0x04, 0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x05, 0xc9, 0x80, 0x1a, 0x00, 0x34, 
-	0x7f, 0x43, 0xd3, 0x78, 0x7f, 0x64, 0xdb, 0x78, 0x7f, 0x85, 0xe3, 0x78, 0x38, 0xc0, 0x00, 0x1d, 
-	0x90, 0x1f, 0x00, 0x00, 0x93, 0xfa, 0x00, 0x34, 0x80, 0x1a, 0x00, 0x08, 0x60, 0x00, 0x00, 0x02, 
-	0x90, 0x1a, 0x00, 0x08, 0x4b, 0xff, 0xf4, 0xcd, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 
-	0xbb, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x7a, 0x1b, 0x78, 0x7c, 0xbc, 0x2b, 0x78, 
-	0x7c, 0x9b, 0x23, 0x78, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0x65, 0x00, 0x0c, 
-	0x80, 0x03, 0x00, 0x08, 0x7f, 0xa3, 0x02, 0x14, 0x7f, 0xa3, 0xeb, 0x78, 0x4b, 0xff, 0xeb, 0x25, 
-	0x2c, 0x03, 0x00, 0x01, 0x41, 0x82, 0x00, 0x24, 0x7f, 0x43, 0xd3, 0x78, 0x7f, 0x64, 0xdb, 0x78, 
-	0x7f, 0x85, 0xe3, 0x78, 0x38, 0xc0, 0x00, 0x1e, 0x38, 0xe0, 0x00, 0x01, 0x39, 0x00, 0x00, 0x00, 
-	0x4b, 0xff, 0xf3, 0xb1, 0x48, 0x00, 0x01, 0x10, 0x83, 0xfa, 0x00, 0x34, 0x48, 0x00, 0x00, 0x2c, 
-	0x7f, 0xa3, 0xeb, 0x78, 0x38, 0x9f, 0x00, 0x04, 0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x05, 0xc5, 
-	0x2c, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x10, 0x3b, 0xff, 0x00, 0x04, 0x48, 0x00, 0x00, 0x18, 
-	0x60, 0x00, 0x00, 0x00, 0x83, 0xff, 0x00, 0x00, 0x28, 0x1f, 0x00, 0x00, 0x40, 0x82, 0xff, 0xd4, 
-	0x3b, 0xe0, 0x00, 0x00, 0x28, 0x1f, 0x00, 0x00, 0x40, 0x82, 0x00, 0x24, 0x7f, 0x43, 0xd3, 0x78, 
-	0x7f, 0x64, 0xdb, 0x78, 0x7f, 0x85, 0xe3, 0x78, 0x38, 0xc0, 0x00, 0x1e, 0x38, 0xe0, 0x00, 0x01, 
-	0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf3, 0x4d, 0x48, 0x00, 0x00, 0xac, 0x83, 0xda, 0x00, 0x34, 
-	0x48, 0x00, 0x00, 0x20, 0x7f, 0xe3, 0xfb, 0x78, 0x38, 0x9e, 0x00, 0x04, 0x38, 0xa0, 0x00, 0x06, 
-	0x48, 0x00, 0x05, 0x61, 0x2c, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x14, 0x83, 0xde, 0x00, 0x00, 
-	0x28, 0x1e, 0x00, 0x00, 0x40, 0x82, 0xff, 0xe0, 0x48, 0x00, 0x00, 0x40, 0x38, 0x9a, 0x00, 0x34, 
-	0x48, 0x00, 0x00, 0x30, 0x60, 0x00, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x7c, 0x00, 0xf0, 0x40, 
-	0x40, 0x82, 0x00, 0x1c, 0x80, 0x1e, 0x00, 0x00, 0x7f, 0xc3, 0xf3, 0x78, 0x90, 0x04, 0x00, 0x00, 
-	0x48, 0x00, 0x02, 0xf1, 0x48, 0x00, 0x00, 0x14, 0x60, 0x00, 0x00, 0x00, 0x7c, 0x04, 0x03, 0x78, 
-	0x28, 0x04, 0x00, 0x00, 0x40, 0x82, 0xff, 0xd4, 0x7f, 0xe3, 0xfb, 0x78, 0x48, 0x00, 0x02, 0xd5, 
-	0x7f, 0xa3, 0xeb, 0x78, 0x4b, 0xff, 0xde, 0xbd, 0x80, 0x1a, 0x00, 0x34, 0x28, 0x00, 0x00, 0x00, 
-	0x40, 0x82, 0x00, 0x10, 0x80, 0x1a, 0x00, 0x08, 0x54, 0x00, 0x07, 0xfa, 0x90, 0x1a, 0x00, 0x08, 
-	0x7f, 0x43, 0xd3, 0x78, 0x7f, 0x64, 0xdb, 0x78, 0x7f, 0x85, 0xe3, 0x78, 0x38, 0xc0, 0x00, 0x1e, 
-	0x4b, 0xff, 0xf3, 0x51, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0x41, 0xff, 0xe8, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0xbf, 0x2b, 0x78, 0x7c, 0x9e, 0x23, 0x78, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0x03, 0x00, 0x04, 0x83, 0xa5, 0x00, 0x0c, 
-	0x28, 0x00, 0x00, 0x03, 0x41, 0x82, 0x00, 0xb4, 0x80, 0x7d, 0x00, 0x04, 0x38, 0x80, 0x00, 0x03, 
-	0x38, 0x63, 0x00, 0x14, 0x4b, 0xff, 0xde, 0xdd, 0x7c, 0x7c, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x14, 
-	0x80, 0x62, 0x00, 0xf4, 0x7f, 0xe4, 0xfb, 0x78, 0x48, 0x00, 0x02, 0x69, 0x48, 0x00, 0x00, 0xa4, 
-	0x80, 0xdc, 0x00, 0x14, 0x38, 0x00, 0x00, 0x01, 0x38, 0xa0, 0x00, 0x09, 0x38, 0x80, 0x00, 0x03, 
-	0x38, 0x60, 0x00, 0x00, 0x98, 0x06, 0x00, 0x0d, 0x38, 0x00, 0x00, 0x14, 0x80, 0xdc, 0x00, 0x10, 
-	0x90, 0xa6, 0x00, 0x00, 0x90, 0x86, 0x00, 0x10, 0x90, 0x66, 0x00, 0x0c, 0x80, 0x7d, 0x00, 0x04, 
-	0x90, 0x66, 0x00, 0x04, 0x90, 0x06, 0x00, 0x08, 0x80, 0x7c, 0x00, 0x10, 0x38, 0x03, 0x00, 0x14, 
-	0x90, 0x1c, 0x00, 0x10, 0x80, 0x1d, 0x00, 0x08, 0x80, 0x7c, 0x00, 0x10, 0x80, 0xbd, 0x00, 0x04, 
-	0x7c, 0x9d, 0x02, 0x14, 0x48, 0x00, 0x03, 0x5d, 0x80, 0x7c, 0x00, 0x10, 0x7f, 0xc4, 0xf3, 0x78, 
-	0x7f, 0x85, 0xe3, 0x78, 0x80, 0x1d, 0x00, 0x04, 0x7c, 0x03, 0x02, 0x14, 0x90, 0x1c, 0x00, 0x10, 
-	0x80, 0x62, 0x00, 0xd4, 0x48, 0x00, 0x02, 0x3d, 0x80, 0x62, 0x00, 0xf4, 0x7f, 0xe4, 0xfb, 0x78, 
-	0x48, 0x00, 0x01, 0xe1, 0x48, 0x00, 0x00, 0x1c, 0x7f, 0xe4, 0xfb, 0x78, 0x38, 0xa0, 0x00, 0x00, 
-	0x4b, 0xff, 0xea, 0x51, 0x28, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x08, 0x4b, 0xff, 0xec, 0x55, 
-	0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x93, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x02, 0xa6, 0x38, 0xa0, 0x00, 0x00, 0x7c, 0x9f, 0x23, 0x78, 
-	0x38, 0xc2, 0x05, 0x04, 0x90, 0x01, 0x00, 0x08, 0x38, 0x00, 0x00, 0x20, 0x38, 0x86, 0xff, 0xf8, 
-	0x7c, 0x09, 0x03, 0xa6, 0x94, 0x21, 0xfe, 0xb0, 0x90, 0xa1, 0x00, 0x44, 0x90, 0xa1, 0x00, 0x40, 
-	0x38, 0xa1, 0x00, 0x40, 0x60, 0x00, 0x00, 0x00, 0x84, 0x04, 0x00, 0x08, 0x94, 0x05, 0x00, 0x08, 
-	0x80, 0x04, 0x00, 0x04, 0x90, 0x05, 0x00, 0x04, 0x42, 0x00, 0xff, 0xf0, 0x38, 0x00, 0x00, 0x00, 
-	0x3c, 0x80, 0x70, 0x77, 0x90, 0x01, 0x00, 0x3c, 0x38, 0xc1, 0x00, 0x44, 0x38, 0xe1, 0x00, 0x40, 
-	0x98, 0x01, 0x00, 0x38, 0x38, 0x84, 0x70, 0x63, 0x39, 0x01, 0x00, 0x48, 0x38, 0xa0, 0x00, 0x01, 
-	0x48, 0x00, 0x04, 0x05, 0x80, 0x41, 0x00, 0x14, 0x7c, 0x60, 0x07, 0x35, 0x41, 0x82, 0x00, 0x0c, 
-	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x30, 0x80, 0x61, 0x00, 0x44, 0x7f, 0xe4, 0xfb, 0x78, 
-	0x38, 0xa1, 0x00, 0x3c, 0x38, 0xc1, 0x00, 0x38, 0x48, 0x00, 0x03, 0xf5, 0x80, 0x41, 0x00, 0x14, 
-	0x7c, 0x60, 0x07, 0x35, 0x41, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x08, 
-	0x80, 0x61, 0x00, 0x3c, 0x80, 0x01, 0x01, 0x58, 0x38, 0x21, 0x01, 0x50, 0x83, 0xe1, 0xff, 0xfc, 
-	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x93, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x9f, 0x23, 0x78, 0x7c, 0x64, 0x1b, 0x78, 
-	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xfe, 0x80, 0x88, 0x03, 0x00, 0x00, 0x38, 0x61, 0x00, 0x38, 
-	0x7c, 0x05, 0x07, 0x74, 0x38, 0xa5, 0x00, 0x01, 0x48, 0x00, 0x01, 0xf9, 0x88, 0x1f, 0x00, 0x00, 
-	0x7f, 0xe4, 0xfb, 0x78, 0x38, 0x61, 0x00, 0x78, 0x7c, 0x05, 0x07, 0x74, 0x38, 0xa5, 0x00, 0x01, 
-	0x48, 0x00, 0x01, 0xe1, 0x38, 0x61, 0x00, 0x38, 0x38, 0x81, 0x00, 0x78, 0x4b, 0xff, 0xfe, 0xe5, 
+	0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0x83, 0x00, 0x00, 0x3b, 0xc5, 0x00, 0x00, 
+	0x3b, 0xa4, 0x00, 0x00, 0x3b, 0xe0, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 
+	0x80, 0xc5, 0x00, 0x0c, 0x80, 0x03, 0x00, 0x04, 0x80, 0x66, 0x00, 0x04, 0x28, 0x00, 0x00, 0x03, 
+	0x80, 0xa6, 0x00, 0x08, 0x7c, 0x86, 0x1a, 0x14, 0x41, 0x82, 0x00, 0x24, 0x38, 0x7c, 0x00, 0x00, 
+	0x38, 0x9d, 0x00, 0x00, 0x38, 0xbe, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x15, 0x38, 0xe0, 0x00, 0x03, 
+	0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf6, 0x45, 0x48, 0x00, 0x00, 0xf0, 0x2c, 0x05, 0x00, 0x01, 
+	0x40, 0x82, 0x00, 0x5c, 0x88, 0x84, 0x00, 0x00, 0x54, 0x80, 0x07, 0xff, 0x41, 0x82, 0x00, 0x48, 
+	0x28, 0x04, 0x00, 0xff, 0x41, 0x82, 0x00, 0x40, 0xa0, 0x1c, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0xfe, 
+	0x41, 0x81, 0x00, 0x2c, 0x7c, 0x83, 0x36, 0x70, 0x54, 0x80, 0xfe, 0xfe, 0x54, 0x64, 0x10, 0x3a, 
+	0x38, 0x60, 0x00, 0x01, 0x7c, 0x9c, 0x22, 0x14, 0x7c, 0x60, 0x00, 0x30, 0x80, 0x64, 0x00, 0x18, 
+	0x7c, 0x60, 0x00, 0x78, 0x90, 0x04, 0x00, 0x18, 0x48, 0x00, 0x00, 0x58, 0x3b, 0xe0, 0x00, 0x07, 
+	0x48, 0x00, 0x00, 0x50, 0x3b, 0xe0, 0x00, 0x01, 0x48, 0x00, 0x00, 0x48, 0x2c, 0x05, 0x00, 0x05, 
+	0x40, 0x82, 0x00, 0x40, 0xa0, 0x1c, 0x00, 0x0c, 0x2c, 0x00, 0x00, 0xaa, 0x40, 0x82, 0x00, 0x30, 
+	0x80, 0x1c, 0x00, 0x08, 0x54, 0x00, 0x07, 0xff, 0x41, 0x82, 0x00, 0x1c, 0x38, 0x7c, 0x00, 0x28, 
+	0x48, 0x00, 0x07, 0x55, 0x2c, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x18, 0x3b, 0xe0, 0x00, 0x01, 
+	0x48, 0x00, 0x00, 0x10, 0x3b, 0xe0, 0x00, 0x01, 0x48, 0x00, 0x00, 0x08, 0x3b, 0xe0, 0x00, 0x07, 
+	0x2c, 0x1f, 0x00, 0x00, 0x41, 0x82, 0x00, 0x24, 0x38, 0x7c, 0x00, 0x00, 0x38, 0x9d, 0x00, 0x00, 
+	0x38, 0xbe, 0x00, 0x00, 0x38, 0xff, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x15, 0x39, 0x00, 0x00, 0x00, 
+	0x4b, 0xff, 0xf5, 0x79, 0x48, 0x00, 0x00, 0x24, 0x80, 0x1c, 0x00, 0x08, 0x38, 0x7c, 0x00, 0x00, 
+	0x38, 0x9d, 0x00, 0x00, 0x38, 0xbe, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x15, 0x54, 0x00, 0x00, 0x3c, 
+	0x90, 0x1c, 0x00, 0x08, 0x4b, 0xff, 0xf5, 0xfd, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 
+	0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0xbf, 0x41, 0xff, 0xe8, 
+	0x7c, 0x08, 0x02, 0xa6, 0x3b, 0x43, 0x00, 0x00, 0x3b, 0x85, 0x00, 0x00, 0x7c, 0x9b, 0x23, 0x78, 
+	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xa0, 0x80, 0x65, 0x00, 0x0c, 0x80, 0x03, 0x00, 0x08, 
+	0x7f, 0xc3, 0x02, 0x14, 0x38, 0x7e, 0x00, 0x00, 0x4b, 0xff, 0xec, 0xa9, 0x2c, 0x03, 0x00, 0x01, 
+	0x41, 0x82, 0x00, 0x24, 0x38, 0x7a, 0x00, 0x00, 0x38, 0x9b, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 
+	0x38, 0xc0, 0x00, 0x1d, 0x38, 0xe0, 0x00, 0x01, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf4, 0xed, 
+	0x48, 0x00, 0x00, 0xd4, 0x83, 0xfa, 0x00, 0x30, 0x48, 0x00, 0x00, 0x28, 0x38, 0x7e, 0x00, 0x00, 
+	0x38, 0x9f, 0x00, 0x04, 0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x06, 0x6d, 0x2c, 0x03, 0x00, 0x00, 
+	0x40, 0x82, 0x00, 0x0c, 0x38, 0x1f, 0x00, 0x04, 0x48, 0x00, 0x00, 0x14, 0x83, 0xff, 0x00, 0x00, 
+	0x28, 0x1f, 0x00, 0x00, 0x40, 0x82, 0xff, 0xd8, 0x38, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
+	0x41, 0x82, 0x00, 0x24, 0x38, 0x7a, 0x00, 0x00, 0x38, 0x9b, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 
+	0x38, 0xc0, 0x00, 0x1d, 0x38, 0xe0, 0x00, 0x01, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf4, 0x8d, 
+	0x48, 0x00, 0x00, 0x74, 0x7f, 0xc3, 0xf3, 0x78, 0x4b, 0xff, 0xe0, 0xe1, 0x38, 0x60, 0x00, 0x06, 
+	0x48, 0x00, 0x04, 0x15, 0x80, 0x1e, 0x00, 0x00, 0x7c, 0x64, 0x1b, 0x78, 0x38, 0x60, 0x00, 0x0c, 
+	0x7c, 0x9d, 0x23, 0x78, 0x90, 0x04, 0x00, 0x00, 0xa0, 0x1e, 0x00, 0x04, 0xb0, 0x04, 0x00, 0x04, 
+	0x48, 0x00, 0x03, 0xf5, 0x3b, 0xe3, 0x00, 0x00, 0x38, 0x9d, 0x00, 0x00, 0x38, 0x7f, 0x00, 0x04, 
+	0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x05, 0x3d, 0x80, 0x1a, 0x00, 0x30, 0x38, 0x7a, 0x00, 0x00, 
+	0x38, 0x9b, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x1d, 0x90, 0x1f, 0x00, 0x00, 
+	0x93, 0xfa, 0x00, 0x30, 0x80, 0x1a, 0x00, 0x08, 0x60, 0x00, 0x00, 0x02, 0x90, 0x1a, 0x00, 0x08, 
+	0x4b, 0xff, 0xf4, 0xc1, 0x80, 0x01, 0x00, 0x68, 0x38, 0x21, 0x00, 0x60, 0xbb, 0x41, 0xff, 0xe8, 
+	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0xbf, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x02, 0xa6, 
+	0x3b, 0x43, 0x00, 0x00, 0x3b, 0x85, 0x00, 0x00, 0x7c, 0x9b, 0x23, 0x78, 0x90, 0x01, 0x00, 0x08, 
+	0x94, 0x21, 0xff, 0xa0, 0x80, 0x65, 0x00, 0x0c, 0x80, 0x03, 0x00, 0x08, 0x7f, 0xa3, 0x02, 0x14, 
+	0x38, 0x7d, 0x00, 0x00, 0x4b, 0xff, 0xeb, 0x6d, 0x2c, 0x03, 0x00, 0x01, 0x41, 0x82, 0x00, 0x24, 
+	0x38, 0x7a, 0x00, 0x00, 0x38, 0x9b, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x1e, 
+	0x38, 0xe0, 0x00, 0x01, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf3, 0xb1, 0x48, 0x00, 0x01, 0x04, 
+	0x83, 0xfa, 0x00, 0x30, 0x48, 0x00, 0x00, 0x28, 0x38, 0x7d, 0x00, 0x00, 0x38, 0x9f, 0x00, 0x04, 
+	0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x05, 0x31, 0x2c, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0x0c, 
+	0x3b, 0xdf, 0x00, 0x04, 0x48, 0x00, 0x00, 0x14, 0x83, 0xff, 0x00, 0x00, 0x28, 0x1f, 0x00, 0x00, 
+	0x40, 0x82, 0xff, 0xd8, 0x3b, 0xc0, 0x00, 0x00, 0x28, 0x1e, 0x00, 0x00, 0x40, 0x82, 0x00, 0x24, 
+	0x38, 0x7a, 0x00, 0x00, 0x38, 0x9b, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x1e, 
+	0x38, 0xe0, 0x00, 0x01, 0x39, 0x00, 0x00, 0x00, 0x4b, 0xff, 0xf3, 0x51, 0x48, 0x00, 0x00, 0xa4, 
+	0x83, 0xfa, 0x00, 0x30, 0x48, 0x00, 0x00, 0x20, 0x38, 0x7e, 0x00, 0x00, 0x38, 0x9f, 0x00, 0x04, 
+	0x38, 0xa0, 0x00, 0x06, 0x48, 0x00, 0x04, 0xd1, 0x2c, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x14, 
+	0x83, 0xff, 0x00, 0x00, 0x28, 0x1f, 0x00, 0x00, 0x40, 0x82, 0xff, 0xe0, 0x48, 0x00, 0x00, 0x38, 
+	0x38, 0x9a, 0x00, 0x30, 0x48, 0x00, 0x00, 0x28, 0x80, 0x04, 0x00, 0x00, 0x7c, 0x00, 0xf8, 0x40, 
+	0x40, 0x82, 0x00, 0x18, 0x80, 0x1f, 0x00, 0x00, 0x7f, 0xe3, 0xfb, 0x78, 0x90, 0x04, 0x00, 0x00, 
+	0x48, 0x00, 0x02, 0xb9, 0x48, 0x00, 0x00, 0x10, 0x7c, 0x04, 0x03, 0x78, 0x28, 0x04, 0x00, 0x00, 
+	0x40, 0x82, 0xff, 0xd8, 0x7f, 0xc3, 0xf3, 0x78, 0x48, 0x00, 0x02, 0xa1, 0x7f, 0xa3, 0xeb, 0x78, 
+	0x4b, 0xff, 0xdf, 0x71, 0x80, 0x1a, 0x00, 0x30, 0x28, 0x00, 0x00, 0x00, 0x40, 0x82, 0x00, 0x10, 
+	0x80, 0x1a, 0x00, 0x08, 0x54, 0x00, 0x07, 0xfa, 0x90, 0x1a, 0x00, 0x08, 0x38, 0x7a, 0x00, 0x00, 
+	0x38, 0x9b, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 0x38, 0xc0, 0x00, 0x1e, 0x4b, 0xff, 0xf3, 0x55, 
+	0x80, 0x01, 0x00, 0x68, 0x38, 0x21, 0x00, 0x60, 0xbb, 0x41, 0xff, 0xe8, 0x7c, 0x08, 0x03, 0xa6, 
+	0x4e, 0x80, 0x00, 0x20, 0xbf, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0xbe, 0x2b, 0x78, 
+	0x7c, 0x9d, 0x23, 0x78, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xb0, 0x80, 0x03, 0x00, 0x04, 
+	0x83, 0xe5, 0x00, 0x0c, 0x28, 0x00, 0x00, 0x03, 0x41, 0x82, 0x00, 0xb4, 0x80, 0x7f, 0x00, 0x04, 
+	0x38, 0x80, 0x00, 0x03, 0x38, 0x63, 0x00, 0x14, 0x4b, 0xff, 0xdf, 0x69, 0x7c, 0x7c, 0x1b, 0x79, 
+	0x40, 0x82, 0x00, 0x14, 0x80, 0x62, 0x00, 0xf4, 0x7f, 0xc4, 0xf3, 0x78, 0x48, 0x00, 0x02, 0x31, 
+	0x48, 0x00, 0x00, 0xa8, 0x80, 0xdc, 0x00, 0x14, 0x38, 0x00, 0x00, 0x01, 0x38, 0xa0, 0x00, 0x09, 
+	0x38, 0x80, 0x00, 0x03, 0x38, 0x60, 0x00, 0x00, 0x98, 0x06, 0x00, 0x0d, 0x38, 0x00, 0x00, 0x14, 
+	0x80, 0xdc, 0x00, 0x10, 0x90, 0xa6, 0x00, 0x00, 0x90, 0x86, 0x00, 0x10, 0x90, 0x66, 0x00, 0x0c, 
+	0x80, 0x7f, 0x00, 0x04, 0x90, 0x66, 0x00, 0x04, 0x90, 0x06, 0x00, 0x08, 0x80, 0x7c, 0x00, 0x10, 
+	0x38, 0x03, 0x00, 0x14, 0x90, 0x1c, 0x00, 0x10, 0x80, 0x1f, 0x00, 0x08, 0x80, 0x7c, 0x00, 0x10, 
+	0x80, 0xbf, 0x00, 0x04, 0x7c, 0x9f, 0x02, 0x14, 0x48, 0x00, 0x02, 0xe9, 0x80, 0x7c, 0x00, 0x10, 
+	0x38, 0x9d, 0x00, 0x00, 0x38, 0xbc, 0x00, 0x00, 0x80, 0x1f, 0x00, 0x04, 0x7c, 0x03, 0x02, 0x14, 
+	0x90, 0x1c, 0x00, 0x10, 0x80, 0x62, 0x00, 0xd4, 0x48, 0x00, 0x01, 0xf1, 0x80, 0x62, 0x00, 0xf4, 
+	0x7f, 0xc4, 0xf3, 0x78, 0x48, 0x00, 0x01, 0xa9, 0x48, 0x00, 0x00, 0x20, 0x38, 0x9e, 0x00, 0x00, 
+	0x38, 0xa0, 0x00, 0x00, 0x4b, 0xff, 0xea, 0xa5, 0x7c, 0x7e, 0x1b, 0x79, 0x41, 0x82, 0x00, 0x0c, 
+	0x7f, 0xc3, 0xf3, 0x78, 0x4b, 0xff, 0xec, 0xa5, 0x80, 0x01, 0x00, 0x58, 0x38, 0x21, 0x00, 0x50, 
+	0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x93, 0xe1, 0xff, 0xfc, 
+	0x7c, 0x08, 0x02, 0xa6, 0x38, 0xc0, 0x00, 0x00, 0x3b, 0xe4, 0x00, 0x00, 0x38, 0xa2, 0x05, 0x04, 
+	0x90, 0x01, 0x00, 0x08, 0x38, 0x00, 0x00, 0x20, 0x38, 0xa5, 0xff, 0xf8, 0x94, 0x21, 0xfe, 0xb0, 
+	0x7c, 0x09, 0x03, 0xa6, 0x90, 0xc1, 0x01, 0x44, 0x90, 0xc1, 0x01, 0x40, 0x38, 0xc1, 0x00, 0x38, 
+	0x84, 0x85, 0x00, 0x08, 0x80, 0x05, 0x00, 0x04, 0x94, 0x86, 0x00, 0x08, 0x90, 0x06, 0x00, 0x04, 
+	0x42, 0x00, 0xff, 0xf0, 0x38, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x70, 0x77, 0x90, 0x01, 0x00, 0x3c, 
+	0x38, 0x84, 0x70, 0x63, 0x38, 0xc1, 0x01, 0x44, 0x98, 0x01, 0x00, 0x38, 0x38, 0xe1, 0x01, 0x40, 
+	0x39, 0x01, 0x00, 0x40, 0x38, 0xa0, 0x00, 0x01, 0x48, 0x00, 0x03, 0x79, 0x80, 0x41, 0x00, 0x14, 
+	0x7c, 0x60, 0x07, 0x35, 0x41, 0x82, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x30, 
+	0x80, 0x61, 0x01, 0x44, 0x38, 0x9f, 0x00, 0x00, 0x38, 0xa1, 0x00, 0x3c, 0x38, 0xc1, 0x00, 0x38, 
+	0x48, 0x00, 0x03, 0x69, 0x80, 0x41, 0x00, 0x14, 0x7c, 0x60, 0x07, 0x35, 0x41, 0x82, 0x00, 0x0c, 
+	0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x08, 0x80, 0x61, 0x00, 0x3c, 0x80, 0x01, 0x01, 0x58, 
+	0x38, 0x21, 0x01, 0x50, 0x83, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 
+	0x93, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x02, 0xa6, 0x7c, 0x9f, 0x23, 0x78, 0x38, 0x83, 0x00, 0x00, 
+	0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xfe, 0x80, 0x88, 0x03, 0x00, 0x00, 0x38, 0x61, 0x01, 0x38, 
+	0x7c, 0x05, 0x07, 0x74, 0x38, 0xa5, 0x00, 0x01, 0x48, 0x00, 0x01, 0x99, 0x88, 0x1f, 0x00, 0x00, 
+	0x38, 0x9f, 0x00, 0x00, 0x38, 0x61, 0x00, 0x38, 0x7c, 0x05, 0x07, 0x74, 0x38, 0xa5, 0x00, 0x01, 
+	0x48, 0x00, 0x01, 0x81, 0x38, 0x61, 0x01, 0x38, 0x38, 0x81, 0x00, 0x38, 0x4b, 0xff, 0xfe, 0xf1, 
 	0x80, 0x01, 0x01, 0x88, 0x38, 0x21, 0x01, 0x80, 0x83, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x48, 0x00, 0x03, 0x11, 
-	0x80, 0x41, 0x00, 0x14, 0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x48, 0x00, 0x02, 0x99, 
-	0x80, 0x41, 0x00, 0x14, 0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 
+	0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 
+	0x48, 0x00, 0x02, 0x99, 0x80, 0x41, 0x00, 0x14, 0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 
+	0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 
+	0x94, 0x21, 0xff, 0xc0, 0x48, 0x00, 0x02, 0x2d, 0x80, 0x41, 0x00, 0x14, 0x80, 0x01, 0x00, 0x48, 
+	0x38, 0x21, 0x00, 0x40, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 
+	0x90, 0x01, 0x00, 0x08, 0x90, 0x41, 0x00, 0x0c, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x03, 0x00, 0x00, 
+	0x80, 0x43, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 0x7c, 0x83, 0x23, 0x78, 0x4e, 0x80, 0x04, 0x21, 
+	0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 
+	0x4e, 0x80, 0x00, 0x20, 0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 
 	0x90, 0x41, 0x00, 0x0c, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x03, 0x00, 0x00, 0x80, 0x43, 0x00, 0x04, 
-	0x7c, 0x09, 0x03, 0xa6, 0x7c, 0x83, 0x23, 0x78, 0x4e, 0x80, 0x04, 0x21, 0x80, 0x01, 0x00, 0x48, 
-	0x80, 0x41, 0x00, 0x4c, 0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 
-	0x80, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x03, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 
-	0x90, 0x41, 0x00, 0x0c, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x03, 0x00, 0x00, 0x80, 0x43, 0x00, 0x04, 
 	0x7c, 0x09, 0x03, 0xa6, 0x7c, 0x83, 0x23, 0x78, 0x7c, 0xa4, 0x2b, 0x78, 0x4e, 0x80, 0x04, 0x21, 
 	0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 
-	0x4e, 0x80, 0x00, 0x20, 0x80, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x03, 0xa6, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 
+	0x4e, 0x80, 0x00, 0x20, 0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 
 	0x90, 0x41, 0x00, 0x0c, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x03, 0x00, 0x00, 0x80, 0x43, 0x00, 0x04, 
 	0x7c, 0x09, 0x03, 0xa6, 0x7c, 0x83, 0x23, 0x78, 0x7c, 0xa4, 0x2b, 0x78, 0x7c, 0xc5, 0x33, 0x78, 
 	0x4e, 0x80, 0x04, 0x21, 0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 0x7c, 0x08, 0x03, 0xa6, 
-	0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x80, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x03, 0xa6, 
-	0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08, 
-	0x90, 0x41, 0x00, 0x0c, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x03, 0x00, 0x00, 0x80, 0x43, 0x00, 0x04, 
-	0x7c, 0x09, 0x03, 0xa6, 0x7c, 0x83, 0x23, 0x78, 0x7c, 0xa4, 0x2b, 0x78, 0x7c, 0xc5, 0x33, 0x78, 
-	0x7c, 0xe6, 0x3b, 0x78, 0x7d, 0x07, 0x43, 0x78, 0x7d, 0x28, 0x4b, 0x78, 0x7d, 0x49, 0x53, 0x78, 
-	0x4e, 0x80, 0x04, 0x21, 0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 0x7c, 0x08, 0x03, 0xa6, 
-	0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x80, 0x01, 0x00, 0x08, 0x7c, 0x08, 0x03, 0xa6, 
-	0x7c, 0x08, 0x02, 0xa6, 0x93, 0xe1, 0xff, 0xfc, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 
-	0x7c, 0x7f, 0x1b, 0x78, 0x7c, 0x83, 0x23, 0x78, 0x7f, 0xe4, 0xfb, 0x78, 0x48, 0x00, 0x01, 0x21, 
-	0x80, 0x41, 0x00, 0x14, 0x7f, 0xe3, 0xfb, 0x78, 0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 
-	0x83, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
-	0x7c, 0x08, 0x02, 0xa6, 0x93, 0xe1, 0xff, 0xfc, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 
-	0x7c, 0x7f, 0x1b, 0x78, 0x2c, 0x04, 0x00, 0x00, 0x40, 0x82, 0x00, 0x14, 0x7c, 0xa4, 0x2b, 0x78, 
-	0x48, 0x00, 0x00, 0xf5, 0x80, 0x41, 0x00, 0x14, 0x48, 0x00, 0x00, 0x24, 0x38, 0xa5, 0x00, 0x01, 
-	0x7c, 0x80, 0x07, 0x74, 0x48, 0x00, 0x00, 0x0c, 0x98, 0x03, 0x00, 0x00, 0x38, 0x63, 0x00, 0x01, 
-	0x38, 0xa5, 0xff, 0xff, 0x28, 0x05, 0x00, 0x00, 0x40, 0x82, 0xff, 0xf0, 0x7f, 0xe3, 0xfb, 0x78, 
-	0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 0x83, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x03, 0xa6, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x38, 0xc5, 0x00, 0x01, 0x48, 0x00, 0x00, 0x2c, 0x88, 0xa4, 0x00, 0x00, 0x88, 0x03, 0x00, 0x00, 
-	0x7c, 0x05, 0x00, 0x50, 0x2c, 0x00, 0x00, 0x00, 0x41, 0x82, 0x00, 0x10, 0x7c, 0x03, 0x03, 0x78, 
-	0x4e, 0x80, 0x00, 0x20, 0x60, 0x00, 0x00, 0x00, 0x38, 0x63, 0x00, 0x01, 0x38, 0x84, 0x00, 0x01, 
-	0x38, 0xc6, 0xff, 0xff, 0x28, 0x06, 0x00, 0x00, 0x40, 0x82, 0xff, 0xd0, 0x38, 0x60, 0x00, 0x00, 
-	0x4e, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x90, 0x81, 0x00, 0x1c, 0x90, 0xa1, 0x00, 0x20, 0x90, 0xc1, 0x00, 0x24, 0x90, 0xe1, 0x00, 0x28, 
-	0x91, 0x01, 0x00, 0x2c, 0x91, 0x21, 0x00, 0x30, 0x91, 0x41, 0x00, 0x34, 0x38, 0x60, 0x00, 0x00, 
-	0x4e, 0x80, 0x00, 0x20, 0x81, 0x82, 0x00, 0x14, 0x90, 0x41, 0x00, 0x14, 0x80, 0x0c, 0x00, 0x00, 
-	0x80, 0x4c, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 0x81, 0x82, 0x00, 0x08, 
-	0x90, 0x41, 0x00, 0x14, 0x80, 0x0c, 0x00, 0x00, 0x80, 0x4c, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 
-	0x4e, 0x80, 0x04, 0x20, 0x81, 0x82, 0x00, 0x00, 0x90, 0x41, 0x00, 0x14, 0x80, 0x0c, 0x00, 0x00, 
-	0x80, 0x4c, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 0x81, 0x82, 0x00, 0x04, 
-	0x90, 0x41, 0x00, 0x14, 0x80, 0x0c, 0x00, 0x00, 0x80, 0x4c, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 
-	0x4e, 0x80, 0x04, 0x20, 0x81, 0x82, 0x00, 0x0c, 0x90, 0x41, 0x00, 0x14, 0x80, 0x0c, 0x00, 0x00, 
-	0x80, 0x4c, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 0x81, 0x82, 0x00, 0x10, 
-	0x90, 0x41, 0x00, 0x14, 0x80, 0x0c, 0x00, 0x00, 0x80, 0x4c, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 
-	0x4e, 0x80, 0x04, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x4e, 0x80, 0x00, 0x20, 0x7c, 0x08, 0x02, 0xa6, 
+	0x90, 0x01, 0x00, 0x08, 0x90, 0x41, 0x00, 0x0c, 0x94, 0x21, 0xff, 0xc0, 0x80, 0x03, 0x00, 0x00, 
+	0x80, 0x43, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 0x7c, 0x83, 0x23, 0x78, 0x7c, 0xa4, 0x2b, 0x78, 
+	0x7c, 0xc5, 0x33, 0x78, 0x7c, 0xe6, 0x3b, 0x78, 0x7d, 0x07, 0x43, 0x78, 0x7d, 0x28, 0x4b, 0x78, 
+	0x7d, 0x49, 0x53, 0x78, 0x4e, 0x80, 0x04, 0x21, 0x80, 0x01, 0x00, 0x48, 0x80, 0x41, 0x00, 0x4c, 
+	0x7c, 0x08, 0x03, 0xa6, 0x38, 0x21, 0x00, 0x40, 0x4e, 0x80, 0x00, 0x20, 0x4e, 0x80, 0x00, 0x20, 
+	0x93, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x02, 0xa6, 0x3b, 0xe3, 0x00, 0x00, 0x38, 0x64, 0x00, 0x00, 
+	0x38, 0x9f, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xc0, 0x48, 0x00, 0x00, 0xfd, 
+	0x80, 0x41, 0x00, 0x14, 0x80, 0x01, 0x00, 0x48, 0x38, 0x21, 0x00, 0x40, 0x7f, 0xe3, 0xfb, 0x78, 
+	0x83, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80, 0x00, 0x20, 0x93, 0xe1, 0xff, 0xfc, 
+	0x7c, 0x08, 0x02, 0xa6, 0x2c, 0x04, 0x00, 0x00, 0x3b, 0xe3, 0x00, 0x00, 0x90, 0x01, 0x00, 0x08, 
+	0x94, 0x21, 0xff, 0xc0, 0x40, 0x82, 0x00, 0x18, 0x38, 0x7f, 0x00, 0x00, 0x38, 0x85, 0x00, 0x00, 
+	0x48, 0x00, 0x00, 0xd1, 0x80, 0x41, 0x00, 0x14, 0x48, 0x00, 0x00, 0x24, 0x38, 0x7f, 0x00, 0x00, 
+	0x7c, 0x80, 0x07, 0x74, 0x38, 0xa5, 0x00, 0x01, 0x48, 0x00, 0x00, 0x0c, 0x98, 0x03, 0x00, 0x00, 
+	0x38, 0x63, 0x00, 0x01, 0x34, 0xa5, 0xff, 0xff, 0x40, 0x82, 0xff, 0xf4, 0x80, 0x01, 0x00, 0x48, 
+	0x38, 0x21, 0x00, 0x40, 0x7f, 0xe3, 0xfb, 0x78, 0x83, 0xe1, 0xff, 0xfc, 0x7c, 0x08, 0x03, 0xa6, 
+	0x4e, 0x80, 0x00, 0x20, 0x38, 0xc5, 0x00, 0x01, 0x48, 0x00, 0x00, 0x24, 0x88, 0xa4, 0x00, 0x00, 
+	0x88, 0x03, 0x00, 0x00, 0x7c, 0x05, 0x00, 0x51, 0x41, 0x82, 0x00, 0x0c, 0x7c, 0x03, 0x03, 0x78, 
+	0x4e, 0x80, 0x00, 0x20, 0x38, 0x63, 0x00, 0x01, 0x38, 0x84, 0x00, 0x01, 0x34, 0xc6, 0xff, 0xff, 
+	0x40, 0x82, 0xff, 0xdc, 0x38, 0x60, 0x00, 0x00, 0x4e, 0x80, 0x00, 0x20, 0x90, 0x81, 0x00, 0x1c, 
+	0x38, 0x60, 0x00, 0x00, 0x90, 0xa1, 0x00, 0x20, 0x90, 0xc1, 0x00, 0x24, 0x90, 0xe1, 0x00, 0x28, 
+	0x91, 0x01, 0x00, 0x2c, 0x91, 0x21, 0x00, 0x30, 0x91, 0x41, 0x00, 0x34, 0x4e, 0x80, 0x00, 0x20, 
+	0x81, 0x82, 0x00, 0x14, 0x90, 0x41, 0x00, 0x14, 0x80, 0x0c, 0x00, 0x00, 0x80, 0x4c, 0x00, 0x04, 
+	0x7c, 0x09, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 0x81, 0x82, 0x00, 0x08, 0x90, 0x41, 0x00, 0x14, 
+	0x80, 0x0c, 0x00, 0x00, 0x80, 0x4c, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 
+	0x81, 0x82, 0x00, 0x00, 0x90, 0x41, 0x00, 0x14, 0x80, 0x0c, 0x00, 0x00, 0x80, 0x4c, 0x00, 0x04, 
+	0x7c, 0x09, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 0x81, 0x82, 0x00, 0x04, 0x90, 0x41, 0x00, 0x14, 
+	0x80, 0x0c, 0x00, 0x00, 0x80, 0x4c, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 
+	0x81, 0x82, 0x00, 0x0c, 0x90, 0x41, 0x00, 0x14, 0x80, 0x0c, 0x00, 0x00, 0x80, 0x4c, 0x00, 0x04, 
+	0x7c, 0x09, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 0x81, 0x82, 0x00, 0x10, 0x90, 0x41, 0x00, 0x14, 
+	0x80, 0x0c, 0x00, 0x00, 0x80, 0x4c, 0x00, 0x04, 0x7c, 0x09, 0x03, 0xa6, 0x4e, 0x80, 0x04, 0x20, 
 	0x1a, 0x22, 0x04, 0xf8, 0x82, 0x02, 0x27, 0x04, 0xe0, 0x04, 0xec, 0x04, 0xdc, 0x04, 0xe8, 0x04, 
 	0xd8, 0x04, 0xe4, 0x04, 0xfc, 0x04, 0xf0, 0x04, 0xf4, 0x01, 0x44, 0x05, 0x00, 0x02, 0x44, 0x04, 
 	0x10, 0x03, 0xdf, 0x03, 0xad, 0x03, 0x7c, 0x03, 0x3d, 0x02, 0x5c, 0x03, 0x30, 0x03, 0x21, 0x03, 
 	0x13, 0x03, 0x01, 0x02, 0xef, 0x02, 0xde, 0x02, 0xd4, 0x02, 0xcc, 0x02, 0xc4, 0x02, 0xb8, 0x02, 
 	0xab, 0x02, 0xa2, 0x02, 0x9c, 0x02, 0x96, 0x02, 0x8e, 0x02, 0x87, 0x02, 0x7e, 0x02, 0x77, 0x02, 
-	0x6f, 0x02, 0x62, 0x05, 0x04, 0x00, 0x4d, 0x21, 0x10, 0x0e, 0x22, 0x09, 0x30, 0x86, 0x02, 0x05, 
-	0x07, 0x60, 0x06, 0x60, 0x05, 0xa0, 0x05, 0x70, 0x04, 0xe0, 0x22, 0x14, 0xe0, 0x04, 0x24, 0x6d, 
+	0x6f, 0x02, 0x62, 0x05, 0x04, 0x00, 0x4d, 0x21, 0x08, 0x0e, 0x22, 0x08, 0x74, 0x86, 0x02, 0x05, 
+	0x06, 0xc4, 0x05, 0xd0, 0x05, 0x20, 0x04, 0xfc, 0x04, 0x7c, 0x22, 0x13, 0xd0, 0x04, 0x24, 0x6d, 
 	0x74, 0x65, 0x6a, 0x04, 0x35, 0x14, 0x53, 0x68, 0x65, 0x65, 0x70, 0x53, 0x68, 0x61, 0x76, 0x65, 
 	0x72, 0x20, 0x45, 0x74, 0x68, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x0b, 0x21, 0x01, 0x01, 0x21, 0x80, 
 	0x04, 0x26, 0x04, 0x04, 0x65, 0x6e, 0x65, 0x74, 0x00, 0x3e, 0x25, 0x01, 0x6f, 0x74, 0x61, 0x6e, 
@@ -727,11 +698,11 @@
 	0x6f, 0x70, 0x65, 0x6e, 0x65, 0x64, 0x0a, 0x01, 0x20, 0x30, 0x46, 0x41, 0x54, 0x41, 0x4c, 0x3a, 
 	0x20, 0x65, 0x74, 0x68, 0x65, 0x72, 0x5f, 0x77, 0x70, 0x75, 0x74, 0x28, 0x29, 0x3a, 0x20, 0x45, 
 	0x74, 0x68, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x6e, 
-	0x6f, 0x74, 0x20, 0x6f, 0x70, 0x65, 0x6e, 0x65, 0x64, 0x0a, 0x03, 0x22, 0x08, 0x4c, 0x82, 0x02, 
-	0x30, 0x08, 0x6c, 0x08, 0x7c, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0x2c, 0x08, 
-	0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 
-	0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0x9c, 0x08, 0xcc, 0x08, 0xcc, 0x08, 
-	0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0x8c, 0x08, 0xcc, 0x08, 0xac, 0x08, 0xbc, 0x08, 0xcc, 0x08, 
-	0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 
-	0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 0xcc, 0x08, 
-	0xcc, 0x22, 0x08, 0x5c, 
+	0x6f, 0x74, 0x20, 0x6f, 0x70, 0x65, 0x6e, 0x65, 0x64, 0x0a, 0x03, 0x22, 0x07, 0xb4, 0x82, 0x02, 
+	0x30, 0x07, 0xcc, 0x07, 0xd8, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x07, 0x98, 0x08, 
+	0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 
+	0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x07, 0xf0, 0x08, 0x14, 0x08, 0x14, 0x08, 
+	0x14, 0x08, 0x14, 0x08, 0x14, 0x07, 0xe4, 0x08, 0x14, 0x07, 0xfc, 0x08, 0x08, 0x08, 0x14, 0x08, 
+	0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 
+	0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 0x14, 0x08, 
+	0x14, 0x22, 0x07, 0xc0, 
--- macemu/SheepShaver/src/MacOSX/Launcher/English.lproj/VMSettingsWindow.nib/designable.nib
+++ sheepshaver/SheepShaver/src/MacOSX/Launcher/English.lproj/VMSettingsWindow.nib/designable.nib
@@ -1,773 +1,4004 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14109" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none">
-    <dependencies>
-        <deployment identifier="macosx"/>
-        <development version="8000" identifier="xcode"/>
-        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14109"/>
-        <capability name="box content view" minToolsVersion="7.0"/>
-        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
-    </dependencies>
-    <objects>
-        <customObject id="-2" userLabel="File's Owner" customClass="VMSettingsController">
-            <connections>
-                <outlet property="bootFrom" destination="231" id="319"/>
-                <outlet property="browseRawKeyCodesButton" destination="376" id="379"/>
-                <outlet property="disableCdrom" destination="236" id="320"/>
-                <outlet property="disableSound" destination="160" id="321"/>
-                <outlet property="diskSaveSize" destination="141" id="353"/>
-                <outlet property="diskSaveSizeField" destination="268" id="351"/>
-                <outlet property="disks" destination="251" id="368"/>
-                <outlet property="dontUseCPUWhenIdle" destination="190" id="322"/>
-                <outlet property="enable68kDREmulator" destination="193" id="323"/>
-                <outlet property="enableJIT" destination="191" id="324"/>
-                <outlet property="ethernetInterface" destination="219" id="349"/>
-                <outlet property="height" destination="149" id="342"/>
-                <outlet property="ignoreIllegalInstructions" destination="370" id="372"/>
-                <outlet property="ignoreIllegalMemoryAccesses" destination="192" id="348"/>
-                <outlet property="isCDROM" destination="380" id="383"/>
-                <outlet property="isCDROMcheckbox" destination="381" id="384"/>
-                <outlet property="mixDevice" destination="161" id="339"/>
-                <outlet property="modemPort" destination="217" id="334"/>
-                <outlet property="mouseWheel" destination="201" id="335"/>
-                <outlet property="outDevice" destination="158" id="340"/>
-                <outlet property="printerPort" destination="218" id="336"/>
-                <outlet property="qdAccel" destination="153" id="341"/>
-                <outlet property="ramSize" destination="238" id="337"/>
-                <outlet property="ramSizeStepper" destination="232" id="338"/>
-                <outlet property="rawKeyCodes" destination="197" id="332"/>
-                <outlet property="refreshRate" destination="156" id="345"/>
-                <outlet property="romFile" destination="237" id="326"/>
-                <outlet property="scrollLines" destination="200" id="346"/>
-                <outlet property="scrollLinesStepper" destination="202" id="347"/>
-                <outlet property="unixRoot" destination="239" id="325"/>
-                <outlet property="useRawKeyCodes" destination="196" id="333"/>
-                <outlet property="videoType" destination="151" id="344"/>
-                <outlet property="width" destination="154" id="343"/>
-                <outlet property="window" destination="142" id="318"/>
-            </connections>
-        </customObject>
-        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
-        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
-        <customView id="141" userLabel="DiskSize">
-            <rect key="frame" x="0.0" y="0.0" width="229" height="62"/>
-            <autoresizingMask key="autoresizingMask"/>
-            <subviews>
-                <textField verticalHuggingPriority="750" id="266">
-                    <rect key="frame" x="17" y="22" width="114" height="17"/>
-                    <autoresizingMask key="autoresizingMask"/>
-                    <textFieldCell key="cell" sendsActionOnEndEditing="YES" title="Volume Size (MB)" id="271">
-                        <font key="font" metaFont="system"/>
-                        <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                        <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                    </textFieldCell>
-                </textField>
-                <stepper horizontalHuggingPriority="750" verticalHuggingPriority="750" tag="1" id="267">
-                    <rect key="frame" x="193" y="17" width="19" height="27"/>
-                    <autoresizingMask key="autoresizingMask"/>
-                    <stepperCell key="cell" continuous="YES" alignment="left" tag="1" minValue="1" maxValue="10000" doubleValue="40" valueWraps="YES" id="270"/>
-                    <connections>
-                        <action selector="takeIntValueFrom:" target="268" id="291"/>
-                    </connections>
-                </stepper>
-                <textField verticalHuggingPriority="750" id="268">
-                    <rect key="frame" x="145" y="20" width="43" height="22"/>
-                    <autoresizingMask key="autoresizingMask"/>
-                    <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" alignment="right" title="40" drawsBackground="YES" id="269">
-                        <font key="font" metaFont="system"/>
-                        <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                        <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                    </textFieldCell>
-                    <connections>
-                        <action selector="takeIntValueFrom:" target="267" id="313"/>
-                    </connections>
-                </textField>
-            </subviews>
-        </customView>
-        <window title="Virtual Machine Settings" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" visibleAtLaunch="NO" animationBehavior="default" id="142" userLabel="PrefsWindow">
-            <windowStyleMask key="styleMask" titled="YES" miniaturizable="YES" resizable="YES"/>
-            <windowPositionMask key="initialPositionMask" leftStrut="YES" rightStrut="YES" topStrut="YES" bottomStrut="YES"/>
-            <rect key="contentRect" x="217" y="242" width="580" height="460"/>
-            <rect key="screenRect" x="0.0" y="0.0" width="1440" height="878"/>
-            <value key="minSize" type="size" width="580" height="460"/>
-            <view key="contentView" id="143">
-                <rect key="frame" x="0.0" y="0.0" width="580" height="460"/>
-                <autoresizingMask key="autoresizingMask"/>
-                <subviews>
-                    <tabView id="144">
-                        <rect key="frame" x="13" y="59" width="554" height="395"/>
-                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                        <font key="font" metaFont="system"/>
-                        <tabViewItems>
-                            <tabViewItem label="Setup" identifier="1" id="145">
-                                <view key="view" id="230">
-                                    <rect key="frame" x="10" y="33" width="534" height="349"/>
-                                    <autoresizingMask key="autoresizingMask"/>
-                                    <subviews>
-                                        <textField verticalHuggingPriority="750" id="239">
-                                            <rect key="frame" x="95" y="50" width="327" height="22"/>
-                                            <autoresizingMask key="autoresizingMask" widthSizable="YES"/>
-                                            <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" drawsBackground="YES" id="257">
-                                                <font key="font" metaFont="system"/>
-                                                <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                                                <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                            </textFieldCell>
-                                        </textField>
-                                        <textField verticalHuggingPriority="750" id="237">
-                                            <rect key="frame" x="95" y="78" width="327" height="22"/>
-                                            <autoresizingMask key="autoresizingMask" widthSizable="YES"/>
-                                            <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" drawsBackground="YES" id="259">
-                                                <font key="font" metaFont="system"/>
-                                                <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                                                <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                            </textFieldCell>
-                                        </textField>
-                                        <textField verticalHuggingPriority="750" id="241">
-                                            <rect key="frame" x="14" y="52" width="77" height="17"/>
-                                            <autoresizingMask key="autoresizingMask"/>
-                                            <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="Unix Root:" id="244">
-                                                <font key="font" metaFont="system"/>
-                                                <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                            </textFieldCell>
-                                        </textField>
-                                        <textField verticalHuggingPriority="750" id="235">
-                                            <rect key="frame" x="20" y="80" width="71" height="17"/>
-                                            <autoresizingMask key="autoresizingMask"/>
-                                            <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="ROM File:" id="261">
-                                                <font key="font" metaFont="system"/>
-                                                <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                            </textFieldCell>
-                                        </textField>
-                                        <box title="Volumes" id="240">
-                                            <rect key="frame" x="6" y="123" width="522" height="226"/>
-                                            <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                                            <view key="contentView" id="rto-ZU-5QM">
-                                                <rect key="frame" x="2" y="2" width="518" height="209"/>
-                                                <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                                                <subviews>
-                                                    <button verticalHuggingPriority="750" imageHugsTitle="YES" id="245">
-                                                        <rect key="frame" x="10" y="5" width="82" height="32"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMaxY="YES"/>
-                                                        <buttonCell key="cell" type="push" title="Add..." bezelStyle="rounded" alignment="center" borderStyle="border" inset="2" id="256">
-                                                            <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                        <connections>
-                                                            <action selector="addDisk:" target="-2" id="328"/>
-                                                        </connections>
-                                                    </button>
-                                                    <button verticalHuggingPriority="750" imageHugsTitle="YES" id="246">
-                                                        <rect key="frame" x="211" y="5" width="94" height="32"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMinX="YES" flexibleMaxX="YES" flexibleMaxY="YES"/>
-                                                        <buttonCell key="cell" type="push" title="Create..." bezelStyle="rounded" alignment="center" borderStyle="border" inset="2" id="255">
-                                                            <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                        <connections>
-                                                            <action selector="createDisk:" target="-2" id="329"/>
-                                                        </connections>
-                                                    </button>
-                                                    <button verticalHuggingPriority="750" imageHugsTitle="YES" id="247">
-                                                        <rect key="frame" x="417" y="5" width="90" height="32"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMinX="YES" flexibleMaxY="YES"/>
-                                                        <buttonCell key="cell" type="push" title="Remove" bezelStyle="rounded" alignment="center" borderStyle="border" inset="2" id="254">
-                                                            <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                        <connections>
-                                                            <action selector="removeDisk:" target="-2" id="330"/>
-                                                        </connections>
-                                                    </button>
-                                                    <scrollView horizontalLineScroll="19" horizontalPageScroll="10" verticalLineScroll="19" verticalPageScroll="10" hasHorizontalScroller="NO" usesPredominantAxisScrolling="NO" id="248">
-                                                        <rect key="frame" x="16" y="42" width="485" height="154"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                                                        <clipView key="contentView" id="I8E-z9-99X">
-                                                            <rect key="frame" x="1" y="0.0" width="468" height="153"/>
-                                                            <autoresizingMask key="autoresizingMask"/>
-                                                            <subviews>
-                                                                <tableView verticalHuggingPriority="750" allowsExpansionToolTips="YES" columnAutoresizingStyle="lastColumnOnly" alternatingRowBackgroundColors="YES" columnReordering="NO" columnResizing="NO" multipleSelection="NO" autosaveColumns="NO" headerView="390" id="251">
-                                                                    <rect key="frame" x="0.0" y="0.0" width="468" height="130"/>
-                                                                    <autoresizingMask key="autoresizingMask"/>
-                                                                    <size key="intercellSpacing" width="3" height="2"/>
-                                                                    <color key="backgroundColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
-                                                                    <tableViewGridLines key="gridStyleMask" horizontal="YES"/>
-                                                                    <color key="gridColor" name="gridColor" catalog="System" colorSpace="catalog"/>
-                                                                    <tableColumns>
-                                                                        <tableColumn identifier="pathCol" editable="NO" width="371" minWidth="40" maxWidth="1000" id="252">
-                                                                            <tableHeaderCell key="headerCell" lineBreakMode="truncatingTail" borderStyle="border" alignment="left" title="File">
-                                                                                <font key="font" metaFont="system" size="11"/>
-                                                                                <color key="textColor" name="headerTextColor" catalog="System" colorSpace="catalog"/>
-                                                                                <color key="backgroundColor" white="0.33333299" alpha="1" colorSpace="calibratedWhite"/>
-                                                                            </tableHeaderCell>
-                                                                            <textFieldCell key="dataCell" lineBreakMode="truncatingTail" selectable="YES" editable="YES" alignment="left" id="253">
-                                                                                <font key="font" metaFont="system"/>
-                                                                                <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                                                <color key="backgroundColor" name="controlBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                                            </textFieldCell>
-                                                                        </tableColumn>
-                                                                        <tableColumn identifier="isCDROMcol" width="64" minWidth="10" maxWidth="3.4028234663852886e+38" id="388">
-                                                                            <tableHeaderCell key="headerCell" lineBreakMode="truncatingTail" borderStyle="border" alignment="left" title="CDROM">
-                                                                                <font key="font" metaFont="system" size="11"/>
-                                                                                <color key="textColor" name="headerTextColor" catalog="System" colorSpace="catalog"/>
-                                                                                <color key="backgroundColor" name="headerColor" catalog="System" colorSpace="catalog"/>
-                                                                            </tableHeaderCell>
-                                                                            <buttonCell key="dataCell" type="check" bezelStyle="regularSquare" imagePosition="overlaps" alignment="left" inset="2" id="391">
-                                                                                <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                                                                                <font key="font" metaFont="system"/>
-                                                                            </buttonCell>
-                                                                            <tableColumnResizingMask key="resizingMask" resizeWithTable="YES" userResizable="YES"/>
-                                                                        </tableColumn>
-                                                                    </tableColumns>
-                                                                </tableView>
-                                                            </subviews>
-                                                        </clipView>
-                                                        <scroller key="horizontalScroller" hidden="YES" verticalHuggingPriority="750" horizontal="YES" id="249">
-                                                            <rect key="frame" x="-100" y="-100" width="374" height="15"/>
-                                                            <autoresizingMask key="autoresizingMask"/>
-                                                        </scroller>
-                                                        <scroller key="verticalScroller" verticalHuggingPriority="750" horizontal="NO" id="250">
-                                                            <rect key="frame" x="469" y="23" width="15" height="130"/>
-                                                            <autoresizingMask key="autoresizingMask"/>
-                                                        </scroller>
-                                                        <tableHeaderView key="headerView" id="390">
-                                                            <rect key="frame" x="0.0" y="0.0" width="468" height="23"/>
-                                                            <autoresizingMask key="autoresizingMask"/>
-                                                        </tableHeaderView>
-                                                    </scrollView>
-                                                </subviews>
-                                            </view>
-                                            <font key="titleFont" metaFont="system" size="11"/>
-                                        </box>
-                                        <textField verticalHuggingPriority="750" id="233">
-                                            <rect key="frame" x="14" y="22" width="77" height="17"/>
-                                            <autoresizingMask key="autoresizingMask"/>
-                                            <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="Boot From:" id="263">
-                                                <font key="font" metaFont="system"/>
-                                                <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                            </textFieldCell>
-                                        </textField>
-                                        <comboBox verticalHuggingPriority="750" textCompletion="NO" id="231">
-                                            <rect key="frame" x="95" y="18" width="94" height="26"/>
-                                            <autoresizingMask key="autoresizingMask"/>
-                                            <comboBoxCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" borderStyle="bezel" title="Any" drawsBackground="YES" completes="NO" numberOfVisibleItems="5" id="265">
-                                                <font key="font" metaFont="system"/>
-                                                <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                <objectValues>
-                                                    <string>Any</string>
-                                                    <string>CD-ROM</string>
-                                                </objectValues>
-                                            </comboBoxCell>
-                                        </comboBox>
-                                        <button imageHugsTitle="YES" id="236">
-                                            <rect key="frame" x="390" y="22" width="129" height="18"/>
-                                            <autoresizingMask key="autoresizingMask"/>
-                                            <buttonCell key="cell" type="check" title="Disable CD-ROM" bezelStyle="regularSquare" imagePosition="leading" alignment="left" inset="2" id="260">
-                                                <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                                                <font key="font" metaFont="system"/>
-                                            </buttonCell>
-                                        </button>
-                                        <stepper horizontalHuggingPriority="750" verticalHuggingPriority="750" id="232">
-                                            <rect key="frame" x="355" y="17" width="22" height="28"/>
-                                            <autoresizingMask key="autoresizingMask"/>
-                                            <stepperCell key="cell" continuous="YES" state="on" alignment="left" minValue="4" maxValue="1024" doubleValue="19" id="264"/>
-                                            <connections>
-                                                <action selector="takeIntValueFrom:" target="238" id="311"/>
-                                            </connections>
-                                        </stepper>
-                                        <textField verticalHuggingPriority="750" id="238">
-                                            <rect key="frame" x="309" y="20" width="41" height="22"/>
-                                            <autoresizingMask key="autoresizingMask"/>
-                                            <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" alignment="right" title="64" drawsBackground="YES" id="258">
-                                                <font key="font" metaFont="system"/>
-                                                <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                                                <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                            </textFieldCell>
-                                            <connections>
-                                                <action selector="takeIntValueFrom:" target="232" id="310"/>
-                                            </connections>
-                                        </textField>
-                                        <textField verticalHuggingPriority="750" id="234">
-                                            <rect key="frame" x="200" y="20" width="104" height="19"/>
-                                            <autoresizingMask key="autoresizingMask"/>
-                                            <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="RAM Size (MB):" id="262">
-                                                <font key="font" metaFont="system"/>
-                                                <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                            </textFieldCell>
-                                        </textField>
-                                        <button verticalHuggingPriority="750" imageHugsTitle="YES" id="242">
-                                            <rect key="frame" x="425" y="72" width="98" height="32"/>
-                                            <autoresizingMask key="autoresizingMask" flexibleMinX="YES" flexibleMaxY="YES"/>
-                                            <buttonCell key="cell" type="push" title="Browse..." bezelStyle="rounded" alignment="center" borderStyle="border" inset="2" id="243">
-                                                <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
-                                                <font key="font" metaFont="system"/>
-                                            </buttonCell>
-                                            <connections>
-                                                <action selector="browseForROMFileClicked:" target="-2" id="327"/>
-                                            </connections>
-                                        </button>
-                                        <button verticalHuggingPriority="750" imageHugsTitle="YES" id="364">
-                                            <rect key="frame" x="425" y="44" width="98" height="32"/>
-                                            <autoresizingMask key="autoresizingMask" flexibleMinX="YES" flexibleMaxY="YES"/>
-                                            <buttonCell key="cell" type="push" title="Browse..." bezelStyle="rounded" alignment="center" borderStyle="border" inset="2" id="365">
-                                                <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
-                                                <font key="font" metaFont="system"/>
-                                            </buttonCell>
-                                            <connections>
-                                                <action selector="browseForUnixRootClicked:" target="-2" id="369"/>
-                                            </connections>
-                                        </button>
-                                    </subviews>
-                                </view>
-                            </tabViewItem>
-                            <tabViewItem label="Audio / Video" identifier="2" id="147">
-                                <view key="view" id="148">
-                                    <rect key="frame" x="10" y="33" width="534" height="349"/>
-                                    <autoresizingMask key="autoresizingMask"/>
-                                    <subviews>
-                                        <box title=" Video Settings" id="157">
-                                            <rect key="frame" x="6" y="155" width="522" height="194"/>
-                                            <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                            <view key="contentView" id="3bE-hK-msd">
-                                                <rect key="frame" x="2" y="2" width="518" height="177"/>
-                                                <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                                                <subviews>
-                                                    <button imageHugsTitle="YES" id="153">
-                                                        <rect key="frame" x="125" y="20" width="218" height="18"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMaxX="YES" flexibleMinY="YES"/>
-                                                        <buttonCell key="cell" type="check" title="Enable QuickDraw Acceleration" bezelStyle="regularSquare" imagePosition="leading" alignment="left" state="on" inset="2" id="182">
-                                                            <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                    </button>
-                                                    <popUpButton verticalHuggingPriority="750" imageHugsTitle="YES" id="151">
-                                                        <rect key="frame" x="206" y="132" width="143" height="26"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                                        <popUpButtonCell key="cell" type="push" title="Window" bezelStyle="rounded" alignment="left" lineBreakMode="truncatingTail" state="on" borderStyle="borderAndBezel" tag="1" inset="2" arrowPosition="arrowAtCenter" preferredEdge="maxY" selectedItem="186" id="184">
-                                                            <behavior key="behavior" lightByBackground="YES" lightByGray="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                            <menu key="menu" title="OtherViews" id="185">
-                                                                <items>
-                                                                    <menuItem title="Window" state="on" tag="1" id="186"/>
-                                                                    <menuItem title="Fullscreen" tag="2" id="187"/>
-                                                                </items>
-                                                            </menu>
-                                                        </popUpButtonCell>
-                                                    </popUpButton>
-                                                    <popUpButton verticalHuggingPriority="750" imageHugsTitle="YES" id="156">
-                                                        <rect key="frame" x="206" y="104" width="143" height="26"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                                        <popUpButtonCell key="cell" type="push" title="30 Hz" bezelStyle="rounded" alignment="left" lineBreakMode="truncatingTail" state="on" borderStyle="borderAndBezel" inset="2" arrowPosition="arrowAtCenter" preferredEdge="maxY" selectedItem="176" id="172">
-                                                            <behavior key="behavior" lightByBackground="YES" lightByGray="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                            <menu key="menu" title="OtherViews" id="173">
-                                                                <items>
-                                                                    <menuItem title="5 Hz" id="178"/>
-                                                                    <menuItem title="7.5 Hz" id="174"/>
-                                                                    <menuItem title="10 Hz" id="177"/>
-                                                                    <menuItem title="15 Hz" id="179"/>
-                                                                    <menuItem title="30 Hz" state="on" id="176"/>
-                                                                    <menuItem title="60 Hz" id="175"/>
-                                                                    <menuItem title="Dynamic" id="375"/>
-                                                                </items>
-                                                            </menu>
-                                                        </popUpButtonCell>
-                                                    </popUpButton>
-                                                    <textField verticalHuggingPriority="750" id="152">
-                                                        <rect key="frame" x="118" y="80" width="86" height="17"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="Width:" id="183">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="162">
-                                                        <rect key="frame" x="118" y="52" width="86" height="17"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="Height:" id="167">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <comboBox verticalHuggingPriority="750" textCompletion="NO" id="154">
-                                                        <rect key="frame" x="209" y="76" width="140" height="26"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                                        <comboBoxCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" borderStyle="bezel" title="800" drawsBackground="YES" completes="NO" numberOfVisibleItems="5" id="181">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                            <objectValues>
-                                                                <string>512</string>
-                                                                <string>640</string>
-                                                                <string>800</string>
-                                                                <string>1024</string>
-                                                                <string>Maximum</string>
-                                                            </objectValues>
-                                                        </comboBoxCell>
-                                                    </comboBox>
-                                                    <comboBox verticalHuggingPriority="750" textCompletion="NO" id="149">
-                                                        <rect key="frame" x="209" y="48" width="140" height="26"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                                        <comboBoxCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" borderStyle="bezel" title="600" drawsBackground="YES" completes="NO" numberOfVisibleItems="5" id="188">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                            <objectValues>
-                                                                <string>384</string>
-                                                                <string>480</string>
-                                                                <string>600</string>
-                                                                <string>768</string>
-                                                                <string>Maximum</string>
-                                                            </objectValues>
-                                                        </comboBoxCell>
-                                                    </comboBox>
-                                                    <textField verticalHuggingPriority="750" id="155">
-                                                        <rect key="frame" x="118" y="136" width="86" height="19"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="Video Type:" id="180">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="163">
-                                                        <rect key="frame" x="112" y="108" width="92" height="19"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="Refresh Rate:" id="166">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                </subviews>
-                                            </view>
-                                            <font key="titleFont" metaFont="system" size="11"/>
-                                        </box>
-                                        <box title="Audio Settings" id="150">
-                                            <rect key="frame" x="6" y="0.0" width="522" height="151"/>
-                                            <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                            <view key="contentView" id="scd-0M-Cpb">
-                                                <rect key="frame" x="2" y="2" width="518" height="134"/>
-                                                <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                                                <subviews>
-                                                    <button imageHugsTitle="YES" id="160">
-                                                        <rect key="frame" x="15" y="96" width="172" height="18"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMinY="YES"/>
-                                                        <buttonCell key="cell" type="check" title="Disable Audio Output" bezelStyle="regularSquare" imagePosition="leading" alignment="left" inset="2" id="169">
-                                                            <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                    </button>
-                                                    <textField verticalHuggingPriority="750" id="158">
-                                                        <rect key="frame" x="118" y="59" width="379" height="22"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" title="/dev/dsp" drawsBackground="YES" id="171">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="161">
-                                                        <rect key="frame" x="118" y="29" width="379" height="22"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" title="/dev/mixer" drawsBackground="YES" id="168">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="164">
-                                                        <rect key="frame" x="14" y="61" width="99" height="17"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="Output Device:" id="165">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="159">
-                                                        <rect key="frame" x="14" y="31" width="99" height="17"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="Mixer Device:" id="170">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                </subviews>
-                                            </view>
-                                            <font key="titleFont" metaFont="system" size="11"/>
-                                        </box>
-                                    </subviews>
-                                </view>
-                            </tabViewItem>
-                            <tabViewItem label="Miscellaneous" identifier="Item 4" id="358">
-                                <view key="view" id="359">
-                                    <rect key="frame" x="10" y="33" width="534" height="349"/>
-                                    <autoresizingMask key="autoresizingMask"/>
-                                    <subviews>
-                                        <box title="Serial/Network" id="194">
-                                            <rect key="frame" x="6" y="4" width="522" height="123"/>
-                                            <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                            <view key="contentView" id="rC8-ME-diB">
-                                                <rect key="frame" x="2" y="2" width="518" height="106"/>
-                                                <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                                                <subviews>
-                                                    <textField verticalHuggingPriority="750" id="214">
-                                                        <rect key="frame" x="13" y="75" width="130" height="17"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" sendsActionOnEndEditing="YES" alignment="right" title="Modem Port Device:" id="225">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="215">
-                                                        <rect key="frame" x="18" y="43" width="125" height="17"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" sendsActionOnEndEditing="YES" alignment="right" title="Printer Port Device:" id="224">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="216">
-                                                        <rect key="frame" x="18" y="13" width="126" height="17"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" sendsActionOnEndEditing="YES" alignment="right" title="Ethernet Interface:" id="223">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="217">
-                                                        <rect key="frame" x="146" y="73" width="351" height="22"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" alignment="left" drawsBackground="YES" id="222">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="218">
-                                                        <rect key="frame" x="146" y="41" width="351" height="22"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" alignment="left" drawsBackground="YES" id="221">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="219">
-                                                        <rect key="frame" x="146" y="10" width="351" height="22"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" alignment="left" title="slirp" drawsBackground="YES" id="220">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                </subviews>
-                                            </view>
-                                            <font key="titleFont" metaFont="system" size="11"/>
-                                        </box>
-                                        <box title="CPU Options" id="195">
-                                            <rect key="frame" x="6" y="255" width="522" height="94"/>
-                                            <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                            <view key="contentView" id="zKz-zb-2Yf">
-                                                <rect key="frame" x="2" y="2" width="518" height="77"/>
-                                                <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                                                <subviews>
-                                                    <button imageHugsTitle="YES" id="191">
-                                                        <rect key="frame" x="15" y="51" width="150" height="18"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <buttonCell key="cell" type="check" title="Enable JIT Compiler" bezelStyle="regularSquare" imagePosition="leading" alignment="left" state="on" inset="2" id="228">
-                                                            <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                    </button>
-                                                    <button imageHugsTitle="YES" id="193">
-                                                        <rect key="frame" x="15" y="11" width="333" height="18"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <buttonCell key="cell" type="check" title="Enable built-in 68k DR Emulator (EXPERIMENTAL)" bezelStyle="regularSquare" imagePosition="leading" alignment="left" inset="2" id="226">
-                                                            <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                    </button>
-                                                    <button imageHugsTitle="YES" id="190">
-                                                        <rect key="frame" x="15" y="31" width="236" height="18"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <buttonCell key="cell" type="check" title="Allow Emulated CPU to Idle" bezelStyle="regularSquare" imagePosition="leading" alignment="left" inset="2" id="229">
-                                                            <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                    </button>
-                                                    <button imageHugsTitle="YES" id="370">
-                                                        <rect key="frame" x="269" y="51" width="220" height="18"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMinX="YES" flexibleMinY="YES"/>
-                                                        <buttonCell key="cell" type="check" title="Ignore Illegal Instructions" bezelStyle="regularSquare" imagePosition="leading" alignment="left" inset="2" id="371">
-                                                            <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                    </button>
-                                                    <button imageHugsTitle="YES" id="192">
-                                                        <rect key="frame" x="269" y="31" width="220" height="18"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMinX="YES" flexibleMinY="YES"/>
-                                                        <buttonCell key="cell" type="check" title="Ignore Illegal Memory Accesses" bezelStyle="regularSquare" imagePosition="leading" alignment="left" inset="2" id="227">
-                                                            <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                    </button>
-                                                </subviews>
-                                            </view>
-                                            <font key="titleFont" metaFont="system" size="11"/>
-                                        </box>
-                                        <box title="Mouse/Keyboard" id="203">
-                                            <rect key="frame" x="6" y="131" width="522" height="120"/>
-                                            <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                            <view key="contentView" id="gpc-m9-mow">
-                                                <rect key="frame" x="2" y="2" width="518" height="103"/>
-                                                <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                                                <subviews>
-                                                    <button imageHugsTitle="YES" id="196">
-                                                        <rect key="frame" x="22" y="70" width="142" height="18"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <buttonCell key="cell" type="check" title="Use Raw Keycodes:" bezelStyle="regularSquare" imagePosition="leading" alignment="left" inset="2" id="213">
-                                                            <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                        <connections>
-                                                            <action selector="useRawKeyCodesClicked:" target="-2" id="331"/>
-                                                        </connections>
-                                                    </button>
-                                                    <textField verticalHuggingPriority="750" id="197">
-                                                        <rect key="frame" x="170" y="69" width="239" height="22"/>
-                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES"/>
-                                                        <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" drawsBackground="YES" id="212">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="198">
-                                                        <rect key="frame" x="14" y="43" width="151" height="17"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="Mouse Wheel Function:" id="211">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="199">
-                                                        <rect key="frame" x="66" y="15" width="99" height="17"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <textFieldCell key="cell" sendsActionOnEndEditing="YES" alignment="right" title="Lines to Scroll:" id="210">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                    </textField>
-                                                    <textField verticalHuggingPriority="750" id="200">
-                                                        <rect key="frame" x="170" y="13" width="29" height="22"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" title="3" drawsBackground="YES" id="209">
-                                                            <font key="font" metaFont="system"/>
-                                                            <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
-                                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
-                                                        </textFieldCell>
-                                                        <connections>
-                                                            <action selector="takeIntValueFrom:" target="202" id="282"/>
-                                                        </connections>
-                                                    </textField>
-                                                    <popUpButton verticalHuggingPriority="750" imageHugsTitle="YES" id="201">
-                                                        <rect key="frame" x="167" y="37" width="163" height="26"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <popUpButtonCell key="cell" type="push" title="Page Up/Down" bezelStyle="rounded" alignment="left" lineBreakMode="truncatingTail" state="on" borderStyle="borderAndBezel" inset="2" arrowPosition="arrowAtCenter" preferredEdge="maxY" selectedItem="208" id="205">
-                                                            <behavior key="behavior" lightByBackground="YES" lightByGray="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                            <menu key="menu" title="OtherViews" id="206">
-                                                                <items>
-                                                                    <menuItem title="Page Up/Down" state="on" id="208"/>
-                                                                    <menuItem title="Cursor Up/Down" id="207"/>
-                                                                </items>
-                                                            </menu>
-                                                        </popUpButtonCell>
-                                                    </popUpButton>
-                                                    <stepper horizontalHuggingPriority="750" verticalHuggingPriority="750" id="202">
-                                                        <rect key="frame" x="204" y="10" width="19" height="27"/>
-                                                        <autoresizingMask key="autoresizingMask"/>
-                                                        <stepperCell key="cell" continuous="YES" alignment="left" maxValue="59" valueWraps="YES" id="204"/>
-                                                        <connections>
-                                                            <action selector="takeIntValueFrom:" target="200" id="314"/>
-                                                        </connections>
-                                                    </stepper>
-                                                    <button verticalHuggingPriority="750" imageHugsTitle="YES" id="376">
-                                                        <rect key="frame" x="411" y="63" width="96" height="32"/>
-                                                        <autoresizingMask key="autoresizingMask" flexibleMinX="YES" flexibleMaxY="YES"/>
-                                                        <buttonCell key="cell" type="push" title="Browse..." bezelStyle="rounded" alignment="center" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="377">
-                                                            <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
-                                                            <font key="font" metaFont="system"/>
-                                                        </buttonCell>
-                                                        <connections>
-                                                            <action selector="browseForKeyCodesFileClicked:" target="-2" id="378"/>
-                                                        </connections>
-                                                    </button>
-                                                </subviews>
-                                            </view>
-                                            <font key="titleFont" metaFont="system" size="11"/>
-                                        </box>
-                                    </subviews>
-                                </view>
-                            </tabViewItem>
-                        </tabViewItems>
-                    </tabView>
-                    <button verticalHuggingPriority="750" imageHugsTitle="YES" id="360">
-                        <rect key="frame" x="374" y="20" width="96" height="32"/>
-                        <autoresizingMask key="autoresizingMask" flexibleMinX="YES" flexibleMaxY="YES"/>
-                        <buttonCell key="cell" type="push" title="Cancel" bezelStyle="rounded" alignment="center" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="361">
-                            <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
-                            <font key="font" metaFont="system"/>
-                        </buttonCell>
-                        <connections>
-                            <action selector="cancelEdit:" target="-2" id="374"/>
-                        </connections>
-                    </button>
-                    <button verticalHuggingPriority="750" imageHugsTitle="YES" id="362">
-                        <rect key="frame" x="470" y="20" width="96" height="32"/>
-                        <autoresizingMask key="autoresizingMask" flexibleMinX="YES" flexibleMaxY="YES"/>
-                        <buttonCell key="cell" type="push" title="Save" bezelStyle="rounded" alignment="center" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="363">
-                            <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
-                            <font key="font" metaFont="system"/>
-                        </buttonCell>
-                        <connections>
-                            <action selector="saveChanges:" target="-2" id="373"/>
-                        </connections>
-                    </button>
-                </subviews>
-            </view>
-            <connections>
-                <outlet property="delegate" destination="-2" id="355"/>
-                <outlet property="initialFirstResponder" destination="237" id="283"/>
-            </connections>
-        </window>
-        <customView id="380" userLabel="IsCDROM">
-            <rect key="frame" x="0.0" y="0.0" width="121" height="54"/>
-            <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMinY="YES"/>
-            <subviews>
-                <button imageHugsTitle="YES" id="381">
-                    <rect key="frame" x="18" y="18" width="85" height="18"/>
-                    <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMinY="YES"/>
-                    <buttonCell key="cell" type="check" title="Is CDROM" bezelStyle="regularSquare" imagePosition="leading" alignment="left" inset="2" id="382">
-                        <behavior key="behavior" changeContents="YES" doesNotDimImage="YES" lightByContents="YES"/>
-                        <font key="font" metaFont="system"/>
-                    </buttonCell>
-                </button>
-            </subviews>
-        </customView>
-    </objects>
-</document>
+<archive type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="7.03">
+	<data>
+		<int key="IBDocument.SystemTarget">1050</int>
+		<string key="IBDocument.SystemVersion">9J61</string>
+		<string key="IBDocument.InterfaceBuilderVersion">677</string>
+		<string key="IBDocument.AppKitVersion">949.46</string>
+		<string key="IBDocument.HIToolboxVersion">353.00</string>
+		<object class="NSMutableArray" key="IBDocument.EditedObjectIDs">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<integer value="145"/>
+		</object>
+		<object class="NSArray" key="IBDocument.PluginDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.Metadata">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="NSArray" key="dict.sortedKeys">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+			</object>
+			<object class="NSMutableArray" key="dict.values">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+			</object>
+		</object>
+		<object class="NSMutableArray" key="IBDocument.RootObjects" id="1000">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="NSCustomObject" id="1001">
+				<string key="NSClassName">VMSettingsController</string>
+			</object>
+			<object class="NSCustomObject" id="1003">
+				<string key="NSClassName">FirstResponder</string>
+			</object>
+			<object class="NSCustomObject" id="1004">
+				<string key="NSClassName">NSApplication</string>
+			</object>
+			<object class="NSCustomView" id="232610295">
+				<nil key="NSNextResponder"/>
+				<int key="NSvFlags">256</int>
+				<object class="NSMutableArray" key="NSSubviews">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="NSTextField" id="513058772">
+						<reference key="NSNextResponder" ref="232610295"/>
+						<int key="NSvFlags">256</int>
+						<string key="NSFrame">{{145, 20}, {43, 22}}</string>
+						<reference key="NSSuperview" ref="232610295"/>
+						<bool key="NSEnabled">YES</bool>
+						<object class="NSTextFieldCell" key="NSCell" id="490503381">
+							<int key="NSCellFlags">-1804468671</int>
+							<int key="NSCellFlags2">71304192</int>
+							<string key="NSContents">40</string>
+							<object class="NSFont" key="NSSupport" id="112300701">
+								<string key="NSName">LucidaGrande</string>
+								<double key="NSSize">1.300000e+01</double>
+								<int key="NSfFlags">1044</int>
+							</object>
+							<reference key="NSControlView" ref="513058772"/>
+							<bool key="NSDrawsBackground">YES</bool>
+							<object class="NSColor" key="NSBackgroundColor" id="1055309587">
+								<int key="NSColorSpace">6</int>
+								<string key="NSCatalogName">System</string>
+								<string key="NSColorName">textBackgroundColor</string>
+								<object class="NSColor" key="NSColor" id="80349926">
+									<int key="NSColorSpace">3</int>
+									<bytes key="NSWhite">MQA</bytes>
+								</object>
+							</object>
+							<object class="NSColor" key="NSTextColor" id="559183679">
+								<int key="NSColorSpace">6</int>
+								<string key="NSCatalogName">System</string>
+								<string key="NSColorName">textColor</string>
+								<object class="NSColor" key="NSColor" id="371072340">
+									<int key="NSColorSpace">3</int>
+									<bytes key="NSWhite">MAA</bytes>
+								</object>
+							</object>
+						</object>
+					</object>
+					<object class="NSStepper" id="321640330">
+						<reference key="NSNextResponder" ref="232610295"/>
+						<int key="NSvFlags">256</int>
+						<string key="NSFrame">{{193, 17}, {19, 27}}</string>
+						<reference key="NSSuperview" ref="232610295"/>
+						<int key="NSTag">1</int>
+						<bool key="NSEnabled">YES</bool>
+						<object class="NSStepperCell" key="NSCell" id="184243903">
+							<int key="NSCellFlags">917024</int>
+							<int key="NSCellFlags2">0</int>
+							<int key="NSTag">1</int>
+							<reference key="NSControlView" ref="321640330"/>
+							<double key="NSValue">4.000000e+01</double>
+							<double key="NSMinValue">1.000000e+00</double>
+							<double key="NSMaxValue">1.000000e+04</double>
+							<double key="NSIncrement">1.000000e+00</double>
+							<bool key="NSValueWraps">YES</bool>
+							<bool key="NSAutorepeat">YES</bool>
+						</object>
+					</object>
+					<object class="NSTextField" id="548109881">
+						<reference key="NSNextResponder" ref="232610295"/>
+						<int key="NSvFlags">256</int>
+						<string key="NSFrame">{{17, 22}, {114, 17}}</string>
+						<reference key="NSSuperview" ref="232610295"/>
+						<bool key="NSEnabled">YES</bool>
+						<object class="NSTextFieldCell" key="NSCell" id="957404182">
+							<int key="NSCellFlags">67239424</int>
+							<int key="NSCellFlags2">272629760</int>
+							<string key="NSContents">Volume Size (MB)</string>
+							<reference key="NSSupport" ref="112300701"/>
+							<reference key="NSControlView" ref="548109881"/>
+							<object class="NSColor" key="NSBackgroundColor" id="905988731">
+								<int key="NSColorSpace">6</int>
+								<string key="NSCatalogName">System</string>
+								<string key="NSColorName">controlColor</string>
+								<object class="NSColor" key="NSColor" id="840516165">
+									<int key="NSColorSpace">3</int>
+									<bytes key="NSWhite">MC42NjY2NjY2OQA</bytes>
+								</object>
+							</object>
+							<object class="NSColor" key="NSTextColor" id="502107268">
+								<int key="NSColorSpace">6</int>
+								<string key="NSCatalogName">System</string>
+								<string key="NSColorName">controlTextColor</string>
+								<reference key="NSColor" ref="371072340"/>
+							</object>
+						</object>
+					</object>
+				</object>
+				<string key="NSFrameSize">{229, 62}</string>
+				<string key="NSClassName">NSView</string>
+				<string key="NSExtension">NSResponder</string>
+			</object>
+			<object class="NSWindowTemplate" id="777181097">
+				<int key="NSWindowStyleMask">13</int>
+				<int key="NSWindowBacking">2</int>
+				<string key="NSWindowRect">{{217, 242}, {580, 460}}</string>
+				<int key="NSWTFlags">1886912512</int>
+				<string key="NSWindowTitle">Virtual Machine Settings</string>
+				<object class="NSMutableString" key="NSWindowClass">
+					<characters key="NS.bytes">NSWindow</characters>
+				</object>
+				<object class="NSMutableString" key="NSViewClass">
+					<characters key="NS.bytes">View</characters>
+				</object>
+				<string key="NSWindowContentMaxSize">{3.40282e+38, 3.40282e+38}</string>
+				<string key="NSWindowContentMinSize">{580, 460}</string>
+				<object class="NSView" key="NSWindowView" id="648841812">
+					<reference key="NSNextResponder"/>
+					<int key="NSvFlags">256</int>
+					<object class="NSMutableArray" key="NSSubviews">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSTabView" id="670019266">
+							<reference key="NSNextResponder" ref="648841812"/>
+							<int key="NSvFlags">274</int>
+							<string key="NSFrame">{{13, 59}, {554, 395}}</string>
+							<reference key="NSSuperview" ref="648841812"/>
+							<object class="NSMutableArray" key="NSTabViewItems">
+								<bool key="EncodedWithXMLCoder">YES</bool>
+								<object class="NSTabViewItem" id="522700178">
+									<string key="NSIdentifier">1</string>
+									<object class="NSView" key="NSView" id="1060223166">
+										<reference key="NSNextResponder" ref="670019266"/>
+										<int key="NSvFlags">256</int>
+										<object class="NSMutableArray" key="NSSubviews">
+											<bool key="EncodedWithXMLCoder">YES</bool>
+											<object class="NSTextField" id="1052479163">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">258</int>
+												<string key="NSFrame">{{95, 50}, {327, 22}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSTextFieldCell" key="NSCell" id="564442807">
+													<int key="NSCellFlags">-1804468671</int>
+													<int key="NSCellFlags2">272630784</int>
+													<string key="NSContents"/>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="1052479163"/>
+													<bool key="NSDrawsBackground">YES</bool>
+													<reference key="NSBackgroundColor" ref="1055309587"/>
+													<reference key="NSTextColor" ref="559183679"/>
+												</object>
+											</object>
+											<object class="NSTextField" id="980817371">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">258</int>
+												<string key="NSFrame">{{95, 78}, {327, 22}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSTextFieldCell" key="NSCell" id="506556221">
+													<int key="NSCellFlags">-1804468671</int>
+													<int key="NSCellFlags2">272630784</int>
+													<string key="NSContents"/>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="980817371"/>
+													<bool key="NSDrawsBackground">YES</bool>
+													<reference key="NSBackgroundColor" ref="1055309587"/>
+													<reference key="NSTextColor" ref="559183679"/>
+												</object>
+											</object>
+											<object class="NSTextField" id="269336484">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">256</int>
+												<string key="NSFrame">{{14, 52}, {77, 17}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSTextFieldCell" key="NSCell" id="557060164">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">71303168</int>
+													<string key="NSContents">Unix Root:</string>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="269336484"/>
+													<reference key="NSBackgroundColor" ref="905988731"/>
+													<reference key="NSTextColor" ref="502107268"/>
+												</object>
+											</object>
+											<object class="NSTextField" id="4371419">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">256</int>
+												<string key="NSFrame">{{20, 80}, {71, 17}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSTextFieldCell" key="NSCell" id="1023148966">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">71303168</int>
+													<string key="NSContents">ROM File:</string>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="4371419"/>
+													<reference key="NSBackgroundColor" ref="905988731"/>
+													<reference key="NSTextColor" ref="502107268"/>
+												</object>
+											</object>
+											<object class="NSBox" id="807453778">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">274</int>
+												<object class="NSMutableArray" key="NSSubviews">
+													<bool key="EncodedWithXMLCoder">YES</bool>
+													<object class="NSView" id="756310755">
+														<reference key="NSNextResponder" ref="807453778"/>
+														<int key="NSvFlags">256</int>
+														<object class="NSMutableArray" key="NSSubviews">
+															<bool key="EncodedWithXMLCoder">YES</bool>
+															<object class="NSButton" id="776720636">
+																<reference key="NSNextResponder" ref="756310755"/>
+																<int key="NSvFlags">292</int>
+																<string key="NSFrame">{{10, 5}, {82, 32}}</string>
+																<reference key="NSSuperview" ref="756310755"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="711415791">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">134217728</int>
+																	<string key="NSContents">Add...</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="776720636"/>
+																	<int key="NSButtonFlags">-2038284033</int>
+																	<int key="NSButtonFlags2">1</int>
+																	<reference key="NSAlternateImage" ref="112300701"/>
+																	<string key="NSAlternateContents"/>
+																	<object class="NSMutableString" key="NSKeyEquivalent">
+																		<characters key="NS.bytes"/>
+																	</object>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+															<object class="NSButton" id="615553393">
+																<reference key="NSNextResponder" ref="756310755"/>
+																<int key="NSvFlags">293</int>
+																<string key="NSFrame">{{211, 5}, {94, 32}}</string>
+																<reference key="NSSuperview" ref="756310755"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="1037106617">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">134217728</int>
+																	<string key="NSContents">Create...</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="615553393"/>
+																	<int key="NSButtonFlags">-2038284033</int>
+																	<int key="NSButtonFlags2">1</int>
+																	<reference key="NSAlternateImage" ref="112300701"/>
+																	<string key="NSAlternateContents"/>
+																	<object class="NSMutableString" key="NSKeyEquivalent">
+																		<characters key="NS.bytes"/>
+																	</object>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+															<object class="NSButton" id="760806366">
+																<reference key="NSNextResponder" ref="756310755"/>
+																<int key="NSvFlags">289</int>
+																<string key="NSFrame">{{417, 5}, {90, 32}}</string>
+																<reference key="NSSuperview" ref="756310755"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="288005197">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">134217728</int>
+																	<string key="NSContents">Remove</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="760806366"/>
+																	<int key="NSButtonFlags">-2038284033</int>
+																	<int key="NSButtonFlags2">1</int>
+																	<reference key="NSAlternateImage" ref="112300701"/>
+																	<string key="NSAlternateContents"/>
+																	<object class="NSMutableString" key="NSKeyEquivalent">
+																		<characters key="NS.bytes"/>
+																	</object>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+															<object class="NSScrollView" id="86054106">
+																<reference key="NSNextResponder" ref="756310755"/>
+																<int key="NSvFlags">274</int>
+																<object class="NSMutableArray" key="NSSubviews">
+																	<bool key="EncodedWithXMLCoder">YES</bool>
+																	<object class="NSClipView" id="4719808">
+																		<reference key="NSNextResponder" ref="86054106"/>
+																		<int key="NSvFlags">2304</int>
+																		<object class="NSMutableArray" key="NSSubviews">
+																			<bool key="EncodedWithXMLCoder">YES</bool>
+																			<object class="NSTableView" id="978863379">
+																				<reference key="NSNextResponder" ref="4719808"/>
+																				<int key="NSvFlags">256</int>
+																				<string key="NSFrameSize">{468, 152}</string>
+																				<reference key="NSSuperview" ref="4719808"/>
+																				<bool key="NSEnabled">YES</bool>
+																				<object class="_NSCornerView" key="NSCornerView">
+																					<nil key="NSNextResponder"/>
+																					<int key="NSvFlags">256</int>
+																					<string key="NSFrame">{{375, 0}, {16, 17}}</string>
+																				</object>
+																				<object class="NSMutableArray" key="NSTableColumns">
+																					<bool key="EncodedWithXMLCoder">YES</bool>
+																					<object class="NSTableColumn" id="305629996">
+																						<double key="NSWidth">3.710000e+02</double>
+																						<double key="NSMinWidth">4.000000e+01</double>
+																						<double key="NSMaxWidth">1.000000e+03</double>
+																						<object class="NSTableHeaderCell" key="NSHeaderCell">
+																							<int key="NSCellFlags">75628032</int>
+																							<int key="NSCellFlags2">0</int>
+																							<string key="NSContents"/>
+																							<object class="NSFont" key="NSSupport" id="26">
+																								<string key="NSName">LucidaGrande</string>
+																								<double key="NSSize">1.100000e+01</double>
+																								<int key="NSfFlags">3100</int>
+																							</object>
+																							<object class="NSColor" key="NSBackgroundColor">
+																								<int key="NSColorSpace">3</int>
+																								<bytes key="NSWhite">MC4zMzMzMzI5OQA</bytes>
+																							</object>
+																							<object class="NSColor" key="NSTextColor">
+																								<int key="NSColorSpace">6</int>
+																								<string key="NSCatalogName">System</string>
+																								<string key="NSColorName">headerTextColor</string>
+																								<reference key="NSColor" ref="371072340"/>
+																							</object>
+																						</object>
+																						<object class="NSTextFieldCell" key="NSDataCell" id="260944062">
+																							<int key="NSCellFlags">337772096</int>
+																							<int key="NSCellFlags2">2048</int>
+																							<reference key="NSSupport" ref="112300701"/>
+																							<reference key="NSControlView" ref="978863379"/>
+																							<object class="NSColor" key="NSBackgroundColor" id="379896718">
+																								<int key="NSColorSpace">6</int>
+																								<string key="NSCatalogName">System</string>
+																								<string key="NSColorName">controlBackgroundColor</string>
+																								<reference key="NSColor" ref="840516165"/>
+																							</object>
+																							<reference key="NSTextColor" ref="502107268"/>
+																						</object>
+																						<reference key="NSTableView" ref="978863379"/>
+																					</object>
+																				</object>
+																				<double key="NSIntercellSpacingWidth">3.000000e+00</double>
+																				<double key="NSIntercellSpacingHeight">2.000000e+00</double>
+																				<reference key="NSBackgroundColor" ref="80349926"/>
+																				<object class="NSColor" key="NSGridColor" id="861356657">
+																					<int key="NSColorSpace">6</int>
+																					<string key="NSCatalogName">System</string>
+																					<string key="NSColorName">gridColor</string>
+																					<object class="NSColor" key="NSColor">
+																						<int key="NSColorSpace">3</int>
+																						<bytes key="NSWhite">MC41AA</bytes>
+																					</object>
+																				</object>
+																				<double key="NSRowHeight">1.700000e+01</double>
+																				<int key="NSTvFlags">312475648</int>
+																				<int key="NSGridStyleMask">2</int>
+																				<int key="NSColumnAutoresizingStyle">4</int>
+																				<int key="NSDraggingSourceMaskForLocal">15</int>
+																				<int key="NSDraggingSourceMaskForNonLocal">0</int>
+																				<bool key="NSAllowsTypeSelect">YES</bool>
+																			</object>
+																		</object>
+																		<string key="NSFrame">{{1, 1}, {468, 152}}</string>
+																		<reference key="NSSuperview" ref="86054106"/>
+																		<reference key="NSNextKeyView" ref="978863379"/>
+																		<reference key="NSDocView" ref="978863379"/>
+																		<reference key="NSBGColor" ref="379896718"/>
+																		<int key="NScvFlags">4</int>
+																	</object>
+																	<object class="NSScroller" id="416743339">
+																		<reference key="NSNextResponder" ref="86054106"/>
+																		<int key="NSvFlags">256</int>
+																		<string key="NSFrame">{{469, 1}, {15, 152}}</string>
+																		<reference key="NSSuperview" ref="86054106"/>
+																		<reference key="NSTarget" ref="86054106"/>
+																		<string key="NSAction">_doScroller:</string>
+																		<double key="NSPercent">3.947369e-01</double>
+																	</object>
+																	<object class="NSScroller" id="873932826">
+																		<reference key="NSNextResponder" ref="86054106"/>
+																		<int key="NSvFlags">256</int>
+																		<string key="NSFrame">{{-100, -100}, {374, 15}}</string>
+																		<reference key="NSSuperview" ref="86054106"/>
+																		<int key="NSsFlags">1</int>
+																		<reference key="NSTarget" ref="86054106"/>
+																		<string key="NSAction">_doScroller:</string>
+																		<double key="NSPercent">9.904762e-01</double>
+																	</object>
+																</object>
+																<string key="NSFrame">{{16, 42}, {485, 154}}</string>
+																<reference key="NSSuperview" ref="756310755"/>
+																<reference key="NSNextKeyView" ref="4719808"/>
+																<int key="NSsFlags">18</int>
+																<reference key="NSVScroller" ref="416743339"/>
+																<reference key="NSHScroller" ref="873932826"/>
+																<reference key="NSContentView" ref="4719808"/>
+																<bytes key="NSScrollAmts">QSAAAEEgAABBmAAAQZgAAA</bytes>
+															</object>
+														</object>
+														<string key="NSFrame">{{2, 2}, {518, 209}}</string>
+														<reference key="NSSuperview" ref="807453778"/>
+													</object>
+												</object>
+												<string key="NSFrame">{{6, 123}, {522, 226}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<string key="NSOffsets">{0, 0}</string>
+												<object class="NSTextFieldCell" key="NSTitleCell">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">0</int>
+													<string key="NSContents">Volumes</string>
+													<reference key="NSSupport" ref="26"/>
+													<reference key="NSBackgroundColor" ref="1055309587"/>
+													<object class="NSColor" key="NSTextColor">
+														<int key="NSColorSpace">3</int>
+														<bytes key="NSWhite">MCAwLjgwMDAwMDAxAA</bytes>
+													</object>
+												</object>
+												<reference key="NSContentView" ref="756310755"/>
+												<int key="NSBorderType">3</int>
+												<int key="NSBoxType">0</int>
+												<int key="NSTitlePosition">2</int>
+												<bool key="NSTransparent">NO</bool>
+											</object>
+											<object class="NSTextField" id="47272907">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">256</int>
+												<string key="NSFrame">{{14, 22}, {77, 17}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSTextFieldCell" key="NSCell" id="102958279">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">71303168</int>
+													<string key="NSContents">Boot From:</string>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="47272907"/>
+													<reference key="NSBackgroundColor" ref="905988731"/>
+													<reference key="NSTextColor" ref="502107268"/>
+												</object>
+											</object>
+											<object class="NSComboBox" id="649352634">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">256</int>
+												<string key="NSFrame">{{95, 18}, {94, 26}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSComboBoxCell" key="NSCell" id="739981580">
+													<int key="NSCellFlags">343014976</int>
+													<int key="NSCellFlags2">272630784</int>
+													<string key="NSContents">Any</string>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="649352634"/>
+													<bool key="NSDrawsBackground">YES</bool>
+													<reference key="NSBackgroundColor" ref="1055309587"/>
+													<reference key="NSTextColor" ref="502107268"/>
+													<int key="NSVisibleItemCount">5</int>
+													<bool key="NSHasVerticalScroller">YES</bool>
+													<object class="NSMutableArray" key="NSPopUpListData">
+														<bool key="EncodedWithXMLCoder">YES</bool>
+														<string>Any</string>
+														<string>CD-ROM</string>
+													</object>
+													<reference key="NSDelegate" ref="649352634"/>
+													<object class="NSComboTableView" key="NSTableView" id="761652335">
+														<reference key="NSNextResponder"/>
+														<int key="NSvFlags">274</int>
+														<string key="NSFrameSize">{13, 42}</string>
+														<reference key="NSSuperview"/>
+														<reference key="NSWindow"/>
+														<bool key="NSEnabled">YES</bool>
+														<object class="NSMutableArray" key="NSTableColumns">
+															<bool key="EncodedWithXMLCoder">YES</bool>
+															<object class="NSTableColumn">
+																<integer value="0" key="NSIdentifier" id="8"/>
+																<double key="NSWidth">1.000000e+01</double>
+																<double key="NSMinWidth">1.000000e+01</double>
+																<double key="NSMaxWidth">1.000000e+03</double>
+																<object class="NSTableHeaderCell" key="NSHeaderCell">
+																	<int key="NSCellFlags">75628032</int>
+																	<int key="NSCellFlags2">0</int>
+																	<object class="NSMutableString" key="NSContents">
+																		<characters key="NS.bytes"/>
+																	</object>
+																	<object class="NSFont" key="NSSupport" id="114450232">
+																		<string key="NSName">LucidaGrande</string>
+																		<double key="NSSize">1.200000e+01</double>
+																		<int key="NSfFlags">16</int>
+																	</object>
+																	<object class="NSColor" key="NSBackgroundColor">
+																		<int key="NSColorSpace">3</int>
+																		<bytes key="NSWhite">MC4zMzMzMzI5OQA</bytes>
+																	</object>
+																	<reference key="NSTextColor" ref="80349926"/>
+																</object>
+																<object class="NSTextFieldCell" key="NSDataCell">
+																	<int key="NSCellFlags">338820672</int>
+																	<int key="NSCellFlags2">1024</int>
+																	<string key="NSContents">CD-ROM</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="761652335"/>
+																	<bool key="NSDrawsBackground">YES</bool>
+																	<reference key="NSBackgroundColor" ref="379896718"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+																<int key="NSResizingMask">3</int>
+																<bool key="NSIsResizeable">YES</bool>
+																<reference key="NSTableView" ref="761652335"/>
+															</object>
+														</object>
+														<double key="NSIntercellSpacingWidth">3.000000e+00</double>
+														<double key="NSIntercellSpacingHeight">2.000000e+00</double>
+														<reference key="NSBackgroundColor" ref="379896718"/>
+														<reference key="NSGridColor" ref="861356657"/>
+														<double key="NSRowHeight">1.900000e+01</double>
+														<string key="NSAction">tableViewAction:</string>
+														<int key="NSTvFlags">-765427712</int>
+														<reference key="NSDelegate" ref="739981580"/>
+														<reference key="NSDataSource" ref="739981580"/>
+														<reference key="NSTarget" ref="739981580"/>
+														<int key="NSColumnAutoresizingStyle">1</int>
+														<int key="NSDraggingSourceMaskForLocal">15</int>
+														<int key="NSDraggingSourceMaskForNonLocal">0</int>
+														<bool key="NSAllowsTypeSelect">YES</bool>
+													</object>
+												</object>
+											</object>
+											<object class="NSButton" id="336750324">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">256</int>
+												<string key="NSFrame">{{390, 22}, {129, 18}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSButtonCell" key="NSCell" id="558928485">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">0</int>
+													<string key="NSContents">Disable CD-ROM</string>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="336750324"/>
+													<int key="NSButtonFlags">1211912703</int>
+													<int key="NSButtonFlags2">2</int>
+													<object class="NSCustomResource" key="NSNormalImage" id="685450367">
+														<string key="NSClassName">NSImage</string>
+														<string key="NSResourceName">NSSwitch</string>
+													</object>
+													<object class="NSButtonImageSource" key="NSAlternateImage" id="278666772">
+														<string key="NSImageName">NSSwitch</string>
+													</object>
+													<string key="NSAlternateContents"/>
+													<string key="NSKeyEquivalent"/>
+													<int key="NSPeriodicDelay">200</int>
+													<int key="NSPeriodicInterval">25</int>
+												</object>
+											</object>
+											<object class="NSStepper" id="457634098">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">256</int>
+												<string key="NSFrame">{{355, 17}, {22, 28}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSStepperCell" key="NSCell" id="272257587">
+													<int key="NSCellFlags">-2146566624</int>
+													<int key="NSCellFlags2">0</int>
+													<reference key="NSControlView" ref="457634098"/>
+													<double key="NSValue">1.900000e+01</double>
+													<double key="NSMinValue">4.000000e+00</double>
+													<double key="NSMaxValue">1.024000e+03</double>
+													<double key="NSIncrement">1.000000e+00</double>
+													<bool key="NSAutorepeat">YES</bool>
+												</object>
+											</object>
+											<object class="NSTextField" id="726460923">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">256</int>
+												<string key="NSFrame">{{309, 20}, {41, 22}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSTextFieldCell" key="NSCell" id="975089353">
+													<int key="NSCellFlags">-1804468671</int>
+													<int key="NSCellFlags2">71304192</int>
+													<string key="NSContents">64</string>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="726460923"/>
+													<bool key="NSDrawsBackground">YES</bool>
+													<reference key="NSBackgroundColor" ref="1055309587"/>
+													<reference key="NSTextColor" ref="559183679"/>
+												</object>
+											</object>
+											<object class="NSTextField" id="315487663">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">256</int>
+												<string key="NSFrame">{{200, 20}, {104, 19}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSTextFieldCell" key="NSCell" id="90102410">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">71303168</int>
+													<string key="NSContents">RAM Size (MB):</string>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="315487663"/>
+													<reference key="NSBackgroundColor" ref="905988731"/>
+													<reference key="NSTextColor" ref="502107268"/>
+												</object>
+											</object>
+											<object class="NSButton" id="439199863">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">289</int>
+												<string key="NSFrame">{{425, 72}, {98, 32}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSButtonCell" key="NSCell" id="389138925">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">134217728</int>
+													<string key="NSContents">Browse...</string>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="439199863"/>
+													<int key="NSButtonFlags">-2038284033</int>
+													<int key="NSButtonFlags2">1</int>
+													<reference key="NSAlternateImage" ref="112300701"/>
+													<string key="NSAlternateContents"/>
+													<object class="NSMutableString" key="NSKeyEquivalent">
+														<characters key="NS.bytes"/>
+													</object>
+													<int key="NSPeriodicDelay">200</int>
+													<int key="NSPeriodicInterval">25</int>
+												</object>
+											</object>
+											<object class="NSButton" id="470888227">
+												<reference key="NSNextResponder" ref="1060223166"/>
+												<int key="NSvFlags">289</int>
+												<string key="NSFrame">{{425, 44}, {98, 32}}</string>
+												<reference key="NSSuperview" ref="1060223166"/>
+												<bool key="NSEnabled">YES</bool>
+												<object class="NSButtonCell" key="NSCell" id="673222361">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">134217728</int>
+													<string key="NSContents">Browse...</string>
+													<reference key="NSSupport" ref="112300701"/>
+													<reference key="NSControlView" ref="470888227"/>
+													<int key="NSButtonFlags">-2038284033</int>
+													<int key="NSButtonFlags2">1</int>
+													<reference key="NSAlternateImage" ref="112300701"/>
+													<string key="NSAlternateContents"/>
+													<object class="NSMutableString" key="NSKeyEquivalent">
+														<characters key="NS.bytes"/>
+													</object>
+													<int key="NSPeriodicDelay">200</int>
+													<int key="NSPeriodicInterval">25</int>
+												</object>
+											</object>
+										</object>
+										<string key="NSFrame">{{10, 33}, {534, 349}}</string>
+										<reference key="NSSuperview" ref="670019266"/>
+									</object>
+									<string key="NSLabel">Setup</string>
+									<reference key="NSColor" ref="905988731"/>
+									<reference key="NSTabView" ref="670019266"/>
+								</object>
+								<object class="NSTabViewItem" id="767169657">
+									<string key="NSIdentifier">2</string>
+									<object class="NSView" key="NSView" id="211902778">
+										<nil key="NSNextResponder"/>
+										<int key="NSvFlags">256</int>
+										<object class="NSMutableArray" key="NSSubviews">
+											<bool key="EncodedWithXMLCoder">YES</bool>
+											<object class="NSBox" id="222561211">
+												<reference key="NSNextResponder" ref="211902778"/>
+												<int key="NSvFlags">266</int>
+												<object class="NSMutableArray" key="NSSubviews">
+													<bool key="EncodedWithXMLCoder">YES</bool>
+													<object class="NSView" id="708533349">
+														<reference key="NSNextResponder" ref="222561211"/>
+														<int key="NSvFlags">256</int>
+														<object class="NSMutableArray" key="NSSubviews">
+															<bool key="EncodedWithXMLCoder">YES</bool>
+															<object class="NSButton" id="881922954">
+																<reference key="NSNextResponder" ref="708533349"/>
+																<int key="NSvFlags">270</int>
+																<string key="NSFrame">{{125, 20}, {218, 18}}</string>
+																<reference key="NSSuperview" ref="708533349"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="233356393">
+																	<int key="NSCellFlags">-2080244224</int>
+																	<int key="NSCellFlags2">0</int>
+																	<string key="NSContents">Enable QuickDraw Acceleration</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="881922954"/>
+																	<int key="NSButtonFlags">1211912703</int>
+																	<int key="NSButtonFlags2">2</int>
+																	<reference key="NSNormalImage" ref="685450367"/>
+																	<reference key="NSAlternateImage" ref="278666772"/>
+																	<string key="NSAlternateContents"/>
+																	<string key="NSKeyEquivalent"/>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+															<object class="NSPopUpButton" id="712903768">
+																<reference key="NSNextResponder" ref="708533349"/>
+																<int key="NSvFlags">266</int>
+																<string key="NSFrame">{{206, 132}, {143, 26}}</string>
+																<reference key="NSSuperview" ref="708533349"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSPopUpButtonCell" key="NSCell" id="407236409">
+																	<int key="NSCellFlags">-2076049856</int>
+																	<int key="NSCellFlags2">2048</int>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="712903768"/>
+																	<int key="NSButtonFlags">109199615</int>
+																	<int key="NSButtonFlags2">1</int>
+																	<object class="NSFont" key="NSAlternateImage" id="398128843">
+																		<string key="NSName">LucidaGrande</string>
+																		<double key="NSSize">1.300000e+01</double>
+																		<int key="NSfFlags">16</int>
+																	</object>
+																	<string key="NSAlternateContents"/>
+																	<object class="NSMutableString" key="NSKeyEquivalent">
+																		<characters key="NS.bytes"/>
+																	</object>
+																	<int key="NSPeriodicDelay">400</int>
+																	<int key="NSPeriodicInterval">75</int>
+																	<object class="NSMenuItem" key="NSMenuItem" id="415882579">
+																		<reference key="NSMenu" ref="851600464"/>
+																		<string key="NSTitle">Window</string>
+																		<string key="NSKeyEquiv"/>
+																		<int key="NSKeyEquivModMask">1048576</int>
+																		<int key="NSMnemonicLoc">2147483647</int>
+																		<int key="NSState">1</int>
+																		<object class="NSCustomResource" key="NSOnImage" id="393410035">
+																			<string key="NSClassName">NSImage</string>
+																			<string key="NSResourceName">NSMenuCheckmark</string>
+																		</object>
+																		<object class="NSCustomResource" key="NSMixedImage" id="94298953">
+																			<string key="NSClassName">NSImage</string>
+																			<string key="NSResourceName">NSMenuMixedState</string>
+																		</object>
+																		<string key="NSAction">_popUpItemAction:</string>
+																		<int key="NSTag">1</int>
+																		<reference key="NSTarget" ref="407236409"/>
+																	</object>
+																	<bool key="NSMenuItemRespectAlignment">YES</bool>
+																	<object class="NSMenu" key="NSMenu" id="851600464">
+																		<object class="NSMutableString" key="NSTitle">
+																			<characters key="NS.bytes">OtherViews</characters>
+																		</object>
+																		<object class="NSMutableArray" key="NSMenuItems">
+																			<bool key="EncodedWithXMLCoder">YES</bool>
+																			<reference ref="415882579"/>
+																			<object class="NSMenuItem" id="667958028">
+																				<reference key="NSMenu" ref="851600464"/>
+																				<string key="NSTitle">Fullscreen</string>
+																				<string key="NSKeyEquiv"/>
+																				<int key="NSKeyEquivModMask">1048576</int>
+																				<int key="NSMnemonicLoc">2147483647</int>
+																				<reference key="NSOnImage" ref="393410035"/>
+																				<reference key="NSMixedImage" ref="94298953"/>
+																				<string key="NSAction">_popUpItemAction:</string>
+																				<int key="NSTag">2</int>
+																				<reference key="NSTarget" ref="407236409"/>
+																			</object>
+																		</object>
+																	</object>
+																	<int key="NSPreferredEdge">3</int>
+																	<bool key="NSUsesItemFromMenu">YES</bool>
+																	<bool key="NSAltersState">YES</bool>
+																	<int key="NSArrowPosition">1</int>
+																</object>
+															</object>
+															<object class="NSPopUpButton" id="501935686">
+																<reference key="NSNextResponder" ref="708533349"/>
+																<int key="NSvFlags">266</int>
+																<string key="NSFrame">{{206, 104}, {143, 26}}</string>
+																<reference key="NSSuperview" ref="708533349"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSPopUpButtonCell" key="NSCell" id="268708028">
+																	<int key="NSCellFlags">-2076049856</int>
+																	<int key="NSCellFlags2">2048</int>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="501935686"/>
+																	<int key="NSButtonFlags">109199615</int>
+																	<int key="NSButtonFlags2">1</int>
+																	<reference key="NSAlternateImage" ref="398128843"/>
+																	<string key="NSAlternateContents"/>
+																	<object class="NSMutableString" key="NSKeyEquivalent">
+																		<characters key="NS.bytes"/>
+																	</object>
+																	<int key="NSPeriodicDelay">400</int>
+																	<int key="NSPeriodicInterval">75</int>
+																	<object class="NSMenuItem" key="NSMenuItem" id="487793395">
+																		<reference key="NSMenu" ref="1073161332"/>
+																		<string key="NSTitle">30 Hz</string>
+																		<string key="NSKeyEquiv"/>
+																		<int key="NSKeyEquivModMask">1048576</int>
+																		<int key="NSMnemonicLoc">2147483647</int>
+																		<int key="NSState">1</int>
+																		<reference key="NSOnImage" ref="393410035"/>
+																		<reference key="NSMixedImage" ref="94298953"/>
+																		<string key="NSAction">_popUpItemAction:</string>
+																		<reference key="NSTarget" ref="268708028"/>
+																	</object>
+																	<bool key="NSMenuItemRespectAlignment">YES</bool>
+																	<object class="NSMenu" key="NSMenu" id="1073161332">
+																		<object class="NSMutableString" key="NSTitle">
+																			<characters key="NS.bytes">OtherViews</characters>
+																		</object>
+																		<object class="NSMutableArray" key="NSMenuItems">
+																			<bool key="EncodedWithXMLCoder">YES</bool>
+																			<object class="NSMenuItem" id="480047452">
+																				<reference key="NSMenu" ref="1073161332"/>
+																				<string key="NSTitle">5 Hz</string>
+																				<string key="NSKeyEquiv"/>
+																				<int key="NSKeyEquivModMask">1048576</int>
+																				<int key="NSMnemonicLoc">2147483647</int>
+																				<reference key="NSOnImage" ref="393410035"/>
+																				<reference key="NSMixedImage" ref="94298953"/>
+																				<string key="NSAction">_popUpItemAction:</string>
+																				<reference key="NSTarget" ref="268708028"/>
+																			</object>
+																			<object class="NSMenuItem" id="478477769">
+																				<reference key="NSMenu" ref="1073161332"/>
+																				<string key="NSTitle">7.5 Hz</string>
+																				<string key="NSKeyEquiv"/>
+																				<int key="NSKeyEquivModMask">1048576</int>
+																				<int key="NSMnemonicLoc">2147483647</int>
+																				<reference key="NSOnImage" ref="393410035"/>
+																				<reference key="NSMixedImage" ref="94298953"/>
+																				<string key="NSAction">_popUpItemAction:</string>
+																				<reference key="NSTarget" ref="268708028"/>
+																			</object>
+																			<object class="NSMenuItem" id="146973984">
+																				<reference key="NSMenu" ref="1073161332"/>
+																				<string key="NSTitle">10 Hz</string>
+																				<string key="NSKeyEquiv"/>
+																				<int key="NSKeyEquivModMask">1048576</int>
+																				<int key="NSMnemonicLoc">2147483647</int>
+																				<reference key="NSOnImage" ref="393410035"/>
+																				<reference key="NSMixedImage" ref="94298953"/>
+																				<string key="NSAction">_popUpItemAction:</string>
+																				<reference key="NSTarget" ref="268708028"/>
+																			</object>
+																			<object class="NSMenuItem" id="972610094">
+																				<reference key="NSMenu" ref="1073161332"/>
+																				<string key="NSTitle">15 Hz</string>
+																				<string key="NSKeyEquiv"/>
+																				<int key="NSKeyEquivModMask">1048576</int>
+																				<int key="NSMnemonicLoc">2147483647</int>
+																				<reference key="NSOnImage" ref="393410035"/>
+																				<reference key="NSMixedImage" ref="94298953"/>
+																				<string key="NSAction">_popUpItemAction:</string>
+																				<reference key="NSTarget" ref="268708028"/>
+																			</object>
+																			<reference ref="487793395"/>
+																			<object class="NSMenuItem" id="50504943">
+																				<reference key="NSMenu" ref="1073161332"/>
+																				<string key="NSTitle">60 Hz</string>
+																				<string key="NSKeyEquiv"/>
+																				<int key="NSKeyEquivModMask">1048576</int>
+																				<int key="NSMnemonicLoc">2147483647</int>
+																				<reference key="NSOnImage" ref="393410035"/>
+																				<reference key="NSMixedImage" ref="94298953"/>
+																				<string key="NSAction">_popUpItemAction:</string>
+																				<reference key="NSTarget" ref="268708028"/>
+																			</object>
+																			<object class="NSMenuItem" id="509528543">
+																				<reference key="NSMenu" ref="1073161332"/>
+																				<string key="NSTitle">Dynamic</string>
+																				<string key="NSKeyEquiv"/>
+																				<int key="NSKeyEquivModMask">1048576</int>
+																				<int key="NSMnemonicLoc">2147483647</int>
+																				<reference key="NSOnImage" ref="393410035"/>
+																				<reference key="NSMixedImage" ref="94298953"/>
+																				<string key="NSAction">_popUpItemAction:</string>
+																				<reference key="NSTarget" ref="268708028"/>
+																			</object>
+																		</object>
+																	</object>
+																	<int key="NSSelectedIndex">4</int>
+																	<int key="NSPreferredEdge">3</int>
+																	<bool key="NSUsesItemFromMenu">YES</bool>
+																	<bool key="NSAltersState">YES</bool>
+																	<int key="NSArrowPosition">1</int>
+																</object>
+															</object>
+															<object class="NSTextField" id="1022710513">
+																<reference key="NSNextResponder" ref="708533349"/>
+																<int key="NSvFlags">268</int>
+																<string key="NSFrame">{{118, 80}, {86, 17}}</string>
+																<reference key="NSSuperview" ref="708533349"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="245199648">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">71303168</int>
+																	<string key="NSContents">Width:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="1022710513"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="379526382">
+																<reference key="NSNextResponder" ref="708533349"/>
+																<int key="NSvFlags">268</int>
+																<string key="NSFrame">{{118, 52}, {86, 17}}</string>
+																<reference key="NSSuperview" ref="708533349"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="416456809">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">71303168</int>
+																	<string key="NSContents">Height:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="379526382"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+															<object class="NSComboBox" id="461733131">
+																<reference key="NSNextResponder" ref="708533349"/>
+																<int key="NSvFlags">266</int>
+																<string key="NSFrame">{{209, 76}, {140, 26}}</string>
+																<reference key="NSSuperview" ref="708533349"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSComboBoxCell" key="NSCell" id="202615520">
+																	<int key="NSCellFlags">343014976</int>
+																	<int key="NSCellFlags2">272630784</int>
+																	<string key="NSContents">800</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="461733131"/>
+																	<bool key="NSDrawsBackground">YES</bool>
+																	<reference key="NSBackgroundColor" ref="1055309587"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																	<int key="NSVisibleItemCount">5</int>
+																	<bool key="NSHasVerticalScroller">YES</bool>
+																	<object class="NSMutableArray" key="NSPopUpListData">
+																		<bool key="EncodedWithXMLCoder">YES</bool>
+																		<string>512</string>
+																		<string>640</string>
+																		<string>800</string>
+																		<string>1024</string>
+																		<string>Maximum</string>
+																	</object>
+																	<reference key="NSDelegate" ref="461733131"/>
+																	<object class="NSComboTableView" key="NSTableView" id="601203677">
+																		<reference key="NSNextResponder"/>
+																		<int key="NSvFlags">274</int>
+																		<string key="NSFrameSize">{13, 105}</string>
+																		<reference key="NSSuperview"/>
+																		<reference key="NSWindow"/>
+																		<bool key="NSEnabled">YES</bool>
+																		<object class="NSMutableArray" key="NSTableColumns">
+																			<bool key="EncodedWithXMLCoder">YES</bool>
+																			<object class="NSTableColumn">
+																				<reference key="NSIdentifier" ref="8"/>
+																				<double key="NSWidth">1.000000e+01</double>
+																				<double key="NSMinWidth">1.000000e+01</double>
+																				<double key="NSMaxWidth">1.000000e+03</double>
+																				<object class="NSTableHeaderCell" key="NSHeaderCell">
+																					<int key="NSCellFlags">75628032</int>
+																					<int key="NSCellFlags2">0</int>
+																					<object class="NSMutableString" key="NSContents">
+																						<characters key="NS.bytes"/>
+																					</object>
+																					<reference key="NSSupport" ref="114450232"/>
+																					<object class="NSColor" key="NSBackgroundColor">
+																						<int key="NSColorSpace">3</int>
+																						<bytes key="NSWhite">MC4zMzMzMzI5OQA</bytes>
+																					</object>
+																					<reference key="NSTextColor" ref="80349926"/>
+																				</object>
+																				<object class="NSTextFieldCell" key="NSDataCell">
+																					<int key="NSCellFlags">1412562496</int>
+																					<int key="NSCellFlags2">1024</int>
+																					<string key="NSContents">800</string>
+																					<reference key="NSSupport" ref="112300701"/>
+																					<reference key="NSControlView" ref="601203677"/>
+																					<bool key="NSDrawsBackground">YES</bool>
+																					<reference key="NSBackgroundColor" ref="379896718"/>
+																					<reference key="NSTextColor" ref="502107268"/>
+																				</object>
+																				<int key="NSResizingMask">3</int>
+																				<bool key="NSIsResizeable">YES</bool>
+																				<reference key="NSTableView" ref="601203677"/>
+																			</object>
+																		</object>
+																		<double key="NSIntercellSpacingWidth">3.000000e+00</double>
+																		<double key="NSIntercellSpacingHeight">2.000000e+00</double>
+																		<reference key="NSBackgroundColor" ref="379896718"/>
+																		<reference key="NSGridColor" ref="861356657"/>
+																		<double key="NSRowHeight">1.900000e+01</double>
+																		<string key="NSAction">tableViewAction:</string>
+																		<int key="NSTvFlags">-765427712</int>
+																		<reference key="NSDelegate" ref="202615520"/>
+																		<reference key="NSDataSource" ref="202615520"/>
+																		<reference key="NSTarget" ref="202615520"/>
+																		<int key="NSColumnAutoresizingStyle">1</int>
+																		<int key="NSDraggingSourceMaskForLocal">15</int>
+																		<int key="NSDraggingSourceMaskForNonLocal">0</int>
+																		<bool key="NSAllowsTypeSelect">YES</bool>
+																	</object>
+																</object>
+															</object>
+															<object class="NSComboBox" id="326352010">
+																<reference key="NSNextResponder" ref="708533349"/>
+																<int key="NSvFlags">266</int>
+																<string key="NSFrame">{{209, 48}, {140, 26}}</string>
+																<reference key="NSSuperview" ref="708533349"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSComboBoxCell" key="NSCell" id="474687544">
+																	<int key="NSCellFlags">343014976</int>
+																	<int key="NSCellFlags2">272630784</int>
+																	<string key="NSContents">600</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="326352010"/>
+																	<bool key="NSDrawsBackground">YES</bool>
+																	<reference key="NSBackgroundColor" ref="1055309587"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																	<int key="NSVisibleItemCount">5</int>
+																	<bool key="NSHasVerticalScroller">YES</bool>
+																	<object class="NSMutableArray" key="NSPopUpListData">
+																		<bool key="EncodedWithXMLCoder">YES</bool>
+																		<string>384</string>
+																		<string>480</string>
+																		<string>600</string>
+																		<string>768</string>
+																		<string>Maximum</string>
+																	</object>
+																	<reference key="NSDelegate" ref="326352010"/>
+																	<object class="NSComboTableView" key="NSTableView" id="370496698">
+																		<reference key="NSNextResponder"/>
+																		<int key="NSvFlags">274</int>
+																		<string key="NSFrameSize">{13, 105}</string>
+																		<reference key="NSSuperview"/>
+																		<reference key="NSWindow"/>
+																		<bool key="NSEnabled">YES</bool>
+																		<object class="NSMutableArray" key="NSTableColumns">
+																			<bool key="EncodedWithXMLCoder">YES</bool>
+																			<object class="NSTableColumn">
+																				<reference key="NSIdentifier" ref="8"/>
+																				<double key="NSWidth">1.000000e+01</double>
+																				<double key="NSMinWidth">1.000000e+01</double>
+																				<double key="NSMaxWidth">1.000000e+03</double>
+																				<object class="NSTableHeaderCell" key="NSHeaderCell">
+																					<int key="NSCellFlags">75628032</int>
+																					<int key="NSCellFlags2">0</int>
+																					<object class="NSMutableString" key="NSContents">
+																						<characters key="NS.bytes"/>
+																					</object>
+																					<reference key="NSSupport" ref="114450232"/>
+																					<object class="NSColor" key="NSBackgroundColor">
+																						<int key="NSColorSpace">3</int>
+																						<bytes key="NSWhite">MC4zMzMzMzI5OQA</bytes>
+																					</object>
+																					<reference key="NSTextColor" ref="80349926"/>
+																				</object>
+																				<object class="NSTextFieldCell" key="NSDataCell">
+																					<int key="NSCellFlags">1412562496</int>
+																					<int key="NSCellFlags2">1024</int>
+																					<string key="NSContents">600</string>
+																					<reference key="NSSupport" ref="112300701"/>
+																					<reference key="NSControlView" ref="370496698"/>
+																					<bool key="NSDrawsBackground">YES</bool>
+																					<reference key="NSBackgroundColor" ref="379896718"/>
+																					<reference key="NSTextColor" ref="502107268"/>
+																				</object>
+																				<int key="NSResizingMask">3</int>
+																				<bool key="NSIsResizeable">YES</bool>
+																				<reference key="NSTableView" ref="370496698"/>
+																			</object>
+																		</object>
+																		<double key="NSIntercellSpacingWidth">3.000000e+00</double>
+																		<double key="NSIntercellSpacingHeight">2.000000e+00</double>
+																		<reference key="NSBackgroundColor" ref="379896718"/>
+																		<reference key="NSGridColor" ref="861356657"/>
+																		<double key="NSRowHeight">1.900000e+01</double>
+																		<string key="NSAction">tableViewAction:</string>
+																		<int key="NSTvFlags">-765427712</int>
+																		<reference key="NSDelegate" ref="474687544"/>
+																		<reference key="NSDataSource" ref="474687544"/>
+																		<reference key="NSTarget" ref="474687544"/>
+																		<int key="NSColumnAutoresizingStyle">1</int>
+																		<int key="NSDraggingSourceMaskForLocal">15</int>
+																		<int key="NSDraggingSourceMaskForNonLocal">0</int>
+																		<bool key="NSAllowsTypeSelect">YES</bool>
+																	</object>
+																</object>
+															</object>
+															<object class="NSTextField" id="550307815">
+																<reference key="NSNextResponder" ref="708533349"/>
+																<int key="NSvFlags">268</int>
+																<string key="NSFrame">{{118, 136}, {86, 19}}</string>
+																<reference key="NSSuperview" ref="708533349"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="87807091">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">71303168</int>
+																	<string key="NSContents">Video Type:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="550307815"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="148353339">
+																<reference key="NSNextResponder" ref="708533349"/>
+																<int key="NSvFlags">268</int>
+																<string key="NSFrame">{{112, 108}, {92, 19}}</string>
+																<reference key="NSSuperview" ref="708533349"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="1025684210">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">71303168</int>
+																	<string key="NSContents">Refresh Rate:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="148353339"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+														</object>
+														<string key="NSFrame">{{2, 2}, {518, 177}}</string>
+														<reference key="NSSuperview" ref="222561211"/>
+													</object>
+												</object>
+												<string key="NSFrame">{{6, 155}, {522, 194}}</string>
+												<reference key="NSSuperview" ref="211902778"/>
+												<string key="NSOffsets">{0, 0}</string>
+												<object class="NSTextFieldCell" key="NSTitleCell">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">0</int>
+													<string key="NSContents"> Video Settings</string>
+													<reference key="NSSupport" ref="26"/>
+													<reference key="NSBackgroundColor" ref="1055309587"/>
+													<object class="NSColor" key="NSTextColor">
+														<int key="NSColorSpace">3</int>
+														<bytes key="NSWhite">MCAwLjgwMDAwMDAxAA</bytes>
+													</object>
+												</object>
+												<reference key="NSContentView" ref="708533349"/>
+												<int key="NSBorderType">3</int>
+												<int key="NSBoxType">0</int>
+												<int key="NSTitlePosition">2</int>
+												<bool key="NSTransparent">NO</bool>
+											</object>
+											<object class="NSBox" id="44147686">
+												<reference key="NSNextResponder" ref="211902778"/>
+												<int key="NSvFlags">266</int>
+												<object class="NSMutableArray" key="NSSubviews">
+													<bool key="EncodedWithXMLCoder">YES</bool>
+													<object class="NSView" id="724667479">
+														<reference key="NSNextResponder" ref="44147686"/>
+														<int key="NSvFlags">256</int>
+														<object class="NSMutableArray" key="NSSubviews">
+															<bool key="EncodedWithXMLCoder">YES</bool>
+															<object class="NSButton" id="379314227">
+																<reference key="NSNextResponder" ref="724667479"/>
+																<int key="NSvFlags">264</int>
+																<string key="NSFrame">{{15, 96}, {172, 18}}</string>
+																<reference key="NSSuperview" ref="724667479"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="750892379">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">0</int>
+																	<string key="NSContents">Disable Audio Output</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="379314227"/>
+																	<int key="NSButtonFlags">1211912703</int>
+																	<int key="NSButtonFlags2">2</int>
+																	<reference key="NSNormalImage" ref="685450367"/>
+																	<reference key="NSAlternateImage" ref="278666772"/>
+																	<string key="NSAlternateContents"/>
+																	<string key="NSKeyEquivalent"/>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+															<object class="NSTextField" id="426586135">
+																<reference key="NSNextResponder" ref="724667479"/>
+																<int key="NSvFlags">266</int>
+																<string key="NSFrame">{{118, 59}, {379, 22}}</string>
+																<reference key="NSSuperview" ref="724667479"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="111348041">
+																	<int key="NSCellFlags">-1804468671</int>
+																	<int key="NSCellFlags2">272630784</int>
+																	<string key="NSContents">/dev/dsp</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="426586135"/>
+																	<bool key="NSDrawsBackground">YES</bool>
+																	<reference key="NSBackgroundColor" ref="1055309587"/>
+																	<reference key="NSTextColor" ref="559183679"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="261059178">
+																<reference key="NSNextResponder" ref="724667479"/>
+																<int key="NSvFlags">266</int>
+																<string key="NSFrame">{{118, 29}, {379, 22}}</string>
+																<reference key="NSSuperview" ref="724667479"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="455971206">
+																	<int key="NSCellFlags">-1804468671</int>
+																	<int key="NSCellFlags2">272630784</int>
+																	<string key="NSContents">/dev/mixer</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="261059178"/>
+																	<bool key="NSDrawsBackground">YES</bool>
+																	<reference key="NSBackgroundColor" ref="1055309587"/>
+																	<reference key="NSTextColor" ref="559183679"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="591913548">
+																<reference key="NSNextResponder" ref="724667479"/>
+																<int key="NSvFlags">264</int>
+																<string key="NSFrame">{{14, 61}, {99, 17}}</string>
+																<reference key="NSSuperview" ref="724667479"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="5517320">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">71303168</int>
+																	<string key="NSContents">Output Device:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="591913548"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="795495374">
+																<reference key="NSNextResponder" ref="724667479"/>
+																<int key="NSvFlags">264</int>
+																<string key="NSFrame">{{14, 31}, {99, 17}}</string>
+																<reference key="NSSuperview" ref="724667479"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="135248988">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">71303168</int>
+																	<string key="NSContents">Mixer Device:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="795495374"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+														</object>
+														<string key="NSFrame">{{2, 2}, {518, 134}}</string>
+														<reference key="NSSuperview" ref="44147686"/>
+													</object>
+												</object>
+												<string key="NSFrame">{{6, 0}, {522, 151}}</string>
+												<reference key="NSSuperview" ref="211902778"/>
+												<string key="NSOffsets">{0, 0}</string>
+												<object class="NSTextFieldCell" key="NSTitleCell">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">0</int>
+													<string key="NSContents">Audio Settings</string>
+													<reference key="NSSupport" ref="26"/>
+													<reference key="NSBackgroundColor" ref="1055309587"/>
+													<object class="NSColor" key="NSTextColor">
+														<int key="NSColorSpace">3</int>
+														<bytes key="NSWhite">MCAwLjgwMDAwMDAxAA</bytes>
+													</object>
+												</object>
+												<reference key="NSContentView" ref="724667479"/>
+												<int key="NSBorderType">3</int>
+												<int key="NSBoxType">0</int>
+												<int key="NSTitlePosition">2</int>
+												<bool key="NSTransparent">NO</bool>
+											</object>
+										</object>
+										<string key="NSFrame">{{10, 33}, {534, 349}}</string>
+									</object>
+									<string key="NSLabel">Audio / Video</string>
+									<reference key="NSColor" ref="905988731"/>
+									<reference key="NSTabView" ref="670019266"/>
+								</object>
+								<object class="NSTabViewItem" id="7282019">
+									<string key="NSIdentifier">Item 4</string>
+									<object class="NSView" key="NSView" id="353972395">
+										<nil key="NSNextResponder"/>
+										<int key="NSvFlags">256</int>
+										<object class="NSMutableArray" key="NSSubviews">
+											<bool key="EncodedWithXMLCoder">YES</bool>
+											<object class="NSBox" id="274792831">
+												<reference key="NSNextResponder" ref="353972395"/>
+												<int key="NSvFlags">266</int>
+												<object class="NSMutableArray" key="NSSubviews">
+													<bool key="EncodedWithXMLCoder">YES</bool>
+													<object class="NSView" id="623289937">
+														<reference key="NSNextResponder" ref="274792831"/>
+														<int key="NSvFlags">256</int>
+														<object class="NSMutableArray" key="NSSubviews">
+															<bool key="EncodedWithXMLCoder">YES</bool>
+															<object class="NSTextField" id="707791957">
+																<reference key="NSNextResponder" ref="623289937"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{13, 75}, {130, 17}}</string>
+																<reference key="NSSuperview" ref="623289937"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="491023663">
+																	<int key="NSCellFlags">70385217</int>
+																	<int key="NSCellFlags2">71304192</int>
+																	<string key="NSContents">Modem Port Device:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="707791957"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="535851009">
+																<reference key="NSNextResponder" ref="623289937"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{18, 43}, {125, 17}}</string>
+																<reference key="NSSuperview" ref="623289937"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="820155412">
+																	<int key="NSCellFlags">70385217</int>
+																	<int key="NSCellFlags2">71304192</int>
+																	<string key="NSContents">Printer Port Device:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="535851009"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="141459662">
+																<reference key="NSNextResponder" ref="623289937"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{18, 13}, {126, 17}}</string>
+																<reference key="NSSuperview" ref="623289937"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="795241851">
+																	<int key="NSCellFlags">70385217</int>
+																	<int key="NSCellFlags2">71304192</int>
+																	<string key="NSContents">Ethernet Interface:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="141459662"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="429543509">
+																<reference key="NSNextResponder" ref="623289937"/>
+																<int key="NSvFlags">266</int>
+																<string key="NSFrame">{{146, 73}, {351, 22}}</string>
+																<reference key="NSSuperview" ref="623289937"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="184451495">
+																	<int key="NSCellFlags">-1804468671</int>
+																	<int key="NSCellFlags2">4195328</int>
+																	<string key="NSContents"/>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="429543509"/>
+																	<bool key="NSDrawsBackground">YES</bool>
+																	<reference key="NSBackgroundColor" ref="1055309587"/>
+																	<reference key="NSTextColor" ref="559183679"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="484817699">
+																<reference key="NSNextResponder" ref="623289937"/>
+																<int key="NSvFlags">266</int>
+																<string key="NSFrame">{{146, 41}, {351, 22}}</string>
+																<reference key="NSSuperview" ref="623289937"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="1065354061">
+																	<int key="NSCellFlags">-1804468671</int>
+																	<int key="NSCellFlags2">4195328</int>
+																	<string key="NSContents"/>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="484817699"/>
+																	<bool key="NSDrawsBackground">YES</bool>
+																	<reference key="NSBackgroundColor" ref="1055309587"/>
+																	<reference key="NSTextColor" ref="559183679"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="520985044">
+																<reference key="NSNextResponder" ref="623289937"/>
+																<int key="NSvFlags">266</int>
+																<string key="NSFrame">{{146, 10}, {351, 22}}</string>
+																<reference key="NSSuperview" ref="623289937"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="1028595246">
+																	<int key="NSCellFlags">-1804468671</int>
+																	<int key="NSCellFlags2">4195328</int>
+																	<string key="NSContents">slirp</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="520985044"/>
+																	<bool key="NSDrawsBackground">YES</bool>
+																	<reference key="NSBackgroundColor" ref="1055309587"/>
+																	<reference key="NSTextColor" ref="559183679"/>
+																</object>
+															</object>
+														</object>
+														<string key="NSFrame">{{2, 2}, {518, 106}}</string>
+														<reference key="NSSuperview" ref="274792831"/>
+													</object>
+												</object>
+												<string key="NSFrame">{{6, 4}, {522, 123}}</string>
+												<reference key="NSSuperview" ref="353972395"/>
+												<string key="NSOffsets">{0, 0}</string>
+												<object class="NSTextFieldCell" key="NSTitleCell">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">0</int>
+													<string key="NSContents">Serial/Network</string>
+													<reference key="NSSupport" ref="26"/>
+													<reference key="NSBackgroundColor" ref="1055309587"/>
+													<object class="NSColor" key="NSTextColor">
+														<int key="NSColorSpace">3</int>
+														<bytes key="NSWhite">MCAwLjgwMDAwMDAxAA</bytes>
+													</object>
+												</object>
+												<reference key="NSContentView" ref="623289937"/>
+												<int key="NSBorderType">3</int>
+												<int key="NSBoxType">0</int>
+												<int key="NSTitlePosition">2</int>
+												<bool key="NSTransparent">NO</bool>
+											</object>
+											<object class="NSBox" id="394381257">
+												<reference key="NSNextResponder" ref="353972395"/>
+												<int key="NSvFlags">266</int>
+												<object class="NSMutableArray" key="NSSubviews">
+													<bool key="EncodedWithXMLCoder">YES</bool>
+													<object class="NSView" id="939890218">
+														<reference key="NSNextResponder" ref="394381257"/>
+														<int key="NSvFlags">256</int>
+														<object class="NSMutableArray" key="NSSubviews">
+															<bool key="EncodedWithXMLCoder">YES</bool>
+															<object class="NSButton" id="975636418">
+																<reference key="NSNextResponder" ref="939890218"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{15, 51}, {150, 18}}</string>
+																<reference key="NSSuperview" ref="939890218"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="669399985">
+																	<int key="NSCellFlags">-2080244224</int>
+																	<int key="NSCellFlags2">0</int>
+																	<string key="NSContents">Enable JIT Compiler</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="975636418"/>
+																	<int key="NSButtonFlags">1211912703</int>
+																	<int key="NSButtonFlags2">2</int>
+																	<reference key="NSNormalImage" ref="685450367"/>
+																	<reference key="NSAlternateImage" ref="278666772"/>
+																	<string key="NSAlternateContents"/>
+																	<string key="NSKeyEquivalent"/>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+															<object class="NSButton" id="663086287">
+																<reference key="NSNextResponder" ref="939890218"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{15, 11}, {333, 18}}</string>
+																<reference key="NSSuperview" ref="939890218"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="229560319">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">0</int>
+																	<string key="NSContents">Enable built-in 68k DR Emulator (EXPERIMENTAL)</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="663086287"/>
+																	<int key="NSButtonFlags">1211912703</int>
+																	<int key="NSButtonFlags2">2</int>
+																	<reference key="NSNormalImage" ref="685450367"/>
+																	<reference key="NSAlternateImage" ref="278666772"/>
+																	<string key="NSAlternateContents"/>
+																	<string key="NSKeyEquivalent"/>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+															<object class="NSButton" id="344624164">
+																<reference key="NSNextResponder" ref="939890218"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{15, 31}, {236, 18}}</string>
+																<reference key="NSSuperview" ref="939890218"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="297579270">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">0</int>
+																	<string key="NSContents">Allow Emulated CPU to Idle</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="344624164"/>
+																	<int key="NSButtonFlags">1211912703</int>
+																	<int key="NSButtonFlags2">2</int>
+																	<reference key="NSAlternateImage" ref="278666772"/>
+																	<string key="NSAlternateContents"/>
+																	<string key="NSKeyEquivalent"/>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+															<object class="NSButton" id="667827064">
+																<reference key="NSNextResponder" ref="939890218"/>
+																<int key="NSvFlags">265</int>
+																<string key="NSFrame">{{269, 51}, {220, 18}}</string>
+																<reference key="NSSuperview" ref="939890218"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="335293817">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">0</int>
+																	<string key="NSContents">Ignore Illegal Instructions</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="667827064"/>
+																	<int key="NSButtonFlags">1211912703</int>
+																	<int key="NSButtonFlags2">2</int>
+																	<reference key="NSNormalImage" ref="685450367"/>
+																	<reference key="NSAlternateImage" ref="278666772"/>
+																	<string key="NSAlternateContents"/>
+																	<string key="NSKeyEquivalent"/>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+															<object class="NSButton" id="281208820">
+																<reference key="NSNextResponder" ref="939890218"/>
+																<int key="NSvFlags">265</int>
+																<string key="NSFrame">{{269, 31}, {220, 18}}</string>
+																<reference key="NSSuperview" ref="939890218"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="952355731">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">0</int>
+																	<string key="NSContents">Ignore Illegal Memory Accesses</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="281208820"/>
+																	<int key="NSButtonFlags">1211912703</int>
+																	<int key="NSButtonFlags2">2</int>
+																	<reference key="NSNormalImage" ref="685450367"/>
+																	<reference key="NSAlternateImage" ref="278666772"/>
+																	<string key="NSAlternateContents"/>
+																	<string key="NSKeyEquivalent"/>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+														</object>
+														<string key="NSFrame">{{2, 2}, {518, 77}}</string>
+														<reference key="NSSuperview" ref="394381257"/>
+													</object>
+												</object>
+												<string key="NSFrame">{{6, 255}, {522, 94}}</string>
+												<reference key="NSSuperview" ref="353972395"/>
+												<string key="NSOffsets">{0, 0}</string>
+												<object class="NSTextFieldCell" key="NSTitleCell">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">0</int>
+													<string key="NSContents">CPU Options</string>
+													<reference key="NSSupport" ref="26"/>
+													<reference key="NSBackgroundColor" ref="1055309587"/>
+													<object class="NSColor" key="NSTextColor">
+														<int key="NSColorSpace">3</int>
+														<bytes key="NSWhite">MCAwLjgwMDAwMDAxAA</bytes>
+													</object>
+												</object>
+												<reference key="NSContentView" ref="939890218"/>
+												<int key="NSBorderType">3</int>
+												<int key="NSBoxType">0</int>
+												<int key="NSTitlePosition">2</int>
+												<bool key="NSTransparent">NO</bool>
+											</object>
+											<object class="NSBox" id="541762374">
+												<reference key="NSNextResponder" ref="353972395"/>
+												<int key="NSvFlags">266</int>
+												<object class="NSMutableArray" key="NSSubviews">
+													<bool key="EncodedWithXMLCoder">YES</bool>
+													<object class="NSView" id="976218909">
+														<reference key="NSNextResponder" ref="541762374"/>
+														<int key="NSvFlags">256</int>
+														<object class="NSMutableArray" key="NSSubviews">
+															<bool key="EncodedWithXMLCoder">YES</bool>
+															<object class="NSButton" id="891275640">
+																<reference key="NSNextResponder" ref="976218909"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{22, 70}, {142, 18}}</string>
+																<reference key="NSSuperview" ref="976218909"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="967392554">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">0</int>
+																	<string key="NSContents">Use Raw Keycodes:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="891275640"/>
+																	<int key="NSButtonFlags">1211912703</int>
+																	<int key="NSButtonFlags2">2</int>
+																	<reference key="NSNormalImage" ref="685450367"/>
+																	<reference key="NSAlternateImage" ref="278666772"/>
+																	<string key="NSAlternateContents"/>
+																	<string key="NSKeyEquivalent"/>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+															<object class="NSTextField" id="770533714">
+																<reference key="NSNextResponder" ref="976218909"/>
+																<int key="NSvFlags">266</int>
+																<string key="NSFrame">{{170, 69}, {239, 22}}</string>
+																<reference key="NSSuperview" ref="976218909"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="365627130">
+																	<int key="NSCellFlags">-1804468671</int>
+																	<int key="NSCellFlags2">272630784</int>
+																	<string key="NSContents"/>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="770533714"/>
+																	<bool key="NSDrawsBackground">YES</bool>
+																	<reference key="NSBackgroundColor" ref="1055309587"/>
+																	<reference key="NSTextColor" ref="559183679"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="284400701">
+																<reference key="NSNextResponder" ref="976218909"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{14, 43}, {151, 17}}</string>
+																<reference key="NSSuperview" ref="976218909"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="487892379">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">71303168</int>
+																	<string key="NSContents">Mouse Wheel Function:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="284400701"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="1005724872">
+																<reference key="NSNextResponder" ref="976218909"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{66, 15}, {99, 17}}</string>
+																<reference key="NSSuperview" ref="976218909"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="1015405188">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">71303168</int>
+																	<string key="NSContents">Lines to Scroll:</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="1005724872"/>
+																	<reference key="NSBackgroundColor" ref="905988731"/>
+																	<reference key="NSTextColor" ref="502107268"/>
+																</object>
+															</object>
+															<object class="NSTextField" id="297993568">
+																<reference key="NSNextResponder" ref="976218909"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{170, 13}, {29, 22}}</string>
+																<reference key="NSSuperview" ref="976218909"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSTextFieldCell" key="NSCell" id="690043401">
+																	<int key="NSCellFlags">-1804468671</int>
+																	<int key="NSCellFlags2">272630784</int>
+																	<string key="NSContents">3</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="297993568"/>
+																	<bool key="NSDrawsBackground">YES</bool>
+																	<reference key="NSBackgroundColor" ref="1055309587"/>
+																	<reference key="NSTextColor" ref="559183679"/>
+																</object>
+															</object>
+															<object class="NSPopUpButton" id="487013224">
+																<reference key="NSNextResponder" ref="976218909"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{167, 37}, {163, 26}}</string>
+																<reference key="NSSuperview" ref="976218909"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSPopUpButtonCell" key="NSCell" id="48013634">
+																	<int key="NSCellFlags">-2076049856</int>
+																	<int key="NSCellFlags2">2048</int>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="487013224"/>
+																	<int key="NSButtonFlags">109199615</int>
+																	<int key="NSButtonFlags2">1</int>
+																	<reference key="NSAlternateImage" ref="398128843"/>
+																	<string key="NSAlternateContents"/>
+																	<object class="NSMutableString" key="NSKeyEquivalent">
+																		<characters key="NS.bytes"/>
+																	</object>
+																	<int key="NSPeriodicDelay">400</int>
+																	<int key="NSPeriodicInterval">75</int>
+																	<object class="NSMenuItem" key="NSMenuItem" id="324417270">
+																		<reference key="NSMenu" ref="258333059"/>
+																		<string key="NSTitle">Page Up/Down</string>
+																		<string key="NSKeyEquiv"/>
+																		<int key="NSKeyEquivModMask">1048576</int>
+																		<int key="NSMnemonicLoc">2147483647</int>
+																		<int key="NSState">1</int>
+																		<reference key="NSOnImage" ref="393410035"/>
+																		<reference key="NSMixedImage" ref="94298953"/>
+																		<string key="NSAction">_popUpItemAction:</string>
+																		<reference key="NSTarget" ref="48013634"/>
+																	</object>
+																	<bool key="NSMenuItemRespectAlignment">YES</bool>
+																	<object class="NSMenu" key="NSMenu" id="258333059">
+																		<object class="NSMutableString" key="NSTitle">
+																			<characters key="NS.bytes">OtherViews</characters>
+																		</object>
+																		<object class="NSMutableArray" key="NSMenuItems">
+																			<bool key="EncodedWithXMLCoder">YES</bool>
+																			<reference ref="324417270"/>
+																			<object class="NSMenuItem" id="464363541">
+																				<reference key="NSMenu" ref="258333059"/>
+																				<string key="NSTitle">Cursor Up/Down</string>
+																				<string key="NSKeyEquiv"/>
+																				<int key="NSKeyEquivModMask">1048576</int>
+																				<int key="NSMnemonicLoc">2147483647</int>
+																				<reference key="NSOnImage" ref="393410035"/>
+																				<reference key="NSMixedImage" ref="94298953"/>
+																				<string key="NSAction">_popUpItemAction:</string>
+																				<reference key="NSTarget" ref="48013634"/>
+																			</object>
+																		</object>
+																	</object>
+																	<int key="NSPreferredEdge">3</int>
+																	<bool key="NSUsesItemFromMenu">YES</bool>
+																	<bool key="NSAltersState">YES</bool>
+																	<int key="NSArrowPosition">1</int>
+																</object>
+															</object>
+															<object class="NSStepper" id="628828757">
+																<reference key="NSNextResponder" ref="976218909"/>
+																<int key="NSvFlags">256</int>
+																<string key="NSFrame">{{204, 10}, {19, 27}}</string>
+																<reference key="NSSuperview" ref="976218909"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSStepperCell" key="NSCell" id="42977313">
+																	<int key="NSCellFlags">917024</int>
+																	<int key="NSCellFlags2">0</int>
+																	<reference key="NSControlView" ref="628828757"/>
+																	<double key="NSMaxValue">5.900000e+01</double>
+																	<double key="NSIncrement">1.000000e+00</double>
+																	<bool key="NSValueWraps">YES</bool>
+																	<bool key="NSAutorepeat">YES</bool>
+																</object>
+															</object>
+															<object class="NSButton" id="947618242">
+																<reference key="NSNextResponder" ref="976218909"/>
+																<int key="NSvFlags">289</int>
+																<string key="NSFrame">{{411, 63}, {96, 32}}</string>
+																<reference key="NSSuperview" ref="976218909"/>
+																<bool key="NSEnabled">YES</bool>
+																<object class="NSButtonCell" key="NSCell" id="337142710">
+																	<int key="NSCellFlags">67239424</int>
+																	<int key="NSCellFlags2">134217728</int>
+																	<string key="NSContents">Browse...</string>
+																	<reference key="NSSupport" ref="112300701"/>
+																	<reference key="NSControlView" ref="947618242"/>
+																	<int key="NSButtonFlags">-2038284033</int>
+																	<int key="NSButtonFlags2">129</int>
+																	<string key="NSAlternateContents"/>
+																	<string key="NSKeyEquivalent"/>
+																	<int key="NSPeriodicDelay">200</int>
+																	<int key="NSPeriodicInterval">25</int>
+																</object>
+															</object>
+														</object>
+														<string key="NSFrame">{{2, 2}, {518, 103}}</string>
+														<reference key="NSSuperview" ref="541762374"/>
+													</object>
+												</object>
+												<string key="NSFrame">{{6, 131}, {522, 120}}</string>
+												<reference key="NSSuperview" ref="353972395"/>
+												<string key="NSOffsets">{0, 0}</string>
+												<object class="NSTextFieldCell" key="NSTitleCell">
+													<int key="NSCellFlags">67239424</int>
+													<int key="NSCellFlags2">0</int>
+													<string key="NSContents">Mouse/Keyboard</string>
+													<reference key="NSSupport" ref="26"/>
+													<reference key="NSBackgroundColor" ref="1055309587"/>
+													<object class="NSColor" key="NSTextColor">
+														<int key="NSColorSpace">3</int>
+														<bytes key="NSWhite">MCAwLjgwMDAwMDAxAA</bytes>
+													</object>
+												</object>
+												<reference key="NSContentView" ref="976218909"/>
+												<int key="NSBorderType">3</int>
+												<int key="NSBoxType">0</int>
+												<int key="NSTitlePosition">2</int>
+												<bool key="NSTransparent">NO</bool>
+											</object>
+										</object>
+										<string key="NSFrame">{{10, 33}, {534, 349}}</string>
+									</object>
+									<string key="NSLabel">Miscellaneous</string>
+									<reference key="NSColor" ref="905988731"/>
+									<reference key="NSTabView" ref="670019266"/>
+								</object>
+							</object>
+							<reference key="NSSelectedTabViewItem" ref="522700178"/>
+							<reference key="NSFont" ref="112300701"/>
+							<int key="NSTvFlags">0</int>
+							<bool key="NSAllowTruncatedLabels">YES</bool>
+							<bool key="NSDrawsBackground">YES</bool>
+							<object class="NSMutableArray" key="NSSubviews">
+								<bool key="EncodedWithXMLCoder">YES</bool>
+								<reference ref="1060223166"/>
+							</object>
+						</object>
+						<object class="NSButton" id="500796533">
+							<reference key="NSNextResponder" ref="648841812"/>
+							<int key="NSvFlags">289</int>
+							<string key="NSFrame">{{374, 20}, {96, 32}}</string>
+							<reference key="NSSuperview" ref="648841812"/>
+							<bool key="NSEnabled">YES</bool>
+							<object class="NSButtonCell" key="NSCell" id="585197460">
+								<int key="NSCellFlags">67239424</int>
+								<int key="NSCellFlags2">134217728</int>
+								<string key="NSContents">Cancel</string>
+								<reference key="NSSupport" ref="112300701"/>
+								<reference key="NSControlView" ref="500796533"/>
+								<int key="NSButtonFlags">-2038284033</int>
+								<int key="NSButtonFlags2">129</int>
+								<string key="NSAlternateContents"/>
+								<string key="NSKeyEquivalent"/>
+								<int key="NSPeriodicDelay">200</int>
+								<int key="NSPeriodicInterval">25</int>
+							</object>
+						</object>
+						<object class="NSButton" id="663932743">
+							<reference key="NSNextResponder" ref="648841812"/>
+							<int key="NSvFlags">289</int>
+							<string key="NSFrame">{{470, 20}, {96, 32}}</string>
+							<reference key="NSSuperview" ref="648841812"/>
+							<bool key="NSEnabled">YES</bool>
+							<object class="NSButtonCell" key="NSCell" id="434474760">
+								<int key="NSCellFlags">67239424</int>
+								<int key="NSCellFlags2">134217728</int>
+								<string key="NSContents">Save</string>
+								<reference key="NSSupport" ref="112300701"/>
+								<reference key="NSControlView" ref="663932743"/>
+								<int key="NSButtonFlags">-2038284033</int>
+								<int key="NSButtonFlags2">129</int>
+								<string key="NSAlternateContents"/>
+								<string key="NSKeyEquivalent"/>
+								<int key="NSPeriodicDelay">200</int>
+								<int key="NSPeriodicInterval">25</int>
+							</object>
+						</object>
+					</object>
+					<string key="NSFrameSize">{580, 460}</string>
+					<reference key="NSSuperview"/>
+				</object>
+				<string key="NSScreenRect">{{0, 0}, {1440, 878}}</string>
+				<string key="NSMinSize">{580, 482}</string>
+				<string key="NSMaxSize">{3.40282e+38, 3.40282e+38}</string>
+			</object>
+		</object>
+		<object class="IBObjectContainer" key="IBDocument.Objects">
+			<object class="NSMutableArray" key="connectionRecords">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntValueFrom:</string>
+						<reference key="source" ref="628828757"/>
+						<reference key="destination" ref="297993568"/>
+					</object>
+					<int key="connectionID">282</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">initialFirstResponder</string>
+						<reference key="source" ref="777181097"/>
+						<reference key="destination" ref="980817371"/>
+					</object>
+					<int key="connectionID">283</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntValueFrom:</string>
+						<reference key="source" ref="513058772"/>
+						<reference key="destination" ref="321640330"/>
+					</object>
+					<int key="connectionID">291</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntValueFrom:</string>
+						<reference key="source" ref="457634098"/>
+						<reference key="destination" ref="726460923"/>
+					</object>
+					<int key="connectionID">310</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntValueFrom:</string>
+						<reference key="source" ref="726460923"/>
+						<reference key="destination" ref="457634098"/>
+					</object>
+					<int key="connectionID">311</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntValueFrom:</string>
+						<reference key="source" ref="321640330"/>
+						<reference key="destination" ref="513058772"/>
+					</object>
+					<int key="connectionID">313</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntValueFrom:</string>
+						<reference key="source" ref="297993568"/>
+						<reference key="destination" ref="628828757"/>
+					</object>
+					<int key="connectionID">314</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">window</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="777181097"/>
+					</object>
+					<int key="connectionID">318</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">bootFrom</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="649352634"/>
+					</object>
+					<int key="connectionID">319</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">disableCdrom</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="336750324"/>
+					</object>
+					<int key="connectionID">320</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">disableSound</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="379314227"/>
+					</object>
+					<int key="connectionID">321</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">dontUseCPUWhenIdle</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="344624164"/>
+					</object>
+					<int key="connectionID">322</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">enable68kDREmulator</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="663086287"/>
+					</object>
+					<int key="connectionID">323</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">enableJIT</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="975636418"/>
+					</object>
+					<int key="connectionID">324</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">unixRoot</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="1052479163"/>
+					</object>
+					<int key="connectionID">325</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">romFile</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="980817371"/>
+					</object>
+					<int key="connectionID">326</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">browseForROMFileClicked:</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="439199863"/>
+					</object>
+					<int key="connectionID">327</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">addDisk:</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="776720636"/>
+					</object>
+					<int key="connectionID">328</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">createDisk:</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="615553393"/>
+					</object>
+					<int key="connectionID">329</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">removeDisk:</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="760806366"/>
+					</object>
+					<int key="connectionID">330</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">useRawKeyCodesClicked:</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="891275640"/>
+					</object>
+					<int key="connectionID">331</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">rawKeyCodes</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="770533714"/>
+					</object>
+					<int key="connectionID">332</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">useRawKeyCodes</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="891275640"/>
+					</object>
+					<int key="connectionID">333</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">modemPort</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="429543509"/>
+					</object>
+					<int key="connectionID">334</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">mouseWheel</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="487013224"/>
+					</object>
+					<int key="connectionID">335</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">printerPort</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="484817699"/>
+					</object>
+					<int key="connectionID">336</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">ramSize</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="726460923"/>
+					</object>
+					<int key="connectionID">337</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">ramSizeStepper</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="457634098"/>
+					</object>
+					<int key="connectionID">338</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">mixDevice</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="261059178"/>
+					</object>
+					<int key="connectionID">339</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">outDevice</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="426586135"/>
+					</object>
+					<int key="connectionID">340</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">qdAccel</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="881922954"/>
+					</object>
+					<int key="connectionID">341</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">height</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="326352010"/>
+					</object>
+					<int key="connectionID">342</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">width</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="461733131"/>
+					</object>
+					<int key="connectionID">343</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">videoType</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="712903768"/>
+					</object>
+					<int key="connectionID">344</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">refreshRate</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="501935686"/>
+					</object>
+					<int key="connectionID">345</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">scrollLines</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="297993568"/>
+					</object>
+					<int key="connectionID">346</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">scrollLinesStepper</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="628828757"/>
+					</object>
+					<int key="connectionID">347</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">ignoreIllegalMemoryAccesses</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="281208820"/>
+					</object>
+					<int key="connectionID">348</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">ethernetInterface</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="520985044"/>
+					</object>
+					<int key="connectionID">349</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">diskSaveSizeField</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="513058772"/>
+					</object>
+					<int key="connectionID">351</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">diskSaveSize</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="232610295"/>
+					</object>
+					<int key="connectionID">353</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">delegate</string>
+						<reference key="source" ref="777181097"/>
+						<reference key="destination" ref="1001"/>
+					</object>
+					<int key="connectionID">355</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">disks</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="978863379"/>
+					</object>
+					<int key="connectionID">368</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">browseForUnixRootClicked:</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="470888227"/>
+					</object>
+					<int key="connectionID">369</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">ignoreIllegalInstructions</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="667827064"/>
+					</object>
+					<int key="connectionID">372</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">saveChanges:</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="663932743"/>
+					</object>
+					<int key="connectionID">373</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">cancelEdit:</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="500796533"/>
+					</object>
+					<int key="connectionID">374</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">browseForKeyCodesFileClicked:</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="947618242"/>
+					</object>
+					<int key="connectionID">378</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">browseRawKeyCodesButton</string>
+						<reference key="source" ref="1001"/>
+						<reference key="destination" ref="947618242"/>
+					</object>
+					<int key="connectionID">379</int>
+				</object>
+			</object>
+			<object class="IBMutableOrderedSet" key="objectRecords">
+				<object class="NSArray" key="orderedObjects">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBObjectRecord">
+						<int key="objectID">0</int>
+						<object class="NSArray" key="object" id="1002">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+						</object>
+						<reference key="children" ref="1000"/>
+						<nil key="parent"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-2</int>
+						<reference key="object" ref="1001"/>
+						<reference key="parent" ref="1002"/>
+						<string type="base64-UTF8" key="objectName">RmlsZSdzIE93bmVyA</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-1</int>
+						<reference key="object" ref="1003"/>
+						<reference key="parent" ref="1002"/>
+						<string key="objectName">First Responder</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-3</int>
+						<reference key="object" ref="1004"/>
+						<reference key="parent" ref="1002"/>
+						<string key="objectName">Application</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">141</int>
+						<reference key="object" ref="232610295"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="548109881"/>
+							<reference ref="321640330"/>
+							<reference ref="513058772"/>
+						</object>
+						<reference key="parent" ref="1002"/>
+						<string key="objectName">DiskSize</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">142</int>
+						<reference key="object" ref="777181097"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="648841812"/>
+						</object>
+						<reference key="parent" ref="1002"/>
+						<string key="objectName">PrefsWindow</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">143</int>
+						<reference key="object" ref="648841812"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="500796533"/>
+							<reference ref="663932743"/>
+							<reference ref="670019266"/>
+						</object>
+						<reference key="parent" ref="777181097"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">144</int>
+						<reference key="object" ref="670019266"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="522700178"/>
+							<reference ref="767169657"/>
+							<reference ref="7282019"/>
+						</object>
+						<reference key="parent" ref="648841812"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">145</int>
+						<reference key="object" ref="522700178"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1060223166"/>
+						</object>
+						<reference key="parent" ref="670019266"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">147</int>
+						<reference key="object" ref="767169657"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="211902778"/>
+						</object>
+						<reference key="parent" ref="670019266"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">148</int>
+						<reference key="object" ref="211902778"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="222561211"/>
+							<reference ref="44147686"/>
+						</object>
+						<reference key="parent" ref="767169657"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">157</int>
+						<reference key="object" ref="222561211"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="712903768"/>
+							<reference ref="881922954"/>
+							<reference ref="550307815"/>
+							<reference ref="501935686"/>
+							<reference ref="148353339"/>
+							<reference ref="1022710513"/>
+							<reference ref="461733131"/>
+							<reference ref="379526382"/>
+							<reference ref="326352010"/>
+						</object>
+						<reference key="parent" ref="211902778"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">230</int>
+						<reference key="object" ref="1060223166"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1052479163"/>
+							<reference ref="980817371"/>
+							<reference ref="269336484"/>
+							<reference ref="47272907"/>
+							<reference ref="649352634"/>
+							<reference ref="807453778"/>
+							<reference ref="4371419"/>
+							<reference ref="439199863"/>
+							<reference ref="470888227"/>
+							<reference ref="315487663"/>
+							<reference ref="726460923"/>
+							<reference ref="457634098"/>
+							<reference ref="336750324"/>
+						</object>
+						<reference key="parent" ref="522700178"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">231</int>
+						<reference key="object" ref="649352634"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="739981580"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">232</int>
+						<reference key="object" ref="457634098"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="272257587"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">233</int>
+						<reference key="object" ref="47272907"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="102958279"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">234</int>
+						<reference key="object" ref="315487663"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="90102410"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">235</int>
+						<reference key="object" ref="4371419"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1023148966"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">236</int>
+						<reference key="object" ref="336750324"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="558928485"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">237</int>
+						<reference key="object" ref="980817371"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="506556221"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">238</int>
+						<reference key="object" ref="726460923"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="975089353"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">239</int>
+						<reference key="object" ref="1052479163"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="564442807"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">240</int>
+						<reference key="object" ref="807453778"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="86054106"/>
+							<reference ref="776720636"/>
+							<reference ref="760806366"/>
+							<reference ref="615553393"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">241</int>
+						<reference key="object" ref="269336484"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="557060164"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">242</int>
+						<reference key="object" ref="439199863"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="389138925"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">243</int>
+						<reference key="object" ref="389138925"/>
+						<reference key="parent" ref="439199863"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">244</int>
+						<reference key="object" ref="557060164"/>
+						<reference key="parent" ref="269336484"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">245</int>
+						<reference key="object" ref="776720636"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="711415791"/>
+						</object>
+						<reference key="parent" ref="807453778"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">246</int>
+						<reference key="object" ref="615553393"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1037106617"/>
+						</object>
+						<reference key="parent" ref="807453778"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">247</int>
+						<reference key="object" ref="760806366"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="288005197"/>
+						</object>
+						<reference key="parent" ref="807453778"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">248</int>
+						<reference key="object" ref="86054106"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="873932826"/>
+							<reference ref="416743339"/>
+							<reference ref="978863379"/>
+						</object>
+						<reference key="parent" ref="807453778"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">249</int>
+						<reference key="object" ref="873932826"/>
+						<reference key="parent" ref="86054106"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">250</int>
+						<reference key="object" ref="416743339"/>
+						<reference key="parent" ref="86054106"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">251</int>
+						<reference key="object" ref="978863379"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="305629996"/>
+						</object>
+						<reference key="parent" ref="86054106"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">252</int>
+						<reference key="object" ref="305629996"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="260944062"/>
+						</object>
+						<reference key="parent" ref="978863379"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">253</int>
+						<reference key="object" ref="260944062"/>
+						<reference key="parent" ref="305629996"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">254</int>
+						<reference key="object" ref="288005197"/>
+						<reference key="parent" ref="760806366"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">255</int>
+						<reference key="object" ref="1037106617"/>
+						<reference key="parent" ref="615553393"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">256</int>
+						<reference key="object" ref="711415791"/>
+						<reference key="parent" ref="776720636"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">257</int>
+						<reference key="object" ref="564442807"/>
+						<reference key="parent" ref="1052479163"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">258</int>
+						<reference key="object" ref="975089353"/>
+						<reference key="parent" ref="726460923"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">259</int>
+						<reference key="object" ref="506556221"/>
+						<reference key="parent" ref="980817371"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">260</int>
+						<reference key="object" ref="558928485"/>
+						<reference key="parent" ref="336750324"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">261</int>
+						<reference key="object" ref="1023148966"/>
+						<reference key="parent" ref="4371419"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">262</int>
+						<reference key="object" ref="90102410"/>
+						<reference key="parent" ref="315487663"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">263</int>
+						<reference key="object" ref="102958279"/>
+						<reference key="parent" ref="47272907"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">264</int>
+						<reference key="object" ref="272257587"/>
+						<reference key="parent" ref="457634098"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">265</int>
+						<reference key="object" ref="739981580"/>
+						<reference key="parent" ref="649352634"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">266</int>
+						<reference key="object" ref="548109881"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="957404182"/>
+						</object>
+						<reference key="parent" ref="232610295"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">267</int>
+						<reference key="object" ref="321640330"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="184243903"/>
+						</object>
+						<reference key="parent" ref="232610295"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">268</int>
+						<reference key="object" ref="513058772"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="490503381"/>
+						</object>
+						<reference key="parent" ref="232610295"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">269</int>
+						<reference key="object" ref="490503381"/>
+						<reference key="parent" ref="513058772"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">270</int>
+						<reference key="object" ref="184243903"/>
+						<reference key="parent" ref="321640330"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">271</int>
+						<reference key="object" ref="957404182"/>
+						<reference key="parent" ref="548109881"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">358</int>
+						<reference key="object" ref="7282019"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="353972395"/>
+						</object>
+						<reference key="parent" ref="670019266"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">359</int>
+						<reference key="object" ref="353972395"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="394381257"/>
+							<reference ref="541762374"/>
+							<reference ref="274792831"/>
+						</object>
+						<reference key="parent" ref="7282019"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">360</int>
+						<reference key="object" ref="500796533"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="585197460"/>
+						</object>
+						<reference key="parent" ref="648841812"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">361</int>
+						<reference key="object" ref="585197460"/>
+						<reference key="parent" ref="500796533"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">362</int>
+						<reference key="object" ref="663932743"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="434474760"/>
+						</object>
+						<reference key="parent" ref="648841812"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">363</int>
+						<reference key="object" ref="434474760"/>
+						<reference key="parent" ref="663932743"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">364</int>
+						<reference key="object" ref="470888227"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="673222361"/>
+						</object>
+						<reference key="parent" ref="1060223166"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">365</int>
+						<reference key="object" ref="673222361"/>
+						<reference key="parent" ref="470888227"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">195</int>
+						<reference key="object" ref="394381257"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="975636418"/>
+							<reference ref="344624164"/>
+							<reference ref="667827064"/>
+							<reference ref="281208820"/>
+							<reference ref="663086287"/>
+						</object>
+						<reference key="parent" ref="353972395"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">192</int>
+						<reference key="object" ref="281208820"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="952355731"/>
+						</object>
+						<reference key="parent" ref="394381257"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">370</int>
+						<reference key="object" ref="667827064"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="335293817"/>
+						</object>
+						<reference key="parent" ref="394381257"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">190</int>
+						<reference key="object" ref="344624164"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="297579270"/>
+						</object>
+						<reference key="parent" ref="394381257"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">193</int>
+						<reference key="object" ref="663086287"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="229560319"/>
+						</object>
+						<reference key="parent" ref="394381257"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">191</int>
+						<reference key="object" ref="975636418"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="669399985"/>
+						</object>
+						<reference key="parent" ref="394381257"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">228</int>
+						<reference key="object" ref="669399985"/>
+						<reference key="parent" ref="975636418"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">226</int>
+						<reference key="object" ref="229560319"/>
+						<reference key="parent" ref="663086287"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">229</int>
+						<reference key="object" ref="297579270"/>
+						<reference key="parent" ref="344624164"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">371</int>
+						<reference key="object" ref="335293817"/>
+						<reference key="parent" ref="667827064"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">227</int>
+						<reference key="object" ref="952355731"/>
+						<reference key="parent" ref="281208820"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">194</int>
+						<reference key="object" ref="274792831"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="429543509"/>
+							<reference ref="484817699"/>
+							<reference ref="707791957"/>
+							<reference ref="535851009"/>
+							<reference ref="141459662"/>
+							<reference ref="520985044"/>
+						</object>
+						<reference key="parent" ref="353972395"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">214</int>
+						<reference key="object" ref="707791957"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="491023663"/>
+						</object>
+						<reference key="parent" ref="274792831"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">225</int>
+						<reference key="object" ref="491023663"/>
+						<reference key="parent" ref="707791957"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">215</int>
+						<reference key="object" ref="535851009"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="820155412"/>
+						</object>
+						<reference key="parent" ref="274792831"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">224</int>
+						<reference key="object" ref="820155412"/>
+						<reference key="parent" ref="535851009"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">216</int>
+						<reference key="object" ref="141459662"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="795241851"/>
+						</object>
+						<reference key="parent" ref="274792831"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">223</int>
+						<reference key="object" ref="795241851"/>
+						<reference key="parent" ref="141459662"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">217</int>
+						<reference key="object" ref="429543509"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="184451495"/>
+						</object>
+						<reference key="parent" ref="274792831"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">222</int>
+						<reference key="object" ref="184451495"/>
+						<reference key="parent" ref="429543509"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">218</int>
+						<reference key="object" ref="484817699"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1065354061"/>
+						</object>
+						<reference key="parent" ref="274792831"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">221</int>
+						<reference key="object" ref="1065354061"/>
+						<reference key="parent" ref="484817699"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">219</int>
+						<reference key="object" ref="520985044"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1028595246"/>
+						</object>
+						<reference key="parent" ref="274792831"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">220</int>
+						<reference key="object" ref="1028595246"/>
+						<reference key="parent" ref="520985044"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">203</int>
+						<reference key="object" ref="541762374"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1005724872"/>
+							<reference ref="284400701"/>
+							<reference ref="297993568"/>
+							<reference ref="487013224"/>
+							<reference ref="770533714"/>
+							<reference ref="891275640"/>
+							<reference ref="628828757"/>
+							<reference ref="947618242"/>
+						</object>
+						<reference key="parent" ref="353972395"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">196</int>
+						<reference key="object" ref="891275640"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="967392554"/>
+						</object>
+						<reference key="parent" ref="541762374"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">197</int>
+						<reference key="object" ref="770533714"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="365627130"/>
+						</object>
+						<reference key="parent" ref="541762374"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">198</int>
+						<reference key="object" ref="284400701"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="487892379"/>
+						</object>
+						<reference key="parent" ref="541762374"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">199</int>
+						<reference key="object" ref="1005724872"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1015405188"/>
+						</object>
+						<reference key="parent" ref="541762374"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">200</int>
+						<reference key="object" ref="297993568"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="690043401"/>
+						</object>
+						<reference key="parent" ref="541762374"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">201</int>
+						<reference key="object" ref="487013224"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="48013634"/>
+						</object>
+						<reference key="parent" ref="541762374"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">202</int>
+						<reference key="object" ref="628828757"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="42977313"/>
+						</object>
+						<reference key="parent" ref="541762374"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">204</int>
+						<reference key="object" ref="42977313"/>
+						<reference key="parent" ref="628828757"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">205</int>
+						<reference key="object" ref="48013634"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="258333059"/>
+						</object>
+						<reference key="parent" ref="487013224"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">206</int>
+						<reference key="object" ref="258333059"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="464363541"/>
+							<reference ref="324417270"/>
+						</object>
+						<reference key="parent" ref="48013634"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">207</int>
+						<reference key="object" ref="464363541"/>
+						<reference key="parent" ref="258333059"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">208</int>
+						<reference key="object" ref="324417270"/>
+						<reference key="parent" ref="258333059"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">209</int>
+						<reference key="object" ref="690043401"/>
+						<reference key="parent" ref="297993568"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">210</int>
+						<reference key="object" ref="1015405188"/>
+						<reference key="parent" ref="1005724872"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">211</int>
+						<reference key="object" ref="487892379"/>
+						<reference key="parent" ref="284400701"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">212</int>
+						<reference key="object" ref="365627130"/>
+						<reference key="parent" ref="770533714"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">213</int>
+						<reference key="object" ref="967392554"/>
+						<reference key="parent" ref="891275640"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">150</int>
+						<reference key="object" ref="44147686"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="426586135"/>
+							<reference ref="261059178"/>
+							<reference ref="591913548"/>
+							<reference ref="795495374"/>
+							<reference ref="379314227"/>
+						</object>
+						<reference key="parent" ref="211902778"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">158</int>
+						<reference key="object" ref="426586135"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="111348041"/>
+						</object>
+						<reference key="parent" ref="44147686"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">161</int>
+						<reference key="object" ref="261059178"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="455971206"/>
+						</object>
+						<reference key="parent" ref="44147686"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">164</int>
+						<reference key="object" ref="591913548"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="5517320"/>
+						</object>
+						<reference key="parent" ref="44147686"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">159</int>
+						<reference key="object" ref="795495374"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="135248988"/>
+						</object>
+						<reference key="parent" ref="44147686"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">160</int>
+						<reference key="object" ref="379314227"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="750892379"/>
+						</object>
+						<reference key="parent" ref="44147686"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">169</int>
+						<reference key="object" ref="750892379"/>
+						<reference key="parent" ref="379314227"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">170</int>
+						<reference key="object" ref="135248988"/>
+						<reference key="parent" ref="795495374"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">165</int>
+						<reference key="object" ref="5517320"/>
+						<reference key="parent" ref="591913548"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">168</int>
+						<reference key="object" ref="455971206"/>
+						<reference key="parent" ref="261059178"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">171</int>
+						<reference key="object" ref="111348041"/>
+						<reference key="parent" ref="426586135"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">153</int>
+						<reference key="object" ref="881922954"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="233356393"/>
+						</object>
+						<reference key="parent" ref="222561211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">182</int>
+						<reference key="object" ref="233356393"/>
+						<reference key="parent" ref="881922954"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">151</int>
+						<reference key="object" ref="712903768"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="407236409"/>
+						</object>
+						<reference key="parent" ref="222561211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">184</int>
+						<reference key="object" ref="407236409"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="851600464"/>
+						</object>
+						<reference key="parent" ref="712903768"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">185</int>
+						<reference key="object" ref="851600464"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="667958028"/>
+							<reference ref="415882579"/>
+						</object>
+						<reference key="parent" ref="407236409"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">187</int>
+						<reference key="object" ref="667958028"/>
+						<reference key="parent" ref="851600464"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">186</int>
+						<reference key="object" ref="415882579"/>
+						<reference key="parent" ref="851600464"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">156</int>
+						<reference key="object" ref="501935686"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="268708028"/>
+						</object>
+						<reference key="parent" ref="222561211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">172</int>
+						<reference key="object" ref="268708028"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1073161332"/>
+						</object>
+						<reference key="parent" ref="501935686"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">173</int>
+						<reference key="object" ref="1073161332"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="972610094"/>
+							<reference ref="480047452"/>
+							<reference ref="146973984"/>
+							<reference ref="487793395"/>
+							<reference ref="50504943"/>
+							<reference ref="478477769"/>
+							<reference ref="509528543"/>
+						</object>
+						<reference key="parent" ref="268708028"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">179</int>
+						<reference key="object" ref="972610094"/>
+						<reference key="parent" ref="1073161332"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">178</int>
+						<reference key="object" ref="480047452"/>
+						<reference key="parent" ref="1073161332"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">177</int>
+						<reference key="object" ref="146973984"/>
+						<reference key="parent" ref="1073161332"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">176</int>
+						<reference key="object" ref="487793395"/>
+						<reference key="parent" ref="1073161332"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">175</int>
+						<reference key="object" ref="50504943"/>
+						<reference key="parent" ref="1073161332"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">174</int>
+						<reference key="object" ref="478477769"/>
+						<reference key="parent" ref="1073161332"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">152</int>
+						<reference key="object" ref="1022710513"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="245199648"/>
+						</object>
+						<reference key="parent" ref="222561211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">183</int>
+						<reference key="object" ref="245199648"/>
+						<reference key="parent" ref="1022710513"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">162</int>
+						<reference key="object" ref="379526382"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="416456809"/>
+						</object>
+						<reference key="parent" ref="222561211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">167</int>
+						<reference key="object" ref="416456809"/>
+						<reference key="parent" ref="379526382"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">154</int>
+						<reference key="object" ref="461733131"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="202615520"/>
+						</object>
+						<reference key="parent" ref="222561211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">181</int>
+						<reference key="object" ref="202615520"/>
+						<reference key="parent" ref="461733131"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">149</int>
+						<reference key="object" ref="326352010"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="474687544"/>
+						</object>
+						<reference key="parent" ref="222561211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">188</int>
+						<reference key="object" ref="474687544"/>
+						<reference key="parent" ref="326352010"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">155</int>
+						<reference key="object" ref="550307815"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="87807091"/>
+						</object>
+						<reference key="parent" ref="222561211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">180</int>
+						<reference key="object" ref="87807091"/>
+						<reference key="parent" ref="550307815"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">163</int>
+						<reference key="object" ref="148353339"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1025684210"/>
+						</object>
+						<reference key="parent" ref="222561211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">166</int>
+						<reference key="object" ref="1025684210"/>
+						<reference key="parent" ref="148353339"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">375</int>
+						<reference key="object" ref="509528543"/>
+						<reference key="parent" ref="1073161332"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">376</int>
+						<reference key="object" ref="947618242"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="337142710"/>
+						</object>
+						<reference key="parent" ref="541762374"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">377</int>
+						<reference key="object" ref="337142710"/>
+						<reference key="parent" ref="947618242"/>
+					</object>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="flattenedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="NSMutableArray" key="dict.sortedKeys">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>-1.IBPluginDependency</string>
+					<string>-2.IBPluginDependency</string>
+					<string>-3.IBPluginDependency</string>
+					<string>141.IBEditorWindowLastContentRect</string>
+					<string>141.IBPluginDependency</string>
+					<string>141.ImportedFromIB2</string>
+					<string>142.IBEditorWindowLastContentRect</string>
+					<string>142.IBWindowTemplateEditedContentRect</string>
+					<string>142.ImportedFromIB2</string>
+					<string>142.NSWindowTemplate.visibleAtLaunch</string>
+					<string>142.windowTemplate.hasMinSize</string>
+					<string>142.windowTemplate.minSize</string>
+					<string>143.IBPluginDependency</string>
+					<string>143.ImportedFromIB2</string>
+					<string>144.IBPluginDependency</string>
+					<string>144.ImportedFromIB2</string>
+					<string>145.IBPluginDependency</string>
+					<string>145.ImportedFromIB2</string>
+					<string>147.IBPluginDependency</string>
+					<string>147.ImportedFromIB2</string>
+					<string>148.IBPluginDependency</string>
+					<string>148.ImportedFromIB2</string>
+					<string>149.IBPluginDependency</string>
+					<string>149.ImportedFromIB2</string>
+					<string>150.IBPluginDependency</string>
+					<string>150.ImportedFromIB2</string>
+					<string>151.IBPluginDependency</string>
+					<string>151.ImportedFromIB2</string>
+					<string>152.IBPluginDependency</string>
+					<string>152.ImportedFromIB2</string>
+					<string>153.IBPluginDependency</string>
+					<string>153.ImportedFromIB2</string>
+					<string>154.IBPluginDependency</string>
+					<string>154.ImportedFromIB2</string>
+					<string>155.IBPluginDependency</string>
+					<string>155.ImportedFromIB2</string>
+					<string>156.IBPluginDependency</string>
+					<string>156.ImportedFromIB2</string>
+					<string>157.IBPluginDependency</string>
+					<string>157.ImportedFromIB2</string>
+					<string>158.IBPluginDependency</string>
+					<string>158.ImportedFromIB2</string>
+					<string>159.IBPluginDependency</string>
+					<string>159.ImportedFromIB2</string>
+					<string>160.IBPluginDependency</string>
+					<string>160.ImportedFromIB2</string>
+					<string>161.IBPluginDependency</string>
+					<string>161.ImportedFromIB2</string>
+					<string>162.IBPluginDependency</string>
+					<string>162.ImportedFromIB2</string>
+					<string>163.IBPluginDependency</string>
+					<string>163.ImportedFromIB2</string>
+					<string>164.IBPluginDependency</string>
+					<string>164.ImportedFromIB2</string>
+					<string>165.IBPluginDependency</string>
+					<string>166.IBPluginDependency</string>
+					<string>167.IBPluginDependency</string>
+					<string>168.IBPluginDependency</string>
+					<string>169.IBPluginDependency</string>
+					<string>170.IBPluginDependency</string>
+					<string>171.IBPluginDependency</string>
+					<string>172.IBPluginDependency</string>
+					<string>173.IBEditorWindowLastContentRect</string>
+					<string>173.IBPluginDependency</string>
+					<string>173.ImportedFromIB2</string>
+					<string>174.IBPluginDependency</string>
+					<string>174.ImportedFromIB2</string>
+					<string>175.IBPluginDependency</string>
+					<string>175.ImportedFromIB2</string>
+					<string>176.IBPluginDependency</string>
+					<string>176.ImportedFromIB2</string>
+					<string>177.IBPluginDependency</string>
+					<string>177.ImportedFromIB2</string>
+					<string>178.IBPluginDependency</string>
+					<string>178.ImportedFromIB2</string>
+					<string>179.IBPluginDependency</string>
+					<string>179.ImportedFromIB2</string>
+					<string>180.IBPluginDependency</string>
+					<string>181.IBPluginDependency</string>
+					<string>182.IBPluginDependency</string>
+					<string>183.IBPluginDependency</string>
+					<string>184.IBPluginDependency</string>
+					<string>185.IBEditorWindowLastContentRect</string>
+					<string>185.IBPluginDependency</string>
+					<string>185.ImportedFromIB2</string>
+					<string>186.IBPluginDependency</string>
+					<string>186.ImportedFromIB2</string>
+					<string>187.IBPluginDependency</string>
+					<string>187.ImportedFromIB2</string>
+					<string>188.IBPluginDependency</string>
+					<string>190.IBPluginDependency</string>
+					<string>190.ImportedFromIB2</string>
+					<string>191.IBPluginDependency</string>
+					<string>191.ImportedFromIB2</string>
+					<string>192.IBPluginDependency</string>
+					<string>192.ImportedFromIB2</string>
+					<string>193.IBPluginDependency</string>
+					<string>193.ImportedFromIB2</string>
+					<string>194.IBPluginDependency</string>
+					<string>194.ImportedFromIB2</string>
+					<string>195.IBPluginDependency</string>
+					<string>195.ImportedFromIB2</string>
+					<string>196.IBPluginDependency</string>
+					<string>196.ImportedFromIB2</string>
+					<string>197.IBPluginDependency</string>
+					<string>197.ImportedFromIB2</string>
+					<string>198.IBPluginDependency</string>
+					<string>198.ImportedFromIB2</string>
+					<string>199.IBPluginDependency</string>
+					<string>199.ImportedFromIB2</string>
+					<string>200.IBPluginDependency</string>
+					<string>200.ImportedFromIB2</string>
+					<string>201.IBPluginDependency</string>
+					<string>201.ImportedFromIB2</string>
+					<string>202.IBPluginDependency</string>
+					<string>202.ImportedFromIB2</string>
+					<string>203.IBPluginDependency</string>
+					<string>203.ImportedFromIB2</string>
+					<string>204.IBPluginDependency</string>
+					<string>205.IBPluginDependency</string>
+					<string>206.IBPluginDependency</string>
+					<string>206.ImportedFromIB2</string>
+					<string>207.IBPluginDependency</string>
+					<string>207.ImportedFromIB2</string>
+					<string>208.IBPluginDependency</string>
+					<string>208.ImportedFromIB2</string>
+					<string>209.IBPluginDependency</string>
+					<string>210.IBPluginDependency</string>
+					<string>211.IBPluginDependency</string>
+					<string>212.IBPluginDependency</string>
+					<string>213.IBPluginDependency</string>
+					<string>214.IBPluginDependency</string>
+					<string>214.ImportedFromIB2</string>
+					<string>215.IBPluginDependency</string>
+					<string>215.ImportedFromIB2</string>
+					<string>216.IBPluginDependency</string>
+					<string>216.ImportedFromIB2</string>
+					<string>217.IBPluginDependency</string>
+					<string>217.ImportedFromIB2</string>
+					<string>218.IBPluginDependency</string>
+					<string>218.ImportedFromIB2</string>
+					<string>219.IBPluginDependency</string>
+					<string>219.ImportedFromIB2</string>
+					<string>220.IBPluginDependency</string>
+					<string>221.IBPluginDependency</string>
+					<string>222.IBPluginDependency</string>
+					<string>223.IBPluginDependency</string>
+					<string>224.IBPluginDependency</string>
+					<string>225.IBPluginDependency</string>
+					<string>226.IBPluginDependency</string>
+					<string>227.IBPluginDependency</string>
+					<string>228.IBPluginDependency</string>
+					<string>229.IBPluginDependency</string>
+					<string>230.IBPluginDependency</string>
+					<string>230.ImportedFromIB2</string>
+					<string>231.IBPluginDependency</string>
+					<string>231.ImportedFromIB2</string>
+					<string>232.IBPluginDependency</string>
+					<string>232.ImportedFromIB2</string>
+					<string>233.IBPluginDependency</string>
+					<string>233.ImportedFromIB2</string>
+					<string>234.IBPluginDependency</string>
+					<string>234.ImportedFromIB2</string>
+					<string>235.IBPluginDependency</string>
+					<string>235.ImportedFromIB2</string>
+					<string>236.IBPluginDependency</string>
+					<string>236.ImportedFromIB2</string>
+					<string>237.IBPluginDependency</string>
+					<string>237.ImportedFromIB2</string>
+					<string>238.IBPluginDependency</string>
+					<string>238.ImportedFromIB2</string>
+					<string>239.IBPluginDependency</string>
+					<string>239.ImportedFromIB2</string>
+					<string>240.IBPluginDependency</string>
+					<string>240.ImportedFromIB2</string>
+					<string>241.IBPluginDependency</string>
+					<string>241.ImportedFromIB2</string>
+					<string>242.IBPluginDependency</string>
+					<string>242.ImportedFromIB2</string>
+					<string>243.IBPluginDependency</string>
+					<string>244.IBPluginDependency</string>
+					<string>245.IBPluginDependency</string>
+					<string>245.ImportedFromIB2</string>
+					<string>246.IBPluginDependency</string>
+					<string>246.ImportedFromIB2</string>
+					<string>247.IBPluginDependency</string>
+					<string>247.ImportedFromIB2</string>
+					<string>248.IBPluginDependency</string>
+					<string>248.ImportedFromIB2</string>
+					<string>249.IBPluginDependency</string>
+					<string>249.IBShouldRemoveOnLegacySave</string>
+					<string>250.IBPluginDependency</string>
+					<string>250.IBShouldRemoveOnLegacySave</string>
+					<string>251.IBPluginDependency</string>
+					<string>251.ImportedFromIB2</string>
+					<string>252.IBPluginDependency</string>
+					<string>252.ImportedFromIB2</string>
+					<string>253.IBPluginDependency</string>
+					<string>253.IBShouldRemoveOnLegacySave</string>
+					<string>254.IBPluginDependency</string>
+					<string>255.IBPluginDependency</string>
+					<string>256.IBPluginDependency</string>
+					<string>257.IBPluginDependency</string>
+					<string>258.IBPluginDependency</string>
+					<string>259.IBPluginDependency</string>
+					<string>260.IBPluginDependency</string>
+					<string>261.IBPluginDependency</string>
+					<string>262.IBPluginDependency</string>
+					<string>263.IBPluginDependency</string>
+					<string>264.IBPluginDependency</string>
+					<string>265.IBPluginDependency</string>
+					<string>266.IBPluginDependency</string>
+					<string>266.ImportedFromIB2</string>
+					<string>267.IBPluginDependency</string>
+					<string>267.ImportedFromIB2</string>
+					<string>268.IBPluginDependency</string>
+					<string>268.ImportedFromIB2</string>
+					<string>269.IBPluginDependency</string>
+					<string>270.IBPluginDependency</string>
+					<string>271.IBPluginDependency</string>
+					<string>358.IBPluginDependency</string>
+					<string>359.IBPluginDependency</string>
+					<string>360.IBPluginDependency</string>
+					<string>361.IBPluginDependency</string>
+					<string>362.IBPluginDependency</string>
+					<string>363.IBPluginDependency</string>
+					<string>364.IBPluginDependency</string>
+					<string>364.ImportedFromIB2</string>
+					<string>365.IBPluginDependency</string>
+					<string>370.IBPluginDependency</string>
+					<string>370.ImportedFromIB2</string>
+					<string>371.IBPluginDependency</string>
+					<string>375.IBPluginDependency</string>
+					<string>375.ImportedFromIB2</string>
+					<string>376.IBPluginDependency</string>
+					<string>377.IBPluginDependency</string>
+				</object>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>{{21, 760}, {229, 62}}</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<boolean value="YES" id="5"/>
+					<string>{{138, 317}, {580, 460}}</string>
+					<string>{{138, 317}, {580, 460}}</string>
+					<reference ref="5"/>
+					<boolean value="NO"/>
+					<reference ref="5"/>
+					<string>{580, 460}</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>{{601, 517}, {143, 143}}</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>{{196, 720}, {138, 43}}</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<reference ref="5"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="unlocalizedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="NSArray" key="dict.sortedKeys">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+				</object>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+				</object>
+			</object>
+			<nil key="activeLocalization"/>
+			<object class="NSMutableDictionary" key="localizations">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="NSArray" key="dict.sortedKeys">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+				</object>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+				</object>
+			</object>
+			<nil key="sourceID"/>
+			<int key="maxID">379</int>
+		</object>
+		<object class="IBClassDescriber" key="IBDocument.Classes">
+			<object class="NSMutableArray" key="referencedPartialClassDescriptions">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBPartialClassDescription">
+					<string key="className">VMSettingsController</string>
+					<string key="superclassName">NSWindowController</string>
+					<object class="NSMutableDictionary" key="actions">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSMutableArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>addDisk:</string>
+							<string>browseForKeyCodesFileClicked:</string>
+							<string>browseForROMFileClicked:</string>
+							<string>browseForUnixRootClicked:</string>
+							<string>cancelEdit:</string>
+							<string>createDisk:</string>
+							<string>removeDisk:</string>
+							<string>saveChanges:</string>
+							<string>useRawKeyCodesClicked:</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>id</string>
+							<string>id</string>
+							<string>id</string>
+							<string>id</string>
+							<string>id</string>
+							<string>id</string>
+							<string>id</string>
+							<string>id</string>
+							<string>id</string>
+						</object>
+					</object>
+					<object class="NSMutableDictionary" key="outlets">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSMutableArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>bootFrom</string>
+							<string>browseRawKeyCodesButton</string>
+							<string>disableCdrom</string>
+							<string>disableSound</string>
+							<string>diskSaveSize</string>
+							<string>diskSaveSizeField</string>
+							<string>disks</string>
+							<string>dontUseCPUWhenIdle</string>
+							<string>enable68kDREmulator</string>
+							<string>enableJIT</string>
+							<string>ethernetInterface</string>
+							<string>height</string>
+							<string>ignoreIllegalInstructions</string>
+							<string>ignoreIllegalMemoryAccesses</string>
+							<string>mixDevice</string>
+							<string>modemPort</string>
+							<string>mouseWheel</string>
+							<string>outDevice</string>
+							<string>printerPort</string>
+							<string>qdAccel</string>
+							<string>ramSize</string>
+							<string>ramSizeStepper</string>
+							<string>rawKeyCodes</string>
+							<string>refreshRate</string>
+							<string>romFile</string>
+							<string>scrollLines</string>
+							<string>scrollLinesStepper</string>
+							<string>unixRoot</string>
+							<string>useRawKeyCodes</string>
+							<string>videoType</string>
+							<string>width</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>NSComboBox</string>
+							<string>NSButton</string>
+							<string>NSButton</string>
+							<string>NSButton</string>
+							<string>NSView</string>
+							<string>NSTextField</string>
+							<string>NSTableView</string>
+							<string>NSButton</string>
+							<string>NSButton</string>
+							<string>NSButton</string>
+							<string>NSTextField</string>
+							<string>NSComboBox</string>
+							<string>NSButton</string>
+							<string>NSButton</string>
+							<string>NSTextField</string>
+							<string>NSTextField</string>
+							<string>NSPopUpButton</string>
+							<string>NSTextField</string>
+							<string>NSTextField</string>
+							<string>NSButton</string>
+							<string>NSTextField</string>
+							<string>NSStepper</string>
+							<string>NSTextField</string>
+							<string>NSPopUpButton</string>
+							<string>NSTextField</string>
+							<string>NSTextField</string>
+							<string>NSStepper</string>
+							<string>NSTextField</string>
+							<string>NSButton</string>
+							<string>NSPopUpButton</string>
+							<string>NSComboBox</string>
+						</object>
+					</object>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">VMSettingsController.h</string>
+					</object>
+				</object>
+			</object>
+		</object>
+		<int key="IBDocument.localizationMode">0</int>
+		<string key="IBDocument.LastKnownRelativeProjectPath">../SheepShaverLauncher.xcodeproj</string>
+		<int key="IBDocument.defaultPropertyAccessControl">3</int>
+	</data>
+</archive>
--- macemu/SheepShaver/src/MacOSX/PrefsEditor/English.lproj/MainMenu.nib/classes.nib
+++ sheepshaver/SheepShaver/src/MacOSX/PrefsEditor/English.lproj/MainMenu.nib/classes.nib
@@ -1,105 +1,50 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>IBClasses</key>
-	<array>
-		<dict>
-			<key>ACTIONS</key>
-			<dict>
-				<key>addDisk</key>
-				<string>id</string>
-				<key>browseForROMFileClicked</key>
-				<string>id</string>
-				<key>createDisk</key>
-				<string>id</string>
-				<key>moveDiskToTop</key>
-				<string>id</string>
-				<key>removeDisk</key>
-				<string>id</string>
-				<key>useRawKeyCodesClicked</key>
-				<string>id</string>
-			</dict>
-			<key>CLASS</key>
-			<string>PrefsEditor</string>
-			<key>LANGUAGE</key>
-			<string>ObjC</string>
-			<key>OUTLETS</key>
-			<dict>
-				<key>bootFrom</key>
-				<string>NSComboBox</string>
-				<key>disableCdrom</key>
-				<string>NSButton</string>
-				<key>disableSound</key>
-				<string>NSButton</string>
-				<key>diskSaveSize</key>
-				<string>NSView</string>
-				<key>diskSaveSizeField</key>
-				<string>NSTextField</string>
-				<key>disks</key>
-				<string>NSTableView</string>
-				<key>dontUseCPUWhenIdle</key>
-				<string>NSButton</string>
-				<key>enable68kDREmulator</key>
-				<string>NSButton</string>
-				<key>enableJIT</key>
-				<string>NSButton</string>
-				<key>ethernetInterface</key>
-				<string>NSTextField</string>
-				<key>height</key>
-				<string>NSComboBox</string>
-				<key>ignoreIllegalMemoryAccesses</key>
-				<string>NSButton</string>
-				<key>mixDevice</key>
-				<string>NSTextField</string>
-				<key>modemPort</key>
-				<string>NSTextField</string>
-				<key>mouseWheel</key>
-				<string>NSPopUpButton</string>
-				<key>outDevice</key>
-				<string>NSTextField</string>
-				<key>printerPort</key>
-				<string>NSTextField</string>
-				<key>qdAccel</key>
-				<string>NSButton</string>
-				<key>ramSize</key>
-				<string>NSTextField</string>
-				<key>ramSizeStepper</key>
-				<string>NSStepper</string>
-				<key>rawKeyCodes</key>
-				<string>NSTextField</string>
-				<key>refreshRate</key>
-				<string>NSPopUpButton</string>
-				<key>romFile</key>
-				<string>NSTextField</string>
-				<key>scrollLines</key>
-				<string>NSTextField</string>
-				<key>scrollLinesStepper</key>
-				<string>NSStepper</string>
-				<key>unixRoot</key>
-				<string>NSTextField</string>
-				<key>useRawKeyCodes</key>
-				<string>NSButton</string>
-				<key>videoType</key>
-				<string>NSPopUpButton</string>
-				<key>width</key>
-				<string>NSComboBox</string>
-				<key>window</key>
-				<string>NSWindow</string>
-			</dict>
-			<key>SUPERCLASS</key>
-			<string>NSObject</string>
-		</dict>
-		<dict>
-			<key>CLASS</key>
-			<string>FirstResponder</string>
-			<key>LANGUAGE</key>
-			<string>ObjC</string>
-			<key>SUPERCLASS</key>
-			<string>NSObject</string>
-		</dict>
-	</array>
-	<key>IBVersion</key>
-	<string>1</string>
-</dict>
-</plist>
+{
+    IBClasses = (
+        {CLASS = FirstResponder; LANGUAGE = ObjC; SUPERCLASS = NSObject; }, 
+        {
+            ACTIONS = {
+                addDisk = id; 
+                browseForROMFileClicked = id; 
+                createDisk = id; 
+                removeDisk = id; 
+                useRawKeyCodesClicked = id; 
+            }; 
+            CLASS = PrefsEditor; 
+            LANGUAGE = ObjC; 
+            OUTLETS = {
+                bootFrom = NSComboBox; 
+                disableCdrom = NSButton; 
+                disableSound = NSButton; 
+                diskSaveSize = NSView; 
+                diskSaveSizeField = NSTextField; 
+                disks = NSTableView; 
+                dontUseCPUWhenIdle = NSButton; 
+                enable68kDREmulator = NSButton; 
+                enableJIT = NSButton; 
+                ethernetInterface = NSTextField; 
+                height = NSComboBox; 
+                ignoreIllegalMemoryAccesses = NSButton; 
+                mixDevice = NSTextField; 
+                modemPort = NSTextField; 
+                mouseWheel = NSPopUpButton; 
+                outDevice = NSTextField; 
+                printerPort = NSTextField; 
+                qdAccel = NSButton; 
+                ramSize = NSTextField; 
+                ramSizeStepper = NSStepper; 
+                rawKeyCodes = NSTextField; 
+                refreshRate = NSPopUpButton; 
+                romFile = NSTextField; 
+                scrollLines = NSTextField; 
+                scrollLinesStepper = NSStepper; 
+                unixRoot = NSTextField; 
+                useRawKeyCodes = NSButton; 
+                videoType = NSPopUpButton; 
+                width = NSComboBox; 
+                window = NSWindow; 
+            }; 
+            SUPERCLASS = NSObject; 
+        }
+    ); 
+    IBVersion = 1; 
+}
\ No newline at end of file
--- macemu/SheepShaver/src/MacOSX/PrefsEditor/PrefsEditor.h
+++ sheepshaver/SheepShaver/src/MacOSX/PrefsEditor/PrefsEditor.h
@@ -61,9 +61,8 @@
 }
 - (id) init;
 - (IBAction) addDisk:(id)sender;
-- (IBAction) createDisk:(id)sender;
 - (IBAction) removeDisk:(id)sender;
-- (IBAction) moveDiskToTop:(id)sender;
+- (IBAction) createDisk:(id)sender;
 - (IBAction) useRawKeyCodesClicked:(id)sender;
 - (IBAction) browseForROMFileClicked:(id)sender;
 - (void) windowWillClose: (NSNotification *) aNotification;
--- macemu/SheepShaver/src/MacOSX/PrefsEditor/PrefsEditor.mm
+++ sheepshaver/SheepShaver/src/MacOSX/PrefsEditor/PrefsEditor.mm
@@ -20,12 +20,12 @@
 
 #import "PrefsEditor.h"
 
-#import "../../CrossPlatform/sysdeps.h"
+#import "sysdeps.h"
 #import "prefs.h"
 
 const int CDROMRefNum = -62;			// RefNum of driver
 
-//#ifdef STANDALONE_PREFS
+#ifdef STANDALONE_PREFS
 void prefs_init()
 {
 }
@@ -33,7 +33,7 @@
 void prefs_exit()
 {
 }
-//#endif
+#endif
 
 @implementation PrefsEditor
 
@@ -54,12 +54,12 @@
   return self;
 }
 
-- (NSInteger)numberOfRowsInTableView:(NSTableView *)aTable
+- (int)numberOfRowsInTableView:(NSTableView *)aTable
 {
   return [diskArray count];
 }
 
-- (id)tableView:(NSTableView *)aTable objectValueForTableColumn:(NSTableColumn *)aCol row:(NSInteger)aRow
+- (id)tableView:(NSTableView *)aTable objectValueForTableColumn:(NSTableColumn *)aCol row:(int)aRow
 {
   return [diskArray objectAtIndex: aRow];
 }
@@ -155,20 +155,6 @@
   [modemPort setStringValue: getStringFromPrefs("seriala") ];
   [printerPort setStringValue: getStringFromPrefs("serialb") ];
   [ethernetInterface setStringValue: getStringFromPrefs("ether") ];
-}
-
-- (IBAction) moveDiskToTop:(id)sender
-{
-	int selectedRow = [disks selectedRow];
-	NSLog(@"selected row %i", selectedRow);
-	if (selectedRow >= 0) {
-		id object = [[diskArray objectAtIndex:selectedRow] retain];
-		[diskArray removeObjectAtIndex:selectedRow];
-		[diskArray insertObject:object atIndex:0];
-		NSIndexSet *indexSet = [NSIndexSet indexSetWithIndex:0];
-		[disks selectRowIndexes:indexSet byExtendingSelection:NO];
-		[disks reloadData];
-	}
 }
 
 - (IBAction) addDisk:(id)sender
--- macemu/SheepShaver/src/MacOSX/PrefsEditor/SheepShaverPrefs.xcodeproj/project.pbxproj
+++ sheepshaver/SheepShaver/src/MacOSX/PrefsEditor/SheepShaverPrefs.xcodeproj/project.pbxproj
@@ -3,7 +3,7 @@
 	archiveVersion = 1;
 	classes = {
 	};
-	objectVersion = 45;
+	objectVersion = 42;
 	objects = {
 
 /* Begin PBXBuildFile section */
@@ -27,8 +27,8 @@
 		08DC90C20B67078300799A45 /* prefs.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = prefs.h; path = ../../include/prefs.h; sourceTree = SOURCE_ROOT; };
 		08DC90C40B67079800799A45 /* sys.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = sys.h; path = ../../include/sys.h; sourceTree = SOURCE_ROOT; };
 		08DC90C50B6707AC00799A45 /* user_strings_unix.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = user_strings_unix.h; path = ../../Unix/user_strings_unix.h; sourceTree = SOURCE_ROOT; };
-		08DC90C60B6707B400799A45 /* config.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = config.h; path = ../config.h; sourceTree = SOURCE_ROOT; };
-		08DC90C70B6707BE00799A45 /* sysdeps.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = sysdeps.h; path = ../../../../BasiliskII/src/Unix/sysdeps.h; sourceTree = SOURCE_ROOT; };
+		08DC90C60B6707B400799A45 /* config.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = config.h; path = ../../Unix/config.h; sourceTree = SOURCE_ROOT; };
+		08DC90C70B6707BE00799A45 /* sysdeps.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = sysdeps.h; path = ../../Unix/sysdeps.h; sourceTree = SOURCE_ROOT; };
 		1058C7A1FEA54F0111CA2CBB /* Cocoa.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cocoa.framework; path = /System/Library/Frameworks/Cocoa.framework; sourceTree = "<absolute>"; };
 		13E42FB307B3F0F600E4EEF1 /* CoreData.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreData.framework; path = /System/Library/Frameworks/CoreData.framework; sourceTree = "<absolute>"; };
 		29B97316FDCFA39411CA2CEA /* main.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = "<group>"; };
@@ -161,19 +161,10 @@
 /* Begin PBXProject section */
 		29B97313FDCFA39411CA2CEA /* Project object */ = {
 			isa = PBXProject;
-			attributes = {
-				LastUpgradeCheck = 0900;
-			};
 			buildConfigurationList = C01FCF4E08A954540054247B /* Build configuration list for PBXProject "SheepShaverPrefs" */;
-			compatibilityVersion = "Xcode 3.1";
-			developmentRegion = en;
 			hasScannedForEncodings = 1;
-			knownRegions = (
-				en,
-			);
 			mainGroup = 29B97314FDCFA39411CA2CEA /* SheepShaverPrefs */;
 			projectDirPath = "";
-			projectRoot = "";
 			targets = (
 				8D1107260486CEB800E47090 /* SheepShaverPrefs */,
 			);
@@ -243,9 +234,7 @@
 				INFOPLIST_FILE = Info.plist;
 				INSTALL_PATH = "$(HOME)/Applications";
 				OTHER_CFLAGS = "$(inherited)";
-				PRODUCT_BUNDLE_IDENTIFIER = net.sourceforge.SheepShaverPrefs;
 				PRODUCT_NAME = SheepShaverPrefs;
-				SDKROOT = macosx;
 				WRAPPER_EXTENSION = app;
 				ZERO_LINK = YES;
 			};
@@ -254,6 +243,10 @@
 		C01FCF4C08A954540054247B /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				ARCHS = (
+					ppc,
+					i386,
+				);
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_INPUT_FILETYPE = sourcecode.cpp.objcpp;
 				GCC_MODEL_TUNING = G5;
@@ -264,9 +257,7 @@
 				INFOPLIST_FILE = Info.plist;
 				INSTALL_PATH = "$(HOME)/Applications";
 				OTHER_CFLAGS = "$(inherited)";
-				PRODUCT_BUNDLE_IDENTIFIER = net.sourceforge.SheepShaverPrefs;
 				PRODUCT_NAME = SheepShaverPrefs;
-				SDKROOT = macosx;
 				WRAPPER_EXTENSION = app;
 			};
 			name = Release;
@@ -274,66 +265,20 @@
 		C01FCF4F08A954540054247B /* Debug */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
-				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
-				CLANG_WARN_BOOL_CONVERSION = YES;
-				CLANG_WARN_COMMA = YES;
-				CLANG_WARN_CONSTANT_CONVERSION = YES;
-				CLANG_WARN_EMPTY_BODY = YES;
-				CLANG_WARN_ENUM_CONVERSION = YES;
-				CLANG_WARN_INFINITE_RECURSION = YES;
-				CLANG_WARN_INT_CONVERSION = YES;
-				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
-				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
-				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
-				CLANG_WARN_STRICT_PROTOTYPES = YES;
-				CLANG_WARN_SUSPICIOUS_MOVE = YES;
-				CLANG_WARN_UNREACHABLE_CODE = YES;
-				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
-				ENABLE_STRICT_OBJC_MSGSEND = YES;
-				ENABLE_TESTABILITY = YES;
-				GCC_NO_COMMON_BLOCKS = YES;
-				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
 				GCC_WARN_ABOUT_RETURN_TYPE = YES;
-				GCC_WARN_UNDECLARED_SELECTOR = YES;
-				GCC_WARN_UNINITIALIZED_AUTOS = YES;
-				GCC_WARN_UNUSED_FUNCTION = YES;
 				GCC_WARN_UNUSED_VARIABLE = YES;
-				MACOSX_DEPLOYMENT_TARGET = 10.7;
-				ONLY_ACTIVE_ARCH = YES;
 				PREBINDING = NO;
-				SDKROOT = "$(DEVELOPER_SDK_DIR)/MacOSX10.4u.sdk";
+				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
 			};
 			name = Debug;
 		};
 		C01FCF5008A954540054247B /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
-				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
-				CLANG_WARN_BOOL_CONVERSION = YES;
-				CLANG_WARN_COMMA = YES;
-				CLANG_WARN_CONSTANT_CONVERSION = YES;
-				CLANG_WARN_EMPTY_BODY = YES;
-				CLANG_WARN_ENUM_CONVERSION = YES;
-				CLANG_WARN_INFINITE_RECURSION = YES;
-				CLANG_WARN_INT_CONVERSION = YES;
-				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
-				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
-				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
-				CLANG_WARN_STRICT_PROTOTYPES = YES;
-				CLANG_WARN_SUSPICIOUS_MOVE = YES;
-				CLANG_WARN_UNREACHABLE_CODE = YES;
-				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
-				ENABLE_STRICT_OBJC_MSGSEND = YES;
-				GCC_NO_COMMON_BLOCKS = YES;
-				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
 				GCC_WARN_ABOUT_RETURN_TYPE = YES;
-				GCC_WARN_UNDECLARED_SELECTOR = YES;
-				GCC_WARN_UNINITIALIZED_AUTOS = YES;
-				GCC_WARN_UNUSED_FUNCTION = YES;
 				GCC_WARN_UNUSED_VARIABLE = YES;
-				MACOSX_DEPLOYMENT_TARGET = 10.7;
 				PREBINDING = NO;
-				SDKROOT = "$(DEVELOPER_SDK_DIR)/MacOSX10.4u.sdk";
+				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
 			};
 			name = Release;
 		};
--- macemu/SheepShaver/src/Unix/Linux/NetDriver/sheep_net.c
+++ sheepshaver/SheepShaver/src/Unix/Linux/NetDriver/sheep_net.c
@@ -240,7 +220,7 @@
 {
 	/* Unregister driver */
 	misc_deregister(&sheep_net_device);
-	printk("sheep net: driver removed\n");
+	D(bug("Sheep net driver removed\n"));
 }
 
 
@@ -268,9 +248,12 @@
 	memset(v, 0, sizeof(struct SheepVars));
 	skb_queue_head_init(&v->queue);
 	init_waitqueue_head(&v->wait);
-	v->fake_addr[0] = 'v'; /* "SheepShaver" */
-	v->fake_addr[1] = 'r'; /*          ^ ^  */
-	get_random_bytes(&v->fake_addr[2], 4);
+	v->fake_addr[0] = 0xfe;
+	v->fake_addr[1] = 0xfd;
+	v->fake_addr[2] = 0xde;
+	v->fake_addr[3] = 0xad;
+	v->fake_addr[4] = 0xbe;
+	v->fake_addr[5] = 0xef;
 
 	/* Put our stuff where we will be able to find it later */
 	f->private_data = (void *)v;
@@ -338,7 +321,7 @@
 }
 
 
-/*
+/* 
  * Outgoing packet. Replace the fake enet addr with the real local one.
  */
 
@@ -351,7 +334,7 @@
 {
 	u8 *p = skb_mac_header(skb);
 	int proto = (p[12] << 8) | p[13];
-
+	
 	do_demasq(v, p + 6); /* source address */
 
 	/* Need to fix ARP packets */
@@ -407,12 +390,7 @@
 			break;
 
 		/* No packet in queue and in blocking mode, so block */
-#ifdef LINUX_3_15
-		atomic_set(&v->got_packet, 0);
-		wait_event_interruptible(v->wait, atomic_read(&v->got_packet));
-#else
 		interruptible_sleep_on(&v->wait);
-#endif
 
 		/* Signal received? Then bail out */
 		if (signal_pending(current))
@@ -435,11 +413,6 @@
  *  Driver write() function
  */
 
-static inline void do_nothing(struct sk_buff *skb)
-{
-	return;
-}
-
 static ssize_t sheep_net_write(struct file *f, const char *buf, size_t count, loff_t *off)
 {
 	struct SheepVars *v = (struct SheepVars *)f->private_data;
@@ -472,9 +445,7 @@
 	}
 
 	/* Transmit packet */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
 	atomic_add(skb->truesize, &v->skt->wmem_alloc);
-#endif
 	skb->sk = v->skt;
 	skb->dev = v->ether;
 	skb->priority = 0;
@@ -499,13 +470,11 @@
 
 	/* Is this packet addressed solely to the local host? */
 	if (is_local_addr(v, skb->data) && !(skb->data[0] & ETH_ADDR_MULTICAST)) {
-		skb->destructor = do_nothing;
 		skb->protocol = eth_type_trans(skb, v->ether);
 		netif_rx(skb);
 		return count;
 	}
-	/* Relay multicast for host process except ARP packet */
-	if ((skb->data[0] & ETH_ADDR_MULTICAST) && (eth_hdr(skb)->h_proto != htons(ETH_P_ARP))) {
+	if (skb->data[0] & ETH_ADDR_MULTICAST) {
 		/* We can't clone the skb since we will manipulate the data below */
 		struct sk_buff *lskb = skb_copy(skb, GFP_ATOMIC);
 		if (lskb) {
@@ -517,7 +486,6 @@
 	/* Outgoing packet (will be on the net) */
 	demasquerade(v, skb);
 
-	skb->destructor = do_nothing;
 	skb->protocol = PROT_MAGIC;	/* Magic value (we can recognize the packet in sheep_net_receiver) */
 	dev_queue_xmit(skb);
 	return count;
@@ -601,7 +569,7 @@
 
 			/* Allocate socket */
 #ifdef LINUX_26
-			v->skt = compat_sk_alloc(dev_net(v->ether), GFP_USER, 1, &sheep_proto);
+			v->skt = sk_alloc(dev_net(v->ether), GFP_USER, 1, &sheep_proto);
 #else
 			v->skt = sk_alloc(0, GFP_USER, 1);
 #endif
@@ -611,16 +579,10 @@
 			}
 			skt_set_dead(v->skt);
 
-			/*initialize ipfilter*/
-			v->ipfilter = 0;
-
 			/* Attach packet handler */
 			v->pt.type = htons(ETH_P_ALL);
 			v->pt.dev = v->ether;
 			v->pt.func = sheep_net_receiver;
-#ifdef LINUX_26
-			v->pt.af_packet_priv = v;
-#endif
 			dev_add_pack(&v->pt);
 #ifndef LINUX_24
 			dev_unlock_list();
@@ -726,11 +688,7 @@
 static int sheep_net_receiver(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt)
 #endif
 {
-#ifdef LINUX_26
-	struct SheepVars *v = (struct SheepVars *)pt->af_packet_priv;
-#else
 	struct SheepVars *v = (struct SheepVars *)pt;
-#endif
 	struct sk_buff *skb2;
 	int fake;
 	int multicast;
@@ -754,25 +712,8 @@
 	/* Apply any filters here (if fake is true, then we *know* we want this packet) */
 	if (!fake) {
 		if ((skb->protocol == htons(ETH_P_IP))
-		 && (!v->ipfilter || (ntohl(ip_hdr(skb)->daddr) != v->ipfilter && !multicast))) {
-#if DEBUG
-			char source[16];
-			snprintf(source, 16, "%pI4", &ip_hdr(skb)->saddr);
-			D(bug("sheep_net: drop incoming IP packet %s for filter %d.%d.%d.%d\n",
-					 source,
-					 (v->ipfilter >> 24) & 0xff, (v->ipfilter >> 16) & 0xff, (v->ipfilter >> 8) & 0xff, v->ipfilter & 0xff));
-#endif
+		 && (!v->ipfilter || (ntohl(ipip_hdr(skb)->daddr) != v->ipfilter && !multicast)))
 			goto drop;
-		}
-#if DEBUG
-		else{
-			if(!multicast){
-				char source[16];
-				snprintf(source, 16, "%pI4", &ip_hdr(skb)->saddr);
-				D(bug("sheep_net: retain incoming unicast IP packet %s\n", source));
-			}
-		}
-#endif
 	}
 
 	/* Masquerade (we are typically a clone - best to make a real copy) */
@@ -790,17 +731,7 @@
 	skb_queue_tail(&v->queue, skb);
 
 	/* Unblock blocked read */
-#ifdef LINUX_3_15
-
-	atomic_set(&v->got_packet, 1);
-
-	wake_up_interruptible(&v->wait);
-
-#else
-
 	wake_up(&v->wait);
-
-#endif
 	return 0;
 
 drop:
--- macemu/SheepShaver/src/Unix/Linux/sheepthreads.c
+++ sheepshaver/SheepShaver/src/Unix/Linux/sheepthreads.c
@@ -48,19 +48,19 @@
 /* Linux kernel calls */
 extern int __clone(int (*fn)(void *), void *, int, void *);
 
-/* libc no longer provides struct _pthread_fastlock in pthread.h */
-struct fastlock {
-	int status;
-	int spinlock;
-};
-
+/* struct sem_t */
 typedef struct {
-	struct fastlock sem_lock;
-	int sem_value;
-	int sem_waiting;
+	struct _pthread_fastlock __sem_lock;
+	int __sem_value;
+	_pthread_descr __sem_waiting;
 } sem_t;
 
 #define SEM_VALUE_MAX 64
+#define status __status
+#define spinlock __spinlock
+#define sem_lock __sem_lock
+#define sem_value __sem_value
+#define sem_waiting __sem_waiting
 
 /* Wait for "clone" children only (Linux 2.4+ specific) */
 #ifndef __WCLONE
@@ -185,13 +185,13 @@
    need to make sure that the compiler has flushed everything to memory.  */
 #define MEMORY_BARRIER() __asm__ __volatile__ ("sync" : : : "memory")
 
-static void fastlock_init(struct fastlock *lock)
+static void fastlock_init(struct _pthread_fastlock *lock)
 {
 	lock->status = 0;
 	lock->spinlock = 0;
 }
 
-static int fastlock_try_acquire(struct fastlock *lock)
+static int fastlock_try_acquire(struct _pthread_fastlock *lock)
 {
 	int res = EBUSY;
 	if (test_and_set(&lock->spinlock, 1) == 0) {
@@ -205,14 +205,14 @@
 	return res;
 }
 
-static void fastlock_acquire(struct fastlock *lock)
+static void fastlock_acquire(struct _pthread_fastlock *lock)
 {
 	MEMORY_BARRIER();
 	while (test_and_set(&lock->spinlock, 1))
 		usleep(0);
 }
 
-static void fastlock_release(struct fastlock *lock)
+static void fastlock_release(struct _pthread_fastlock *lock)
 {
 	MEMORY_BARRIER();
 	lock->spinlock = 0;
@@ -226,7 +226,10 @@
 
 int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutex_attr)
 {
-	fastlock_init((struct fastlock *)mutex);
+	fastlock_init(&mutex->__m_lock);
+	mutex->__m_kind = mutex_attr ? mutex_attr->__mutexkind : PTHREAD_MUTEX_TIMED_NP;
+	mutex->__m_count = 0;
+	mutex->__m_owner = NULL;
 	return 0;
 }
 
@@ -237,7 +240,12 @@
 
 int pthread_mutex_destroy(pthread_mutex_t *mutex)
 {
-	return (((struct fastlock *)mutex)->status != 0) ? EBUSY : 0;
+	switch (mutex->__m_kind) {
+	case PTHREAD_MUTEX_TIMED_NP:
+		return (mutex->__m_lock.__status != 0) ? EBUSY : 0;
+	default:
+		return EINVAL;
+	}
 }
 
 
@@ -247,8 +255,13 @@
 
 int pthread_mutex_lock(pthread_mutex_t *mutex)
 {
-	fastlock_acquire((struct fastlock *)mutex);
-	return 0;
+	switch (mutex->__m_kind) {
+	case PTHREAD_MUTEX_TIMED_NP:
+		fastlock_acquire(&mutex->__m_lock);
+		return 0;
+	default:
+		return EINVAL;
+	}
 }
 
 
@@ -258,7 +271,12 @@
 
 int pthread_mutex_trylock(pthread_mutex_t *mutex)
 {
-	return fastlock_try_acquire((struct fastlock *)mutex);
+	switch (mutex->__m_kind) {
+	case PTHREAD_MUTEX_TIMED_NP:
+		return fastlock_try_acquire(&mutex->__m_lock);
+	default:
+		return EINVAL;
+	}
 }
 
 
@@ -268,8 +286,13 @@
 
 int pthread_mutex_unlock(pthread_mutex_t *mutex)
 {
-	fastlock_release((struct fastlock *)mutex);
-	return 0;
+	switch (mutex->__m_kind) {
+	case PTHREAD_MUTEX_TIMED_NP:
+		fastlock_release(&mutex->__m_lock);
+		return 0;
+	default:
+		return EINVAL;
+	}
 }
 
 
@@ -279,6 +302,7 @@
 
 int pthread_mutexattr_init(pthread_mutexattr_t *attr)
 {
+	attr->__mutexkind = PTHREAD_MUTEX_TIMED_NP;
 	return 0;
 }
 
@@ -309,7 +333,7 @@
 	}
 	fastlock_init(&sem->sem_lock);
 	sem->sem_value = value;
-	sem->sem_waiting = 0;
+	sem->sem_waiting = NULL;
 	return 0;
 }
 
@@ -329,7 +353,7 @@
 		return -1;
 	}
 	sem->sem_value = 0;
-	sem->sem_waiting = 0;
+	sem->sem_waiting = NULL;
 	return 0;
 }
 
@@ -350,7 +374,7 @@
 		fastlock_release(&sem->sem_lock);
 		return 0;
 	}
-	sem->sem_waiting++;
+	sem->sem_waiting = (struct _pthread_descr_struct *)((long)sem->sem_waiting + 1);
 	while (sem->sem_value == 0) {
 		fastlock_release(&sem->sem_lock);
 		usleep(0);
@@ -374,7 +398,7 @@
 	}
 	fastlock_acquire(&sem->sem_lock);
 	if (sem->sem_waiting)
-		sem->sem_waiting--;
+		sem->sem_waiting = (struct _pthread_descr_struct *)((long)sem->sem_waiting - 1);
 	else {
 		if (sem->sem_value >= SEM_VALUE_MAX) {
 			errno = ERANGE;
--- macemu/SheepShaver/src/Unix/Makefile.in
+++ sheepshaver/SheepShaver/src/Unix/Makefile.in
@@ -17,7 +17,7 @@
 CXX = @CXX@
 CFLAGS = @CFLAGS@
 CXXFLAGS = @CXXFLAGS@
-CPPFLAGS = @CPPFLAGS@ -I../include -I. -I../CrossPlatform -I../slirp
+CPPFLAGS = @CPPFLAGS@ -I../include -I.
 DEFS = @DEFS@ -D_REENTRANT -DDATADIR=\"$(datadir)/$(APP)\"
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
@@ -26,7 +26,6 @@
 MONSRCS = @MONSRCS@
 PERL = @PERL@
 USE_DYNGEN = @USE_DYNGEN@
-USE_DYNGEN_PRECOMPILED = @USE_DYNGEN_PRECOMPILED@
 DYNGENSRCS = @DYNGENSRCS@
 DYNGEN_CC = @DYNGEN_CC@
 DYNGEN_CFLAGS = @DYNGEN_CFLAGS@
@@ -36,24 +35,15 @@
 EXEEXT = @EXEEXT@
 KEYCODES = @KEYCODES@
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@ -s
 INSTALL_DATA = @INSTALL_DATA@
 
-SLIRP_CFLAGS = @SLIRP_CFLAGS@
-SLIRP_SRCS = @SLIRP_SRCS@
-SLIRP_OBJS = $(SLIRP_SRCS:../slirp/%.c=obj/%.o)
-
-USE_BINCUE = @USE_BINCUE@
-
 STANDALONE_GUI = @STANDALONE_GUI@
 GUI_CFLAGS = @GUI_CFLAGS@
 GUI_LIBS = @GUI_LIBS@
 GUI_SRCS = ../prefs.cpp prefs_unix.cpp prefs_editor_gtk.cpp ../prefs_items.cpp \
-	../user_strings.cpp user_strings_unix.cpp xpram_unix.cpp sys_unix.cpp rpc_unix.cpp \
-	../dummy/prefs_dummy.cpp
+	../user_strings.cpp user_strings_unix.cpp xpram_unix.cpp sys_unix.cpp rpc_unix.cpp
 
-XPLAT_SRCS = ../CrossPlatform/vm_alloc.cpp ../CrossPlatform/sigsegv.cpp ../CrossPlatform/video_blit.cpp
-
 # Append disassembler to dyngen, if available
 ifneq (:no,$(MONSRCS):$(USE_DYNGEN))
 DYNGENSRCS += $(filter %i386-dis.c,$(MONSRCS))
@@ -64,10 +54,11 @@
     ../rom_patches.cpp ../rsrc_patches.cpp ../emul_op.cpp ../name_registry.cpp \
     ../macos_util.cpp ../timer.cpp timer_unix.cpp ../xpram.cpp xpram_unix.cpp \
     ../adb.cpp ../sony.cpp ../disk.cpp ../cdrom.cpp ../scsi.cpp \
-    ../gfxaccel.cpp ../video.cpp ../audio.cpp ../ether.cpp ../thunks.cpp \
-    ../serial.cpp ../extfs.cpp disk_sparsebundle.cpp tinyxml2.cpp \
-    about_window_unix.cpp ../user_strings.cpp user_strings_unix.cpp rpc_unix.cpp \
-    sshpty.c strlcpy.c $(XPLAT_SRCS) $(SYSSRCS) $(CPUSRCS) $(MONSRCS) $(SLIRP_SRCS)
+    ../gfxaccel.cpp ../video.cpp video_blit.cpp ../audio.cpp ../ether.cpp ../thunks.cpp \
+    ../serial.cpp ../extfs.cpp \
+    about_window_unix.cpp ../user_strings.cpp user_strings_unix.cpp \
+    vm_alloc.cpp sigsegv.cpp rpc_unix.cpp \
+    sshpty.c strlcpy.c $(SYSSRCS) $(CPUSRCS) $(MONSRCS)
 APP = SheepShaver
 APP_EXE = $(APP)$(EXEEXT)
 APP_APP = $(APP).app
@@ -101,13 +92,10 @@
 OBJS = $(SRCS_LIST_TO_OBJS)
 
 define GUI_SRCS_LIST_TO_OBJS
-	$(addprefix $(OBJ_DIR)/, $(addsuffix .guio, $(foreach file, $(GUI_SRCS), \
+	$(addprefix $(OBJ_DIR)/, $(addsuffix .go, $(foreach file, $(GUI_SRCS), \
 	$(basename $(notdir $(file))))))
 endef
 GUI_OBJS = $(GUI_SRCS_LIST_TO_OBJS)
-ifeq ($(USE_BINCUE),yes)
-GUI_OBJS += bincue_unix.o
-endif
 
 define DYNGENSRCS_LIST_TO_OBJS
 	$(addprefix $(OBJ_DIR)/, $(addsuffix .dgo, $(foreach file, $(DYNGENSRCS), \
@@ -124,7 +112,7 @@
 	$(BLESS) $(APP_EXE)
 
 $(GUI_APP_EXE): $(OBJ_DIR) $(GUI_OBJS)
-	$(CXX) -o $@ $(LDFLAGS) $(GUI_OBJS) $(GUI_LIBS) $(LIBS)
+	$(CXX) -o $@ $(LDFLAGS) $(GUI_OBJS) $(GUI_LIBS)
 
 $(APP)_app: $(APP) ../MacOSX/Info.plist ../MacOSX/$(APP).icns
 	rm -rf $(APP_APP)/Contents
@@ -190,12 +178,8 @@
 
 $(OBJ_DIR)/SDLMain.o : SDLMain.m
 	$(CC) $(CPPFLAGS) $(DEFS) $(CFLAGS) -c $< -o $@
-$(OBJ_DIR)/%.o : ../slirp/%.c
-	$(CC) $(CPPFLAGS) $(DEFS) $(CFLAGS) $(SLIRP_CFLAGS) -c $< -o $@
 $(OBJ_DIR)/%.o : %.c
 	$(CC) $(CPPFLAGS) $(DEFS) $(CFLAGS) -c $< -o $@
-$(OBJ_DIR)/DiskType.o : DiskType.m
-	$(CC) $(CPPFLAGS) $(DEFS) $(CFLAGS) -c $< -o $@
 $(OBJ_DIR)/%.o : %.cpp
 	$(CXX) $(CPPFLAGS) $(DEFS) $(CXXFLAGS) -c $< -o $@
 $(OBJ_DIR)/%.o : %.mm
@@ -204,7 +188,7 @@
 	$(CPP) $(CPPFLAGS) -D__ASSEMBLY__ $< -o $*.out.s
 	$(AS) $(ASFLAGS) -o $@ $*.out.s
 	rm $*.out.s
-$(OBJ_DIR)/%.guio : %.cpp
+$(OBJ_DIR)/%.go : %.cpp
 	$(CXX) $(CPPFLAGS) $(DEFS) $(CXXFLAGS) $(GUI_CFLAGS) -DSTANDALONE_GUI -c $< -o $@
 
 # Kheperix CPU emulator
@@ -215,28 +199,9 @@
 ifeq ($(USE_DYNGEN),yes)
 DYNGENDEPS = basic-dyngen-ops.hpp ppc-dyngen-ops.hpp
 
-ifeq ($(USE_DYNGEN_PRECOMPILED),yes)
-basic-dyngen-ops.hpp: dyngen_precompiled/basic-dyngen-ops.hpp basic-dyngen-ops-x86_32.hpp basic-dyngen-ops-x86_64.hpp
-	cp -f $< $@
-basic-dyngen-ops-x86_32.hpp: dyngen_precompiled/basic-dyngen-ops-x86_32.hpp
-	cp -f $< $@
-basic-dyngen-ops-x86_64.hpp: dyngen_precompiled/basic-dyngen-ops-x86_64.hpp
-	cp -f $< $@
-ppc-dyngen-ops.hpp: dyngen_precompiled/ppc-dyngen-ops.hpp ppc-dyngen-ops-x86_32.hpp ppc-dyngen-ops-x86_64.hpp
-	cp -f $< $@
-ppc-dyngen-ops-x86_32.hpp: dyngen_precompiled/ppc-dyngen-ops-x86_32.hpp
-	cp -f $< $@
-ppc-dyngen-ops-x86_64.hpp: dyngen_precompiled/ppc-dyngen-ops-x86_64.hpp
-	cp -f $< $@
-else
 # Only GCC is supported for generating synthetic opcodes
 $(DYNGEN): $(DYNGENOBJS)
 	$(DYNGEN_CC) -o $@ $(LDFLAGS) $(DYNGENOBJS)
-basic-dyngen-ops.hpp: $(OBJ_DIR)/basic-dyngen-ops.o $(DYNGEN)
-	./$(DYNGEN) -o $@ $<
-ppc-dyngen-ops.hpp: $(OBJ_DIR)/ppc-dyngen-ops.o $(DYNGEN)
-	./$(DYNGEN) -o $@ $<
-endif
 
 $(OBJ_DIR)/%.dgo : %.c
 	$(DYNGEN_CC) -xc $(CPPFLAGS) $(DEFS) $(DYNGEN_CFLAGS) -c $< -o $@
@@ -246,17 +211,21 @@
 $(OBJ_DIR)/basic-dyngen.o: basic-dyngen-ops.hpp
 $(OBJ_DIR)/basic-dyngen-ops.o: $(kpxsrcdir)/cpu/jit/basic-dyngen-ops.cpp
 	$(DYNGEN_CC) $(CPPFLAGS) $(DEFS) $(DYNGEN_CXXFLAGS) $(DYNGEN_OP_FLAGS) -c $< -o $@
+basic-dyngen-ops.hpp: $(OBJ_DIR)/basic-dyngen-ops.o $(DYNGEN)
+	./$(DYNGEN) -o $@ $<
 
 $(OBJ_DIR)/ppc-dyngen.o: ppc-dyngen-ops.hpp
 $(OBJ_DIR)/ppc-dyngen-ops.o: $(kpxsrcdir)/cpu/ppc/ppc-dyngen-ops.cpp basic-dyngen-ops.hpp
 	$(DYNGEN_CC) $(CPPFLAGS) $(DEFS) $(DYNGEN_CXXFLAGS) $(DYNGEN_OP_FLAGS) -c $< -o $@
+ppc-dyngen-ops.hpp: $(OBJ_DIR)/ppc-dyngen-ops.o $(DYNGEN)
+	./$(DYNGEN) -o $@ $<
 
 $(OBJ_DIR)/sheepshaver_glue.o $(OBJ_DIR)/ppc-cpu.o $(OBJ_DIR)/ppc-decode.o $(OBJ_DIR)/ppc-translate.o $(OBJ_DIR)/ppc-jit.o: basic-dyngen-ops.hpp ppc-dyngen-ops.hpp
 endif
 
 $(OBJ_DIR)/ppc-execute.o: ppc-execute-impl.cpp
 ppc-execute-impl.cpp: $(kpxsrcdir)/cpu/ppc/ppc-decode.cpp $(GENEXECPL) $(DYNGENDEPS)
-	$(CPP) $(CPPFLAGS) -DGENEXEC $< | $(PERL) $(GENEXECPL) > $@
+	$(CPP) $(CPPFLAGS) $(DEFS) -DGENEXEC $< | $(PERL) $(GENEXECPL) > $@
 
 # PowerPC CPU tester
 TESTSRCS_ = mathlib/ieeefp.cpp mathlib/mathlib.cpp cpu/ppc/ppc-cpu.cpp cpu/ppc/ppc-decode.cpp cpu/ppc/ppc-execute.cpp cpu/ppc/ppc-translate.cpp test/test-powerpc.cpp $(MONSRCS) vm_alloc.cpp utils/utils-cpuinfo.cpp
--- macemu/SheepShaver/src/Unix/autogen.sh
+++ sheepshaver/SheepShaver/src/Unix/autogen.sh
@@ -35,7 +35,9 @@
 fi
 
 if test -z "$ACLOCAL_FLAGS"; then
-    ACLOCAL_FLAGS="-I `aclocal --print-ac-dir` -I m4"
+    ACLOCAL_FLAGS="-I `aclocal --print-ac-dir` -I `dirname $0`/m4"
+else
+    ACLOCAL_FLAGS="$ACLOCAL_FLAGS -I `dirname $0`/m4"
 fi
 
 aclocalinclude="$ACLOCAL_FLAGS"; \
@@ -47,6 +49,9 @@
  echo "done.") && \
 (echo $_echo_n " + Running autoconf: $_echo_c"; \
     autoconf; \
+ echo "done.") && \
+(echo $_echo_n " + Running automake: $_echo_c"; \
+    automake -a -c -f; \
  echo "done.") 
 
 rm -f config.cache
@@ -59,3 +64,4 @@
     fi
     ./configure "$@"
 fi
+
--- macemu/SheepShaver/src/Unix/bincue_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/bincue_unix.cpp
@@ -17,7 +17,7 @@
  */
 
 /* Geoffrey Brown 2010
- * Includes ideas from dosbox src/dos/cdrom_image.cpp
+ * Includes ideas from dosbox src/dos/cdrom_image.cpp 
  *
  * Limitations:	1) cue files must reference single bin file
  *              2) only supports raw mode1 data and audio
@@ -41,15 +41,16 @@
 #include <sys/stat.h>
 #include <errno.h>
 
-/*#ifdef OSX_CORE_AUDIO
+#ifdef OSX_CORE_AUDIO
 #include "../MacOSX/MacOSX_sound_if.h"
 static int bincue_core_audio_callback(void);
-#endif*/
+#endif
 
 #ifdef USE_SDL_AUDIO
 #include <SDL.h>
 #include <SDL_audio.h>
 #endif
+
 #include "bincue_unix.h"
 #define DEBUG 0
 #include "debug.h"
@@ -110,9 +111,9 @@
 	unsigned int silence;		// pregap (silence) bytes
 	unsigned char audiostatus;	// See defines above for status
 	loff_t fileoffset;			// offset from file beginning to audiostart
-/*#ifdef OSX_CORE_AUDIO
+#ifdef OSX_CORE_AUDIO
 	OSXsoundOutput soundoutput;
-#endif*/
+#endif
 } CDPlayer;
 
 // Minute,Second,Frame data type
@@ -232,7 +233,7 @@
 	char line[MAXLINE];
 	unsigned int i_line=0;
 	char *keyword;
-
+	
 	totalPregap = 0;
 	prestart = 0;
 
@@ -255,8 +256,8 @@
 
 				if (i_line > 1) {
 					D(bug("More than one FILE token\n"));
-					goto fail;
-				}
+					goto fail;	
+				}	
 				filename = strtok(NULL, "\"\t\n\r");
 				filetype = strtok(NULL, " \"\t\n\r");
 				if (strcmp("BINARY", filetype)) {
@@ -289,7 +290,7 @@
 				field = strtok(NULL, " \t\n\r");
 				if (1 != sscanf(field, "%d", &i_track)) {
 					D(bug("Expected  track number\n"));
-					goto fail;
+					goto fail;		
 				}
 				curr->number = i_track;
 
@@ -321,7 +322,7 @@
 				// parse INDEX start
 
 				field = strtok(NULL, " \t\n\r");
-				if (3 != sscanf(field, "%d:%d:%d",
+				if (3 != sscanf(field, "%d:%d:%d", 
 								 &msf.m, &msf.s, &msf.f)) {
 					D(bug("Expected index start frame\n"));
 					goto fail;
@@ -334,10 +335,10 @@
 			} else if (!strcmp("PREGAP", keyword)) {
 				MSF msf;
 				char *field = strtok(NULL, " \t\n\r");
-				if (3 != sscanf(field, "%d:%d:%d",
+				if (3 != sscanf(field, "%d:%d:%d", 
 								 &msf.m, &msf.s, &msf.f)) {
 					D(bug("Expected pregap frame\n"));
-					goto fail;
+					goto fail;	
 				}
 				curr->pregap = MSFToFrames(msf);
 
@@ -350,7 +351,7 @@
 			} else if (!strcmp("SONGWRITER", keyword)) {
 			} else {
 				D(bug("Unexpected keyword %s\n", keyword));
-				goto fail;
+				goto fail;		
 			}
 		}
 	}
@@ -391,12 +392,12 @@
 
 
 		tlast = &cs->tracks[cs->tcnt - 1];
-		tlast->length = buf.st_size/RAW_SECTOR_SIZE
+		tlast->length = buf.st_size/RAW_SECTOR_SIZE 
 						- tlast->start + totalPregap;
 
 		if (tlast->length < 0) {
 			D(bug("Binary file too short \n"));
- 		  	goto fail;
+ 		  	goto fail;	
    	    }
 
 		// save bin file length and pointer
@@ -409,7 +410,7 @@
 
 	  fail:
 		if (binfh >= 0)
-			close(binfh);
+			close(binfh);	
 		fclose(fh);
 		free(cs->binfile);
 		return false;
@@ -433,9 +434,9 @@
 
 		if (LoadCueSheet(name, cs)) {
 			player.cs = cs;
-/*#ifdef OSX_CORE_AUDIO
+#ifdef OSX_CORE_AUDIO
 			audio_enabled = true;
-#endif*/
+#endif
 			if (audio_enabled)
 				player.audiostatus = CDROM_AUDIO_NO_STATUS;
 			else
@@ -525,7 +526,6 @@
 	if (fh) {
 		return ((CueSheet *)fh)->length * COOKED_SECTOR_SIZE;
 	}
-	return 0;
 }
 
 bool readtoc_bincue(void *fh, unsigned char *toc)
@@ -564,7 +564,6 @@
 		*toc++ = toc_size & 0xff;
 		return true;
 	}
-	return false;
 }
 
 bool GetPosition_bincue(void *fh, uint8 *pos)
@@ -632,9 +631,9 @@
 	CueSheet *cs = (CueSheet *) fh;
 
 	if (cs && cs == player.cs) {
-/*#ifdef OSX_CORE_AUDIO
+#ifdef OSX_CORE_AUDIO
 		player.soundoutput.stop();
-#endif*/
+#endif
 		if (player.audiostatus != CDROM_AUDIO_INVALID)
 			player.audiostatus = CDROM_AUDIO_NO_STATUS;
 		return true;
@@ -694,7 +693,7 @@
 			// fix up file offset if beyond the silence bytes
 
 			if (!player.silence) // not at the beginning
-				player.fileoffset += (player.audiostart -
+				player.fileoffset += (player.audiostart - 
 									  player.cs->tracks[track].start -
 									  player.cs->tracks[track].pregap) * RAW_SECTOR_SIZE;
 
@@ -713,12 +712,12 @@
 
 		if (audio_enabled) {
 			player.audiostatus = CDROM_AUDIO_PLAY;
-/*#ifdef OSX_CORE_AUDIO
+#ifdef OSX_CORE_AUDIO
 			D(bug("starting os x sound"));
 			player.soundoutput.setCallback(bincue_core_audio_callback);
 			// should be from current track !
 			player.soundoutput.start(16, 2, 44100);
-#endif*/
+#endif
 			return true;
 		}
 	}
@@ -792,7 +791,7 @@
 				player.audioposition++;
 			}
 		}
-	}
+	}		
 	return buf;
 }
 
@@ -800,9 +799,9 @@
 #ifdef USE_SDL_AUDIO
 void MixAudio_bincue(uint8 *stream, int stream_len)
 {
+	uint8 *buf;
 	if (audio_enabled && (player.audiostatus == CDROM_AUDIO_PLAY)) {
-		uint8 *buf = fill_buffer(stream_len);
-		if (buf)
+		if (buf = fill_buffer(stream_len))
 			SDL_MixAudio(stream, buf, stream_len, SDL_MIX_MAXVOLUME);
 	}
 }
@@ -820,7 +819,7 @@
 }
 #endif
 
-/*#ifdef OSX_CORE_AUDIO
+#ifdef OSX_CORE_AUDIO
 static int bincue_core_audio_callback(void)
 {
 	int frames = player.soundoutput.bufferSizeFrames();
@@ -832,4 +831,4 @@
 
 	return 1;
 }
-#endif*/
\ No newline at end of file
+#endif
--- macemu/SheepShaver/src/Unix/bincue_unix.h
+++ sheepshaver/SheepShaver/src/Unix/bincue_unix.h
@@ -35,9 +35,9 @@
 extern bool CDResume_bincue(void *);
 extern bool CDStop_bincue(void *);
 
-/*#ifdef USE_SDL_AUDIO
+#ifdef USE_SDL_AUDIO
 extern void OpenAudio_bincue(int, int, int, uint8);
 extern void MixAudio_bincue(uint8 *, int);
-#endif*/
+#endif
 
 #endif
--- macemu/SheepShaver/src/Unix/clip_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/clip_unix.cpp
@@ -374,15 +374,7 @@
 	}
 }
 
-/*
- * Mac application zeroes clipboard
- */
 
-void ZeroScrap()
-{
-
-}
-
 /*
  *  Mac application reads clipboard
  */
@@ -650,15 +642,14 @@
 {
 	bool handled =false;
 
-	if (req->target == xa_timestamp) {
+	if (req->target == xa_timestamp)
 		handled = handle_selection_TIMESTAMP(req);
-	} else if (req->target == xa_targets) {
+	else if (req->target == xa_targets)
 		handled = handle_selection_TARGETS(req);
-	} else if (req->target == XA_STRING) {
+	else if (req->target == XA_STRING)
 		handled = handle_selection_STRING(req);
-	} else if (req->target == xa_multiple) {
+	else if (req->target == xa_multiple)
 		handled = handle_selection_MULTIPLE(req);
-	}
 
 	// Notify requestor only when we are done with his request
 	if (handled && !is_multiple) {
@@ -667,7 +658,7 @@
 		out_event.xselection.requestor = req->requestor;
 		out_event.xselection.selection = req->selection;
 		out_event.xselection.target    = req->target;
-		out_event.xselection.property  = req->property;
+		out_event.xselection.property  = handled ? req->property : None;
 		out_event.xselection.time      = req->time;
 		XSendEvent(x_display, req->requestor, False, 0, &out_event);
 	}
Only in macemu/: SheepShaver/src/Unix/config.guess
Only in macemu/: SheepShaver/src/Unix/config.h.old
Only in macemu/: SheepShaver/src/Unix/config.sub
--- macemu/SheepShaver/src/Unix/configure.ac
+++ sheepshaver/SheepShaver/src/Unix/configure.ac
@@ -1,22 +1,27 @@
 dnl Process this file with autoconf to produce a configure script.
 dnl Written in 2002 by Christian Bauer
 
-AC_INIT([SheepShaver], 2.4, [Christian.Bauer@uni-mainz.de], SheepShaver)
+AC_INIT([SheepShaver], 2.3, [Christian.Bauer@uni-mainz.de], SheepShaver)
 AC_CONFIG_SRCDIR(main_unix.cpp)
-AC_PREREQ(2.52)
-AC_CONFIG_HEADER(config.h)
-AH_TOP(
-#ifndef CONFIG_H
-#define CONFIG_H
-)
-AH_BOTTOM(
-#endif /* CONFIG_H */
-)
 
 dnl Canonical system information.
 AC_CANONICAL_HOST
 AC_CANONICAL_TARGET
 
+AM_INIT_AUTOMAKE
+AC_PREREQ(2.52)
+AC_CONFIG_HEADER(config.h)
+
+dnl Checks for programs.
+AC_PROG_CC
+AC_PROG_CPP
+AC_PROG_CXX
+AC_PROG_MAKE_SET
+AC_PROG_INSTALL
+AC_PROG_EGREP
+AC_PATH_PROGS(FILE, [file false])
+AC_PATH_PROG(PERL, [perl])
+
 dnl Some systems do not put corefiles in the currect directory, avoid saving
 dnl cores for the configure tests since some are intended to dump core.
 ulimit -c 0
@@ -29,7 +34,7 @@
 esac
 
 dnl Options.
-AC_ARG_ENABLE(jit,          [  --enable-jit            enable JIT compiler [default=yes]], [WANT_JIT=$enableval], [WANT_JIT=yes])
+AC_ARG_ENABLE(jit,          [  --enable-jit            enable JIT compiler [default=no]], [WANT_JIT=$enableval], [WANT_JIT=no])
 AC_ARG_ENABLE(ppc-emulator, [  --enable-ppc-emulator   use the selected PowerPC emulator [default=auto]], [WANT_EMULATED_PPC=$enableval], [WANT_EMULATED_PPC=auto])
 AC_ARG_ENABLE(fbdev-dga,    [  --enable-fbdev-dga      use direct frame buffer access via /dev/fb0 [default=yes]], [WANT_FBDEV_DGA=$enableval], [WANT_FBDEV_DGA=yes])
 AC_ARG_ENABLE(xf86-dga,     [  --enable-xf86-dga       use the XFree86 DGA extension [default=yes]], [WANT_XF86_DGA=$enableval], [WANT_XF86_DGA=yes])
@@ -37,16 +42,9 @@
 AC_ARG_ENABLE(vosf,         [  --enable-vosf           enable video on SEGV signals [default=yes]], [WANT_VOSF=$enableval], [WANT_VOSF=yes])
 AC_ARG_ENABLE(standalone-gui,[  --enable-standalone-gui enable a standalone GUI prefs editor [default=no]], [WANT_STANDALONE_GUI=$enableval], [WANT_STANDALONE_GUI=no])
 AC_ARG_WITH(esd,            [  --with-esd              support ESD for sound under Linux/FreeBSD [default=yes]], [WANT_ESD=$withval], [WANT_ESD=yes])
-AC_ARG_WITH(gtk,            [  --with-gtk              use GTK user interface [default=yes]],
-  [case "$withval" in
-   gtk1)      WANT_GTK="gtk";;
-   gtk|gtk2)  WANT_GTK="$withval";;
-   yes)       WANT_GTK="gtk2 gtk";;
-   *)         WANT_GTK="no";;
-   esac],
-  [WANT_GTK="gtk2 gtk"])
+AC_ARG_WITH(gtk,            [  --with-gtk              use GTK user interface [default=yes]], [WANT_GTK=$withval], [WANT_GTK=yes])
 AC_ARG_WITH(mon,            [  --with-mon              use mon as debugger [default=yes]], [WANT_MON=$withval], [WANT_MON=yes])
-AC_ARG_WITH(dgcc,           [  --with-dgcc=COMPILER    use C++ COMPILER to compile synthetic opcodes or 'precompiled'], [DYNGEN_CC=$withval])
+AC_ARG_WITH(dgcc,           [  --with-dgcc=COMPILER    use C++ COMPILER to compile synthetic opcodes], [DYNGEN_CC=$withval])
 
 AC_ARG_WITH(bincue,   
   AS_HELP_STRING([--with-bincue], [Allow cdrom image files in bin/cue mode]))
@@ -57,13 +55,13 @@
 
 dnl Addressing mode
 AC_ARG_ENABLE(addressing,
-  [  --enable-addressing=AM  set the addressing mode to use [default=real]],
+  [  --enable-addressing=AM  set the addressing mode to use [default=direct,0x1000]],
   [case "$enableval" in
    real)        WANT_ADDRESSING_MODE="real";;
    direct)      WANT_ADDRESSING_MODE="direct";;
    direct,0x*)  WANT_ADDRESSING_MODE="direct"; NATMEM_OFFSET=`echo "$enableval" | sed -n '/direct,\(0[[xX]][[0-9A-Fa-f]]*\([[UuLl]]\{1,2\}\)\?\)$/s//\1/p'`;;
    esac],
-  [WANT_ADDRESSING_MODE="real"]
+  [WANT_ADDRESSING_MODE="direct"; NATMEM_OFFSET="0x1000000"]
 )
 
 dnl SDL options.
@@ -72,18 +70,7 @@
 AC_ARG_ENABLE(sdl-audio,    [  --enable-sdl-audio      use SDL for audio [default=no]], [WANT_SDL_AUDIO=$enableval], [WANT_SDL_AUDIO=no])
 AC_ARG_ENABLE(sdl-framework,    [  --enable-sdl-framework  use SDL framework [default=no]], [WANT_SDL_FRAMEWORK=$enableval], [WANT_SDL_FRAMEWORK=no])
 AC_ARG_ENABLE(sdl-framework-prefix,    [  --enable-sdl-framework-prefix=PFX    default=/Library/Frameworks], [SDL_FRAMEWORK="$enableval"], [SDL_FRAMEWORK=/Library/Frameworks])
-AC_ARG_WITH(sdl1,            [  --with-sdl1             use SDL 1.x, rather than SDL 2.x [default=no]], [WANT_SDL_VERSION_MAJOR=1], [])
 
-dnl Checks for programs.
-AC_PROG_CC
-AC_PROG_CPP
-AC_PROG_CXX
-AC_PROG_MAKE_SET
-AC_PROG_INSTALL
-AC_PROG_EGREP
-AC_PATH_PROGS(FILE, [file false])
-AC_PATH_PROG(PERL, [perl])
-
 dnl Check for PowerPC target CPU.
 HAVE_PPC=no
 AC_MSG_CHECKING(for PowerPC target CPU)
@@ -145,7 +132,7 @@
 AC_CHECK_LIB(posix4, sem_init)
 AC_CHECK_LIB(m, cos)
 
-dnl AC_CHECK_SDLFRAMEWORK($1=NAME, $2=INCLUDES, $3=ACTION_IF_SUCCESSFUL, $4=ACTION_IF_UNSUCCESSFUL)
+dnl AC_CHECK_SDLFRAMEWORK($1=NAME, $2=INCLUDES)
 dnl AC_TRY_LINK uses main() but SDL needs main to take args,
 dnl therefore main is undefined with #undef.
 dnl Framework can be in an custom location.
@@ -155,16 +142,18 @@
     ac_Framework, [
     saved_LIBS="$LIBS"
     LIBS="$LIBS -framework $1"
-    if [[ "x$SDL_FRAMEWORK" != "x/System/Library/Frameworks" ]]; then
-      LIBS="$saved_LIBS -F$SDL_FRAMEWORK -framework $1"
+    if [[ "x$SDL_FRAMEWORK" != "x/Library/Frameworks" ]]; then
+      if [[ "x$SDL_FRAMEWORK" != "x/System/Library/Frameworks" ]]; then
+        LIBS="$saved_LIBS -F$SDL_FRAMEWORK -framework $1"
+      fi
     fi
     saved_CPPFLAGS="$CPPFLAGS"
-    CPPFLAGS="$CPPFLAGS -I$SDL_FRAMEWORK/$1.framework/Headers"
+    CPPFLAGS="$CPPFLAGS -I$SDL_FRAMEWORK/SDL.framework/Headers"
     AC_TRY_LINK(
       [$2
 #undef main], [],
-      [AS_VAR_SET(ac_Framework, yes); $3], [AS_VAR_SET(ac_Framework, no);
-LIBS="$saved_LIBS"; CPPFLAGS="$saved_CPPFLAGS"; $4]
+      [AS_VAR_SET(ac_Framework, yes)], [AS_VAR_SET(ac_Framework, no);
+LIBS="$saved_LIBS"; CPPFLAGS="$saved_CPPFLAGS"]
     )
   ])
   AS_IF([test AS_VAR_GET(ac_Framework) = yes],
@@ -188,66 +177,27 @@
 fi
 if [[ "x$WANT_SDL" = "xyes" ]]; then
   if [[ "x$WANT_SDL_FRAMEWORK" = "xyes" ]]; then
-    TEMP_WANT_SDL_VERSION_MAJOR=$WANT_SDL_VERSION_MAJOR
-    if [[ "x$TEMP_WANT_SDL_VERSION_MAJOR" = "x" ]]; then
-      TEMP_WANT_SDL_VERSION_MAJOR=2
-    fi
-    if [[ "x$TEMP_WANT_SDL_VERSION_MAJOR" = "x2" ]]; then
-      AC_CHECK_SDLFRAMEWORK(SDL2, [#include <SDL.h>], [
-        WANT_SDL_VERSION_MAJOR=2
-      ], [
-        TEMP_WANT_SDL_VERSION_MAJOR=1
-      ])
-    fi
-    if [[ "x$TEMP_WANT_SDL_VERSION_MAJOR" = "x1" ]]; then
-      AC_CHECK_SDLFRAMEWORK(SDL, [#include <SDL.h>], [
-        WANT_SDL_VERSION_MAJOR=1
-      ])
-    fi
+    AC_CHECK_SDLFRAMEWORK(SDL, [#include <SDL.h>])
   else
     ac_cv_framework_SDL=no
   fi
   if [[ "x$ac_cv_framework_SDL" = "xno" ]]; then
-    TEMP_WANT_SDL_VERSION_MAJOR=$WANT_SDL_VERSION_MAJOR
-    if [[ "x$TEMP_WANT_SDL_VERSION_MAJOR" = "x" ]]; then
-      TEMP_WANT_SDL_VERSION_MAJOR=2
-    fi
-    if [[ "x$TEMP_WANT_SDL_VERSION_MAJOR" = "x2" ]]; then
-      AC_PATH_PROG(sdl2_config, "sdl2-config")
-      if [[ -n "$sdl2_config" ]]; then
-        sdl2_cflags=`$sdl2_config --cflags`
-        if [[ "x$WANT_SDL_STATIC" = "xyes" ]]; then
-          sdl2_libs=`$sdl2_config --static-libs`
-        else
-          sdl2_libs=`$sdl2_config --libs`
-        fi
-        CFLAGS="$CFLAGS $sdl2_cflags"
-        CXXFLAGS="$CXXFLAGS $sdl2_cflags"
-        LIBS="$LIBS $sdl2_libs"
-        WANT_SDL_VERSION_MAJOR=2
+    AC_PATH_PROG(sdl_config, "sdl-config")
+    if [[ -n "$sdl_config" ]]; then
+      sdl_cflags=`$sdl_config --cflags`
+      if [[ "x$WANT_SDL_STATIC" = "xyes" ]]; then
+        sdl_libs=`$sdl_config --static-libs`
       else
-        TEMP_WANT_SDL_VERSION_MAJOR=1
+        sdl_libs=`$sdl_config --libs`
       fi
+      CFLAGS="$CFLAGS $sdl_cflags"
+      CXXFLAGS="$CXXFLAGS $sdl_cflags"
+      LIBS="$LIBS $sdl_libs"
+    else
+      WANT_SDL=no
+      WANT_SDL_VIDEO=no
+      WANT_SDL_AUDIO=no
     fi
-    if [[ "x$TEMP_WANT_SDL_VERSION_MAJOR" = "x1" ]]; then
-      AC_PATH_PROG(sdl_config, "sdl-config")
-      if [[ -n "$sdl_config" ]]; then
-        sdl_cflags=`$sdl_config --cflags`
-        if [[ "x$WANT_SDL_STATIC" = "xyes" ]]; then
-          sdl_libs=`$sdl_config --static-libs`
-        else
-          sdl_libs=`$sdl_config --libs`
-        fi
-        CFLAGS="$CFLAGS $sdl_cflags"
-        CXXFLAGS="$CXXFLAGS $sdl_cflags"
-        LIBS="$LIBS $sdl_libs"
-        WANT_SDL_VERSION_MAJOR=1
-      else
-        WANT_SDL=no
-        WANT_SDL_VIDEO=no
-        WANT_SDL_AUDIO=no
-      fi
-    fi
   fi
   SDL_SUPPORT=`echo "$SDL_SUPPORT" | sed -e "s/^ //"`
 else
@@ -337,36 +287,24 @@
 dnl We use GTK+ if possible.
 UISRCS=../dummy/prefs_editor_dummy.cpp
 case "x$WANT_GTK" in
-xgtk2*)
+xyes | xgtk2)
   WANT_GTK=no
-  AM_PATH_GTK_2_0(1.3.15, [
+  AM_PATH_GTK_2_0(2.16.0, [
     GUI_CFLAGS="$GTK_CFLAGS"
     GUI_LIBS="$GTK_LIBS"
     WANT_GTK=gtk2
   ], [
-    case "x${WANT_GTK}x" in
-    *gtkx)
-      AC_MSG_WARN([Could not find GTK+ 2.0, trying with GTK+ 1.2.])
-      WANT_GTK=gtk
-      ;;
-    *)
-      AC_MSG_WARN([Could not find GTK+, disabling user interface.])
-      WANT_GTK=no
-     ;;
-    esac
+    AC_MSG_WARN([Could not find GTK+ 2.16.0 or later, disabling user interface.])
+    WANT_GTK=no
   ])
   ;;
-esac
-if [[ "x$WANT_GTK" = "xgtk" ]]; then
+xgtk)
   WANT_GTK=no
-  AM_PATH_GTK(1.2.0, [
-    GUI_CFLAGS="$GTK_CFLAGS"
-    GUI_LIBS="$GTK_LIBS"
-    WANT_GTK=gtk
-  ], [
-    AC_MSG_WARN([Could not find GTK+, disabling user interface.])
-  ])
-fi
+  ;;
+*)
+  WANT_GTK=no
+  ;;
+esac
 if [[ "x$WANT_GTK" != "xno" -a "x$WANT_STANDALONE_GUI" = "xno" ]]; then
   AC_DEFINE(ENABLE_GTK, 1, [Define if using GTK.])
   UISRCS=prefs_editor_gtk.cpp
@@ -419,7 +357,6 @@
 AC_CHECK_HEADERS(AvailabilityMacros.h)
 AC_CHECK_HEADERS(IOKit/storage/IOBlockStorageDevice.h)
 AC_CHECK_HEADERS(fenv.h)
-AC_CHECK_HEADERS(sys/stropts.h stropts.h)
 
 dnl Checks for typedefs, structures, and compiler characteristics.
 AC_C_BIGENDIAN
@@ -522,9 +459,6 @@
 *-*-darwin*)
 	no_dev_ptmx=1
 	;;
-*-*-freebsd*)
-	no_dev_ptmx=1
-	;;
 esac
 
 if test -z "$no_dev_ptmx" ; then
@@ -663,7 +597,7 @@
   if [[ "x$ac_cv_framework_Carbon" = "xyes" ]]; then
     EXTFSSRC=../MacOSX/extfs_macosx.cpp
     if [[ "x$ac_cv_framework_AppKit" = "xyes" -a "x$WANT_GTK" = "xno" ]]; then
-      PREFSSRC="../MacOSX/prefs_macosx.mm ../MacOSX/Launcher/VMSettingsController.mm ../MacOSX/Launcher/DiskType.m"
+      PREFSSRC="../MacOSX/prefs_macosx.mm ../MacOSX/Launcher/VMSettingsController.mm"
       CPPFLAGS="$CPPFLAGS -I../MacOSX/Launcher"
     fi
   fi
@@ -693,14 +627,12 @@
 dnl BINCUE
 AS_IF([test  "x$with_bincue" = "xyes" ], [have_bincue=yes], [have_bincue=no])
 AS_IF([test  "x$have_bincue" = "xyes" ], [
-   if [[ "xOSX_CORE_AUDIO" = "xno"  -a "x$WANT_SDL_AUDIO"="xno" ]]; then
+   if [[ "xOSX_CORE_AUDIO" = "xno"  -a "x$WANT_SDL_AUDIO"="xno"]]; then
        AC_MSG_ERROR([You need SDL or OSX Core Audio to use BINCUE support.])
-       AC_SUBST(USE_BINCUE, no)
    else
        CPPFLAGS="$CPPFLAGS -DBINCUE $OSX_CORE_AUDIO"
-       AC_SUBST(USE_BINCUE, yes)
    fi
-], [AC_SUBST(USE_BINCUE, no)])
+])
 
 dnl LIBVHD
 AS_IF([test  "x$with_libvhd" = "xyes" ], [have_libvhd=yes], [have_libvhd=no])
@@ -718,50 +650,19 @@
 ])
 
 
-
-
-dnl Is the slirp library supported?
-case "$ac_cv_have_byte_bitfields" in
-yes|"guessing yes")
-  CAN_SLIRP=yes
-  ETHERSRC=ether_unix.cpp
-  ;;
-esac
-if [[ -n "$CAN_SLIRP" ]]; then
-  AC_DEFINE(HAVE_SLIRP, 1, [Define if slirp library is supported])
-  SLIRP_SRCS="\
-    ../slirp/bootp.c     ../slirp/ip_output.c  ../slirp/tcp_input.c  \
-    ../slirp/cksum.c     ../slirp/mbuf.c       ../slirp/tcp_output.c \
-    ../slirp/debug.c     ../slirp/misc.c       ../slirp/tcp_subr.c   \
-    ../slirp/if.c        ../slirp/sbuf.c       ../slirp/tcp_timer.c  \
-    ../slirp/ip_icmp.c   ../slirp/slirp.c      ../slirp/tftp.c       \
-    ../slirp/ip_input.c  ../slirp/socket.c     ../slirp/udp.c"
-fi
-AC_SUBST(SLIRP_SRCS)
-
 dnl SDL overrides
 if [[ "x$WANT_SDL" = "xyes" ]]; then
   AC_DEFINE(USE_SDL, 1, [Define to enble SDL support.])
+  if [[ "x$WANT_SDL_FRAMEWORK" = "xyes" ]]; then
+    EXTRASYSSRCS="$EXTRASYSSRCS ../SDL/SDLMain.m"
+  fi
 fi
 if [[ "x$WANT_SDL_VIDEO" = "xyes" ]]; then
   AC_DEFINE(USE_SDL_VIDEO, 1, [Define to enable SDL video graphics support.])
-  VIDEOSRCS="../SDL/video_sdl.cpp ../SDL/video_sdl2.cpp"
+  VIDEOSRCS="../SDL/video_sdl.cpp"
   KEYCODES="../SDL/keycodes"
   if [[ "x$ac_cv_framework_Carbon" = "xyes" ]]; then
-    AC_MSG_CHECKING([whether __LP64__ is defined])
-    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#if !defined(__LP64__)
-                                         # error __LP64__ not defined
-                                         #endif
-                                       ]])],
-                      [AC_MSG_RESULT(yes); LP64_DEFINED=yes],
-                      [AC_MSG_RESULT(no)])
-    if [[ "x$LP64_DEFINED" = "xyes" ]]; then
-      EXTRASYSSRCS="$EXTRASYSSRCS ../MacOSX/clip_macosx64.mm ../pict.c"
-    else
-      EXTRASYSSRCS="$EXTRASYSSRCS ../MacOSX/clip_macosx.cpp"
-    fi
-    EXTRASYSSRCS="$EXTRASYSSRCS ../MacOSX/utils_macosx.mm"
-    CPPFLAGS="$CPPFLAGS -I../MacOSX"
+    EXTRASYSSRCS="$EXTRASYSSRCS ../MacOSX/clip_macosx.cpp"
   else
     EXTRASYSSRCS="$EXTRASYSSRCS ../dummy/clip_dummy.cpp"
   fi
@@ -836,6 +737,10 @@
 AC_TRANSLATE_DEFINE(HAVE_MACH_VM, "$have_mach_vm",
   [Define if your system has a working vm_allocate()-based memory allocator.])
 
+if [[ "x$have_mach_vm" = "xyes" ]]; then
+  LDFLAGS="$LDFLAGS -Wl,-pagezero_size,0x3000"
+fi
+
 dnl Check that vm_allocate(), vm_protect() work
 if [[ "x$have_mach_vm" = "xyes" ]]; then
 
@@ -849,7 +754,7 @@
     AC_TRY_RUN([
       #define CONFIGURE_TEST_VM_MAP
       #define TEST_VM_PROT_$test_def
-      #include "../CrossPlatform/vm_alloc.cpp"
+      #include "vm_alloc.cpp"
     ], ac_cv_vm_protect_works=no, rm -f core,
     dnl When cross-compiling, do not assume anything
     ac_cv_vm_protect_works="guessing no"
@@ -858,7 +763,7 @@
   AC_TRY_RUN([
     #define CONFIGURE_TEST_VM_MAP
     #define TEST_VM_PROT_RDWR_WRITE
-    #include "../CrossPlatform/vm_alloc.cpp"
+    #include "vm_alloc.cpp"
   ], , ac_cv_vm_protect_works=no,
   dnl When cross-compiling, do not assume anything
   ac_cv_vm_protect_works="guessing no"
@@ -903,7 +808,7 @@
     #define HAVE_MMAP_ANON
     #define CONFIGURE_TEST_VM_MAP
     #define TEST_VM_MMAP_ANON
-    #include "../CrossPlatform/vm_alloc.cpp"
+    #include "vm_alloc.cpp"
   ], ac_cv_mmap_anon=yes, ac_cv_mmap_anon=no,
   dnl When cross-compiling, do not assume anything.
   ac_cv_mmap_anon="guessing no"
@@ -922,7 +827,7 @@
     #define HAVE_MMAP_ANONYMOUS
     #define CONFIGURE_TEST_VM_MAP
     #define TEST_VM_MMAP_ANON
-    #include "../CrossPlatform/vm_alloc.cpp"
+    #include "vm_alloc.cpp"
   ], ac_cv_mmap_anonymous=yes, ac_cv_mmap_anonymous=no,
   dnl When cross-compiling, do not assume anything.
   ac_cv_mmap_anonymous="guessing no"
@@ -943,7 +848,7 @@
     AC_TRY_RUN([
       #define CONFIGURE_TEST_VM_MAP
       #define TEST_VM_PROT_$test_def
-      #include "../CrossPlatform/vm_alloc.cpp"
+      #include "vm_alloc.cpp"
     ], ac_cv_mprotect_works=no, rm -f core,
     dnl When cross-compiling, do not assume anything
     ac_cv_mprotect_works="guessing no"
@@ -952,7 +857,7 @@
   AC_TRY_RUN([
     #define CONFIGURE_TEST_VM_MAP
     #define TEST_VM_PROT_RDWR_WRITE
-    #include "../CrossPlatform/vm_alloc.cpp"
+    #include "vm_alloc.cpp"
   ], , ac_cv_mprotect_works=no,
   dnl When cross-compiling, do not assume anything
   ac_cv_mprotect_works="guessing no"
@@ -973,38 +878,13 @@
 
 fi dnl HAVE_MMAP_VM
 
-dnl Check if we can disable position-independent code
-AC_CACHE_CHECK([how to disable position-independent code],
-  ac_cv_no_pie, [
-  ac_cv_no_pie='-Wl,-no_pie'
-  saved_LDFLAGS="$LDFLAGS"
-  LDFLAGS="$LDFLAGS $ac_cv_no_pie"
-  AC_TRY_LINK(,,,[ac_cv_no_pie="cannot"])
-  if [[ "$ac_cv_no_pie" = "cannot" ]]; then
-    LDFLAGS="$saved_LDFLAGS"
-  fi
-])
-
-dnl Check if we can modify the __PAGEZERO segment for use as Low Memory
-AC_CACHE_CHECK([whether __PAGEZERO can be Low Memory area 0x0000-0x3000],
-  ac_cv_pagezero_hack, [
-  ac_cv_pagezero_hack=no 
-  if AC_TRY_COMMAND([Darwin/testlmem.sh 0x3000]); then
-    ac_cv_pagezero_hack=yes
-    dnl might as well skip the test for mmap-able low memory
-    ac_cv_can_map_lm=no
-  fi
-])
-AC_TRANSLATE_DEFINE(PAGEZERO_HACK, "$ac_cv_pagezero_hack",
-  [Define if the __PAGEZERO Mach-O Low Memory Globals hack works on this system.])
-
 dnl Check if we can mmap 0x3000 bytes from 0x0000
 AC_CACHE_CHECK([whether we can map Low Memory area 0x0000-0x3000],
   ac_cv_can_map_lm, [
   AC_LANG_SAVE
   AC_LANG_CPLUSPLUS
   AC_TRY_RUN([
-    #include "../CrossPlatform/vm_alloc.cpp"
+    #include "vm_alloc.cpp"
     int main(void) { /* returns 0 if we could map the lowmem globals */
       volatile char * lm = 0;
       if (vm_init() < 0) exit(1);
@@ -1090,8 +970,8 @@
   AC_TRY_RUN([
     #define HAVE_MACH_EXCEPTIONS 1
     #define CONFIGURE_TEST_SIGSEGV_RECOVERY
-    #include "../CrossPlatform/vm_alloc.cpp"
-    #include "../CrossPlatform/sigsegv.cpp"
+    #include "vm_alloc.cpp"
+    #include "sigsegv.cpp"
   ],
   ac_cv_have_mach_exceptions=yes,
   ac_cv_have_mach_exceptions=no,
@@ -1115,8 +995,8 @@
   AC_TRY_RUN([
     #define HAVE_WIN32_EXCEPTIONS 1
     #define CONFIGURE_TEST_SIGSEGV_RECOVERY
-    #include "../CrossPlatform/vm_alloc.cpp"
-    #include "../CrossPlatform/sigsegv.cpp"
+    #include "vm_alloc.cpp"
+    #include "sigsegv.cpp"
   ], [
   sigsegv_recovery=win32
   ac_cv_have_win32_exceptions=yes
@@ -1140,8 +1020,8 @@
     AC_TRY_RUN([
       #define HAVE_SIGINFO_T 1
       #define CONFIGURE_TEST_SIGSEGV_RECOVERY
-      #include "../CrossPlatform/vm_alloc.cpp"
-      #include "../CrossPlatform/sigsegv.cpp"
+      #include "vm_alloc.cpp"
+      #include "sigsegv.cpp"
     ],
     ac_cv_have_extended_signals=yes,
     ac_cv_have_extended_signals=no,
@@ -1167,8 +1047,8 @@
     AC_TRY_RUN([
       #define HAVE_SIGCONTEXT_SUBTERFUGE 1
       #define CONFIGURE_TEST_SIGSEGV_RECOVERY
-      #include "../CrossPlatform/vm_alloc.cpp"
-      #include "../CrossPlatform/sigsegv.cpp"
+      #include "vm_alloc.cpp"
+      #include "sigsegv.cpp"
     ],
     ac_cv_have_sigcontext_hack=yes,
     ac_cv_have_sigcontext_hack=no,
@@ -1192,8 +1072,8 @@
   AC_TRY_RUN([
     #define HAVE_SIGSEGV_SKIP_INSTRUCTION 1
     #define CONFIGURE_TEST_SIGSEGV_RECOVERY
-    #include "../CrossPlatform/vm_alloc.cpp"
-    #include "../CrossPlatform/sigsegv.cpp"
+    #include "vm_alloc.cpp"
+    #include "sigsegv.cpp"
   ], ac_cv_have_skip_instruction=yes, ac_cv_have_skip_instruction=no,
   dnl When cross-compiling, do not assume anything.
   ac_cv_have_skip_instruction=no
@@ -1235,7 +1115,7 @@
   cat >> conftest.$ac_ext << EOF
 #include <stdio.h>
 #include <string.h>
-#include "../CrossPlatform/vm_alloc.cpp"
+#include "vm_alloc.cpp"
 
 int main(void)
 {
@@ -1318,6 +1198,8 @@
 AC_DEFUN([gcc_AC_EXAMINE_OBJECT],
 [AC_LANG_SAVE
 AC_LANG_C
+OLD_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -fno-lto"
 dnl Next bit cribbed from AC_TRY_COMPILE.
 cat > conftest.$ac_ext <<EOF
 [#line __oline__ "configure"
@@ -1341,6 +1223,7 @@
 )dnl
 fi
 rm -rf conftest*
+CFLAGS=$OLD_CFLAGS
 AC_LANG_RESTORE])
 
 dnl Floating point format probe.
@@ -1444,7 +1327,6 @@
 AC_PATH_PROG(BLESS, "true")
 if [[ "x$ac_cv_pagezero_hack" = "xyes" ]]; then
   BLESS=Darwin/lowmem
-  LDFLAGS="$LDFLAGS -pagezero_size 0x3000"
 fi
 
 dnl Check for GCC 2.7 or higher.
@@ -1469,21 +1351,10 @@
                   [AC_MSG_RESULT(yes); HAVE_GCC30=yes],
                   [AC_MSG_RESULT(no)])
 
-dnl Check for GCC 4.0 or higher.
-HAVE_GCC40=no
-AC_MSG_CHECKING(for GCC 4.0 or higher)
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#if ! (__GNUC__ >= 4)
-                                     # error gcc < 4
-                                     typedef syntax error;
-                                     #endif
-                                   ]])],
-                  [AC_MSG_RESULT(yes); HAVE_GCC40=yes],
-                  [AC_MSG_RESULT(no)])
-
 dnl Check for ICC.
 AC_MSG_CHECKING(for ICC)
 HAVE_ICC=no
-if $CXX -V -v 2>&1 | grep -q "Intel(R) C++ Compiler"; then
+if $CXX -V -v 2>&1 | grep -q "Intel.*Compiler"; then
   HAVE_ICC=yes
 fi
 AC_MSG_RESULT($HAVE_ICC)
@@ -1509,7 +1380,7 @@
   rm -rf conftest*
 ])
 
-dnl Add -fno-strict-aliasing for slirp sources
+dnl Add -fno-strict-aliasing
 if [[ "x$HAVE_GCC30" = "xyes" ]]; then
   SAVED_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS -fno-strict-aliasing"
@@ -1518,9 +1389,10 @@
     AC_TRY_COMPILE([],[],[ac_cv_gcc_no_strict_aliasing=yes],[ac_cv_gcc_no_strict_aliasing=no])
   ])
   if [[ "x$ac_cv_gcc_no_strict_aliasing" = "xyes" ]]; then
-    AC_SUBST(SLIRP_CFLAGS, "-fno-strict-aliasing")
+    CXXFLAGS="$SAVED_CFLAGS -fno-strict-aliasing"
+  else
+    CFLAGS="$SAVED_CFLAGS"
   fi
-  CFLAGS="$SAVED_CFLAGS"
 fi
 
 dnl Add -mdynamic-no-pic for MacOS X (XXX icc10 will support MacOS X)
@@ -1552,7 +1424,6 @@
 
   dnl Enable JIT compiler, if possible
   if [[ "x$WANT_JIT" = "xyes" ]]; then
-    ac_cv_use_dyngen_precompiled=no
     AC_CACHE_CHECK([whether dyngen can be used],
       ac_cv_use_dyngen, [
       case $host_cpu:$ac_cv_object_format in
@@ -1583,30 +1454,20 @@
       esac
       dnl Check for a suitable synthetic opcodes compiler (icc is faking itself as gcc 3.2.2)
       if [[ -z "$DYNGEN_CC" ]]; then
-        if [[ "x$HAVE_GCC27" = "xyes" -a "x$HAVE_GCC40" = "xno" -a "x$HAVE_ICC" = "xno" ]]; then
+        if [[ "x$HAVE_GCC27" = "xyes" -a "x$HAVE_ICC" = "xno" ]]; then
           DYNGEN_CC=$CXX
-        elif command -v g++ >/dev/null; then
-          vers=`g++ -dumpversion`
-          function version { echo "$@" | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }'; }
-          if [[ $(version $vers) -ge $(version "2.7.0") ]] && [[ $(version $vers) -lt $(version "4.0.0") ]]; then
-            DYNGEN_CC="$gxx"
-          fi
+        else
+          for p in /usr/bin /usr/local/bin /usr/freeware/bin; do
+            gxx="$p/g++"
+            if [[ -x "$gxx" ]]; then
+              DYNGEN_CC="$gxx"
+            fi
+          done
         fi
       fi
-      if [[ -z "$DYNGEN_CC" -o "x$DYNGEN_CC" = "xprecompiled" ]]; then
-        case $host_cpu in
-          i?86)
-            ac_cv_use_dyngen_precompiled=yes
-            ;;
-          x86_64)
-            ac_cv_use_dyngen_precompiled=yes
-            ;;
-          *)
-            ac_cv_use_dyngen=no
-            ;;
-        esac
+      if [[ -z "$DYNGEN_CC" ]]; then
+        ac_cv_use_dyngen=no
       fi
-      if [[ "x$ac_cv_use_dyngen_precompiled" = "xyes" ]]; then DYNGEN_CC=precompiled; fi
     ])
     if [[ "x$ac_cv_use_dyngen" = "xyes" ]]; then
       case $host_cpu in
@@ -1623,17 +1484,10 @@
         ;;
       esac
       have_dyngen_gcc3=no
-      if [[ "$DYNGEN_CC" != "precompiled" ]]; then
-        case "x`$DYNGEN_CC -dumpversion`" in
-        x[12].*) ;;
-        x*) have_dyngen_gcc3=yes ;;
-        esac
-      else
-        case "x`$CXX -dumpversion`" in
-        x[12].*) ;;
-        x*) have_dyngen_gcc3=yes ;;
-        esac
-      fi
+      case "x`$DYNGEN_CC -dumpversion`" in
+      x[12].*) ;;
+      x*) have_dyngen_gcc3=yes ;;
+      esac
       if [[ "x$have_dyngen_gcc3" = "xyes" ]]; then
         DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -fno-align-functions"
       else
@@ -1665,7 +1519,7 @@
         ../kpx_cpu/src/cpu/ppc/ppc-jit.cpp $CPUSRCS"
     fi
   fi
-  CPUSRCS="$CPUSRCS ../kpx_cpu/sheepshaver_glue.cpp ../kpx_cpu/ppc-dis.c"
+  CPUSRCS="$CPUSRCS ../kpx_cpu/sheepshaver_glue.cpp"
 else
   WANT_JIT=no
 fi
@@ -1717,7 +1571,6 @@
 dnl Generate Makefile.
 AC_SUBST(PERL)
 AC_SUBST(USE_DYNGEN, [$ac_cv_use_dyngen])
-AC_SUBST(USE_DYNGEN_PRECOMPILED, [$ac_cv_use_dyngen_precompiled])
 AC_SUBST(DYNGENSRCS)
 AC_SUBST(DYNGEN_CC)
 AC_SUBST(DYNGEN_CFLAGS)
@@ -1727,17 +1580,17 @@
 AC_SUBST(CPUSRCS)
 AC_SUBST(BLESS)
 AC_SUBST(KEYCODES)
-AC_OUTPUT([
+AC_CONFIG_FILES([
 Makefile
 ../MacOSX/Info.plist
 ])
+AC_OUTPUT
 
 dnl Print summary.
 echo
 echo SheepShaver configuration summary:
 echo
 echo SDL support ...................... : $SDL_SUPPORT
-echo SDL major-version ................ : $WANT_SDL_VERSION_MAJOR
 echo BINCUE support ................... : $have_bincue
 echo LIBVHD support ................... : $have_libvhd
 echo FBDev DGA support ................ : $WANT_FBDEV_DGA
Only in macemu/: SheepShaver/src/Unix/disk_sparsebundle.cpp
Only in macemu/: SheepShaver/src/Unix/disk_unix.h
--- macemu/SheepShaver/src/Unix/ether_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/ether_unix.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "../CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 /*
  *  NOTES concerning MacOS X issues:
@@ -33,9 +33,6 @@
 #define USE_POLL 1
 #endif
 
-// Define to let the slirp library determine the right timeout for select()
-#define USE_SLIRP_TIMEOUT 1
-
 #ifdef HAVE_SYS_POLL_H
 #include <sys/poll.h>
 #endif
@@ -64,11 +61,6 @@
 #include <net/if_tun.h>
 #endif
 
-#ifdef HAVE_SLIRP
-#include "libslirp.h"
-#include "ctl.h"
-#endif
-
 #include "cpu_emulation.h"
 #include "main.h"
 #include "macos_util.h"
@@ -92,14 +84,11 @@
 enum {
 	NET_IF_SHEEPNET,
 	NET_IF_ETHERTAP,
-	NET_IF_TUNTAP,
-	NET_IF_SLIRP
+	NET_IF_TUNTAP
 };
 
 // Constants
-#if ENABLE_TUNTAP
 static const char ETHERCONFIG_FILE_NAME[] = DATADIR "/tunconfig";
-#endif
 
 // Global variables
 static int fd = -1;							// fd of sheep_net device
@@ -111,10 +100,6 @@
 static int net_if_type = -1;				// Ethernet device type
 static char *net_if_name = NULL;			// TUN/TAP device name
 static const char *net_if_script = NULL;	// Network config script
-static pthread_t slirp_thread;				// Slirp reception thread
-static bool slirp_thread_active = false;	// Flag: Slirp reception threadinstalled
-static int slirp_output_fd = -1;			// fd of slirp output pipe
-static int slirp_input_fds[2] = { -1, -1 };	// fds of slirp input pipe
 #ifdef SHEEPSHAVER
 static bool net_open = false;				// Flag: initialization succeeded, network device open
 static uint8 ether_addr[6];					// Our Ethernet address
@@ -127,13 +112,11 @@
 
 // Prototypes
 static void *receive_func(void *arg);
-static void *slirp_receive_func(void *arg);
+static int poll_fd(int fd);
 static int16 ether_do_add_multicast(uint8 *addr);
 static int16 ether_do_del_multicast(uint8 *addr);
 static int16 ether_do_write(uint32 arg);
 static void ether_do_interrupt(void);
-static void slirp_add_redirs();
-static int slirp_add_redir(const char *redir_str);
 
 
 /*
@@ -154,16 +137,6 @@
 		return false;
 	}
 
-#ifdef HAVE_SLIRP
-	if (net_if_type == NET_IF_SLIRP) {
-		slirp_thread_active = (pthread_create(&slirp_thread, NULL, slirp_receive_func, NULL) == 0);
-		if (!slirp_thread_active) {
-			printf("WARNING: Cannot start slirp reception thread\n");
-			return false;
-		}
-	}
-#endif
-
 	return true;
 }
 
@@ -174,16 +147,6 @@
 
 static void stop_thread(void)
 {
-#ifdef HAVE_SLIRP
-	if (slirp_thread_active) {
-#ifdef HAVE_PTHREAD_CANCEL
-		pthread_cancel(slirp_thread);
-#endif
-		pthread_join(slirp_thread, NULL);
-		slirp_thread_active = false;
-	}
-#endif
-
 	if (thread_active) {
 #ifdef HAVE_PTHREAD_CANCEL
 		pthread_cancel(ether_thread);
@@ -230,7 +193,7 @@
 
 bool ether_init(void)
 {
-	int val;
+	int val, nonblock = 1;
 	char str[256];
 
 	// Do nothing if no Ethernet device specified
@@ -246,10 +209,6 @@
 	else if (strcmp(name, "tun") == 0)
 		net_if_type = NET_IF_TUNTAP;
 #endif
-#ifdef HAVE_SLIRP
-	else if (strcmp(name, "slirp") == 0)
-		net_if_type = NET_IF_SLIRP;
-#endif
 	else
 		net_if_type = NET_IF_SHEEPNET;
 
@@ -263,31 +222,6 @@
 		sigaction(SIGPIPE, &sigpipe_sa, NULL);
 	}
 
-#ifdef HAVE_SLIRP
-	// Initialize slirp library
-	if (net_if_type == NET_IF_SLIRP) {
-		if (slirp_init() < 0) {
-			sprintf(str, "%s", GetString(STR_SLIRP_NO_DNS_FOUND_WARN));
-			WarningAlert(str);
-			return false;
-		}
-
-		// Open slirp output pipe
-		int fds[2];
-		if (pipe(fds) < 0)
-			return false;
-		fd = fds[0];
-		slirp_output_fd = fds[1];
-
-		// Open slirp input pipe
-		if (pipe(slirp_input_fds) < 0)
-			return false;
-
-		// Set up port redirects
-		slirp_add_redirs();
-	}
-#endif
-
 	// Open sheep_net or ethertap or TUN/TAP device
 	char dev_name[16];
 	switch (net_if_type) {
@@ -301,13 +235,12 @@
 		strcpy(dev_name, "/dev/sheep_net");
 		break;
 	}
-	if (net_if_type != NET_IF_SLIRP) {
-		fd = open(dev_name, O_RDWR);
-		if (fd < 0) {
-			sprintf(str, GetString(STR_NO_SHEEP_NET_DRIVER_WARN), dev_name, strerror(errno));
-			WarningAlert(str);
-			goto open_error;
-		}
+
+	fd = open(dev_name, O_RDWR);
+	if (fd < 0) {
+		sprintf(str, GetString(STR_NO_SHEEP_NET_DRIVER_WARN), dev_name, strerror(errno));
+		WarningAlert(str);
+		goto open_error;
 	}
 
 #if ENABLE_TUNTAP
@@ -355,7 +288,6 @@
 
 	// Set nonblocking I/O
 #ifdef USE_FIONBIO
-	int nonblock = 1;
 	if (ioctl(fd, FIONBIO, &nonblock) < 0) {
 		sprintf(str, GetString(STR_BLOCKING_NET_SOCKET_WARN), strerror(errno));
 		WarningAlert(str);
@@ -371,7 +303,7 @@
 #endif
 
 	// Get Ethernet address
-	if (net_if_type == NET_IF_ETHERTAP || net_if_type == NET_IF_TUNTAP) {
+	if (net_if_type == NET_IF_ETHERTAP) {
 		pid_t p = getpid();	// If configured for multicast, ethertap requires that the lower 32 bit of the Ethernet address are our PID
 		ether_addr[0] = 0xfe;
 		ether_addr[1] = 0xfd;
@@ -379,18 +311,24 @@
 		ether_addr[3] = p >> 16;
 		ether_addr[4] = p >> 8;
 		ether_addr[5] = p;
-#ifdef HAVE_SLIRP
-	} else if (net_if_type == NET_IF_SLIRP) {
-		ether_addr[0] = 0x52;
-		ether_addr[1] = 0x54;
-		ether_addr[2] = 0x00;
-		ether_addr[3] = 0x12;
-		ether_addr[4] = 0x34;
-		ether_addr[5] = 0x56;
+	} else {
+#ifdef __linux
+		struct ifreq ifr;
+		int r, sock;
+		memset(&ifr, 0, sizeof(ifr));
+		sock = socket(PF_INET, SOCK_DGRAM, 0);
+		strcpy(ifr.ifr_name, net_if_name);
+		r = ioctl(sock, SIOCGIFHWADDR, &ifr);
+		if (r == -1)
+			perror("ioctl(SIOCGIFHWADDR)");
+		else
+			memcpy(ether_addr, ifr.ifr_hwaddr.sa_data, 6);
+		close(sock);
+#else
+		ioctl(fd, SIOCGIFADDR, &ether_addr);
 #endif
-	} else
-		ioctl(fd, SIOCGIFADDR, ether_addr);
-	D(bug("Ethernet address %02x %02x %02x %02x %02x %02x\n", ether_addr[0], ether_addr[1], ether_addr[2], ether_addr[3], ether_addr[4], ether_addr[5]));
+	}
+	D(bug("Ethernet address %02x:%02x:%02x:%02x:%02x:%02x\n", ether_addr[0], ether_addr[1], ether_addr[2], ether_addr[3], ether_addr[4], ether_addr[5]));
 
 	// Start packet reception thread
 	if (!start_thread())
@@ -406,18 +344,6 @@
 		close(fd);
 		fd = -1;
 	}
-	if (slirp_input_fds[0] >= 0) {
-		close(slirp_input_fds[0]);
-		slirp_input_fds[0] = -1;
-	}
-	if (slirp_input_fds[1] >= 0) {
-		close(slirp_input_fds[1]);
-		slirp_input_fds[1] = -1;
-	}
-	if (slirp_output_fd >= 0) {
-		close(slirp_output_fd);
-		slirp_output_fd = -1;
-	}
 	return false;
 }
 
@@ -443,16 +369,6 @@
 	if (fd > 0)
 		close(fd);
 
-	// Close slirp input buffer
-	if (slirp_input_fds[0] >= 0)
-		close(slirp_input_fds[0]);
-	if (slirp_input_fds[1] >= 0)
-		close(slirp_input_fds[1]);
-
-	// Close slirp output buffer
-	if (slirp_output_fd > 0)
-		close(slirp_output_fd);
-
 #if STATISTICS
 	// Show statistics
 	printf("%ld messages put on write queue\n", num_wput);
@@ -658,13 +574,11 @@
 	case NET_IF_SHEEPNET:
 		if (ioctl(fd, SIOCADDMULTI, addr) < 0) {
 			D(bug("WARNING: Couldn't enable multicast address\n"));
-			if (net_if_type == NET_IF_ETHERTAP) {
+			if (net_if_type == NET_IF_ETHERTAP)
 				return noErr;
-			} else {
+			else
 				return eMultiErr;
-			}
 		}
-		return noErr;
 	default:
 		return noErr;
 	}
@@ -684,7 +598,6 @@
 			D(bug("WARNING: Couldn't disable multicast address\n"));
 			return eMultiErr;
 		}
-		return noErr;
 	default:
 		return noErr;
 	}
@@ -743,14 +656,6 @@
 #endif
 
 	// Transmit packet
-#ifdef HAVE_SLIRP
-	if (net_if_type == NET_IF_SLIRP) {
-		const int slirp_input_fd = slirp_input_fds[1];
-		write(slirp_input_fd, &len, sizeof(len));
-		write(slirp_input_fd, packet, len);
-		return noErr;
-	} else
-#endif
 	if (write(fd, packet, len) < 0) {
 		D(bug("WARNING: Couldn't transmit packet\n"));
 		return excessCollsns;
@@ -783,79 +688,6 @@
 
 
 /*
- *  SLIRP output buffer glue
- */
-
-#ifdef HAVE_SLIRP
-int slirp_can_output(void)
-{
-	return 1;
-}
-
-void slirp_output(const uint8 *packet, int len)
-{
-	write(slirp_output_fd, packet, len);
-}
-
-void *slirp_receive_func(void *arg)
-{
-	const int slirp_input_fd = slirp_input_fds[0];
-
-	for (;;) {
-		// Wait for packets to arrive
-		fd_set rfds, wfds, xfds;
-		int nfds;
-		struct timeval tv;
-
-		// ... in the input queue
-		FD_ZERO(&rfds);
-		FD_SET(slirp_input_fd, &rfds);
-		tv.tv_sec = 0;
-		tv.tv_usec = 0;
-		if (select(slirp_input_fd + 1, &rfds, NULL, NULL, &tv) > 0) {
-			int len;
-			read(slirp_input_fd, &len, sizeof(len));
-			uint8 packet[1516];
-			assert(len <= sizeof(packet));
-			read(slirp_input_fd, packet, len);
-			slirp_input(packet, len);
-		}
-
-		// ... in the output queue
-		nfds = -1;
-		FD_ZERO(&rfds);
-		FD_ZERO(&wfds);
-		FD_ZERO(&xfds);
-		int timeout = slirp_select_fill(&nfds, &rfds, &wfds, &xfds);
-#if ! USE_SLIRP_TIMEOUT
-		timeout = 10000;
-#endif
-		tv.tv_sec = 0;
-		tv.tv_usec = timeout;
-		if (select(nfds + 1, &rfds, &wfds, &xfds, &tv) >= 0)
-			slirp_select_poll(&rfds, &wfds, &xfds);
-
-#ifdef HAVE_PTHREAD_TESTCANCEL
-		// Explicit cancellation point if select() was not covered
-		// This seems to be the case on MacOS X 10.2
-		pthread_testcancel();
-#endif
-	}
-	return NULL;
-}
-#else
-int slirp_can_output(void)
-{
-	return 0;
-}
-
-void slirp_output(const uint8 *packet, int len)
-{
-}
-#endif
-
-
-/*
  *  Packet reception thread
  */
 
@@ -956,96 +788,4 @@
 			ether_dispatch_packet(p, length);
 		}
 	}
-}
-
-// Helper function for port forwarding
-static int get_str_sep(char *buf, int buf_size, const char **pp, int sep)
-{
-	const char *p, *p1;
-	int len;
-	p = *pp;
-	p1 = strchr(p, sep);
-	if (!p1)
-		return -1;
-	len = p1 - p;
-	p1++;
-	if (buf_size > 0) {
-		if (len > buf_size - 1)
-			len = buf_size - 1;
-		memcpy(buf, p, len);
-		buf[len] = '\0';
-	}
-	*pp = p1;
-	return 0;
-}
-
-// Set up port forwarding for slirp
-static void slirp_add_redirs()
-{
-	int index = 0;
-	const char *str;
-	while ((str = PrefsFindString("redir", index++)) != NULL) {
-		slirp_add_redir(str);
-	}
-}
-
-// Add a port forward/redirection for slirp
-static int slirp_add_redir(const char *redir_str)
-{
-	// code adapted from qemu source
-	struct in_addr guest_addr = {0};
-	int host_port, guest_port;
-	const char *p;
-	char buf[256];
-	int is_udp;
-	char *end;
-	char str[256];
-
-	p = redir_str;
-	if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {
-		goto fail_syntax;
-	}
-	if (!strcmp(buf, "tcp") || buf[0] == '\0') {
-		is_udp = 0;
-	} else if (!strcmp(buf, "udp")) {
-		is_udp = 1;
-	} else {
-		goto fail_syntax;
-	}
-
-	if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {
-		goto fail_syntax;
-	}
-	host_port = strtol(buf, &end, 0);
-	if (*end != '\0' || host_port < 1 || host_port > 65535) {
-		goto fail_syntax;
-	}
-
-	if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {
-		goto fail_syntax;
-	}
-	// 0.0.0.0 doesn't seem to work, so default to a client address
-	// if none is specified
-	if (buf[0] == '\0' ?
-			!inet_aton(CTL_LOCAL, &guest_addr) :
-			!inet_aton(buf, &guest_addr)) {
-		goto fail_syntax;
-	}
-
-	guest_port = strtol(p, &end, 0);
-	if (*end != '\0' || guest_port < 1 || guest_port > 65535) {
-		goto fail_syntax;
-	}
-
-	if (slirp_redir(is_udp, host_port, guest_addr, guest_port) < 0) {
-		sprintf(str, "could not set up host forwarding rule '%s'", redir_str);
-		WarningAlert(str);
-		return -1;
-	}
-	return 0;
-
- fail_syntax:
-	sprintf(str, "invalid host forwarding rule '%s'", redir_str);
-	WarningAlert(str);
-	return -1;
 }
--- macemu/SheepShaver/src/Unix/extfs_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/extfs_unix.cpp
@@ -25,7 +25,6 @@
 #include <unistd.h>
 #include <dirent.h>
 #include <errno.h>
-#include <utime.h>
 
 #include "sysdeps.h"
 #include "extfs.h"
@@ -257,14 +256,6 @@
 
 void set_finfo(const char *path, uint32 finfo, uint32 fxinfo, bool is_dir)
 {
-	struct utimbuf times;
-	times.actime = MacTimeToTime(ReadMacInt32(finfo - ioFlFndrInfo + ioFlCrDat));
-	times.modtime = MacTimeToTime(ReadMacInt32(finfo - ioFlFndrInfo + ioFlMdDat));
-
-	if (utime(path, &times) < 0) {
-		D(bug("utime failed on %s\n", path));
-	}
-
 	// Open Finder info file
 	int fd = open_finf(path, O_RDWR);
 	if (fd < 0)
@@ -291,7 +282,7 @@
 
 	// Get size
 	off_t size = lseek(fd, 0, SEEK_END);
-
+	
 	// Close file and return size
 	close(fd);
 	return size < 0 ? 0 : size;
@@ -397,3 +388,5 @@
 {
 	return filename;
 }
+
+
Only in macemu/: SheepShaver/src/Unix/install-sh
--- macemu/SheepShaver/src/Unix/main_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/main_unix.cpp
@@ -90,14 +90,13 @@
 #include <sys/ipc.h>
 #include <sys/shm.h>
 #include <sys/stat.h>
-#include <sys/param.h>
 #include <signal.h>
 
-#include "../CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "main.h"
 #include "version.h"
 #include "prefs.h"
-//#include "prefs_editor.h"
+#include "prefs_editor.h"
 #include "cpu_emulation.h"
 #include "emul_op.h"
 #include "xlowmem.h"
@@ -109,8 +108,8 @@
 #include "macos_util.h"
 #include "rom_patches.h"
 #include "user_strings.h"
-#include "../CrossPlatform/vm_alloc.h"
-#include "../CrossPlatform/sigsegv.h"
+#include "vm_alloc.h"
+#include "sigsegv.h"
 #include "sigregs.h"
 #include "rpc.h"
 
@@ -162,14 +161,14 @@
 const char ROM_FILE_NAME[] = "ROM";
 const char ROM_FILE_NAME2[] = "Mac OS ROM";
 
-/*#if !REAL_ADDRESSING
+#if !REAL_ADDRESSING
 // FIXME: needs to be >= 0x04000000
 const uintptr RAM_BASE = 0x10000000;		// Base address of RAM
 #endif
 const uintptr ROM_BASE = 0x40800000;		// Base address of ROM
-#if REAL_ADDRESSING*/
+#if REAL_ADDRESSING
 const uint32 ROM_ALIGNMENT = 0x100000;		// ROM must be aligned to a 1MB boundary
-/*#endif*/
+#endif
 const uint32 SIG_STACK_SIZE = 0x10000;		// Size of signal stack
 
 
@@ -190,12 +189,8 @@
 int64 TimebaseSpeed;	// Timebase clock speed (Hz)
 uint8 *RAMBaseHost;		// Base address of Mac RAM (host address space)
 uint8 *ROMBaseHost;		// Base address of Mac ROM (host address space)
-uint32 ROMEnd;
 
-/*#if defined(__APPLE__) && defined(__x86_64__)*/
-uint8 /*gZeroPage[0x3000],*/ gKernelData[0x2000];
-/*#endif*/
-//uintptr SheepMem::zero_page = ((uintptr)calloc((size_t)1,(size_t)4096));			// Address of ro page filled in with zeros
+
 // Global variables
 #ifndef USE_SDL_VIDEO
 char *x_display_name = NULL;				// X11 display name
@@ -225,11 +220,12 @@
 static pthread_t emul_thread;				// MacOS thread
 
 static bool ready_for_signals = false;		// Handler installed, signals can be sent
+static int64 num_segv = 0;					// Number of handled SEGV signals
 
+static struct sigaction sigusr2_action;		// Interrupt signal (of emulator thread)
 #if EMULATED_PPC
 static uintptr sig_stack = 0;				// Stack for PowerPC interrupt routine
 #else
-static struct sigaction sigusr2_action;		// Interrupt signal (of emulator thread)
 static struct sigaction sigsegv_action;		// Data access exception signal (of emulator thread)
 static struct sigaction sigill_action;		// Illegal instruction signal (of emulator thread)
 static stack_t sig_stack;					// Stack for signal handlers
@@ -242,7 +238,8 @@
 static rpc_connection_t *gui_connection = NULL;	// RPC connection to the GUI
 static const char *gui_connection_path = NULL;	// GUI connection identifier
 
-/*uint32  SheepMem::page_size;	*/			// Size of a native page
+uint32  SheepMem::page_size;				// Size of a native page
+uintptr SheepMem::zero_page = 0;			// Address of ro page filled in with zeros
 uintptr SheepMem::base = 0x60000000;		// Address of SheepShaver data
 uintptr SheepMem::proc;						// Bottom address of SheepShave procedures
 uintptr SheepMem::data;						// Top of SheepShaver data (stack like storage)
@@ -296,8 +293,8 @@
 {
 	return sig_stack + SIG_STACK_SIZE;
 }
-#else/*the below Atomic operations are duplicate with emul_ppc*/
 
+
 /*
  *  Atomic operations
  */
@@ -386,17 +383,219 @@
 	return false;
 }
 
-static void get_system_info(void)
+int main(int argc, char **argv)
 {
-#if !EMULATED_PPC
+	char str[256];
+	int rom_fd;
 	FILE *proc_file;
+	const char *rom_path;
+	uint32 rom_size, actual;
+	uint8 *rom_tmp;
+	time_t now, expire;
+	bool memory_mapped_from_zero, ram_rom_areas_contiguous;
+	const char *vmdir = NULL;
+
+#ifdef USE_SDL_VIDEO
+	// Don't let SDL block the screensaver
+	setenv("SDL_VIDEO_ALLOW_SCREENSAVER", "1", 1);
+
+	// Make SDL pass through command-clicks and option-clicks unaltered
+	setenv("SDL_HAS3BUTTONMOUSE", "1", 1);
 #endif
 
+	// Initialize variables
+	RAMBase = 0;
+	tzset();
+
+	// Print some info
+	printf(GetString(STR_ABOUT_TEXT1), VERSION_MAJOR, VERSION_MINOR);
+	printf(" %s\n", GetString(STR_ABOUT_TEXT2));
+
+#if !EMULATED_PPC
+#ifdef SYSTEM_CLOBBERS_R2
+	// Get TOC pointer
+	TOC = get_r2();
+#endif
+#ifdef SYSTEM_CLOBBERS_R13
+	// Get r13 register
+	R13 = get_r13();
+#endif
+#endif
+
+	// Parse command line arguments
+	for (int i=1; i<argc; i++) {
+		if (strcmp(argv[i], "--help") == 0) {
+			usage(argv[0]);
+#ifndef USE_SDL_VIDEO
+		} else if (strcmp(argv[i], "--display") == 0) {
+			i++;
+			if (i < argc)
+				x_display_name = strdup(argv[i]);
+#endif
+		} else if (strcmp(argv[i], "--gui-connection") == 0) {
+			argv[i++] = NULL;
+			if (i < argc) {
+				gui_connection_path = argv[i];
+				argv[i] = NULL;
+			}
+		} else if (valid_vmdir(argv[i])) {
+			vmdir = argv[i];
+			argv[i] = NULL;
+			printf("Using %s as vmdir.\n", vmdir);
+			if (chdir(vmdir)) {
+				printf("Failed to chdir to %s. Good bye.", vmdir);
+				exit(1);
+			}
+			break;
+		}
+	}
+
+	// Remove processed arguments
+	for (int i=1; i<argc; i++) {
+		int k;
+		for (k=i; k<argc; k++)
+			if (argv[k] != NULL)
+				break;
+		if (k > i) {
+			k -= i;
+			for (int j=i+k; j<argc; j++)
+				argv[j-k] = argv[j];
+			argc -= k;
+		}
+	}
+
+	// Connect to the external GUI
+	if (gui_connection_path) {
+		if ((gui_connection = rpc_init_client(gui_connection_path)) == NULL) {
+			fprintf(stderr, "Failed to initialize RPC client connection to the GUI\n");
+			return 1;
+		}
+	}
+
+#ifdef ENABLE_GTK
+	if (!gui_connection) {
+		// Init GTK
+		gtk_set_locale();
+		gtk_init(&argc, &argv);
+	}
+#endif
+
+	// Read preferences
+	PrefsInit(vmdir, argc, argv);
+
+	// Any command line arguments left?
+	for (int i=1; i<argc; i++) {
+		if (argv[i][0] == '-') {
+			fprintf(stderr, "Unrecognized option '%s'\n", argv[i]);
+			usage(argv[0]);
+		}
+	}
+
+#ifdef USE_SDL
+	// Initialize SDL system
+	int sdl_flags = 0;
+#ifdef USE_SDL_VIDEO
+	sdl_flags |= SDL_INIT_VIDEO;
+#endif
+#ifdef USE_SDL_AUDIO
+	sdl_flags |= SDL_INIT_AUDIO;
+#endif
+	assert(sdl_flags != 0);
+	if (SDL_Init(sdl_flags) == -1) {
+		char str[256];
+		sprintf(str, "Could not initialize SDL: %s.\n", SDL_GetError());
+		ErrorAlert(str);
+		goto quit;
+	}
+	atexit(SDL_Quit);
+
+	// Don't let SDL catch SIGINT and SIGTERM signals
+	signal(SIGINT, SIG_DFL);
+	signal(SIGTERM, SIG_DFL);
+#endif
+
+#ifndef USE_SDL_VIDEO
+	// Open display
+	x_display = XOpenDisplay(x_display_name);
+	if (x_display == NULL) {
+		char str[256];
+		sprintf(str, GetString(STR_NO_XSERVER_ERR), XDisplayName(x_display_name));
+		ErrorAlert(str);
+		goto quit;
+	}
+
+#if defined(ENABLE_XF86_DGA) && !defined(ENABLE_MON)
+	// Fork out, so we can return from fullscreen mode when things get ugly
+	XF86DGAForkApp(DefaultScreen(x_display));
+#endif
+#endif
+
+#ifdef ENABLE_MON
+	// Initialize mon
+	mon_init();
+#endif
+
+#if !EMULATED_PPC
+	// Create and install stacks for signal handlers
+	sig_stack.ss_sp = malloc(SIG_STACK_SIZE);
+	D(bug("Signal stack at %p\n", sig_stack.ss_sp));
+	if (sig_stack.ss_sp == NULL) {
+		ErrorAlert(GetString(STR_NOT_ENOUGH_MEMORY_ERR));
+		goto quit;
+	}
+	sig_stack.ss_flags = 0;
+	sig_stack.ss_size = SIG_STACK_SIZE;
+	if (sigaltstack(&sig_stack, NULL) < 0) {
+		sprintf(str, GetString(STR_SIGALTSTACK_ERR), strerror(errno));
+		ErrorAlert(str);
+		goto quit;
+	}
+	extra_stack.ss_sp = malloc(SIG_STACK_SIZE);
+	D(bug("Extra stack at %p\n", extra_stack.ss_sp));
+	if (extra_stack.ss_sp == NULL) {
+		ErrorAlert(GetString(STR_NOT_ENOUGH_MEMORY_ERR));
+		goto quit;
+	}
+	extra_stack.ss_flags = 0;
+	extra_stack.ss_size = SIG_STACK_SIZE;
+#endif
+
+#if !EMULATED_PPC
+	// Install SIGSEGV and SIGBUS handlers
+	sigemptyset(&sigsegv_action.sa_mask);	// Block interrupts during SEGV handling
+	sigaddset(&sigsegv_action.sa_mask, SIGUSR2);
+	sigsegv_action.sa_sigaction = sigsegv_handler;
+	sigsegv_action.sa_flags = SA_ONSTACK | SA_SIGINFO;
+#ifdef HAVE_SIGNAL_SA_RESTORER
+	sigsegv_action.sa_restorer = NULL;
+#endif
+	if (sigaction(SIGSEGV, &sigsegv_action, NULL) < 0) {
+		sprintf(str, GetString(STR_SIG_INSTALL_ERR), "SIGSEGV", strerror(errno));
+		ErrorAlert(str);
+		goto quit;
+	}
+	if (sigaction(SIGBUS, &sigsegv_action, NULL) < 0) {
+		sprintf(str, GetString(STR_SIG_INSTALL_ERR), "SIGBUS", strerror(errno));
+		ErrorAlert(str);
+		goto quit;
+	}
+#else
+	// Install SIGSEGV handler for CPU emulator
+	if (!sigsegv_install_handler(sigsegv_handler)) {
+		sprintf(str, GetString(STR_SIG_INSTALL_ERR), "SIGSEGV", strerror(errno));
+		ErrorAlert(str);
+		goto quit;
+	}
+#endif
+
+	// Initialize VM system
+	vm_init();
+
+	// Get system info
 	PVR = 0x00040000;			// Default: 604
 	CPUClockSpeed = 100000000;	// Default: 100MHz
 	BusClockSpeed = 100000000;	// Default: 100MHz
 	TimebaseSpeed =  25000000;	// Default:  25MHz
-
 #if EMULATED_PPC
 	PVR = 0x000c0000;			// Default: 7400 (with AltiVec)
 #elif defined(__APPLE__) && defined(__MACH__)
@@ -431,7 +630,6 @@
 		}
 		fclose(proc_file);
 	} else {
-		char str[256];
 		sprintf(str, GetString(STR_PROC_CPUINFO_WARN), strerror(errno));
 		WarningAlert(str);
 	}
@@ -486,7 +684,6 @@
 			{ 0xffff0000, 0x00350000, "Power4" },
 			{ 0xffff0000, 0x00390000, "PPC970" },
 			{ 0xffff0000, 0x003c0000, "PPC970FX" },
-			{ 0xffff0000, 0x00440000, "PPC970MP" },
 			{ 0xffff0000, 0x003a0000, "POWER5 (gr)" },
 			{ 0xffff0000, 0x003b0000, "POWER5+ (gs)" },
 			{ 0xffff0000, 0x003e0000, "POWER6" },
@@ -529,7 +726,6 @@
 		}
 		fclose(proc_file);
 	} else {
-		char str[256];
 		sprintf(str, GetString(STR_PROC_CPUINFO_WARN), strerror(errno));
 		WarningAlert(str);
 	}
@@ -564,7 +760,6 @@
 		closedir(cpus_dir);
 	}
 #endif
-
 	// Remap any newer G4/G5 processor to plain G4 for compatibility
 	switch (PVR >> 16) {
 	case 0x8000:				// 7450
@@ -574,294 +769,18 @@
 	case 0x8004:				// 7448
 	case 0x0039:				//  970
 	case 0x003c:				//  970FX
-	case 0x0044:				//  970MP
 		PVR = 0x000c0000;		// 7400
 		break;
 	}
 	D(bug("PVR: %08x (assumed)\n", PVR));
-}
 
-static bool load_mac_rom(void)
-{
-	uint32 rom_size, actual;
-	uint8 *rom_tmp;
-	const char *rom_path = PrefsFindString("rom");
-	int rom_fd = open(rom_path && *rom_path ? rom_path : ROM_FILE_NAME, O_RDONLY);
-	if (rom_fd < 0) {
-		rom_fd = open(ROM_FILE_NAME2, O_RDONLY);
-		if (rom_fd < 0) {
-			ErrorAlert(GetString(STR_NO_ROM_FILE_ERR));
-			return false;
-		}
-	}
-	printf("%s", GetString(STR_READING_ROM_FILE));
-	rom_size = lseek(rom_fd, 0, SEEK_END);
-	lseek(rom_fd, 0, SEEK_SET);
-	rom_tmp = new uint8[ROM_SIZE];
-	actual = read(rom_fd, (void *)rom_tmp, ROM_SIZE);
-	close(rom_fd);
-
-	// Decode Mac ROM
-	if (!DecodeROM(rom_tmp, actual)) {
-		if (rom_size != 4*1024*1024) {
-			ErrorAlert(GetString(STR_ROM_SIZE_ERR));
-			return false;
-		} else {
-			ErrorAlert(GetString(STR_ROM_FILE_READ_ERR));
-			return false;
-		}
-	}
-	/*delete[] rom_tmp;*/
-	return true;
-}
-
-static bool install_signal_handlers(void)
-{
-	char str[256];
-#if !EMULATED_PPC
-	// Create and install stacks for signal handlers
-	sig_stack.ss_sp = malloc(SIG_STACK_SIZE);
-	D(bug("Signal stack at %p\n", sig_stack.ss_sp));
-	if (sig_stack.ss_sp == NULL) {
-		ErrorAlert(GetString(STR_NOT_ENOUGH_MEMORY_ERR));
-		return false;
-	}
-	sig_stack.ss_flags = 0;
-	sig_stack.ss_size = SIG_STACK_SIZE;
-	if (sigaltstack(&sig_stack, NULL) < 0) {
-		sprintf(str, GetString(STR_SIGALTSTACK_ERR), strerror(errno));
-		ErrorAlert(str);
-		return false;
-	}
-	extra_stack.ss_sp = malloc(SIG_STACK_SIZE);
-	D(bug("Extra stack at %p\n", extra_stack.ss_sp));
-	if (extra_stack.ss_sp == NULL) {
-		ErrorAlert(GetString(STR_NOT_ENOUGH_MEMORY_ERR));
-		return false;
-	}
-	extra_stack.ss_flags = 0;
-	extra_stack.ss_size = SIG_STACK_SIZE;
-
-	// Install SIGSEGV and SIGBUS handlers
-	sigemptyset(&sigsegv_action.sa_mask);	// Block interrupts during SEGV handling
-	sigaddset(&sigsegv_action.sa_mask, SIGUSR2);
-	sigsegv_action.sa_sigaction = sigsegv_handler;
-	sigsegv_action.sa_flags = SA_ONSTACK | SA_SIGINFO;
-#ifdef HAVE_SIGNAL_SA_RESTORER
-	sigsegv_action.sa_restorer = NULL;
-#endif
-	if (sigaction(SIGSEGV, &sigsegv_action, NULL) < 0) {
-		sprintf(str, GetString(STR_SIG_INSTALL_ERR), "SIGSEGV", strerror(errno));
-		ErrorAlert(str);
-		return false;
-	}
-	if (sigaction(SIGBUS, &sigsegv_action, NULL) < 0) {
-		sprintf(str, GetString(STR_SIG_INSTALL_ERR), "SIGBUS", strerror(errno));
-		ErrorAlert(str);
-		return false;
-	}
-#else
-	// Install SIGSEGV handler for CPU emulator
-	if (!sigsegv_install_handler(sigsegv_handler)) {
-		sprintf(str, GetString(STR_SIG_INSTALL_ERR), "SIGSEGV", strerror(errno));
-		ErrorAlert(str);
-		return false;
-	}
-#endif
-	return true;
-}
-
-#ifdef USE_SDL
-static bool init_sdl()
-{
-	int sdl_flags = 0;
-#ifdef USE_SDL_VIDEO
-	sdl_flags |= SDL_INIT_VIDEO;
-#endif
-#ifdef USE_SDL_AUDIO
-	sdl_flags |= SDL_INIT_AUDIO;
-#endif
-	/*assert(sdl_flags != 0);*/
-
-#ifdef USE_SDL_VIDEO
-	// Don't let SDL block the screensaver
-	setenv("SDL_VIDEO_ALLOW_SCREENSAVER", "1", true);
-
-	// Make SDL pass through command-clicks and option-clicks unaltered
-	setenv("SDL_HAS3BUTTONMOUSE", "1", true);
-#endif
-
-	if (SDL_Init(sdl_flags) == -1) {
-		char str[256];
-		sprintf(str, "Could not initialize SDL: %s.\n", SDL_GetError());
-		ErrorAlert(str);
-		return false;
-	}
-	atexit(SDL_Quit);
-
-	// Don't let SDL catch SIGINT and SIGTERM signals
-	signal(SIGINT, SIG_DFL);
-	signal(SIGTERM, SIG_DFL);
-	return true;
-}
-#endif
-
-int main(int argc, char **argv)
-{
-	char str[256];
-	bool memory_mapped_from_zero, ram_rom_areas_contiguous;
-	const char *vmdir = NULL;
-
-	// Initialize variables
-	RAMBase = 0;
-	tzset();
-
-	// Print some info
-	printf(GetString(STR_ABOUT_TEXT1), VERSION_MAJOR, VERSION_MINOR);
-	printf(" %s\n", GetString(STR_ABOUT_TEXT2));
-
-#if !EMULATED_PPC
-#ifdef SYSTEM_CLOBBERS_R2
-	// Get TOC pointer
-	TOC = get_r2();
-#endif
-#ifdef SYSTEM_CLOBBERS_R13
-	// Get r13 register
-	R13 = get_r13();
-#endif
-#endif
-
-	// Parse command line arguments
-	
-/*#if defined(__APPLE__) && defined(__MACH__)*/
-	// Mac OS X likes to pass in various options of its own, when launching an app.
-	// Attempt to ignore these.
-	for (int i=1; i<argc; i++) {
-		const char * mac_psn_prefix = "-psn_";
-		if (strcmp(argv[i], "-NSDocumentRevisionsDebugMode") == 0) {
-			argv[i] = NULL;
-		} else if (strncmp(mac_psn_prefix, argv[i], strlen(mac_psn_prefix)) == 0) {
-			argv[i] = NULL;
-		}
-	}
-/*#endif*/
-	
-	for (int i=1; i<argc; i++) {
-		if (argv[i] == NULL) {
-			continue;
-		}
-		
-		if (strcmp(argv[i], "--help") == 0) {
-			usage(argv[0]);
-#ifndef USE_SDL_VIDEO
-		} else if (strcmp(argv[i], "--display") == 0) {
-			i++;
-			if (i < argc)
-				x_display_name = strdup(argv[i]);
-#endif
-		} else if (strcmp(argv[i], "--gui-connection") == 0) {
-			argv[i++] = NULL;
-			if (i < argc) {
-				gui_connection_path = argv[i];
-				argv[i] = NULL;
-			}
-		} else if (valid_vmdir(argv[i])) {
-			vmdir = argv[i];
-			argv[i] = NULL;
-			printf("Using %s as vmdir.\n", vmdir);
-			if (chdir(vmdir)) {
-				printf("Failed to chdir to %s. Good bye.", vmdir);
-				exit(1);
-			}
-			break;
-		}
-	}
-
-	// Remove processed arguments
-	for (int i=1; i<argc; i++) {
-		int k;
-		for (k=i; k<argc; k++)
-			if (argv[k] != NULL)
-				break;
-		if (k > i) {
-			k -= i;
-			for (int j=i+k; j<argc; j++)
-				argv[j-k] = argv[j];
-			argc -= k;
-		}
-	}
-
-	// Connect to the external GUI
-	if (gui_connection_path) {
-		if ((gui_connection = rpc_init_client(gui_connection_path)) == NULL) {
-			fprintf(stderr, "Failed to initialize RPC client connection to the GUI\n");
-			return 1;
-		}
-	}
-
-#ifdef ENABLE_GTK
-	if (!gui_connection) {
-		// Init GTK
-		gtk_set_locale();
-		gtk_init(&argc, &argv);
-	}
-#endif
-
-	// Read preferences
-	PrefsInit(vmdir, argc, argv);
-
-	// Any command line arguments left?
-	for (int i=1; i<argc; i++) {
-		if (argv[i][0] == '-') {
-			fprintf(stderr, "Unrecognized option '%s'\n", argv[i]);
-			usage(argv[0]);
-		}
-	}
-
-#ifdef USE_SDL
-	// Initialize SDL system
-	if (!init_sdl())
-		goto quit;
-#endif
-
-#ifndef USE_SDL_VIDEO
-	// Open display
-	x_display = XOpenDisplay(x_display_name);
-	if (x_display == NULL) {
-		char str[256];
-		sprintf(str, GetString(STR_NO_XSERVER_ERR), XDisplayName(x_display_name));
-		ErrorAlert(str);
-		goto quit;
-	}
-
-#if defined(ENABLE_XF86_DGA) && !defined(ENABLE_MON)
-	// Fork out, so we can return from fullscreen mode when things get ugly
-	XF86DGAForkApp(DefaultScreen(x_display));
-#endif
-#endif
-
-#ifdef ENABLE_MON
-	// Initialize mon
-	mon_init();
-#endif
-
-  // Install signal handlers
-	if (!install_signal_handlers())
-		goto quit;
-
-	// Initialize VM system
-	vm_init();
-
-	// Get system info
-	get_system_info();
-
 	// Init system routines
 	SysInit();
 
 	// Show preferences editor
-/*	if (!PrefsFindBool("nogui"))
+	if (!PrefsFindBool("nogui"))
 		if (!PrefsEditor())
-			goto quit; */
+			goto quit;
 
 #if !EMULATED_PPC
 	// Check some things
@@ -876,17 +795,15 @@
 		goto quit;
 	}
 
-/*#if !defined(__APPLE__) || !defined(__x86_64__)
 	// Create areas for Kernel Data
 	if (!kernel_data_init())
 		goto quit;
-#endif*/
 	kernel_data = (KernelData *)Mac2HostAddr(KERNEL_DATA_BASE);
 	emulator_data = &kernel_data->ed;
 	KernelDataAddr = KERNEL_DATA_BASE;
 	D(bug("Kernel Data at %p (%08x)\n", kernel_data, KERNEL_DATA_BASE));
 	D(bug("Emulator Data at %p (%08x)\n", emulator_data, KERNEL_DATA_BASE + offsetof(KernelData, ed)));
-#if 0
+
 	// Create area for DR Cache
 	if (vm_mac_acquire_fixed(DR_EMULATOR_BASE, DR_EMULATOR_SIZE) < 0) {
 		sprintf(str, GetString(STR_DR_EMULATOR_MMAP_ERR), strerror(errno));
@@ -909,7 +826,14 @@
 #endif
 	DRCacheAddr = DR_CACHE_BASE;
 	D(bug("DR Cache at %p\n", DRCacheAddr));
-#endif
+
+	// Create area for SheepShaver data
+	if (!SheepMem::Init()) {
+		sprintf(str, GetString(STR_SHEEP_MEM_MMAP_ERR), strerror(errno));
+		ErrorAlert(str);
+		goto quit;
+	}
+	
 	// Create area for Mac RAM
 	RAMSize = PrefsFindInt32("ramsize");
 	if (RAMSize < 8*1024*1024) {
@@ -917,7 +841,7 @@
 		RAMSize = 8*1024*1024;
 	}
 	memory_mapped_from_zero = false;
-	/*ram_rom_areas_contiguous = false;
+	ram_rom_areas_contiguous = false;
 #if REAL_ADDRESSING && HAVE_LINKER_SCRIPT
 	if (vm_mac_acquire_fixed(0, RAMSize) == 0) {
 		D(bug("Could allocate RAM from 0x0000\n"));
@@ -936,35 +860,20 @@
 		}
 		lm_area_mapped = true;
 #endif
-#if REAL_ADDRESSING*/
+#if REAL_ADDRESSING
 		// Allocate RAM at any address. Since ROM must be higher than RAM, allocate the RAM
 		// and ROM areas contiguously, plus a little extra to allow for ROM address alignment.
-		RAMBaseHost = vm_mac_acquire(RAMSize + ROM_AREA_SIZE + ROM_ALIGNMENT + SIG_STACK_SIZE);
+		RAMBaseHost = vm_mac_acquire(RAMSize + ROM_AREA_SIZE + ROM_ALIGNMENT);
 		if (RAMBaseHost == VM_MAP_FAILED) {
 			sprintf(str, GetString(STR_RAM_ROM_MMAP_ERR), strerror(errno));
 			ErrorAlert(str);
 			goto quit;
 		}
-		vm_ini((uint8 *)RAMBaseHost);
 		RAMBase = Host2MacAddr(RAMBaseHost);
-		while (RAMBase != 0) {
-			/* wait if it isn't initialized*/
-			int i = 0;
-			sleep(1);
-			RAMBase = Host2MacAddr(RAMBaseHost);
-			i ++;
-			if (i > 10) {
-				fprintf(stderr, "RAM isn't allocated right, so it'll probably crash.\nRAMBase=%d should be RAMBase=0", (int)RAMBase);
-				break;
-			}
-		}
-		ROMBase = (RAMBase + RAMSize + ROM_ALIGNMENT -1) & ~(ROM_ALIGNMENT-1);
+		ROMBase = (RAMBase + RAMSize + ROM_ALIGNMENT -1) & -ROM_ALIGNMENT;
 		ROMBaseHost = Mac2HostAddr(ROMBase);
-		ROMEnd = RAMSize + ROM_AREA_SIZE + ROM_ALIGNMENT + SIG_STACK_SIZE;
-		setSize(ROMEnd);
-		
 		ram_rom_areas_contiguous = true;
-/*#else
+#else
 		if (vm_mac_acquire_fixed(RAM_BASE, RAMSize) < 0) {
 			sprintf(str, GetString(STR_RAM_MMAP_ERR), strerror(errno));
 			ErrorAlert(str);
@@ -973,7 +882,7 @@
 		RAMBase = RAM_BASE;
 		RAMBaseHost = Mac2HostAddr(RAMBase);
 #endif
-	}*/
+	}
 #if !EMULATED_PPC
 	if (vm_protect(RAMBaseHost, RAMSize, VM_PAGE_READ | VM_PAGE_WRITE | VM_PAGE_EXECUTE) < 0) {
 		sprintf(str, GetString(STR_RAM_MMAP_ERR), strerror(errno));
@@ -989,15 +898,8 @@
 		goto quit;
 	}
 	
-	// Create area for SheepShaver data
-	if (!SheepMem::Init()) {
-		sprintf(str, GetString(STR_SHEEP_MEM_MMAP_ERR), strerror(errno));
-		ErrorAlert(str);
-		goto quit;
-	}
-	
 	// Create area for Mac ROM
-	/*if (!ram_rom_areas_contiguous) {
+	if (!ram_rom_areas_contiguous) {
 		if (vm_mac_acquire_fixed(ROM_BASE, ROM_AREA_SIZE) < 0) {
 			sprintf(str, GetString(STR_ROM_MMAP_ERR), strerror(errno));
 			ErrorAlert(str);
@@ -1005,7 +907,7 @@
 		}
 		ROMBase = ROM_BASE;
 		ROMBaseHost = Mac2HostAddr(ROMBase);
-	}*/
+	}
 #if !EMULATED_PPC
 	if (vm_protect(ROMBaseHost, ROM_AREA_SIZE, VM_PAGE_READ | VM_PAGE_WRITE | VM_PAGE_EXECUTE) < 0) {
 		sprintf(str, GetString(STR_ROM_MMAP_ERR), strerror(errno));
@@ -1016,14 +918,39 @@
 	rom_area_mapped = true;
 	D(bug("ROM area at %p (%08x)\n", ROMBaseHost, ROMBase));
 
-	/*if (RAMBase > ROMBase) {
+	if (RAMBase > ROMBase) {
 		ErrorAlert(GetString(STR_RAM_HIGHER_THAN_ROM_ERR));
 		goto quit;
-	}*/
+	}
 
 	// Load Mac ROM
-	if (!load_mac_rom())
-		goto quit;
+	rom_path = PrefsFindString("rom");
+	rom_fd = open(rom_path && *rom_path ? rom_path : ROM_FILE_NAME, O_RDONLY);
+	if (rom_fd < 0) {
+		rom_fd = open(ROM_FILE_NAME2, O_RDONLY);
+		if (rom_fd < 0) {
+			ErrorAlert(GetString(STR_NO_ROM_FILE_ERR));
+			goto quit;
+		}
+	}
+	printf("%s", GetString(STR_READING_ROM_FILE));
+	rom_size = lseek(rom_fd, 0, SEEK_END);
+	lseek(rom_fd, 0, SEEK_SET);
+	rom_tmp = new uint8[ROM_SIZE];
+	actual = read(rom_fd, (void *)rom_tmp, ROM_SIZE);
+	close(rom_fd);
+	
+	// Decode Mac ROM
+	if (!DecodeROM(rom_tmp, actual)) {
+		if (rom_size != 4*1024*1024) {
+			ErrorAlert(GetString(STR_ROM_SIZE_ERR));
+			goto quit;
+		} else {
+			ErrorAlert(GetString(STR_ROM_FILE_READ_ERR));
+			goto quit;
+		}
+	}
+	delete[] rom_tmp;
 
 	// Initialize everything
 	if (!InitAll(vmdir))
@@ -1034,7 +961,7 @@
 #if !EMULATED_PPC
 	flush_icache_range(ROMBase, ROMBase + ROM_AREA_SIZE);
 #endif
-	/*vm_protect(ROMBaseHost, ROM_AREA_SIZE, VM_PAGE_READ | VM_PAGE_EXECUTE);*/
+	vm_protect(ROMBaseHost, ROM_AREA_SIZE, VM_PAGE_READ | VM_PAGE_EXECUTE);
 
 	// Start 60Hz thread
 	tick_thread_cancel = false;
@@ -1350,11 +1277,11 @@
 {
 	if ((start >= ROMBase) && (start < (ROMBase + ROM_SIZE)))
 		return;
-/*#if EMULATED_PPC
+#if EMULATED_PPC
 	FlushCodeCache(start, start + length);
 #else
 	flush_icache_range(start, start + length);
-#endif*/
+#endif
 }
 
 
@@ -1440,7 +1367,7 @@
 #ifdef ENABLE_MON
 			// Start up mon in real-mode
 			printf("Welcome to the sheep factory.\n");
-			const char *arg[4] = {"mon", "-m", "-r", NULL};
+			char *arg[4] = {"mon", "-m", "-r", NULL};
 			mon(3, arg);
 #endif
 			return NULL;
@@ -1480,7 +1407,7 @@
 		pthread_attr_setinheritsched(attr, PTHREAD_EXPLICIT_SCHED);
 		pthread_attr_setschedpolicy(attr, SCHED_FIFO);
 		struct sched_param fifo_param;
-		fifo_param.sched_priority = ((sched_get_priority_min(SCHED_FIFO) +
+		fifo_param.sched_priority = ((sched_get_priority_min(SCHED_FIFO) + 
 					      sched_get_priority_max(SCHED_FIFO)) / 2 +
 					     priority);
 		pthread_attr_setschedparam(attr, &fifo_param);
@@ -1506,7 +1433,7 @@
 #ifdef HAVE_PTHREADS
 
 struct B2_mutex {
-	B2_mutex() {
+	B2_mutex() { 
 	    pthread_mutexattr_t attr;
 	    pthread_mutexattr_init(&attr);
 	    // Initialize the mutex for priority inheritance --
@@ -1523,7 +1450,7 @@
 	    pthread_mutex_init(&m, &attr);
 	    pthread_mutexattr_destroy(&attr);
 	}
-	~B2_mutex() {
+	~B2_mutex() { 
 	    pthread_mutex_trylock(&m); // Make sure it's locked before
 	    pthread_mutex_unlock(&m);  // unlocking it.
 	    pthread_mutex_destroy(&m);
@@ -1601,12 +1528,12 @@
 
 void SetInterruptFlag(uint32 flag)
 {
-	*(uint32 *)&InterruptFlags |= flag;
+	atomic_or((int *)&InterruptFlags, flag);
 }
 
 void ClearInterruptFlag(uint32 flag)
 {
-	*(uint32 *)&InterruptFlags &= ~flag;
+	atomic_and((int *)&InterruptFlags, ~flag);
 }
 
 
@@ -1672,8 +1599,8 @@
 	switch (ReadMacInt32(XLM_RUN_MODE)) {
 		case MODE_68K:
 			// 68k emulator active, trigger 68k interrupt level 1
-			WriteMacInt16(ReadMacInt32(0x67c), 1);
-			r->cr() |= ReadMacInt32(0x674);
+			WriteMacInt16(ntohl(kernel_data->v[0x67c >> 2]), 1);
+			r->cr() |= ntohl(kernel_data->v[0x674 >> 2]);
 			break;
 
 #if INTERRUPTS_IN_NATIVE_MODE
@@ -1683,10 +1610,10 @@
 
 				// Set extra stack for SIGSEGV handler
 				sigaltstack(&extra_stack, NULL);
-
+				
 				// Prepare for 68k interrupt level 1
-				WriteMacInt16(ReadMacInt32(0x67c), 1);
-				WriteMacInt32(ReadMacInt32(0x658) + 0xdc, ReadMacInt32(ReadMacInt32(0x658) + 0xdc) | ReadMacInt32(0x674));
+				WriteMacInt16(ntohl(kernel_data->v[0x67c >> 2]), 1);
+				WriteMacInt32(ntohl(kernel_data->v[0x658 >> 2]) + 0xdc, ReadMacInt32(ntohl(kernel_data->v[0x658 >> 2]) + 0xdc) | ntohl(kernel_data->v[0x674 >> 2]));
 
 				// Execute nanokernel interrupt routine (this will activate the 68k emulator)
 				DisableInterrupt();
@@ -1746,15 +1673,7 @@
 /*
  *  SIGSEGV handler
  */
-#if EMULATED_PPC
-sigsegv_return_t sigsegv_handler(sigsegv_info_t * dummy)
-{
-	/*dummy function
-	fprintf(stderr, "sigsegv");
-	fprintf(stderr, "sigsegv at %d\n", addr, num_same);*/
-	return SIGSEGV_RETURN_SKIP_INSTRUCTION;
-}
-#endif
+
 #if !EMULATED_PPC
 static void sigsegv_handler(int sig, siginfo_t *sip, void *scp)
 {
@@ -1762,7 +1681,7 @@
 
 	// Get effective address
 	uint32 addr = r->dar();
-
+	
 #ifdef SYSTEM_CLOBBERS_R2
 	// Restore pointer to Thread Local Storage
 	set_r2(TOC);
@@ -1784,6 +1703,8 @@
 		return;
 #endif
 
+	num_segv++;
+
 	// Fault in Mac ROM or RAM or DR Cache?
 	bool mac_fault = (r->pc() >= ROMBase) && (r->pc() < (ROMBase + ROM_AREA_SIZE)) || (r->pc() >= RAMBase) && (r->pc() < (RAMBase + RAMSize)) || (r->pc() >= DR_CACHE_BASE && r->pc() < (DR_CACHE_BASE + DR_CACHE_SIZE));
 	if (mac_fault) {
@@ -1793,19 +1714,19 @@
 			r->pc() += 4;
 			r->gpr(8) = 0;
 			return;
-
+	
 		// MacOS 8.5 installation
 		} else if (r->pc() == ROMBase + 0x488140 && r->gpr(16) == 0xf8000000) {
 			r->pc() += 4;
 			r->gpr(8) = 0;
 			return;
-
+	
 		// MacOS 8 serial drivers on startup
 		} else if (r->pc() == ROMBase + 0x48e080 && (r->gpr(8) == 0xf3012002 || r->gpr(8) == 0xf3012000)) {
 			r->pc() += 4;
 			r->gpr(8) = 0;
 			return;
-
+	
 		// MacOS 8.1 serial drivers on startup
 		} else if (r->pc() == ROMBase + 0x48c5e0 && (r->gpr(20) == 0xf3012002 || r->gpr(20) == 0xf3012000)) {
 			r->pc() += 4;
@@ -1813,7 +1734,7 @@
 		} else if (r->pc() == ROMBase + 0x4a10a0 && (r->gpr(20) == 0xf3012002 || r->gpr(20) == 0xf3012000)) {
 			r->pc() += 4;
 			return;
-
+	
 		// MacOS 8.6 serial drivers on startup (with DR Cache and OldWorld ROM)
 		} else if ((r->pc() - DR_CACHE_BASE) < DR_CACHE_SIZE && (r->gpr(16) == 0xf3012002 || r->gpr(16) == 0xf3012000)) {
 			r->pc() += 4;
@@ -1884,7 +1805,7 @@
 						transfer_type = TYPE_STORE; transfer_size = SIZE_HALFWORD; addr_mode = MODE_UX; break;
 				}
 				break;
-
+	
 			case 32:	// lwz
 				transfer_type = TYPE_LOAD; transfer_size = SIZE_WORD; addr_mode = MODE_NORM; break;
 			case 33:	// lwzu
@@ -1913,7 +1834,7 @@
 				transfer_type = TYPE_STORE; transfer_size = SIZE_HALFWORD; addr_mode = MODE_NORM; break;
 			case 45:	// sthu
 				transfer_type = TYPE_STORE; transfer_size = SIZE_HALFWORD; addr_mode = MODE_U; break;
-/*#if EMULATE_UNALIGNED_LOADSTORE_MULTIPLE*/
+#if EMULATE_UNALIGNED_LOADSTORE_MULTIPLE
 			case 46:	// lmw
 				if ((addr % 4) != 0) {
 					uint32 ea = addr;
@@ -1938,14 +1859,13 @@
 					goto rti;
 				}
 				break;
-/*#endif*/
+#endif
 		}
-
+	
 		// Ignore ROM writes (including to the zero page, which is read-only)
 		if (transfer_type == TYPE_STORE &&
 			((addr >= ROMBase && addr < ROMBase + ROM_SIZE) ||
 			 (addr >= SheepMem::ZeroPage() && addr < SheepMem::ZeroPage() + SheepMem::PageSize()))) {
-			/*blech: we already do this*/
 //			D(bug("WARNING: %s write access to ROM at %08lx, pc %08lx\n", transfer_size == SIZE_BYTE ? "Byte" : transfer_size == SIZE_HALFWORD ? "Halfword" : "Word", addr, r->pc()));
 			if (addr_mode == MODE_U || addr_mode == MODE_UX)
 				r->gpr(ra) = addr;
@@ -2199,23 +2119,25 @@
 bool SheepMem::Init(void)
 {
 	// Size of a native page
-	/*page_size = getpagesize();*/
+	page_size = getpagesize();
 
 	// Allocate SheepShaver globals
-	uint8 *adr = vm_mac_acquire(size);
-	init_sheep_mem(adr);
-	if (adr == VM_MAP_FAILED)
+	proc = base;
+	if (vm_mac_acquire_fixed(base, size) < 0)
 		return false;
-	proc = base = Host2MacAddr(adr);
+
 	// Allocate page with all bits set to 0, right in the middle
 	// This is also used to catch undesired overlaps between proc and data areas
-	/*zero_page = proc + (size / 2);
+	zero_page = proc + (size / 2);
 	Mac_memset(zero_page, 0, page_size);
 	if (vm_protect(Mac2HostAddr(zero_page), page_size, VM_PAGE_READ) < 0)
-		return false;*/
+		return false;
 
 #if EMULATED_PPC
-	sig_stack = ROMEnd;
+	// Allocate alternate stack for PowerPC interrupt routine
+	sig_stack = base + size;
+	if (vm_mac_acquire_fixed(sig_stack, SIG_STACK_SIZE) < 0)
+		return false;
 #endif
 
 	data = base + size;
Only in macemu/: SheepShaver/src/Unix/mkinstalldirs
--- macemu/SheepShaver/src/Unix/paranoia.cpp
+++ sheepshaver/SheepShaver/src/Unix/paranoia.cpp
@@ -32,7 +32,7 @@
 #include <sys/types.h>
 #include <sys/ucontext.h>
 
-#include "../CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "sigregs.h"
 #include "main.h"
 #include "user_strings.h"
--- macemu/SheepShaver/src/Unix/posix_sem.cpp
+++ sheepshaver/SheepShaver/src/Unix/posix_sem.cpp
@@ -41,14 +41,14 @@
 		errno = EINVAL;
 		return -1;
 	}
-	if(pshared) {
+	if(pshared) {	
 		errno = ENOSYS;
 		return -1;
 	}
 	pthread_mutex_init(&sem->sem_lock, NULL);
 	sem->sem_value = value;
 	sem->sem_waiting = 0;
-	return 0;
+	return 0;	
 }
 
 
@@ -102,7 +102,7 @@
 	}
 	while(!sem->sem_value) nanosleep(NULL, &req);
 	pthread_mutex_unlock(&sem->sem_lock);
-	return 0;
+	return 0;	
 }
 
 int sem_trywait(sem_t* sem)
--- macemu/SheepShaver/src/Unix/ppc_asm.S
+++ sheepshaver/SheepShaver/src/Unix/ppc_asm.S
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "../CrossPlatform/ppc_asm.tmpl"
+#include <ppc_asm.tmpl>
 #include <xlowmem.h>
 
 #define SAVE_FP_EXEC_68K 1
--- macemu/SheepShaver/src/Unix/prefs_editor_gtk.cpp
+++ sheepshaver/SheepShaver/src/Unix/prefs_editor_gtk.cpp
@@ -201,14 +201,14 @@
 	label = gtk_label_new(GetString(label_id));
 	gtk_widget_show(label);
 	gtk_table_attach(GTK_TABLE(table), label, 0, 1, row, row + 1, (GtkAttachOptions)0, (GtkAttachOptions)0, 4, 4);
-
+	
 	combo = gtk_combo_new();
 	gtk_widget_show(combo);
 	gtk_combo_set_popdown_strings(GTK_COMBO(combo), glist);
 
 	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), default_value);
 	gtk_table_attach(GTK_TABLE(table), combo, 1, 2, row, row + 1, (GtkAttachOptions)(GTK_FILL | GTK_EXPAND), (GtkAttachOptions)0, 4, 4);
-
+	
 	return combo;
 }
 
@@ -240,7 +240,7 @@
 	gtk_table_attach(GTK_TABLE(table), box, 1, 2, row, row + 1, (GtkAttachOptions)(GTK_FILL | GTK_EXPAND), (GtkAttachOptions)0, 4, 4);
 
 	entry = gtk_entry_new();
-	gtk_entry_set_text(GTK_ENTRY(entry), str);
+	gtk_entry_set_text(GTK_ENTRY(entry), str); 
 	gtk_widget_show(entry);
 	gtk_box_pack_start(GTK_BOX(box), entry, TRUE, TRUE, 0);
 
@@ -294,7 +294,7 @@
 	const char *str = PrefsFindString(prefs_item);
 	if (str == NULL)
 		str = "";
-	gtk_entry_set_text(GTK_ENTRY(entry), str);
+	gtk_entry_set_text(GTK_ENTRY(entry), str); 
 	gtk_box_pack_start(GTK_BOX(box), entry, TRUE, TRUE, 0);
 	return entry;
 }
@@ -685,7 +685,7 @@
 {
 	GtkWidget *box, *table, *label, *menu;
 	char str[32];
-
+	
 	box = make_pane(top, STR_JIT_PANE_TITLE);
 
 	if (is_jit_capable()) {
@@ -947,7 +947,7 @@
 		sprintf(str, "%d", dis_width);
 	else
 		strcpy(str, GetString(STR_SIZE_MAX_LAB));
-	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str);
+	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str); 
 	gtk_table_attach(GTK_TABLE(table), combo, 1, 2, 2, 3, (GtkAttachOptions)GTK_FILL, (GtkAttachOptions)0, 4, 4);
 	w_display_x = GTK_COMBO(combo)->entry;
 
@@ -968,7 +968,7 @@
 		sprintf(str, "%d", dis_height);
 	else
 		strcpy(str, GetString(STR_SIZE_MAX_LAB));
-	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str);
+	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str); 
 	gtk_table_attach(GTK_TABLE(table), combo, 1, 2, 3, 4, (GtkAttachOptions)GTK_FILL, (GtkAttachOptions)0, 4, 4);
 	w_display_y = GTK_COMBO(combo)->entry;
 
@@ -1047,7 +1047,7 @@
 		str = "";
 
 	w_keycode_file = gtk_entry_new();
-	gtk_entry_set_text(GTK_ENTRY(w_keycode_file), str);
+	gtk_entry_set_text(GTK_ENTRY(w_keycode_file), str); 
 	gtk_widget_show(w_keycode_file);
 	gtk_box_pack_start(GTK_BOX(hbox), w_keycode_file, TRUE, TRUE, 0);
 
@@ -1181,10 +1181,6 @@
 		}
 		close(s);
 	}
-#ifdef HAVE_SLIRP
-	static char s_slirp[] = "slirp";
-	glist = g_list_append(glist, s_slirp);
-#endif
 	if (glist)
 		g_list_sort(glist, gl_str_cmp);
 	else
@@ -1211,7 +1207,7 @@
 	const char *str = PrefsFindString("seriala");
 	if (str == NULL)
 		str = "";
-	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str);
+	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str); 
 	gtk_table_attach(GTK_TABLE(table), combo, 1, 2, 0, 1, (GtkAttachOptions)(GTK_FILL | GTK_EXPAND), (GtkAttachOptions)0, 4, 4);
 	w_seriala = GTK_COMBO(combo)->entry;
 
@@ -1225,7 +1221,7 @@
 	str = PrefsFindString("serialb");
 	if (str == NULL)
 		str = "";
-	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str);
+	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str); 
 	gtk_table_attach(GTK_TABLE(table), combo, 1, 2, 1, 2, (GtkAttachOptions)(GTK_FILL | GTK_EXPAND), (GtkAttachOptions)0, 4, 4);
 	w_serialb = GTK_COMBO(combo)->entry;
 
@@ -1240,7 +1236,7 @@
 	str = PrefsFindString("ether");
 	if (str == NULL)
 		str = "";
-	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str);
+	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str); 
 	gtk_table_attach(GTK_TABLE(table), combo, 1, 2, 2, 3, (GtkAttachOptions)(GTK_FILL | GTK_EXPAND), (GtkAttachOptions)0, 4, 4);
 	w_ether = GTK_COMBO(combo)->entry;
 }
@@ -1493,7 +1489,7 @@
 	gtk_init(&argc, &argv);
 
 	// Read preferences
-	PrefsInit(0, argc, argv);
+	PrefsInit(argc, argv);
 
 	// Show preferences editor
 	bool start = PrefsEditor();
--- macemu/SheepShaver/src/Unix/prefs_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/prefs_unix.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "../CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <string.h>
 #include <stdlib.h>
@@ -41,9 +41,6 @@
 	{"ignoresegv", TYPE_BOOLEAN, false,    "ignore illegal memory accesses"},
 #endif
 	{"idlewait", TYPE_BOOLEAN, false,      "sleep when idle"},
-#ifdef USE_SDL_VIDEO
-	{"sdlrender", TYPE_STRING, false,      "SDL_Renderer driver (\"auto\", \"software\" (may be faster), etc.)"},
-#endif
 	{NULL, TYPE_END, false, NULL} // End of list
 };
 
--- macemu/SheepShaver/src/Unix/rpc_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/rpc_unix.cpp
@@ -29,7 +29,7 @@
  *  - windows rpc
  */
 
-#include "../CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <errno.h>
 #include <fcntl.h>
@@ -64,6 +64,8 @@
 #define pthread_cancel(th)
 #define pthread_join(th, ret)
 #define pthread_testcancel()
+#define pthread_create(th, attr, start, arg) dummy_thread_create()
+static inline int dummy_thread_create(void) { errno = ENOSYS; return -1; }
 
 #undef  pthread_mutex_t
 #define pthread_mutex_t volatile int
@@ -194,14 +196,12 @@
 
   if (bind(connection->server_socket, (struct sockaddr *)&addr, addr_len) < 0) {
 	perror("server bind");
-	close(connection->socket);
 	free(connection);
 	return NULL;
   }
 
   if (listen(connection->server_socket, 1) < 0) {
 	perror("server listen");
-	close(connection->socket);
 	free(connection);
 	return NULL;
   }
@@ -253,7 +253,6 @@
 	  break;
 	if (n_connect_attempts > 1 && errno != ECONNREFUSED && errno != ENOENT) {
 	  perror("client_connect");
-	  close(connection->socket);
 	  free(connection);
 	  return NULL;
 	}
@@ -261,7 +260,6 @@
 	usleep(N_CONNECT_WAIT_DELAY);
   }
   if (n_connect_attempts == 0) {
-	close(connection->socket);
 	free(connection);
 	return NULL;
   }
@@ -328,7 +326,6 @@
 	return _rpc_wait_dispatch(connection, timeout);
 }
 
-#ifdef USE_THREADS
 // Process incoming messages in the background
 static void *rpc_server_func(void *arg)
 {
@@ -355,7 +352,6 @@
   connection->server_thread_active = 0;
   return NULL;
 }
-#endif
 
 // Return listen socket of RPC connection
 int rpc_listen_socket(rpc_connection_t *connection)
@@ -431,9 +427,7 @@
   int last;
   int count;
 } g_message_descriptors = { NULL, 0, 0 };
-#ifdef USE_THREADS
 static pthread_mutex_t g_message_descriptors_lock = PTHREAD_MUTEX_INITIALIZER;
-#endif
 
 // Add a user-defined marshaler
 static int rpc_message_add_callback(const rpc_message_descriptor_t *desc)
@@ -786,15 +780,13 @@
   if ((error = _rpc_message_recv_bytes(message, (unsigned char *)&r_value, sizeof(r_value))) < 0)
 	return error;
   length = ntohl(r_value);
-  if (length == 0) {
+  if (length == 0)
 	str = NULL;
-  } else {
+  else {
 	if ((str = (char *)malloc(length + 1)) == NULL)
 	  return RPC_ERROR_NO_MEMORY;
-	if ((error = _rpc_message_recv_bytes(message, (unsigned char *)str, length)) < 0) {
-	  free(str);
+	if ((error = _rpc_message_recv_bytes(message, (unsigned char *)str, length)) < 0)
 	  return error;
-	}
 	str[length] = '\0';
   }
   *ret = str;
@@ -846,10 +838,8 @@
 		if ((array = (unsigned char *)malloc(array_size * sizeof(*array))) == NULL)
 		  return RPC_ERROR_NO_MEMORY;
 		error = _rpc_message_recv_bytes(message, array, array_size);
-		if (error != RPC_ERROR_NO_ERROR) {
-		  free(array);
+		if (error != RPC_ERROR_NO_ERROR)
 		  return error;
-		}
 		*((void **)p_value) = (void *)array;
 		break;
 	  }
@@ -860,10 +850,8 @@
 		  return RPC_ERROR_NO_MEMORY;
 		for (i = 0; i < array_size; i++) {
 		  int32_t value;
-		  if ((error = rpc_message_recv_int32(message, &value)) < 0) {
-		    free(array);
+		  if ((error = rpc_message_recv_int32(message, &value)) < 0)
 			return error;
-		  }
 		  array[i] = value;
 		}
 		*((void **)p_value) = (void *)array;
@@ -875,10 +863,8 @@
 		  return RPC_ERROR_NO_MEMORY;
 		for (i = 0; i < array_size; i++) {
 		  uint32_t value;
-		  if ((error = rpc_message_recv_uint32(message, &value)) < 0) {
-		    free(array);
+		  if ((error = rpc_message_recv_uint32(message, &value)) < 0)
 			return error;
-		  }
 		  array[i] = value;
 		}
 		*((void **)p_value) = (void *)array;
@@ -890,10 +876,8 @@
 		  return RPC_ERROR_NO_MEMORY;
 		for (i = 0; i < array_size; i++) {
 		  char *str;
-		  if ((error = rpc_message_recv_string(message, &str)) < 0) {
-		    free(array);
+		  if ((error = rpc_message_recv_string(message, &str)) < 0)
 			return error;
-		  }
 		  array[i] = str;
 		}
 		*((void **)p_value) = (void *)array;
@@ -905,10 +889,8 @@
 		  if ((array = (char *)malloc(array_size * desc->size)) == NULL)
 			return RPC_ERROR_NO_MEMORY;
 		  for (i = 0; i < array_size; i++) {
-			if ((error = desc->recv_callback(message, &array[i * desc->size])) < 0) {
-			  free(array);
+			if ((error = desc->recv_callback(message, &array[i * desc->size])) < 0)
 			  return error;
-			}
 		  }
 		  *((void **)p_value) = array;
 		}
@@ -978,7 +960,7 @@
   rpc_message_init(&message, connection);
 
   int32_t method, value, ret = RPC_MESSAGE_FAILURE;
-  if (rpc_message_recv_int32(&message, &value) != RPC_ERROR_NO_ERROR ||
+  if (rpc_message_recv_int32(&message, &value) != RPC_ERROR_NO_ERROR &&
 	  value != RPC_MESSAGE_START)
 	return ret;
 
--- macemu/SheepShaver/src/Unix/serial_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/serial_unix.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "../CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <sys/ioctl.h>
 #include <sys/stat.h>
@@ -222,7 +222,7 @@
 	}
 
 	// Configure port for raw mode
-	if (protocol == serial || protocol == pty) {
+	if (protocol == serial) {
 		if (tcgetattr(fd, &mode) < 0)
 			goto open_error;
 		cfmakeraw(&mode);
@@ -239,7 +239,7 @@
 	if (sem_init(&input_signal, 0, 0) < 0)
 		goto open_error;
 	if (sem_init(&output_signal, 0, 0) < 0)
-		goto open_error;
+		goto open_error; 
 	input_thread_active = (pthread_create(&input_thread, &thread_attr, input_func, this) == 0);
 	output_thread_active = (pthread_create(&output_thread, &thread_attr, output_func, this) == 0);
 	if (!input_thread_active || !output_thread_active)
@@ -566,7 +566,7 @@
 	protocol = pty;
 	if (!pty_allocate(&fd, &slavefd, slave, sizeof(slave)))
 		return false;
-
+		
 	fflush(stdout);
 	fflush(stderr);
 	switch (pid = fork()) {
@@ -821,7 +821,7 @@
 				WriteMacInt32(s->output_pb + ioActCount, 0);
 				WriteMacInt32(s->output_dt + serdtResult, uint16(writErr));
 			}
-
+	
 			// Trigger serial interrupt
 			D(bug(" triggering serial interrupt\n"));
 			s->write_done = true;
Only in sheepshaver/: SheepShaver/src/Unix/sigsegv.cpp
Only in sheepshaver/: SheepShaver/src/Unix/sigsegv.h
--- macemu/SheepShaver/src/Unix/sshpty.c
+++ sheepshaver/SheepShaver/src/Unix/sshpty.c
@@ -70,13 +70,9 @@
 #else /* stubs for BasiliskII */
 #define log printf
 #define error printf
-#define fatal(x) do { printf("Fatal error: %s", x); return 0; } while(0)
+#define fatal(x) {printf("Fatal error: %s", x); return 0}
 #endif /* not in BasiliskII */
 
-#define mysig_t sig_t
-#define mysignal signal
-#include <signal.h>
-
 /* Pty allocated with _getpty gets broken if we do I_PUSH:es to it. */
 #if defined(HAVE__GETPTY) || defined(HAVE_OPENPTY)
 #undef HAVE_DEV_PTMX
@@ -87,9 +83,6 @@
 #endif
 #if defined(HAVE_DEV_PTMX) && defined(HAVE_SYS_STROPTS_H)
 # include <sys/stropts.h>
-#endif
-#if defined(HAVE_DEV_PTMX) && defined(HAVE_STROPTS_H)
-# include <stropts.h>
 #endif
 
 #ifndef O_NOCTTY
--- macemu/SheepShaver/src/Unix/strlcpy.h
+++ sheepshaver/SheepShaver/src/Unix/strlcpy.h
@@ -1,4 +1,4 @@
-/* $Id$ */
+/* $Id: strlcpy.h,v 1.1 2002/07/31 16:46:14 cebix Exp $ */
 
 #ifndef _BSD_STRLCPY_H
 #define _BSD_STRLCPY_H
--- macemu/SheepShaver/src/Unix/sys_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/sys_unix.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "../CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <sys/ioctl.h>
 #include <sys/stat.h>
@@ -56,29 +56,21 @@
 #include "prefs.h"
 #include "user_strings.h"
 #include "sys.h"
-#include "disk_unix.h"
 
 #if defined(BINCUE)
 #include "bincue_unix.h"
 #endif
 
+#if defined(HAVE_LIBVHD)
+#include "vhd_unix.h"
+#endif
 
 
 #define DEBUG 0
 #include "debug.h"
 
-static disk_factory *disk_factories[] = {
-#ifndef STANDALONE_GUI
-	disk_sparsebundle_factory,
-#if defined(HAVE_LIBVHD)
-	disk_vhd_factory,
-#endif
-#endif
-	NULL
-};
-
 // File handles are pointers to these structures
-struct mac_file_handle {
+struct su_file_handle {
 	char *name;	        // Copy of device/file name
 	int fd;
 
@@ -91,7 +83,6 @@
 	loff_t file_size;	// Size of file data (only valid if is_file is true)
 
 	bool is_media_present;		// Flag: media is inserted and available
-	disk_generic *generic_disk;
 
 #if defined(__linux__)
 	int cdrom_cap;		// CD-ROM capability flags (only valid if is_cdrom is true)
@@ -106,21 +97,26 @@
 	bool is_bincue;		// Flag: BIN CUE file
 	void *bincue_fd;
 #endif
+
+#if defined(HAVE_LIBVHD)
+	bool is_vhd;		// Flag: VHD file
+	void *vhd_fd;
+#endif
 };
 
 // Open file handles
-struct open_mac_file_handle {
-	mac_file_handle *fh;
-	open_mac_file_handle *next;
+struct open_su_file_handle {
+	su_file_handle *fh;
+	open_su_file_handle *next;
 };
-static open_mac_file_handle *open_mac_file_handles = NULL;
+static open_su_file_handle *open_su_file_handles = NULL;
 
 // File handle of first floppy drive (for SysMountFirstFloppy())
-static mac_file_handle *first_floppy = NULL;
+static su_file_handle *first_floppy = NULL;
 
 // Prototypes
-static void cdrom_close(mac_file_handle *fh);
-static bool cdrom_open(mac_file_handle *fh, const char *path = NULL);
+static void cdrom_close(su_file_handle *fh);
+static bool cdrom_open(su_file_handle *fh, const char *path = NULL);
 
 
 /*
@@ -153,25 +149,25 @@
  *  Manage open file handles
  */
 
-static void sys_add_mac_file_handle(mac_file_handle *fh)
+static void sys_add_su_file_handle(su_file_handle *fh)
 {
-	open_mac_file_handle *p = new open_mac_file_handle;
+	open_su_file_handle *p = new open_su_file_handle;
 	p->fh = fh;
-	p->next = open_mac_file_handles;
-	open_mac_file_handles = p;
+	p->next = open_su_file_handles;
+	open_su_file_handles = p;
 }
 
-static void sys_remove_mac_file_handle(mac_file_handle *fh)
+static void sys_remove_su_file_handle(su_file_handle *fh)
 {
-	open_mac_file_handle *p = open_mac_file_handles;
-	open_mac_file_handle *q = NULL;
+	open_su_file_handle *p = open_su_file_handles;
+	open_su_file_handle *q = NULL;
 
 	while (p) {
 		if (p->fh == fh) {
 			if (q)
 				q->next = p->next;
 			else
-				open_mac_file_handles = p->next;
+				open_su_file_handles = p->next;
 			delete p;
 			break;
 		}
@@ -192,7 +188,7 @@
 		PrefsReplaceString("cdrom", path);
 
 	// Wait for media to be available for reading
-	if (open_mac_file_handles) {
+	if (open_su_file_handles) {
 		const int MAX_WAIT = 5;
 		for (int i = 0; i < MAX_WAIT; i++) {
 			if (access(path, R_OK) == 0)
@@ -208,8 +204,8 @@
 		}
 	}
 
-	for (open_mac_file_handle *p = open_mac_file_handles; p != NULL; p = p->next) {
-		mac_file_handle * const fh = p->fh;
+	for (open_su_file_handle *p = open_su_file_handles; p != NULL; p = p->next) {
+		su_file_handle * const fh = p->fh;
 
 		// Re-open CD-ROM device
 		if (fh->is_cdrom && type == MEDIA_CD) {
@@ -232,8 +228,8 @@
 	if ((type & MEDIA_REMOVABLE) != MEDIA_CD)
 		return;
 
-	for (open_mac_file_handle *p = open_mac_file_handles; p != NULL; p = p->next) {
-		mac_file_handle * const fh = p->fh;
+	for (open_su_file_handle *p = open_su_file_handles; p != NULL; p = p->next) {
+		su_file_handle * const fh = p->fh;
 
 		// Mark media as not available
 		if (!fh->is_cdrom || !fh->is_media_present)
@@ -328,7 +324,7 @@
 			line[len-1] = 0;
 
 			// Parse line
-			char *dev = NULL, *mnt_point = NULL, *fstype = NULL;
+			char *dev, *mnt_point, *fstype;
 			if (sscanf(line, "%as %as %as", &dev, &mnt_point, &fstype) == 3) {
 				if (strcmp(fstype, "hfs") == 0)
 					PrefsAddString("disk", dev);
@@ -420,7 +416,7 @@
  *  Open CD-ROM device and initialize internal data
  */
 
-static bool cdrom_open_1(mac_file_handle *fh)
+static bool cdrom_open_1(su_file_handle *fh)
 {
 #if defined __MACOSX__
 	// In OS X, the device name is OK for sending ioctls to,
@@ -428,7 +424,7 @@
 	// (it seems to have extra data padded in)
 	//
 	// So, we keep the already opened file handle,
-	// and open a slightly different file for CDROM data
+	// and open a slightly different file for CDROM data 
 	//
 	fh->ioctl_fd = fh->fd;
 	fh->ioctl_name = fh->name;
@@ -445,7 +441,7 @@
 	return true;
 }
 
-bool cdrom_open(mac_file_handle *fh, const char *path)
+bool cdrom_open(su_file_handle *fh, const char *path)
 {
 	if (path)
 		fh->name = strdup(path);
@@ -461,7 +457,7 @@
  *  Close a CD-ROM device
  */
 
-void cdrom_close(mac_file_handle *fh)
+void cdrom_close(su_file_handle *fh)
 {
 
 	if (fh->fd >= 0) {
@@ -522,14 +518,13 @@
 /*
  *  Open file/device, create new file handle (returns NULL on error)
  */
-
-static mac_file_handle *open_filehandle(const char *name)
+ 
+static su_file_handle *open_filehandle(const char *name)
 {
-		mac_file_handle *fh = new mac_file_handle;
-		memset(fh, 0, sizeof(mac_file_handle));
+		su_file_handle *fh = new su_file_handle;
+		memset(fh, 0, sizeof(su_file_handle));
 		fh->name = strdup(name);
 		fh->fd = -1;
-		fh->generic_disk = NULL;
 #if defined __MACOSX__
 		fh->ioctl_fd = -1;
 		fh->ioctl_name = NULL;
@@ -593,63 +588,46 @@
 #if defined(BINCUE)
 	void *binfd = open_bincue(name);
 	if (binfd) {
-		mac_file_handle *fh = open_filehandle(name);
+		su_file_handle *fh = open_filehandle(name);
 		D(bug("opening %s as bincue\n", name));
 		fh->bincue_fd = binfd;
 		fh->is_bincue = true;
 		fh->read_only = true;
 		fh->is_media_present = true;
-		sys_add_mac_file_handle(fh);
+		sys_add_su_file_handle(fh);
 		return fh;
 	}
 #endif
 
 
-	for (int i = 0; disk_factories[i]; ++i) {
-		disk_factory *f = disk_factories[i];
-		disk_generic *generic;
-		disk_generic::status st = f(name, read_only, &generic);
-		if (st == disk_generic::DISK_INVALID)
-			return NULL;
-		if (st == disk_generic::DISK_VALID) {
-			mac_file_handle *fh = open_filehandle(name);
-			fh->generic_disk = generic;
-			fh->file_size = generic->size();
-			fh->read_only = generic->is_read_only();
-			fh->is_media_present = true;
-			sys_add_mac_file_handle(fh);
-			return fh;
-		}
+#if defined(HAVE_LIBVHD)
+	int vhdsize;
+	void *vhdfd = vhd_unix_open(name, &vhdsize, read_only);
+	if (vhdfd) {
+		su_file_handle *fh = open_filehandle(name);
+		D(bug("opening %s as vnd\n", name));
+		fh->is_vhd = true;
+		fh->vhd_fd = vhdfd; 
+		fh->read_only = read_only;
+		fh->file_size = vhdsize;
+		fh->is_media_present = true;
+		sys_add_su_file_handle(fh);
+		return fh;
 	}
+#endif
 
-	int open_flags = (read_only ? O_RDONLY : O_RDWR);
 #if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__MACOSX__)
-	open_flags |= (is_cdrom ? O_NONBLOCK : 0);
+	int fd = open(name, (read_only ? O_RDONLY : O_RDWR) | (is_cdrom ? O_NONBLOCK : 0));
+#else
+	int fd = open(name, read_only ? O_RDONLY : O_RDWR);
 #endif
-#if defined(__MACOSX__)
-	open_flags |= (is_file ? O_EXLOCK | O_NONBLOCK : 0);
-#endif
-	int fd = open(name, open_flags);
-#if defined(__MACOSX__)
-	if (fd < 0 && (open_flags & O_EXLOCK)) {
-		if (errno == EOPNOTSUPP) {
-			// File system does not support locking. Try again without.
-			open_flags &= ~O_EXLOCK;
-			fd = open(name, open_flags);
-		} else if (errno == EAGAIN) {
-			// File is likely already locked by another process.
-			printf("WARNING: Cannot open %s (%s)\n", name, strerror(errno));
-			return NULL;
-		}
-	}
-#endif
 	if (fd < 0 && !read_only) {
 		// Read-write failed, try read-only
 		read_only = true;
 		fd = open(name, O_RDONLY);
 	}
 	if (fd >= 0 || is_polled_media) {
-		mac_file_handle *fh = open_filehandle(name);
+		su_file_handle *fh = open_filehandle(name);
 		fh->fd = fd;
 		fh->is_file = is_file;
 		fh->read_only = read_only;
@@ -703,7 +681,7 @@
 		}
 		if (fh->is_floppy && first_floppy == NULL)
 			first_floppy = fh;
-		sys_add_mac_file_handle(fh);
+		sys_add_su_file_handle(fh);
 		return fh;
 	} else {
 		printf("WARNING: Cannot open %s (%s)\n", name, strerror(errno));
@@ -718,18 +696,21 @@
 
 void Sys_close(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return;
 
-	sys_remove_mac_file_handle(fh);
+	sys_remove_su_file_handle(fh);
 
+#if defined(HAVE_LIBVHD)
+	if (fh->is_vhd)
+		vhd_unix_close(fh->vhd_fd);
+#endif
+
 #if defined(BINCUE)
 	if (fh->is_bincue)
 		close_bincue(fh->bincue_fd);
 #endif
-	if (fh->generic_disk)
-		delete fh->generic_disk;
 
 	if (fh->is_cdrom)
 		cdrom_close(fh);
@@ -748,7 +729,7 @@
 
 size_t Sys_read(void *arg, void *buffer, loff_t offset, size_t length)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return 0;
 
@@ -757,8 +738,10 @@
 		return read_bincue(fh->bincue_fd, buffer, offset, length);
 #endif
 
-	if (fh->generic_disk)
-		return fh->generic_disk->read(buffer, offset, length);
+#if defined(HAVE_LIBVHD)
+	if (fh->is_vhd)
+		return vhd_unix_read(fh->vhd_fd, buffer, offset, length);
+#endif
 
 	// Seek to position
 	if (lseek(fh->fd, offset + fh->start_byte, SEEK_SET) < 0)
@@ -776,12 +759,14 @@
 
 size_t Sys_write(void *arg, void *buffer, loff_t offset, size_t length)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return 0;
 
-	if (fh->generic_disk)
-		return fh->generic_disk->write(buffer, offset, length);
+#if defined(HAVE_LIBVHD)
+	if (fh->is_vhd)
+		return vhd_unix_write(fh->vhd_fd, buffer, offset, length);
+#endif
 
 	// Seek to position
 	if (lseek(fh->fd, offset + fh->start_byte, SEEK_SET) < 0)
@@ -798,23 +783,25 @@
 
 loff_t SysGetFileSize(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return true;
 
 #if defined(BINCUE)
 	if (fh->is_bincue)
 		return size_bincue(fh->bincue_fd);
-#endif
+#endif 
 
-	if (fh->generic_disk)
+#if defined(HAVE_LIBVHD)
+	if (fh->is_vhd)
 		return fh->file_size;
+#endif
 
 	if (fh->is_file)
 		return fh->file_size;
 	else {
-#if defined(__linux__)
 		long blocks;
+#if defined(__linux__)
 		if (ioctl(fh->fd, BLKGETSIZE, &blocks) < 0)
 			return 0;
 		D(bug(" BLKGETSIZE returns %d blocks\n", blocks));
@@ -842,7 +829,7 @@
 
 void SysEject(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return;
 
@@ -883,12 +870,10 @@
 
 			// Try to use "diskutil eject" but it can take up to 5
 			// seconds to complete
-			if (fh->ioctl_name) {
-				static const char eject_cmd[] = "/usr/sbin/diskutil eject %s 2>&1 >/dev/null";
-				char *cmd = (char *)alloca(strlen(eject_cmd) + strlen(fh->ioctl_name) + 1);
-				sprintf(cmd, eject_cmd, fh->ioctl_name);
-				system(cmd);
-			}
+			static const char eject_cmd[] = "/usr/sbin/diskutil eject %s 2>&1 >/dev/null";
+			char *cmd = (char *)alloca(strlen(eject_cmd) + strlen(fh->ioctl_name) + 1);
+			sprintf(cmd, eject_cmd, fh->ioctl_name);
+			system(cmd);
 		}
 		fh->is_media_present = false;
 	}
@@ -902,7 +887,7 @@
 
 bool SysFormat(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return false;
 
@@ -917,7 +902,7 @@
 
 bool SysIsReadOnly(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return true;
 
@@ -941,12 +926,14 @@
 
 bool SysIsFixedDisk(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return true;
 
-	if (fh->generic_disk)
+#if defined(HAVE_LIBVHD)
+	if (fh->is_vhd)
 		return true;
+#endif
 
 	if (fh->is_file)
 		return true;
@@ -963,12 +950,14 @@
 
 bool SysIsDiskInserted(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return false;
 
-	if (fh->generic_disk)
+#if defined(HAVE_LIBVHD)
+	if (fh->is_vhd)
 		return true;
+#endif
 
 	if (fh->is_file) {
 		return true;
@@ -1025,13 +1014,13 @@
 
 void SysPreventRemoval(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return;
 
 #if defined(__linux__) && defined(CDROM_LOCKDOOR)
 	if (fh->is_cdrom)
-		ioctl(fh->fd, CDROM_LOCKDOOR, 1);
+		ioctl(fh->fd, CDROM_LOCKDOOR, 1);	
 #endif
 }
 
@@ -1042,13 +1031,13 @@
 
 void SysAllowRemoval(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return;
 
 #if defined(__linux__) && defined(CDROM_LOCKDOOR)
 	if (fh->is_cdrom)
-		ioctl(fh->fd, CDROM_LOCKDOOR, 0);
+		ioctl(fh->fd, CDROM_LOCKDOOR, 0);	
 #endif
 }
 
@@ -1059,7 +1048,7 @@
 
 bool SysCDReadTOC(void *arg, uint8 *toc)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return false;
 
@@ -1206,7 +1195,7 @@
 
 bool SysCDGetPosition(void *arg, uint8 *pos)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return false;
 
@@ -1276,7 +1265,7 @@
 
 bool SysCDPlay(void *arg, uint8 start_m, uint8 start_s, uint8 start_f, uint8 end_m, uint8 end_s, uint8 end_f)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return false;
 
@@ -1318,7 +1307,7 @@
 
 bool SysCDPause(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return false;
 
@@ -1346,7 +1335,7 @@
 
 bool SysCDResume(void *arg)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return false;
 
@@ -1375,7 +1364,7 @@
 
 bool SysCDStop(void *arg, uint8 lead_out_m, uint8 lead_out_s, uint8 lead_out_f)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return false;
 
@@ -1404,7 +1393,7 @@
 
 bool SysCDScan(void *arg, uint8 start_m, uint8 start_s, uint8 start_f, bool reverse)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return false;
 
@@ -1419,7 +1408,7 @@
 
 void SysCDSetVolume(void *arg, uint8 left, uint8 right)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return;
 
@@ -1445,7 +1434,7 @@
 
 void SysCDGetVolume(void *arg, uint8 &left, uint8 &right)
 {
-	mac_file_handle *fh = (mac_file_handle *)arg;
+	su_file_handle *fh = (su_file_handle *)arg;
 	if (!fh)
 		return;
 
Only in sheepshaver/: SheepShaver/src/Unix/sysdeps.h
--- macemu/SheepShaver/src/Unix/timer_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/timer_unix.cpp
@@ -45,7 +45,7 @@
 		host_clock_inited = true;
 	}
 	
-	clock_get_time(host_clock, (mach_timespec_t *)&t);
+	clock_get_time(host_clock, &t);
 }
 #endif
 
@@ -57,14 +57,14 @@
 void Microseconds(uint32 &hi, uint32 &lo)
 {
 	D(bug("Microseconds\n"));
-#if defined(__MACH__)
-	tm_time_t t;
-	mach_current_time(t);
-	uint64 tl = (uint64)t.tv_sec * 1000000 + t.tv_nsec / 1000;
-#elif defined(HAVE_CLOCK_GETTIME)
+#if defined(HAVE_CLOCK_GETTIME)
 	struct timespec t;
 	clock_gettime(CLOCK_REALTIME, &t);
 	uint64 tl = (uint64)t.tv_sec * 1000000 + t.tv_nsec / 1000;
+#elif defined(__MACH__)
+	tm_time_t t;
+	mach_current_time(t);
+	uint64 tl = (uint64)t.tv_sec * 1000000 + t.tv_nsec / 1000;
 #else
 	struct timeval t;
 	gettimeofday(&t, NULL);
@@ -91,10 +91,10 @@
 
 void timer_current_time(tm_time_t &t)
 {
-#if defined(__MACH__)
-	mach_current_time(t);
-#elif defined(HAVE_CLOCK_GETTIME)
+#ifdef HAVE_CLOCK_GETTIME
 	clock_gettime(CLOCK_REALTIME, &t);
+#elif defined(__MACH__)
+	mach_current_time(t);
 #else
 	gettimeofday(&t, NULL);
 #endif
@@ -229,14 +229,14 @@
 
 uint64 GetTicks_usec(void)
 {
-#if defined(__MACH__)
-	tm_time_t t;
-	mach_current_time(t);
-	return (uint64)t.tv_sec * 1000000 + t.tv_nsec / 1000;
-#elif defined(HAVE_CLOCK_GETTIME)
+#ifdef HAVE_CLOCK_GETTIME
 	struct timespec t;
 	clock_gettime(CLOCK_REALTIME, &t);
 	return (uint64)t.tv_sec * 1000000 + t.tv_nsec / 1000;
+#elif defined(__MACH__)
+	tm_time_t t;
+	mach_current_time(t);
+	return (uint64)t.tv_sec * 1000000 + t.tv_nsec / 1000;
 #else
 	struct timeval t;
 	gettimeofday(&t, NULL);
@@ -264,10 +264,10 @@
 #define USE_COND_TIMEDWAIT
 #endif
 
-void Delay_usec(uint64 usec)
+void Delay_usec(uint32 usec)
 {
 	int was_error;
-	
+
 #if defined(USE_NANOSLEEP)
 	struct timespec elapsed, tv;
 #elif defined(USE_COND_TIMEDWAIT)
Only in macemu/: SheepShaver/src/Unix/tinyxml2.cpp
Only in macemu/: SheepShaver/src/Unix/tinyxml2.h
--- macemu/SheepShaver/src/Unix/tunconfig
+++ sheepshaver/SheepShaver/src/Unix/tunconfig
@@ -17,86 +17,34 @@
 #
 ###########################################################################
 
+set -e
+
 SUDO=/usr/bin/sudo
+BRCTL=/sbin/brctl
 IFCONFIG=/sbin/ifconfig
 IPTABLES=/sbin/iptables
 
-#########################################################
-
-[[ "x$1" = "x-n" ]] && {
-    DONT_EXECUTE=yes
-    shift 1
-}
-
+BRIDGE_DEV=br0
 TUN_DEV=$1
 ACTION=$2
 
-TUN_NUM=`echo $TUN_DEV | sed s/[^0-9]//g`
-NET_NUM=`expr 40 + $TUN_NUM`
-TUN_NET=172.20.$NET_NUM.0/24
-TUN_HOST=172.20.$NET_NUM.1
-
-#########################################################
-# Misc Checks
-#########################################################
-
 [[ $# = 2 ]] || {
-	echo "Usage: tunconfig [-n] iface up|down"
+	echo "Usage: tunconfig iface up|down"
     exit 2
 }
 
 [[ "`id -u`" = "0" ]] && {
-    echo "---> $SUDO not necessary." 1>&2
     SUDO=""
 }
 
-[[ -x $IPTABLES ]] || {
-    echo "---> $IPTABLES not found." 1>&2
-    exit 1
-}
+set -x
 
-if [ -n "$SUDO" ]; then
-    $SUDO -l | grep -q "NOPASSWD: $IFCONFIG" || {
-        echo "---> Missing sudo NOPASSWD: $IFCONFIG." 1>&2
-        exit 1
-    }
-    $SUDO -l | grep -q "NOPASSWD: $IPTABLES" || {
-        echo "---> Missing sudo NOPASSWD: $IPTABLES." 1>&2
-        exit 1
-    }
-    IFCONFIG="$SUDO $IFCONFIG"
-    IPTABLES="$SUDO $IPTABLES"
-fi
-
-[[ "x$DONT_EXECUTE" = "xyes" ]] && exit 0
-
-$IPTABLES -L -n -t nat > /dev/null || exit 1
-
-#########################################################
-# Remove old (possibly stale) ruleset
-#########################################################
-
-{
-    $IPTABLES -t nat -D POSTROUTING -s $TUN_NET ! -d $TUN_NET -j MASQUERADE
-} >& /dev/null
-
-#########################################################
-# Bring down interface
-#########################################################
-
-[[ "$ACTION" = down ]] && {
-    $IFCONFIG $TUN_DEV down
-}
-
-#########################################################
-# Configure interface
-#########################################################
-
 [[ "$ACTION" = up ]] && {
-    $IFCONFIG $TUN_DEV $TUN_HOST
-
-    # masquerade the tun network
-    $IPTABLES -t nat -A POSTROUTING -s $TUN_NET ! -d $TUN_NET -j MASQUERADE
+	$SUDO $BRCTL addif $BRIDGE_DEV $TUN_DEV
+	$SUDO $IFCONFIG $TUN_DEV up
 }
 
-exit 0
+[[ "$ACTION" = down ]] && {
+	$SUDO $IFCONFIG $TUN_DEV down
+    $SUDO $BRCTL delif $BRIDGE_DEV $TUN_DEV
+}
--- macemu/SheepShaver/src/Unix/user_strings_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/user_strings_unix.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "../CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "user_strings.h"
 
 
@@ -53,7 +53,6 @@
 	{STR_NO_SHEEP_NET_DRIVER_WARN, "Cannot open %s (%s). Ethernet will not be available."},
 	{STR_SHEEP_NET_ATTACH_WARN, "Cannot attach to Ethernet card (%s). Ethernet will not be available."},
 	{STR_TUN_TAP_CONFIG_WARN, "Cannot configure TUN/TAP device (%s). Ethernet will not be available."},
-	{STR_SLIRP_NO_DNS_FOUND_WARN, "Cannot get DNS address. Ethernet will not be available."},
 	{STR_NO_AUDIO_DEV_WARN, "Cannot open %s (%s). Audio output will be disabled."},
 	{STR_NO_AUDIO_WARN, "No audio device found, audio output will be disabled."},
 	{STR_NO_ESD_WARN, "Cannot open ESD connection. Audio output will be disabled."},
@@ -84,6 +83,7 @@
 	{STR_VOSF_INIT_ERR, "Cannot initialize Video on SEGV signals."},
 
 	{STR_OPEN_WINDOW_ERR, "Cannot open Mac window."},
+	{STR_WINDOW_TITLE_GRABBED, "SheepShaver (mouse grabbed, press Ctrl-F5 to release)"},
 
 	{STR_NO_B2_EXE_FOUND, "Could not start %s (%s)."},
 
--- macemu/SheepShaver/src/Unix/user_strings_unix.h
+++ sheepshaver/SheepShaver/src/Unix/user_strings_unix.h
@@ -18,8 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifndef USER_STRINGS_UNIX_H
-#define USER_STRINGS_UNIX_H
+#ifndef USER_STRINGS_LINUX_H
+#define USER_STRINGS_LINUX_H
 
 enum {
 	STR_NO_DEV_ZERO_ERR = 10000,
@@ -46,7 +46,6 @@
 	STR_NO_SHEEP_NET_DRIVER_WARN,
 	STR_SHEEP_NET_ATTACH_WARN,
 	STR_TUN_TAP_CONFIG_WARN,
-	STR_SLIRP_NO_DNS_FOUND_WARN,
 	STR_NO_AUDIO_DEV_WARN,
 	STR_NO_AUDIO_WARN,
 	STR_NO_ESD_WARN,
@@ -78,6 +77,7 @@
 	STR_MOUSEWHEELLINES_CTRL,
 
 	STR_OPEN_WINDOW_ERR,
+	STR_WINDOW_TITLE_GRABBED,
 
 	STR_NO_B2_EXE_FOUND
 };
--- macemu/SheepShaver/src/Unix/vhd_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/vhd_unix.cpp
@@ -1,5 +1,5 @@
 /*
- * vhd_unix.cpp -- support for disk images in vhd format
+ * vhd_unix.cpp -- support for disk images in vhd format 
  *
  *	(C) 2010 Geoffrey Brown
  *
@@ -19,7 +19,7 @@
  */
 
 #include "sysdeps.h"
-#include "disk_unix.h"
+#include "vhd_unix.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -32,8 +32,7 @@
 #define DEBUG 0
 #include "debug.h"
 
-static disk_generic::status vhd_unix_open(const char *name, int *size,
-	bool read_only, vhd_context_t **ctx)
+void *vhd_unix_open(const char *name, int *size, bool read_only)
 {
 	int amode = read_only ? R_OK : (R_OK | W_OK);
 	int fid;
@@ -43,13 +42,13 @@
 
 	if (access(name, amode)) {
 		D(bug("vhd open -- incorrect permissions %s\n", name));
-		return disk_generic::DISK_UNKNOWN;
+		return NULL;
 	}
-
-	if (! (fid = open(name, O_RDONLY))) {
+  
+	if (! (fid = open(name, O_RDONLY))) { 
 		D(bug("vhd open -- couldn't open file %s\n", name));
-		return disk_generic::DISK_UNKNOWN;
-	}
+		return NULL;
+	} 
 	else {
 		char buf[9];
 		read(fid, buf, sizeof(buf)-1);
@@ -57,58 +56,57 @@
 		close(fid);
 		if (strcmp("conectix", buf) != 0) {
 			D(bug("vhd open -- not vhd magic = %s\n", buf));
-			return disk_generic::DISK_UNKNOWN;
+			return NULL;
 		}
 		if (vhd = (vhd_context_t *) malloc(sizeof(vhd_context_t))) {
 			int err;
-			if (err = vhd_open(vhd, name, read_only ?
+			if (err = vhd_open(vhd, name, read_only ? 
 								VHD_OPEN_RDONLY : VHD_OPEN_RDWR)) {
 				D(bug("vhd_open failed (%d)\n", err));
 				free(vhd);
-				return disk_generic::DISK_INVALID;
-			}
+				return NULL;
+			} 
 			else {
 				*size = (int) vhd->footer.curr_size;
 				printf("VHD Open %s\n", name);
-				*ctx = vhd;
-				return disk_generic::DISK_VALID;
+				return (void *) vhd;
 			}
 		}
 		else {
 			D(bug("vhd open -- malloc failed\n"));
-			return disk_generic::DISK_INVALID;
+			return NULL;
 		}
 	}
 }
 
-static int vhd_unix_read(vhd_context_t *ctx, void *buffer, loff_t offset,
-	size_t length)
+int vhd_unix_read(void *arg, void *buffer, loff_t offset, size_t length)
 {
+	vhd_context_t *ctx = (vhd_context_t *) arg;
 	int err;
 	if ((offset % VHD_SECTOR_SIZE) || (length % VHD_SECTOR_SIZE)) {
 		printf("vhd read only supported on sector boundaries (%d)\n",
 				VHD_SECTOR_SIZE);
 		return 0;
-	}
-	if (err = vhd_io_read(ctx, (char *) buffer, offset / VHD_SECTOR_SIZE,
+	}	
+	if (err = vhd_io_read(ctx, (char *) buffer, offset / VHD_SECTOR_SIZE, 
 							length / VHD_SECTOR_SIZE)){
-		D(bug("vhd read error %d\n", err));
+		D(bug("vhd read error %d\n", err));	
 		return err;
 	}
-	else
+	else 
 		return length;
 }
 
-static int vhd_unix_write(vhd_context_t *ctx, void *buffer, loff_t offset,
-	size_t length)
+int vhd_unix_write(void *arg, void *buffer, loff_t offset, size_t length)
 {
 	int err;
+	vhd_context_t *ctx = (vhd_context_t *) arg;
 
 	if ((offset % VHD_SECTOR_SIZE) || (length % VHD_SECTOR_SIZE)) {
 		printf("vhd write only supported on sector boundaries (%d)\n",
 				VHD_SECTOR_SIZE);
 		return 0;
-	}
+	}	
 	if (err = vhd_io_write(ctx, (char *) buffer, offset/VHD_SECTOR_SIZE,
 							length/VHD_SECTOR_SIZE)) {
 		D(bug("vhd write error %d\n", err));
@@ -118,43 +116,9 @@
 		return length;
 }
 
-
-static void vhd_unix_close(vhd_context_t *ctx)
+void vhd_unix_close(void *arg)
 {
 	D(bug("vhd close\n"));
-	vhd_close(ctx);
-	free(ctx);
-}
-
-
-struct disk_vhd : disk_generic {
-	disk_vhd(vhd_context_t *ctx, bool read_only, loff_t size)
-	: ctx(ctx), read_only(read_only), file_size(size) { }
-
-	virtual ~disk_vhd() { vhd_unix_close(ctx); }
-	virtual bool is_read_only() { return read_only; }
-	virtual loff_t size() { return file_size; }
-
-	virtual size_t read(void *buf, loff_t offset, size_t length) {
-		return vhd_unix_read(ctx, buf, offset, length);
-	}
-
-	virtual size_t write(void *buf, loff_t offset, size_t length) {
-		return vhd_unix_write(ctx, buf, offset, length);
-	}
-
-protected:
-	vhd_context_t *ctx;
-	bool read_only;
-	loff_t file_size;
-};
-
-disk_generic::status disk_vhd_factory(const char *path,
-		bool read_only, disk_generic **disk) {
-	int size;
-	vhd_context_t *ctx = NULL;
-	disk_generic::status st = vhd_unix_open(path, &size, read_only, &ctx);
-	if (st == disk_generic::DISK_VALID)
-		*disk = new disk_vhd(ctx, read_only, size);
-	return st;
+	vhd_close((vhd_context_t *) arg);
+	free(arg);
 }
Only in sheepshaver/: SheepShaver/src/Unix/vhd_unix.h
Only in sheepshaver/: SheepShaver/src/Unix/video_blit.cpp
Only in sheepshaver/: SheepShaver/src/Unix/video_blit.h
Only in sheepshaver/: SheepShaver/src/Unix/video_vosf.h
--- macemu/SheepShaver/src/Unix/video_x.cpp
+++ sheepshaver/SheepShaver/src/Unix/video_x.cpp
@@ -703,7 +703,7 @@
 		D(bug("[fbdev] visual '%s' not supported\n", fb_visual_str));
 		return false;
 	}
-
+	
 	// Map frame buffer
 	the_buffer = (uint8 *)mmap(NULL, fb_finfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb_dev_fd, 0);
 	if (the_buffer == MAP_FAILED) {
@@ -752,7 +752,7 @@
 	visualFormat.Rmask = visualInfo.red_mask;
 	visualFormat.Gmask = visualInfo.green_mask;
 	visualFormat.Bmask = visualInfo.blue_mask;
-	D(bug("[fbdev] %d bpp, (%08x,%08x,%08x)\n",
+	D(bug("[fbdev] %d bpp, (%08x,%08x,%08x)\n", 
 		  visualFormat.depth,
 		  visualFormat.Rmask, visualFormat.Gmask, visualFormat.Bmask));
 	D(bug("[fbdev] Mac depth %d bpp\n", depth));
@@ -765,7 +765,7 @@
 	const bool native_byte_order = (XImageByteOrder(x_display) == LSBFirst);
 #endif
 	Screen_blitter_init(visualFormat, native_byte_order, depth);
-
+	
 	// Allocate memory for frame buffer (SIZE is extended to page-boundary)
 	use_vosf = true;
 	the_host_buffer = the_buffer;
@@ -856,7 +856,7 @@
 	// Screen_blitter_init() returns TRUE if VOSF is mandatory
 	// i.e. the framebuffer update function is not Blit_Copy_Raw
 	use_vosf = Screen_blitter_init(visualFormat, native_byte_order, depth);
-
+	
 	if (use_vosf) {
 	  // Allocate memory for frame buffer (SIZE is extended to page-boundary)
 	  the_host_buffer = the_buffer;
@@ -1369,12 +1369,12 @@
 	mainBuffer.dirtyPages = NULL;
 	mainBuffer.pageInfo = NULL;
 #endif
-
+	
 	// Check if X server runs on local machine
 	local_X11 = (strncmp(XDisplayName(x_display_name), ":", 1) == 0)
 	         || (strncmp(XDisplayName(x_display_name), "/", 1) == 0)
 	         || (strncmp(XDisplayName(x_display_name), "unix:", 5) == 0);
-
+    
 	// Init keycode translation
 	keycode_init();
 
@@ -1402,7 +1402,7 @@
 		return false;
 	}
 	sort(avail_depths, avail_depths + num_depths);
-
+	
 	// Get screen depth
 	xdepth = DefaultDepth(x_display, screen);
 
@@ -1708,8 +1708,6 @@
 	if (x_display != NULL) {
 		XSync(x_display, false);
 		close_display();
-		XFlush(x_display);
-		XSync(x_display, false);
 	}
 
 #ifdef ENABLE_FBDEV_DGA
@@ -1804,7 +1802,7 @@
 		UNLOCK_VOSF;
 	}
 #endif
-
+	
 	// Restore frame buffer
 	if (fb_save) {
 #ifdef ENABLE_VOSF
Only in sheepshaver/: SheepShaver/src/Unix/vm_alloc.cpp
Only in sheepshaver/: SheepShaver/src/Unix/vm_alloc.h
--- macemu/SheepShaver/src/Unix/xpram_unix.cpp
+++ sheepshaver/SheepShaver/src/Unix/xpram_unix.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "../CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <stdlib.h>
 
--- macemu/SheepShaver/src/Windows/Makefile.in
+++ sheepshaver/SheepShaver/src/Windows/Makefile.in
@@ -65,7 +65,7 @@
     ../rom_patches.cpp ../rsrc_patches.cpp ../emul_op.cpp ../name_registry.cpp \
     ../macos_util.cpp ../timer.cpp timer_windows.cpp ../xpram.cpp xpram_windows.cpp \
     ../adb.cpp ../sony.cpp ../disk.cpp ../cdrom.cpp ../scsi.cpp ../dummy/scsi_dummy.cpp \
-    ../gfxaccel.cpp ../video.cpp ../SDL/video_sdl.cpp ../SDL/video_sdl2.cpp video_blit.cpp \
+    ../gfxaccel.cpp ../video.cpp ../SDL/video_sdl.cpp video_blit.cpp \
     ../audio.cpp ../SDL/audio_sdl.cpp ../ether.cpp ether_windows.cpp \
     ../thunks.cpp ../serial.cpp serial_windows.cpp ../extfs.cpp extfs_windows.cpp \
     about_window_windows.cpp ../user_strings.cpp user_strings_windows.cpp \
@@ -73,7 +73,7 @@
     vm_alloc.cpp sigsegv.cpp posix_emu.cpp SheepShaver.rc \
 	$(CPUSRCS) $(ROUTERSRCS) $(SLIRP_OBJS)
 
-UI_SRCS = ../prefs.cpp prefs_windows.cpp prefs_editor_gtk.cpp xpram_windows.cpp \
+UI_SRCS = ../prefs.cpp ../dummy/prefs_dummy.cpp prefs_windows.cpp prefs_editor_gtk.cpp xpram_windows.cpp \
 	../prefs_items.cpp ../user_strings.cpp user_strings_windows.cpp util_windows.cpp \
 	b2ether/packet32.cpp SheepShaverGUI.rc
 
Only in sheepshaver/: SheepShaver/src/Windows/SheepShaver.sln
Only in sheepshaver/: SheepShaver/src/Windows/SheepShaver.vcproj
Only in sheepshaver/: SheepShaver/src/Windows/autogen.sh
--- macemu/SheepShaver/src/Windows/b2ether/inc/b2ether_hl.h
+++ sheepshaver/SheepShaver/src/Windows/b2ether/inc/b2ether_hl.h
@@ -1,115 +1,116 @@
-/*
- *  b2ether_hl.h - Win32 ethernet driver high-level interface
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _B2_ETHER_HL_
-#define _B2_ETHER_HL_
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define	ETH_802_3_ADDRESS_LENGTH 6
-#define MAX_LINK_NAME_LENGTH 124
-
-typedef struct _ADAPTER {
-  HANDLE     hFile;
-  TCHAR      SymbolicLink[MAX_LINK_NAME_LENGTH];
-} ADAPTER, *LPADAPTER;
-
-typedef struct _PACKET {
-  OVERLAPPED   OverLapped;
-  PVOID        Buffer;
-  UINT         Length;
-  ULONG        BytesReceived;
-  BOOL         bIoComplete;
-  BOOL         free;
-	struct _PACKET *next;
-} PACKET, *LPPACKET;
-
-
-
-BOOLEAN StartPacketDriver(
-	LPCTSTR ServiceName
-);
-
-LPADAPTER PacketOpenAdapter(
-	LPCTSTR   AdapterName,
-	int16		 mode
-);
-
-VOID PacketCloseAdapter(
-	LPADAPTER   lpAdapter
-);
-
-LPPACKET PacketAllocatePacket(
-	LPADAPTER   AdapterObject,
-	UINT Length
-);
-
-VOID PacketFreePacket(
-	LPPACKET    lpPacket
-);
-
-BOOLEAN PacketSendPacket(
-	LPADAPTER   AdapterObject,
-	LPPACKET    lpPacket,
-	BOOLEAN     Sync,
-	BOOLEAN     RecyclingAllowed
-);
-
-BOOLEAN PacketGetAddress(
-  LPADAPTER  AdapterObject,
-  PUCHAR     AddressBuffer,
-  PUINT       Length
-);
-
-BOOLEAN PacketReceivePacket(
-  LPADAPTER   AdapterObject,
-  LPPACKET    lpPacket,
-  BOOLEAN     Sync
-);
-
-BOOLEAN PacketSetFilter( LPADAPTER  AdapterObject, ULONG Filter );
-BOOLEAN PacketGetMAC( LPADAPTER AdapterObject, LPBYTE address, BOOL permanent );
-BOOLEAN PacketAddMulticast( LPADAPTER AdapterObject, LPBYTE address );
-BOOLEAN PacketDelMulticast( LPADAPTER AdapterObject, LPBYTE address );
-
-ULONG PacketGetAdapterNames( LPADAPTER lpAdapter, LPTSTR pStr, PULONG BufferSize );
-
-// callbacks
-void recycle_write_packet( LPPACKET Packet );
-
-VOID CALLBACK packet_read_completion(
-  DWORD dwErrorCode,
-  DWORD dwNumberOfBytesTransfered,
-  LPOVERLAPPED lpOverlapped
-);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif // _B2_ETHER_HL_
+/*
+ *  b2ether_hl.h - Win32 ethernet driver high-level interface
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _B2_ETHER_HL_
+#define _B2_ETHER_HL_
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define	ETH_802_3_ADDRESS_LENGTH 6
+#define MAX_LINK_NAME_LENGTH 124
+
+typedef struct _ADAPTER {
+  HANDLE     hFile;
+  TCHAR      SymbolicLink[MAX_LINK_NAME_LENGTH];
+} ADAPTER, *LPADAPTER;
+
+typedef struct _PACKET {
+  OVERLAPPED   OverLapped;
+  PVOID        Buffer;
+  UINT         Length;
+  ULONG        BytesReceived;
+  BOOL         bIoComplete;
+  BOOL         free;
+	struct _PACKET *next;
+} PACKET, *LPPACKET;
+
+
+
+BOOLEAN StartPacketDriver(
+	LPTSTR ServiceName
+);
+
+LPADAPTER PacketOpenAdapter(
+	LPCSTR   AdapterName,
+	int16		 mode
+);
+
+VOID PacketCloseAdapter(
+	LPADAPTER   lpAdapter
+);
+
+LPPACKET PacketAllocatePacket(
+	LPADAPTER   AdapterObject,
+	UINT Length
+);
+
+VOID PacketFreePacket(
+	LPPACKET    lpPacket
+);
+
+BOOLEAN PacketSendPacket(
+	LPADAPTER   AdapterObject,
+	LPPACKET    lpPacket,
+	BOOLEAN     Sync,
+	BOOLEAN     RecyclingAllowed
+);
+
+BOOLEAN PacketGetAddress(
+  LPADAPTER  AdapterObject,
+  PUCHAR     AddressBuffer,
+  PUINT       Length
+);
+
+BOOLEAN PacketReceivePacket(
+  LPADAPTER   AdapterObject,
+  LPPACKET    lpPacket,
+  BOOLEAN     Sync
+);
+
+BOOLEAN PacketSetFilter( LPADAPTER  AdapterObject, ULONG Filter );
+BOOLEAN PacketGetMAC( LPADAPTER AdapterObject, LPBYTE address, BOOL permanent );
+BOOLEAN PacketAddMulticast( LPADAPTER AdapterObject, LPBYTE address );
+BOOLEAN PacketDelMulticast( LPADAPTER AdapterObject, LPBYTE address );
+
+ULONG PacketGetAdapterNames( LPADAPTER lpAdapter, PTSTR pStr, PULONG BufferSize );
+ULONG PacketSelectAdapterByName( LPADAPTER  AdapterObject, LPCSTR name );
+
+// callbacks
+void recycle_write_packet( LPPACKET Packet );
+
+VOID CALLBACK packet_read_completion(
+  DWORD dwErrorCode,
+  DWORD dwNumberOfBytesTransfered,
+  LPOVERLAPPED lpOverlapped
+);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif // _B2_ETHER_HL_
--- macemu/SheepShaver/src/Windows/b2ether/inc/ntddpack.h
+++ sheepshaver/SheepShaver/src/Windows/b2ether/inc/ntddpack.h
@@ -1,32 +1,32 @@
-// #include <ntddndis.h>
-
-#ifndef __NTDDPACKET
-#define __NTDDPACKET 1
-
-// #include <devioctl.h>
-
-#define        MAX_LINK_NAME_LENGTH   124
-
-#pragma pack(1)
-typedef struct _PACKET_OID_DATA {
-	ULONG           Oid;
-	ULONG           Length;
-	UCHAR           Data[1];
-} ATTRIBUTE_PACKED  PACKET_OID_DATA, *PPACKET_OID_DATA;
-#pragma pack()
-
-
-#define FILE_DEVICE_PROTOCOL        0x8000
-
-
-
-#define IOCTL_PROTOCOL_SET_OID					CTL_CODE(FILE_DEVICE_PROTOCOL, 0 , METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define IOCTL_PROTOCOL_QUERY_OID				CTL_CODE(FILE_DEVICE_PROTOCOL, 1 , METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define IOCTL_PROTOCOL_RESET						CTL_CODE(FILE_DEVICE_PROTOCOL, 2 , METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define IOCTL_PROTOCOL_READ							CTL_CODE(FILE_DEVICE_PROTOCOL, 3 , METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define IOCTL_PROTOCOL_WRITE						CTL_CODE(FILE_DEVICE_PROTOCOL, 4 , METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define IOCTL_PROTOCOL_MACNAME					CTL_CODE(FILE_DEVICE_PROTOCOL, 5 , METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define IOCTL_PROTOCOL_SELECT_BY_NAME		CTL_CODE(FILE_DEVICE_PROTOCOL, 6 , METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define IOCTL_ENUM_ADAPTERS							CTL_CODE(FILE_DEVICE_PROTOCOL, 7 , METHOD_BUFFERED, FILE_ANY_ACCESS)
-
-#endif
+// #include <ntddndis.h>
+
+#ifndef __NTDDPACKET
+#define __NTDDPACKET 1
+
+// #include <devioctl.h>
+
+#define        MAX_LINK_NAME_LENGTH   124
+
+#pragma pack(1)
+typedef struct _PACKET_OID_DATA {
+	ULONG           Oid;
+	ULONG           Length;
+	UCHAR           Data[1];
+} ATTRIBUTE_PACKED  PACKET_OID_DATA, *PPACKET_OID_DATA;
+#pragma pack()
+
+
+#define FILE_DEVICE_PROTOCOL        0x8000
+
+
+
+#define IOCTL_PROTOCOL_SET_OID					CTL_CODE(FILE_DEVICE_PROTOCOL, 0 , METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define IOCTL_PROTOCOL_QUERY_OID				CTL_CODE(FILE_DEVICE_PROTOCOL, 1 , METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define IOCTL_PROTOCOL_RESET						CTL_CODE(FILE_DEVICE_PROTOCOL, 2 , METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define IOCTL_PROTOCOL_READ							CTL_CODE(FILE_DEVICE_PROTOCOL, 3 , METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define IOCTL_PROTOCOL_WRITE						CTL_CODE(FILE_DEVICE_PROTOCOL, 4 , METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define IOCTL_PROTOCOL_MACNAME					CTL_CODE(FILE_DEVICE_PROTOCOL, 5 , METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define IOCTL_PROTOCOL_SELECT_BY_NAME		CTL_CODE(FILE_DEVICE_PROTOCOL, 6 , METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define IOCTL_ENUM_ADAPTERS							CTL_CODE(FILE_DEVICE_PROTOCOL, 7 , METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#endif
--- macemu/SheepShaver/src/Windows/b2ether/multiopt.h
+++ sheepshaver/SheepShaver/src/Windows/b2ether/multiopt.h
@@ -1,27 +1,27 @@
-/*
- *  multiopt.h
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-enum {
-	ETHER_MULTICAST_MAC,
-	ETHER_MULTICAST_ALL,
-	ETHER_MULTICAST_PROMISCUOUS
-};
+/*
+ *  multiopt.h
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+enum {
+	ETHER_MULTICAST_MAC,
+	ETHER_MULTICAST_ALL,
+	ETHER_MULTICAST_PROMISCUOUS
+};
--- macemu/SheepShaver/src/Windows/b2ether/packet32.cpp
+++ sheepshaver/SheepShaver/src/Windows/b2ether/packet32.cpp
@@ -1,694 +1,788 @@
-/*
- *  packet32.cpp
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "main.h"
-#include "util_windows.h"
-#include <windowsx.h>
-#include <winioctl.h>
-#include "cpu_emulation.h"
-typedef unsigned long ULONG_PTR, *PULONG_PTR;
-
-// VC6 does not have this, Platform SDK has.
-// In case of errors, try to comment out, the needed
-// definitions are below (#ifndef _NTDDNDIS_)
-
-// Most people don't have the Platform SDK, so I take this one out.
-// #include <ntddndis.h>
-
-#include "inc/ntddpack.h"
-
-#include "ether.h"
-#include "ether_defs.h"
-#include "b2ether/multiopt.h"
-#include "b2ether/inc/b2ether_hl.h"
-
-
-
-#ifndef _NTDDNDIS_
-#define NDIS_PACKET_TYPE_DIRECTED					0x00000001
-#define NDIS_PACKET_TYPE_MULTICAST				0x00000002
-#define NDIS_PACKET_TYPE_ALL_MULTICAST		0x00000004
-#define NDIS_PACKET_TYPE_BROADCAST				0x00000008
-#define NDIS_PACKET_TYPE_SOURCE_ROUTING		0x00000010
-#define NDIS_PACKET_TYPE_PROMISCUOUS			0x00000020
-
-#define OID_802_3_PERMANENT_ADDRESS				0x01010101
-#define OID_802_3_CURRENT_ADDRESS					0x01010102
-#define OID_802_3_MULTICAST_LIST					0x01010103
-
-#define OID_GEN_CURRENT_PACKET_FILTER			0x0001010E
-#endif
-
-#define DEBUG_PACKETS 0
-#define DEBUG 0
-#include "debug.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#define MAX_MULTICAST 100
-#define MAX_MULTICAST_SZ (20*ETH_802_3_ADDRESS_LENGTH)
-
-static ULONG packet_filter = 0;
-
-
-LPADAPTER PacketOpenAdapter( LPCTSTR AdapterName, int16 mode )
-{
-  LPADAPTER  lpAdapter;
-  BOOLEAN    Result = TRUE;
-
-  D(bug("Packet32: PacketOpenAdapter\n"));
-
-  // May fail if user is not an Administrator.
-  StartPacketDriver( TEXT("B2ether") );
-
-  lpAdapter = (LPADAPTER)GlobalAllocPtr( GMEM_MOVEABLE|GMEM_ZEROINIT, sizeof(ADAPTER) );
-  if (lpAdapter==NULL) {
-      D(bug("Packet32: PacketOpenAdapter GlobalAlloc Failed\n"));
-      return NULL;
-  }
-
-	TCHAR device_name[256];
-	_sntprintf(lpAdapter->SymbolicLink, lengthof(lpAdapter->SymbolicLink), TEXT("\\\\.\\B2ether_%s"), AdapterName );
-	_sntprintf(device_name, lengthof(device_name), TEXT("\\Device\\B2ether_%s"), AdapterName );
-
-	// Work around one subtle NT4 bug.
-	DefineDosDevice(
-			DDD_REMOVE_DEFINITION,
-			&lpAdapter->SymbolicLink[4],
-			NULL
-	);
-	DefineDosDevice(
-			DDD_RAW_TARGET_PATH,
-			&lpAdapter->SymbolicLink[4],
-			device_name
-	);
-
-	packet_filter = NDIS_PACKET_TYPE_DIRECTED |
-									NDIS_PACKET_TYPE_MULTICAST |
-									NDIS_PACKET_TYPE_BROADCAST;
-
-	if(mode == ETHER_MULTICAST_ALL) packet_filter |= NDIS_PACKET_TYPE_ALL_MULTICAST;
-	if(mode == ETHER_MULTICAST_PROMISCUOUS) packet_filter |= NDIS_PACKET_TYPE_PROMISCUOUS;
-
-  if (Result) {
-    lpAdapter->hFile = CreateFile(lpAdapter->SymbolicLink,
-                         GENERIC_WRITE | GENERIC_READ,
-                         0,
-                         NULL,
-												 // (os == VER_PLATFORM_WIN32_NT) ? CREATE_ALWAYS : OPEN_EXISTING,
-												 OPEN_EXISTING,
-                         FILE_FLAG_OVERLAPPED,
-                         0
-                         );
-    if (lpAdapter->hFile != INVALID_HANDLE_VALUE) {
-			if(*AdapterName && _tcscmp(AdapterName,TEXT("<None>")) != 0) {
-				PacketSetFilter( lpAdapter, packet_filter );
-			}
-      return lpAdapter;
-    }
-  }
-  D(bug("Packet32: PacketOpenAdapter Could not open adapter\n"));
-  GlobalFreePtr( lpAdapter );
-  return NULL;
-}
-
-VOID PacketCloseAdapter( LPADAPTER lpAdapter )
-{
-  D(bug("Packet32: PacketCloseAdapter\n"));
-
-	if(lpAdapter) {
-		if(lpAdapter->hFile) {
-			CloseHandle(lpAdapter->hFile);
-		}
-		GlobalFreePtr(lpAdapter);
-	}
-}
-
-LPPACKET PacketAllocatePacket( LPADAPTER AdapterObject, UINT Length )
-{
-  LPPACKET lpPacket;
-
-  lpPacket = (LPPACKET)GlobalAllocPtr( GMEM_MOVEABLE|GMEM_ZEROINIT, sizeof(PACKET) );
-  if(lpPacket==NULL) {
-      D(bug("Packet32: PacketAllocatePacket: GlobalAlloc Failed\n"));
-      return NULL;
-  }
-
-	lpPacket->OverLapped.hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
-	if(!lpPacket->OverLapped.hEvent) {
-			D(bug("Packet32: PacketAllocatePacket: CreateEvent Failed\n"));
-			GlobalFreePtr(lpPacket);
-			return NULL;
-	}
-
-	lpPacket->Buffer = GlobalAllocPtr(GMEM_MOVEABLE,2048); // 1514
-	if(!lpPacket->Buffer) {
-      D(bug("Packet32: PacketAllocatePacket: GlobalAllocPtr Failed\n"));
-		  if(lpPacket->OverLapped.hEvent) CloseHandle(lpPacket->OverLapped.hEvent);
-      GlobalFreePtr(lpPacket);
-      return NULL;
-	}
-
-  lpPacket->OverLapped.Offset = 0;
-  lpPacket->OverLapped.OffsetHigh = 0;
-	lpPacket->Length = Length;
-	lpPacket->BytesReceived	= 0;
-	lpPacket->bIoComplete	= FALSE;
-	lpPacket->free = TRUE;
-
-  return lpPacket;
-}
-
-VOID PacketFreePacket( LPPACKET lpPacket )
-{
-	if(lpPacket) {
-		if(lpPacket->Buffer) GlobalFreePtr(lpPacket->Buffer);
-		if(lpPacket->OverLapped.hEvent) CloseHandle(lpPacket->OverLapped.hEvent);
-		GlobalFreePtr(lpPacket);
-	}
-}
-
-BOOLEAN PacketDeviceIoControl(
-	LPADAPTER	lpAdapterObject,
-	LPPACKET	lpPacket,
-	ULONG			ulIoctl,
-	BOOLEAN		bSync
-)
-{
-	BOOLEAN Result;
-
-	lpPacket->OverLapped.Offset		= 0;
-	lpPacket->OverLapped.OffsetHigh	= 0;
-	lpPacket->BytesReceived		= 0;
-
-	if ( !ResetEvent( lpPacket->OverLapped.hEvent ) )  {
-		lpPacket->bIoComplete = FALSE;
-		D(bug( "Packet32: PacketDeviceIoControl failed to reset event\r\n", GetLastError() ));
-		return FALSE;
-	}
-
-	Result = DeviceIoControl(
-		lpAdapterObject->hFile,
-		ulIoctl,
-		lpPacket->Buffer,
-		lpPacket->Length,
-		lpPacket->Buffer,
-		lpPacket->Length,
-		&(lpPacket->BytesReceived),
-		&(lpPacket->OverLapped) );
-
-	if( !Result && bSync ) {
-		if (GetLastError() == ERROR_IO_PENDING) {
-			Result = GetOverlappedResult(	lpAdapterObject->hFile,
-											&(lpPacket->OverLapped),
-											&(lpPacket->BytesReceived),
-											TRUE );
-		} else {
-			D(bug( "Packet32: unsupported API call returned error 0x%x\r\n", GetLastError() ));
-		}
-	}
-	lpPacket->bIoComplete = Result;
-	return Result;
-}
-
-VOID CALLBACK PacketSendCompletionRoutine(
-  DWORD dwErrorCode,
-  DWORD dwNumberOfBytesTransfered,
-  LPOVERLAPPED lpOverlapped
-)
-{
-  LPPACKET lpPacket = CONTAINING_RECORD(lpOverlapped,PACKET,OverLapped);
-
-#if DEBUG_PACKETS
-  D(bug("PacketSendCompletionRoutine %d\n",dwNumberOfBytesTransfered));
-#endif
-
-	lpPacket->bIoComplete = TRUE;
-	// lpPacket->free = TRUE;
-	// PacketFreePacket(lpPacket);
-	recycle_write_packet(lpPacket);
-}
-
-BOOLEAN PacketSendPacket(
-  LPADAPTER   AdapterObject,
-  LPPACKET    lpPacket,
-  BOOLEAN     Sync,
-	BOOLEAN     RecyclingAllowed
-)
-{
-  BOOLEAN  Result;
-
-#if DEBUG_PACKETS
-  D(bug("Packet32: PacketSendPacket bytes=%d, sync=%d\n",lpPacket->Length,Sync));
-#endif
-
-	lpPacket->OverLapped.Offset = 0;
-	lpPacket->OverLapped.OffsetHigh = 0;
-	lpPacket->bIoComplete = FALSE;
-
-	if(Sync) {
-		Result = WriteFile(
-							AdapterObject->hFile,
-							lpPacket->Buffer,
-							lpPacket->Length,
-							&lpPacket->BytesReceived,
-							&lpPacket->OverLapped
-							);
-		if(Result) {
-			Result = GetOverlappedResult(
-									AdapterObject->hFile,
-									&lpPacket->OverLapped,
-									&lpPacket->BytesReceived,
-									TRUE
-									);
-		} else {
-			D(bug("Packet32: PacketSendPacket WriteFile failed, err=%d\n",(int)GetLastError()));
-		}
-		lpPacket->bIoComplete = TRUE;
-		if(RecyclingAllowed) PacketFreePacket(lpPacket);
-#if DEBUG_PACKETS
-		D(bug("Packet32: PacketSendPacket result=%d, bytes=%d\n",(int)Result,(int)lpPacket->BytesReceived));
-#endif
-	} else {
-		// don't care about the result
-		Result = WriteFileEx(
-			AdapterObject->hFile,
-			lpPacket->Buffer,
-			lpPacket->Length,
-			&lpPacket->OverLapped,
-			PacketSendCompletionRoutine
-		);
-#if DEBUG_PACKETS
-		D(bug("Packet32: PacketSendPacket result=%d\n",(int)Result));
-#endif
-		if(!Result && RecyclingAllowed)	{
-			recycle_write_packet(lpPacket);
-		}
-	}
-
-  return Result;
-}
-
-BOOLEAN PacketReceivePacket(
-  LPADAPTER   AdapterObject,
-  LPPACKET    lpPacket,
-  BOOLEAN     Sync
-)
-{
-  BOOLEAN      Result;
-
-	lpPacket->OverLapped.Offset=0;
-	lpPacket->OverLapped.OffsetHigh=0;
-	lpPacket->bIoComplete = FALSE;
-
-#if DEBUG_PACKETS
-	D(bug("Packet32: PacketReceivePacket\n"));
-#endif
-
-	if (Sync) {
-		Result = ReadFile(
-							AdapterObject->hFile,
-							lpPacket->Buffer,
-							lpPacket->Length,
-							&lpPacket->BytesReceived,
-							&lpPacket->OverLapped
-							);
-		if(Result) {
-			Result = GetOverlappedResult(
-									AdapterObject->hFile,
-									&lpPacket->OverLapped,
-									&lpPacket->BytesReceived,
-									TRUE
-									);
-			if(Result)
-				lpPacket->bIoComplete = TRUE;
-			else
-				lpPacket->free = TRUE;
-		}
-	} else {
-		Result = ReadFileEx(
-							AdapterObject->hFile,
-							lpPacket->Buffer,
-							lpPacket->Length,
-							&lpPacket->OverLapped,
-							packet_read_completion
-							);
-	}
-
-	if(!Result) lpPacket->BytesReceived = 0;
-
-#if DEBUG_PACKETS
-  D(bug("Packet32: PacketReceivePacket got %d bytes, result=%d\n",lpPacket->BytesReceived,(int)Result));
-#endif
-
-  return Result;
-}
-
-BOOLEAN PacketRequest(
-	LPADAPTER	lpAdapterObject,
-	LPPACKET	lpPacket,
-	BOOLEAN		bSet
-)
-{
-	BOOLEAN	Result = FALSE;
-
-	Result = PacketDeviceIoControl(
-				lpAdapterObject,
-				lpPacket,
-				(ULONG) ((bSet) ? IOCTL_PROTOCOL_SET_OID : IOCTL_PROTOCOL_QUERY_OID),
-				TRUE );
-
-	if ( lpPacket->BytesReceived == 0 ) {
-		D(bug( "Packet32: Ndis returned error to OID\r\n"));
-		Result = FALSE;
-	}
-	return Result;
-}
-
-LPPACKET PacketQueryOid(
-	LPADAPTER	lpAdapter,
-	ULONG		ulOid,
-	ULONG		ulLength
-)
-{
-	ULONG		ioctl;
-	LPPACKET lpPacket;
-
-#define pOidData ((PPACKET_OID_DATA)(lpPacket->Buffer))
-
-	lpPacket = PacketAllocatePacket( lpAdapter, sizeof(PACKET_OID_DATA)-1+ulLength );
-
-	if( lpPacket ) {
-		ioctl = IOCTL_PROTOCOL_QUERY_OID;
-		pOidData->Oid    = ulOid;
-		pOidData->Length = ulLength;
-
-		if (PacketRequest( lpAdapter, lpPacket, FALSE )) {
-			return lpPacket;
-		}
-		PacketFreePacket( lpPacket );
-	}
-
-#undef pOidData
-
-	return 0;
-}
-
-BOOLEAN PacketGetMAC( LPADAPTER AdapterObject, LPBYTE address, BOOL permanent )
-{
-	BOOLEAN    Status;
-	LPPACKET lpPacket;
-
-	lpPacket = PacketQueryOid(
-			AdapterObject,
-			permanent ? OID_802_3_PERMANENT_ADDRESS : OID_802_3_CURRENT_ADDRESS,
-			ETH_802_3_ADDRESS_LENGTH
-	);
-	if(lpPacket) {
-		memcpy( address,
-				((BYTE *)(lpPacket->Buffer)) + sizeof(PACKET_OID_DATA) - 1,
-				ETH_802_3_ADDRESS_LENGTH );
-		PacketFreePacket( lpPacket );
-		Status = TRUE;
-	} else {
-		Status = FALSE;
-	}
-
-	return Status;
-}
-
-// There are other ways to do this.
-
-BOOLEAN PacketAddMulticast( LPADAPTER AdapterObject, LPBYTE address )
-{
-	BOOLEAN Status = FALSE;
-	LPBYTE		p;
-	int				 i, count;
-	LPPACKET lpPacket;
-
-	D(bug("PacketAddMulticast\n"));
-
-	/*
-	if(packet_filter & (NDIS_PACKET_TYPE_ALL_MULTICAST|NDIS_PACKET_TYPE_PROMISCUOUS)) {
-		D(bug("PacketAddMulticast: already listening for all multicast\n"));
-		return TRUE;
-	}
-	*/
-
-	lpPacket = PacketQueryOid( AdapterObject, OID_802_3_MULTICAST_LIST, MAX_MULTICAST_SZ );
-#define OidData	((PPACKET_OID_DATA)(lpPacket->Buffer))
-
-	if(lpPacket) {
-		count = OidData->Length / ETH_802_3_ADDRESS_LENGTH;
-
-		D(bug("PacketAddMulticast: %d old addresses\n",count));
-
-		p = (LPBYTE)OidData->Data;
-
-		for( i=0; i<count; i++ ) {
-			if(memcmp(p,address,ETH_802_3_ADDRESS_LENGTH) == 0) {
-				// This multicast is already defined -- error or not?
-				Status = TRUE;
-				D(bug("PacketAddMulticast: address already defined\n"));
-				break;
-			}
-			p += ETH_802_3_ADDRESS_LENGTH;
-		}
-		if(i == count) {
-			if(i >= MAX_MULTICAST) {
-				D(bug("PacketAddMulticast: too many addresses\n"));
-				Status = FALSE;
-			} else {
-				D(bug("PacketAddMulticast: adding a new address\n"));
-
-				// ULONG IoCtlBufferLength = (sizeof(PACKET_OID_DATA)+ETH_802_3_ADDRESS_LENGTH*1-1);
-				ULONG IoCtlBufferLength = (sizeof(PACKET_OID_DATA)+ETH_802_3_ADDRESS_LENGTH*(count+1)-1);
-
-				LPPACKET lpPacket2 = PacketAllocatePacket( AdapterObject, IoCtlBufferLength );
-#define OidData2	((PPACKET_OID_DATA)(lpPacket2->Buffer))
-				if ( lpPacket2 ) {
-					OidData2->Oid = OID_802_3_MULTICAST_LIST;
-
-					// OidData2->Length = ETH_802_3_ADDRESS_LENGTH*1;
-					// memcpy( OidData2->Data, address, ETH_802_3_ADDRESS_LENGTH );
-
-					memcpy( OidData2->Data, OidData->Data, ETH_802_3_ADDRESS_LENGTH*count );
-					memcpy( OidData2->Data+ETH_802_3_ADDRESS_LENGTH*count, address, ETH_802_3_ADDRESS_LENGTH );
-					OidData2->Length = ETH_802_3_ADDRESS_LENGTH*(count+1);
-
-					Status = PacketRequest( AdapterObject, lpPacket2, TRUE );
-					PacketFreePacket( lpPacket2 );
-				}
-#undef OidData2
-			}
-		}
-		PacketFreePacket( lpPacket );
-	}
-
-	#undef OidData
-
-	// return Status;
-	return TRUE;
-}
-
-// It seems that the last multicast address is never deleted. Why?
-// Don't know the reason, but luckily this is not fatal.
-// Hard to examine return codes. See NE2000 sources, always returns ok.
-
-BOOLEAN PacketDelMulticast( LPADAPTER AdapterObject, LPBYTE address )
-{
-	BOOLEAN Status = FALSE;
-	LPBYTE		 p;
-	int				 i, count;
-	LPPACKET lpPacket, lpPacket2;
-
-	D(bug("PacketDelMulticast\n"));
-
-	if(packet_filter & (NDIS_PACKET_TYPE_ALL_MULTICAST|NDIS_PACKET_TYPE_PROMISCUOUS)) {
-		D(bug("PacketDelMulticast: already listening for all multicast\n"));
-		return TRUE;
-	}
-
-	lpPacket = PacketQueryOid( AdapterObject, OID_802_3_MULTICAST_LIST, MAX_MULTICAST_SZ );
-#define OidData	((PPACKET_OID_DATA)(lpPacket->Buffer))
-
-	if(lpPacket) {
-		count = OidData->Length / ETH_802_3_ADDRESS_LENGTH;
-
-		D(bug("PacketDelMulticast: %d old addresses\n",count));
-
-		Status = FALSE;
-
-		p = (LPBYTE)OidData->Data;
-
-		for( i=0; i<count; i++ ) {
-			int tail_len;
-			if(memcmp(p,address,ETH_802_3_ADDRESS_LENGTH) == 0) {
-				D(bug("PacketDelMulticast: address found, deleting\n"));
-				ULONG IoCtlBufferLength = (sizeof(PACKET_OID_DATA)+ETH_802_3_ADDRESS_LENGTH*(count-1)-1);
-				lpPacket2 = PacketAllocatePacket( AdapterObject, IoCtlBufferLength );
-#define OidData2	((PPACKET_OID_DATA)(lpPacket2->Buffer))
-				if ( lpPacket2 ) {
-					OidData2->Oid = OID_802_3_MULTICAST_LIST;
-					OidData2->Length = ETH_802_3_ADDRESS_LENGTH*(count-1);
-					tail_len = ETH_802_3_ADDRESS_LENGTH * (count-i-1);
-					if(tail_len) memmove( p, p+ETH_802_3_ADDRESS_LENGTH, tail_len );
-					if(OidData2->Length) memcpy( OidData2->Data, OidData->Data, OidData2->Length );
-					if(count == 1) memset( OidData2->Data, 0, ETH_802_3_ADDRESS_LENGTH ); // eh...
-					Status = PacketRequest( AdapterObject, lpPacket2, TRUE );
-					PacketFreePacket( lpPacket2 );
-					D(bug("PacketDelMulticast: PacketRequest returned status 0x%X, last error = 0x%X\n",Status,GetLastError()));
-				}
-				break;
-#undef OidData2
-			}
-			p += ETH_802_3_ADDRESS_LENGTH;
-		}
-		if( i == count ) {
-			D(bug("PacketDelMulticast: cannot delete, was not defined\n"));
-		}
-		PacketFreePacket( lpPacket );
-#undef OidData
-	}
-
-	// return Status;
-	return TRUE;
-}
-
-BOOLEAN PacketSetFilter( LPADAPTER AdapterObject, ULONG Filter )
-{
-	BOOLEAN    Status;
-	ULONG		IoCtlBufferLength = (sizeof(PACKET_OID_DATA)+sizeof(ULONG)-1);
-	LPPACKET	lpPacket;
-
-	lpPacket = PacketAllocatePacket( AdapterObject, IoCtlBufferLength );
-#define lpOidData	((PPACKET_OID_DATA)(lpPacket->Buffer))
-
-	if ( lpPacket ) {
-		lpOidData->Oid = OID_GEN_CURRENT_PACKET_FILTER;
-		lpOidData->Length = sizeof(ULONG);
-		*((PULONG)lpOidData->Data) = Filter;
-		Status = PacketRequest( AdapterObject, lpPacket, TRUE );
-		PacketFreePacket( lpPacket );
-	} else {
-		Status = FALSE;
-	}
-
-#undef lpOidData
-
-	return Status;
-}
-
-BOOLEAN StartPacketDriver( LPCTSTR ServiceName )
-{
-  BOOLEAN Status = FALSE;
-
-  SC_HANDLE  SCManagerHandle;
-  SC_HANDLE  SCServiceHandle;
-
-  SCManagerHandle = OpenSCManager(
-                    NULL,
-                    NULL,
-                    SC_MANAGER_ALL_ACCESS);
-
-  if(SCManagerHandle == NULL) {
-    D(bug("Could not open Service Control Manager\r\n"));
-  } else {
-    SCServiceHandle = OpenService(SCManagerHandle,ServiceName,SERVICE_START);
-    if (SCServiceHandle == NULL) {
-      D(bug(TEXT("Could not open service %s\r\n"),ServiceName));
-    } else {
-			Status = StartService( SCServiceHandle, 0, NULL );
-			if(!Status) {
-				if (GetLastError()==ERROR_SERVICE_ALREADY_RUNNING) {
-					Status = TRUE;
-				}
-			}
-			BOOL waiting = TRUE;
-			// loop until the service is fully started.
-      while (waiting) {
-		    SERVICE_STATUS ServiceStatus;
-        if (QueryServiceStatus(SCServiceHandle, &ServiceStatus)) {
-					switch(ServiceStatus.dwCurrentState) {
-						case SERVICE_RUNNING:
-							waiting = FALSE;
-							Status = TRUE;
-							break;
-						case SERVICE_START_PENDING:
-							Sleep(500);
-							break;
-						default:
-							waiting = FALSE;
-							break;
-					}
-				} else {
-					waiting = FALSE;
-				}
-		  }
-		  CloseServiceHandle(SCServiceHandle);
-		}
-		CloseServiceHandle(SCManagerHandle);
-  }
-  return Status;
-}
-
-ULONG PacketGetAdapterNames( LPADAPTER lpAdapter, LPTSTR pStr, PULONG BufferSize )
-{
-  LONG Status;
-
-	HKEY hKey;
-	DWORD RegType;
-
-	Status = RegOpenKey(
-			HKEY_LOCAL_MACHINE,
-			TEXT("SYSTEM\\CurrentControlSet\\Services\\B2Ether\\Linkage"),
-			&hKey
-	);
-	if( Status == ERROR_SUCCESS ) {
-		Status = RegQueryValueEx(
-								hKey,
-								TEXT("Export"),
-								NULL,
-								&RegType,
-								(LPBYTE)pStr,
-								BufferSize
-								);
-		RegCloseKey(hKey);
-	}
-
-  return Status;
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-#if DEBUG
-#pragma optimize("",on)
-#endif
\ No newline at end of file
+/*
+ *  packet32.cpp
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include <windows.h>
+#include <windowsx.h>
+#include <winioctl.h>
+#include "cpu_emulation.h"
+typedef unsigned long ULONG_PTR, *PULONG_PTR;
+
+// VC6 does not have this, Platform SDK has.
+// In case of errors, try to comment out, the needed
+// definitions are below (#ifndef _NTDDNDIS_)
+
+// Most people don't have the Platform SDK, so I take this one out.
+// #include <ntddndis.h>
+
+#include "inc/ntddpack.h"
+
+#include "ether.h"
+#include "ether_defs.h"
+#include "b2ether/multiopt.h"
+#include "b2ether/inc/b2ether_hl.h"
+
+
+
+#ifndef _NTDDNDIS_
+#define NDIS_PACKET_TYPE_DIRECTED					0x00000001
+#define NDIS_PACKET_TYPE_MULTICAST				0x00000002
+#define NDIS_PACKET_TYPE_ALL_MULTICAST		0x00000004
+#define NDIS_PACKET_TYPE_BROADCAST				0x00000008
+#define NDIS_PACKET_TYPE_SOURCE_ROUTING		0x00000010
+#define NDIS_PACKET_TYPE_PROMISCUOUS			0x00000020
+
+#define OID_802_3_PERMANENT_ADDRESS				0x01010101
+#define OID_802_3_CURRENT_ADDRESS					0x01010102
+#define OID_802_3_MULTICAST_LIST					0x01010103
+
+#define OID_GEN_CURRENT_PACKET_FILTER			0x0001010E
+#endif
+
+#define DEBUG_PACKETS 0
+#define DEBUG 0
+#include "debug.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#define MAX_MULTICAST 100
+#define MAX_MULTICAST_SZ (20*ETH_802_3_ADDRESS_LENGTH)
+
+static int os = VER_PLATFORM_WIN32_WINDOWS;
+
+static ULONG packet_filter = 0;
+
+
+LPADAPTER PacketOpenAdapter( LPCSTR AdapterName, int16 mode )
+{
+  LPADAPTER  lpAdapter;
+  BOOLEAN    Result = TRUE;
+	OSVERSIONINFO osv;
+
+  D(bug("Packet32: PacketOpenAdapter\n"));
+
+	osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+	if(GetVersionEx( &osv )) os = osv.dwPlatformId;
+
+	if(os == VER_PLATFORM_WIN32_NT) {
+		// May fail if user is not an Administrator.
+		StartPacketDriver( "B2ether" );
+	}
+
+  lpAdapter = (LPADAPTER)GlobalAllocPtr( GMEM_MOVEABLE|GMEM_ZEROINIT, sizeof(ADAPTER) );
+  if (lpAdapter==NULL) {
+      D(bug("Packet32: PacketOpenAdapter GlobalAlloc Failed\n"));
+      return NULL;
+  }
+
+	if(os == VER_PLATFORM_WIN32_NT) {
+		char device_name[256];
+		wsprintf(  lpAdapter->SymbolicLink, "\\\\.\\B2ether_%s", AdapterName );
+		wsprintf(  device_name, "\\Device\\B2ether_%s", AdapterName );
+
+		// Work around one subtle NT4 bug.
+		DefineDosDevice(
+				DDD_REMOVE_DEFINITION,
+				&lpAdapter->SymbolicLink[4],
+				NULL
+		);
+		DefineDosDevice(
+				DDD_RAW_TARGET_PATH,
+				&lpAdapter->SymbolicLink[4],
+				device_name
+		);
+	} else {
+		wsprintf(  lpAdapter->SymbolicLink, "\\\\.\\B2ether" );
+	}
+
+	packet_filter = NDIS_PACKET_TYPE_DIRECTED |
+									NDIS_PACKET_TYPE_MULTICAST |
+									NDIS_PACKET_TYPE_BROADCAST;
+
+	if(mode == ETHER_MULTICAST_ALL) packet_filter |= NDIS_PACKET_TYPE_ALL_MULTICAST;
+	if(mode == ETHER_MULTICAST_PROMISCUOUS) packet_filter |= NDIS_PACKET_TYPE_PROMISCUOUS;
+
+  if (Result) {
+    lpAdapter->hFile = CreateFile(lpAdapter->SymbolicLink,
+                         GENERIC_WRITE | GENERIC_READ,
+                         0,
+                         NULL,
+												 // (os == VER_PLATFORM_WIN32_NT) ? CREATE_ALWAYS : OPEN_EXISTING,
+												 OPEN_EXISTING,
+                         FILE_FLAG_OVERLAPPED,
+                         0
+                         );
+    if (lpAdapter->hFile != INVALID_HANDLE_VALUE) {
+			if(*AdapterName && strcmp(AdapterName,"<None>") != 0) {
+				if(os == VER_PLATFORM_WIN32_WINDOWS) {
+					PacketSelectAdapterByName( lpAdapter, AdapterName );
+				}
+				PacketSetFilter( lpAdapter, packet_filter );
+			}
+      return lpAdapter;
+    }
+  }
+  D(bug("Packet32: PacketOpenAdapter Could not open adapter\n"));
+  GlobalFreePtr( lpAdapter );
+  return NULL;
+}
+
+VOID PacketCloseAdapter( LPADAPTER lpAdapter )
+{
+  D(bug("Packet32: PacketCloseAdapter\n"));
+
+	if(lpAdapter) {
+		if(lpAdapter->hFile) {
+			CloseHandle(lpAdapter->hFile);
+		}
+		GlobalFreePtr(lpAdapter);
+	}
+}
+
+LPPACKET PacketAllocatePacket( LPADAPTER AdapterObject, UINT Length )
+{
+  LPPACKET lpPacket;
+
+  lpPacket = (LPPACKET)GlobalAllocPtr( GMEM_MOVEABLE|GMEM_ZEROINIT, sizeof(PACKET) );
+  if(lpPacket==NULL) {
+      D(bug("Packet32: PacketAllocatePacket: GlobalAlloc Failed\n"));
+      return NULL;
+  }
+
+	lpPacket->OverLapped.hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
+	if(!lpPacket->OverLapped.hEvent) {
+			D(bug("Packet32: PacketAllocatePacket: CreateEvent Failed\n"));
+			GlobalFreePtr(lpPacket);
+			return NULL;
+	}
+
+	lpPacket->Buffer = GlobalAllocPtr(GMEM_MOVEABLE,2048); // 1514
+	if(!lpPacket->Buffer) {
+      D(bug("Packet32: PacketAllocatePacket: GlobalAllocPtr Failed\n"));
+		  if(lpPacket->OverLapped.hEvent) CloseHandle(lpPacket->OverLapped.hEvent);
+      GlobalFreePtr(lpPacket);
+      return NULL;
+	}
+
+  lpPacket->OverLapped.Offset = 0;
+  lpPacket->OverLapped.OffsetHigh = 0;
+	lpPacket->Length = Length;
+	lpPacket->BytesReceived	= 0;
+	lpPacket->bIoComplete	= FALSE;
+	lpPacket->free = TRUE;
+
+  return lpPacket;
+}
+
+VOID PacketFreePacket( LPPACKET lpPacket )
+{
+	if(lpPacket) {
+		if(lpPacket->Buffer) GlobalFreePtr(lpPacket->Buffer);
+		if(lpPacket->OverLapped.hEvent) CloseHandle(lpPacket->OverLapped.hEvent);
+		GlobalFreePtr(lpPacket);
+	}
+}
+
+BOOLEAN PacketDeviceIoControl(
+	LPADAPTER	lpAdapterObject,
+	LPPACKET	lpPacket,
+	ULONG			ulIoctl,
+	BOOLEAN		bSync
+)
+{
+	BOOLEAN Result;
+
+	lpPacket->OverLapped.Offset		= 0;
+	lpPacket->OverLapped.OffsetHigh	= 0;
+	lpPacket->BytesReceived		= 0;
+
+	if ( !ResetEvent( lpPacket->OverLapped.hEvent ) )  {
+		lpPacket->bIoComplete = FALSE;
+		D(bug( "Packet32: PacketDeviceIoControl failed to reset event\r\n", GetLastError() ));
+		return FALSE;
+	}
+
+	Result = DeviceIoControl(
+		lpAdapterObject->hFile,
+		ulIoctl,
+		lpPacket->Buffer,
+		lpPacket->Length,
+		lpPacket->Buffer,
+		lpPacket->Length,
+		&(lpPacket->BytesReceived),
+		&(lpPacket->OverLapped) );
+
+	if( !Result && bSync ) {
+		if (GetLastError() == ERROR_IO_PENDING) {
+			Result = GetOverlappedResult(	lpAdapterObject->hFile,
+											&(lpPacket->OverLapped),
+											&(lpPacket->BytesReceived),
+											TRUE );
+		} else {
+			D(bug( "Packet32: unsupported API call returned error 0x%x\r\n", GetLastError() ));
+		}
+	}
+	lpPacket->bIoComplete = Result;
+	return Result;
+}
+
+VOID CALLBACK PacketSendCompletionRoutine(
+  DWORD dwErrorCode,
+  DWORD dwNumberOfBytesTransfered,
+  LPOVERLAPPED lpOverlapped
+)
+{
+  LPPACKET lpPacket = CONTAINING_RECORD(lpOverlapped,PACKET,OverLapped);
+
+#if DEBUG_PACKETS
+  D(bug("PacketSendCompletionRoutine %d\n",dwNumberOfBytesTransfered));
+#endif
+
+	lpPacket->bIoComplete = TRUE;
+	// lpPacket->free = TRUE;
+	// PacketFreePacket(lpPacket);
+	recycle_write_packet(lpPacket);
+}
+
+BOOLEAN PacketSendPacket(
+  LPADAPTER   AdapterObject,
+  LPPACKET    lpPacket,
+  BOOLEAN     Sync,
+	BOOLEAN     RecyclingAllowed
+)
+{
+  BOOLEAN  Result;
+
+#if DEBUG_PACKETS
+  D(bug("Packet32: PacketSendPacket bytes=%d, sync=%d\n",lpPacket->Length,Sync));
+#endif
+
+	if(os == VER_PLATFORM_WIN32_NT) {
+		lpPacket->OverLapped.Offset = 0;
+		lpPacket->OverLapped.OffsetHigh = 0;
+		lpPacket->bIoComplete = FALSE;
+
+		if(Sync) {
+			Result = WriteFile(
+								AdapterObject->hFile,
+								lpPacket->Buffer,
+								lpPacket->Length,
+								&lpPacket->BytesReceived,
+								&lpPacket->OverLapped
+								);
+			if(Result) {
+				Result = GetOverlappedResult(
+									 AdapterObject->hFile,
+									 &lpPacket->OverLapped,
+									 &lpPacket->BytesReceived,
+									 TRUE
+									 );
+			} else {
+				D(bug("Packet32: PacketSendPacket WriteFile failed, err=%d\n",(int)GetLastError()));
+			}
+			lpPacket->bIoComplete = TRUE;
+			if(RecyclingAllowed) PacketFreePacket(lpPacket);
+#if DEBUG_PACKETS
+			D(bug("Packet32: PacketSendPacket result=%d, bytes=%d\n",(int)Result,(int)lpPacket->BytesReceived));
+#endif
+		} else {
+			// don't care about the result
+			Result = WriteFileEx(
+				AdapterObject->hFile,
+				lpPacket->Buffer,
+				lpPacket->Length,
+				&lpPacket->OverLapped,
+				PacketSendCompletionRoutine
+			);
+#if DEBUG_PACKETS
+			D(bug("Packet32: PacketSendPacket result=%d\n",(int)Result));
+#endif
+			if(!Result && RecyclingAllowed)	{
+				recycle_write_packet(lpPacket);
+			}
+		}
+	} else {
+		// Now: make writes always synchronous under Win9x
+		Sync = TRUE;
+		Result = PacketDeviceIoControl( AdapterObject,
+										lpPacket,
+										IOCTL_PROTOCOL_WRITE,
+										Sync );
+		if(RecyclingAllowed) recycle_write_packet(lpPacket);
+	}
+
+  return Result;
+}
+
+BOOLEAN PacketReceivePacket(
+  LPADAPTER   AdapterObject,
+  LPPACKET    lpPacket,
+  BOOLEAN     Sync
+)
+{
+  BOOLEAN      Result;
+
+	if(os == VER_PLATFORM_WIN32_NT) {
+		lpPacket->OverLapped.Offset=0;
+		lpPacket->OverLapped.OffsetHigh=0;
+		lpPacket->bIoComplete = FALSE;
+
+#if DEBUG_PACKETS
+		D(bug("Packet32: PacketReceivePacket\n"));
+#endif
+
+		if (Sync) {
+			Result = ReadFile(
+								AdapterObject->hFile,
+								lpPacket->Buffer,
+								lpPacket->Length,
+								&lpPacket->BytesReceived,
+								&lpPacket->OverLapped
+								);
+			if(Result) {
+				Result = GetOverlappedResult(
+									 AdapterObject->hFile,
+									 &lpPacket->OverLapped,
+									 &lpPacket->BytesReceived,
+									 TRUE
+									 );
+				if(Result)
+					lpPacket->bIoComplete = TRUE;
+				else
+					lpPacket->free = TRUE;
+			}
+		} else {
+			Result = ReadFileEx(
+								AdapterObject->hFile,
+								lpPacket->Buffer,
+								lpPacket->Length,
+								&lpPacket->OverLapped,
+								packet_read_completion
+								);
+		}
+
+		if(!Result) lpPacket->BytesReceived = 0;
+	} else {
+		Result = PacketDeviceIoControl(	AdapterObject,
+										lpPacket,
+										IOCTL_PROTOCOL_READ,
+										Sync );
+		if( !Result && !Sync ) {
+			if (GetLastError() == ERROR_IO_PENDING) {
+				Result = TRUE;
+			}
+		}
+	}
+
+#if DEBUG_PACKETS
+  D(bug("Packet32: PacketReceivePacket got %d bytes, result=%d\n",lpPacket->BytesReceived,(int)Result));
+#endif
+
+  return Result;
+}
+
+BOOLEAN PacketRequest(
+	LPADAPTER	lpAdapterObject,
+	LPPACKET	lpPacket,
+	BOOLEAN		bSet
+)
+{
+	BOOLEAN	Result = FALSE;
+
+	Result = PacketDeviceIoControl(
+				lpAdapterObject,
+				lpPacket,
+				(ULONG) ((bSet) ? IOCTL_PROTOCOL_SET_OID : IOCTL_PROTOCOL_QUERY_OID),
+				TRUE );
+
+	if ( lpPacket->BytesReceived == 0 ) {
+		D(bug( "Packet32: Ndis returned error to OID\r\n"));
+		Result = FALSE;
+	}
+	return Result;
+}
+
+LPPACKET PacketQueryOid(
+	LPADAPTER	lpAdapter,
+	ULONG		ulOid,
+	ULONG		ulLength
+)
+{
+	ULONG		ioctl;
+	LPPACKET lpPacket;
+
+#define pOidData ((PPACKET_OID_DATA)(lpPacket->Buffer))
+
+	lpPacket = PacketAllocatePacket( lpAdapter, sizeof(PACKET_OID_DATA)-1+ulLength );
+
+	if( lpPacket ) {
+		ioctl = IOCTL_PROTOCOL_QUERY_OID;
+		pOidData->Oid    = ulOid;
+		pOidData->Length = ulLength;
+
+		if (PacketRequest( lpAdapter, lpPacket, FALSE )) {
+			return lpPacket;
+		}
+		PacketFreePacket( lpPacket );
+	}
+
+#undef pOidData
+
+	return 0;
+}
+
+BOOLEAN PacketGetMAC( LPADAPTER AdapterObject, LPBYTE address, BOOL permanent )
+{
+	BOOLEAN    Status;
+	LPPACKET lpPacket;
+
+	lpPacket = PacketQueryOid(
+			AdapterObject,
+			permanent ? OID_802_3_PERMANENT_ADDRESS : OID_802_3_CURRENT_ADDRESS,
+			ETH_802_3_ADDRESS_LENGTH
+	);
+	if(lpPacket) {
+		memcpy( address,
+				((BYTE *)(lpPacket->Buffer)) + sizeof(PACKET_OID_DATA) - 1,
+				ETH_802_3_ADDRESS_LENGTH );
+		PacketFreePacket( lpPacket );
+		Status = TRUE;
+	} else {
+		Status = FALSE;
+	}
+
+	return Status;
+}
+
+// There are other ways to do this.
+
+BOOLEAN PacketAddMulticast( LPADAPTER AdapterObject, LPBYTE address )
+{
+	BOOLEAN Status = FALSE;
+	LPBYTE		p;
+	int				 i, count;
+	LPPACKET lpPacket;
+
+	D(bug("PacketAddMulticast\n"));
+
+	/*
+	if(packet_filter & (NDIS_PACKET_TYPE_ALL_MULTICAST|NDIS_PACKET_TYPE_PROMISCUOUS)) {
+		D(bug("PacketAddMulticast: already listening for all multicast\n"));
+		return TRUE;
+	}
+	*/
+
+	lpPacket = PacketQueryOid( AdapterObject, OID_802_3_MULTICAST_LIST, MAX_MULTICAST_SZ );
+#define OidData	((PPACKET_OID_DATA)(lpPacket->Buffer))
+
+	if(lpPacket) {
+		count = OidData->Length / ETH_802_3_ADDRESS_LENGTH;
+
+		D(bug("PacketAddMulticast: %d old addresses\n",count));
+
+		p = (LPBYTE)OidData->Data;
+
+		for( i=0; i<count; i++ ) {
+			if(memcmp(p,address,ETH_802_3_ADDRESS_LENGTH) == 0) {
+				// This multicast is already defined -- error or not?
+				Status = TRUE;
+				D(bug("PacketAddMulticast: address already defined\n"));
+				break;
+			}
+			p += ETH_802_3_ADDRESS_LENGTH;
+		}
+		if(i == count) {
+			if(i >= MAX_MULTICAST) {
+				D(bug("PacketAddMulticast: too many addresses\n"));
+				Status = FALSE;
+			} else {
+				D(bug("PacketAddMulticast: adding a new address\n"));
+
+				// ULONG IoCtlBufferLength = (sizeof(PACKET_OID_DATA)+ETH_802_3_ADDRESS_LENGTH*1-1);
+				ULONG IoCtlBufferLength = (sizeof(PACKET_OID_DATA)+ETH_802_3_ADDRESS_LENGTH*(count+1)-1);
+
+				LPPACKET lpPacket2 = PacketAllocatePacket( AdapterObject, IoCtlBufferLength );
+#define OidData2	((PPACKET_OID_DATA)(lpPacket2->Buffer))
+				if ( lpPacket2 ) {
+					OidData2->Oid = OID_802_3_MULTICAST_LIST;
+
+					// OidData2->Length = ETH_802_3_ADDRESS_LENGTH*1;
+					// memcpy( OidData2->Data, address, ETH_802_3_ADDRESS_LENGTH );
+
+					memcpy( OidData2->Data, OidData->Data, ETH_802_3_ADDRESS_LENGTH*count );
+					memcpy( OidData2->Data+ETH_802_3_ADDRESS_LENGTH*count, address, ETH_802_3_ADDRESS_LENGTH );
+					OidData2->Length = ETH_802_3_ADDRESS_LENGTH*(count+1);
+
+					Status = PacketRequest( AdapterObject, lpPacket2, TRUE );
+					PacketFreePacket( lpPacket2 );
+				}
+#undef OidData2
+			}
+		}
+		PacketFreePacket( lpPacket );
+	}
+
+	#undef OidData
+
+	// return Status;
+	return TRUE;
+}
+
+// It seems that the last multicast address is never deleted. Why?
+// Don't know the reason, but luckily this is not fatal.
+// Hard to examine return codes. See NE2000 sources, always returns ok.
+
+BOOLEAN PacketDelMulticast( LPADAPTER AdapterObject, LPBYTE address )
+{
+	BOOLEAN Status = FALSE;
+	LPBYTE		 p;
+	int				 i, count;
+	LPPACKET lpPacket, lpPacket2;
+
+	D(bug("PacketDelMulticast\n"));
+
+	if(packet_filter & (NDIS_PACKET_TYPE_ALL_MULTICAST|NDIS_PACKET_TYPE_PROMISCUOUS)) {
+		D(bug("PacketDelMulticast: already listening for all multicast\n"));
+		return TRUE;
+	}
+
+	lpPacket = PacketQueryOid( AdapterObject, OID_802_3_MULTICAST_LIST, MAX_MULTICAST_SZ );
+#define OidData	((PPACKET_OID_DATA)(lpPacket->Buffer))
+
+	if(lpPacket) {
+		count = OidData->Length / ETH_802_3_ADDRESS_LENGTH;
+
+		D(bug("PacketDelMulticast: %d old addresses\n",count));
+
+		Status = FALSE;
+
+		p = (LPBYTE)OidData->Data;
+
+		for( i=0; i<count; i++ ) {
+			int tail_len;
+			if(memcmp(p,address,ETH_802_3_ADDRESS_LENGTH) == 0) {
+				D(bug("PacketDelMulticast: address found, deleting\n"));
+				ULONG IoCtlBufferLength = (sizeof(PACKET_OID_DATA)+ETH_802_3_ADDRESS_LENGTH*(count-1)-1);
+				lpPacket2 = PacketAllocatePacket( AdapterObject, IoCtlBufferLength );
+#define OidData2	((PPACKET_OID_DATA)(lpPacket2->Buffer))
+				if ( lpPacket2 ) {
+					OidData2->Oid = OID_802_3_MULTICAST_LIST;
+					OidData2->Length = ETH_802_3_ADDRESS_LENGTH*(count-1);
+					tail_len = ETH_802_3_ADDRESS_LENGTH * (count-i-1);
+					if(tail_len) memmove( p, p+ETH_802_3_ADDRESS_LENGTH, tail_len );
+					if(OidData2->Length) memcpy( OidData2->Data, OidData->Data, OidData2->Length );
+					if(count == 1) memset( OidData2->Data, 0, ETH_802_3_ADDRESS_LENGTH ); // eh...
+					Status = PacketRequest( AdapterObject, lpPacket2, TRUE );
+					PacketFreePacket( lpPacket2 );
+					D(bug("PacketDelMulticast: PacketRequest returned status 0x%X, last error = 0x%X\n",Status,GetLastError()));
+				}
+				break;
+#undef OidData2
+			}
+			p += ETH_802_3_ADDRESS_LENGTH;
+		}
+		if( i == count ) {
+			D(bug("PacketDelMulticast: cannot delete, was not defined\n"));
+		}
+		PacketFreePacket( lpPacket );
+#undef OidData
+	}
+
+	// return Status;
+	return TRUE;
+}
+
+BOOLEAN PacketSetFilter( LPADAPTER AdapterObject, ULONG Filter )
+{
+	BOOLEAN    Status;
+	ULONG		IoCtlBufferLength = (sizeof(PACKET_OID_DATA)+sizeof(ULONG)-1);
+	LPPACKET	lpPacket;
+
+	lpPacket = PacketAllocatePacket( AdapterObject, IoCtlBufferLength );
+#define lpOidData	((PPACKET_OID_DATA)(lpPacket->Buffer))
+
+	if ( lpPacket ) {
+		lpOidData->Oid = OID_GEN_CURRENT_PACKET_FILTER;
+		lpOidData->Length = sizeof(ULONG);
+		*((PULONG)lpOidData->Data) = Filter;
+		Status = PacketRequest( AdapterObject, lpPacket, TRUE );
+		PacketFreePacket( lpPacket );
+	} else {
+		Status = FALSE;
+	}
+
+#undef lpOidData
+
+	return Status;
+}
+
+BOOLEAN StartPacketDriver( LPTSTR ServiceName )
+{
+  BOOLEAN Status = FALSE;
+
+  SC_HANDLE  SCManagerHandle;
+  SC_HANDLE  SCServiceHandle;
+
+  SCManagerHandle = OpenSCManager(
+                    NULL,
+                    NULL,
+                    SC_MANAGER_ALL_ACCESS);
+
+  if(SCManagerHandle == NULL) {
+    D(bug("Could not open Service Control Manager\r\n"));
+  } else {
+    SCServiceHandle = OpenService(SCManagerHandle,ServiceName,SERVICE_START);
+    if (SCServiceHandle == NULL) {
+      D(bug("Could not open service %s\r\n",ServiceName));
+    } else {
+			Status = StartService( SCServiceHandle, 0, NULL );
+			if(!Status) {
+				if (GetLastError()==ERROR_SERVICE_ALREADY_RUNNING) {
+					Status = TRUE;
+				}
+			}
+			BOOL waiting = TRUE;
+			// loop until the service is fully started.
+      while (waiting) {
+		    SERVICE_STATUS ServiceStatus;
+        if (QueryServiceStatus(SCServiceHandle, &ServiceStatus)) {
+					switch(ServiceStatus.dwCurrentState) {
+						case SERVICE_RUNNING:
+							waiting = FALSE;
+							Status = TRUE;
+							break;
+						case SERVICE_START_PENDING:
+							Sleep(500);
+							break;
+						default:
+							waiting = FALSE;
+							break;
+					}
+				} else {
+					waiting = FALSE;
+				}
+      }
+		  CloseServiceHandle(SCServiceHandle);
+		}
+		CloseServiceHandle(SCManagerHandle);
+  }
+  return Status;
+}
+
+ULONG PacketGetAdapterNames( LPADAPTER lpAdapter, PTSTR pStr, PULONG BufferSize )
+{
+  LONG Status;
+
+	if(os == VER_PLATFORM_WIN32_NT) {
+		HKEY hKey;
+	  DWORD RegType;
+
+		Status = RegOpenKey(
+				HKEY_LOCAL_MACHINE,
+				"SYSTEM\\CurrentControlSet\\Services\\B2Ether\\Linkage",
+				&hKey
+		);
+		if( Status == ERROR_SUCCESS ) {
+			Status = RegQueryValueEx(
+								 hKey,
+								 "Export",
+								 NULL,
+								 &RegType,
+								 (LPBYTE)pStr,
+								 BufferSize
+								 );
+			RegCloseKey(hKey);
+		}
+	} else {
+    if (lpAdapter && lpAdapter->hFile != INVALID_HANDLE_VALUE) {
+			LPPACKET Packet = PacketAllocatePacket( lpAdapter, *BufferSize );
+			if(Packet) {
+				memset( pStr, 0, *BufferSize );
+				Packet->Buffer = (PVOID)pStr;
+				Packet->Length = *BufferSize;
+				Status = PacketDeviceIoControl(
+						lpAdapter,
+						Packet,
+						(ULONG)IOCTL_PROTOCOL_MACNAME,
+						TRUE
+				);
+				if(Status) {
+					while(*pStr) {
+						if(*pStr == '|' || *pStr == ' ') *pStr = 0;
+						pStr++;
+					}
+					*(++pStr) = 0;
+					Status = ERROR_SUCCESS;
+				} else {
+					Status = ERROR_ACCESS_DENIED;
+				}
+				*BufferSize = Packet->BytesReceived;
+				PacketFreePacket(Packet);
+			}
+		}
+	}
+
+  return Status;
+}
+
+
+ULONG PacketSelectAdapterByName( LPADAPTER lpAdapter, LPCSTR name )
+{
+  ULONG Status = 0;
+
+	if(os == VER_PLATFORM_WIN32_WINDOWS) {
+		int len = strlen(name) + 1;
+		LPPACKET Packet = PacketAllocatePacket( lpAdapter, len );
+		if(Packet) {
+			Packet->Buffer = (PVOID)name;
+			Packet->Length = len;
+			Status = PacketDeviceIoControl(
+					lpAdapter,
+					Packet,
+					(ULONG)IOCTL_PROTOCOL_SELECT_BY_NAME,
+					TRUE
+			);
+			if(Status) {
+				Status = ERROR_SUCCESS;
+			} else {
+				Status = ERROR_ACCESS_DENIED;
+			}
+			PacketFreePacket(Packet);
+		}
+	}
+  return Status;
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#if DEBUG
+#pragma optimize("",on)
+#endif
--- macemu/SheepShaver/src/Windows/cd_defs.h
+++ sheepshaver/SheepShaver/src/Windows/cd_defs.h
@@ -23,8 +23,6 @@
 #define MAXIMUM_NUMBER_TRACKS 100
 #define MAXIMUM_CDROM_SIZE 804
 
-#pragma pack(push, 1)
-
 typedef struct _TRACK_DATA {
     UCHAR Reserved;
     UCHAR Control : 4;
@@ -32,14 +30,14 @@
     UCHAR TrackNumber;
     UCHAR Reserved1;
     UCHAR Address[4];
-} TRACK_DATA, *PTRACK_DATA;
+} ATTRIBUTE_PACKED TRACK_DATA, *PTRACK_DATA;
 
 typedef struct _CDROM_TOC {
     UCHAR Length[2];
     UCHAR FirstTrack;
     UCHAR LastTrack;
     TRACK_DATA TrackData[MAXIMUM_NUMBER_TRACKS];
-} CDROM_TOC, *PCDROM_TOC;
+} ATTRIBUTE_PACKED CDROM_TOC, *PCDROM_TOC;
 
 // #include "ntddcdrm.h"
 #define IOCTL_CDROM_BASE                 FILE_DEVICE_CD_ROM
@@ -63,7 +61,7 @@
 
 typedef struct _VOLUME_CONTROL {
     UCHAR PortVolume[4];
-} VOLUME_CONTROL, *PVOLUME_CONTROL;
+} ATTRIBUTE_PACKED VOLUME_CONTROL, *PVOLUME_CONTROL;
 
 typedef struct _CDROM_PLAY_AUDIO_MSF {
     UCHAR StartingM;
@@ -72,13 +70,13 @@
     UCHAR EndingM;
     UCHAR EndingS;
     UCHAR EndingF;
-} CDROM_PLAY_AUDIO_MSF, *PCDROM_PLAY_AUDIO_MSF;
+} ATTRIBUTE_PACKED CDROM_PLAY_AUDIO_MSF, *PCDROM_PLAY_AUDIO_MSF;
 
 typedef struct _CDROM_SEEK_AUDIO_MSF {
     UCHAR M;
     UCHAR S;
     UCHAR F;
-} CDROM_SEEK_AUDIO_MSF, *PCDROM_SEEK_AUDIO_MSF;
+} ATTRIBUTE_PACKED CDROM_SEEK_AUDIO_MSF, *PCDROM_SEEK_AUDIO_MSF;
 
 
 //
@@ -89,7 +87,7 @@
     UCHAR Reserved;
     UCHAR AudioStatus;
     UCHAR DataLength[2];
-} SUB_Q_HEADER, *PSUB_Q_HEADER;
+} ATTRIBUTE_PACKED SUB_Q_HEADER, *PSUB_Q_HEADER;
 
 typedef struct _SUB_Q_CURRENT_POSITION {
     SUB_Q_HEADER Header;
@@ -100,7 +98,7 @@
     UCHAR IndexNumber;
     UCHAR AbsoluteAddress[4];
     UCHAR TrackRelativeAddress[4];
-} SUB_Q_CURRENT_POSITION, *PSUB_Q_CURRENT_POSITION;
+} ATTRIBUTE_PACKED SUB_Q_CURRENT_POSITION, *PSUB_Q_CURRENT_POSITION;
 
 typedef struct _SUB_Q_MEDIA_CATALOG_NUMBER {
     SUB_Q_HEADER Header;
@@ -109,7 +107,7 @@
     UCHAR Reserved1 : 7;
     UCHAR Mcval : 1;
     UCHAR MediaCatalog[15];
-} SUB_Q_MEDIA_CATALOG_NUMBER, *PSUB_Q_MEDIA_CATALOG_NUMBER;
+} ATTRIBUTE_PACKED SUB_Q_MEDIA_CATALOG_NUMBER, *PSUB_Q_MEDIA_CATALOG_NUMBER;
 
 typedef struct _SUB_Q_TRACK_ISRC {
     SUB_Q_HEADER Header;
@@ -120,7 +118,7 @@
     UCHAR Reserved2 : 7;
     UCHAR Tcval : 1;
     UCHAR TrackIsrc[15];
-} SUB_Q_TRACK_ISRC, *PSUB_Q_TRACK_ISRC;
+} ATTRIBUTE_PACKED SUB_Q_TRACK_ISRC, *PSUB_Q_TRACK_ISRC;
 
 typedef union _SUB_Q_CHANNEL_DATA {
     SUB_Q_CURRENT_POSITION CurrentPosition;
@@ -138,16 +136,14 @@
     LARGE_INTEGER DiskOffset;
     ULONG    SectorCount;
     TRACK_MODE_TYPE TrackMode;
-} RAW_READ_INFO, *PRAW_READ_INFO;
+} ATTRIBUTE_PACKED RAW_READ_INFO, *PRAW_READ_INFO;
 
 typedef struct _CDROM_SUB_Q_DATA_FORMAT {
     UCHAR Format;
     UCHAR Track;
-} CDROM_SUB_Q_DATA_FORMAT, *PCDROM_SUB_Q_DATA_FORMAT;
+} ATTRIBUTE_PACKED CDROM_SUB_Q_DATA_FORMAT, *PCDROM_SUB_Q_DATA_FORMAT;
 
 #define IOCTL_CDROM_SUB_Q_CHANNEL    0x00
 #define IOCTL_CDROM_CURRENT_POSITION 0x01
 #define IOCTL_CDROM_MEDIA_CATALOG    0x02
 #define IOCTL_CDROM_TRACK_ISRC       0x03
-
-#pragma pack(pop)
--- macemu/SheepShaver/src/Windows/cdenable/cache.cpp
+++ sheepshaver/SheepShaver/src/Windows/cdenable/cache.cpp
@@ -1,181 +1,182 @@
-/*
- *  cache.cpp - simple floppy/cd cache for Win32
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*
-	Note that this is particularly silly cache code
-	and doesn't even use hash buckets. It is sufficient
-	for floppies and maybe emulated cd's but that's it.
-*/
-
-#include "sysdeps.h"
-#include "cache.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef _DEBUG
-#define new DEBUG_NEW
-#undef THIS_FILE
-static char THIS_FILE[] = __FILE__;
-#endif
-
-void cache_clear( cachetype *cptr )
-{
-	if(cptr->inited) {
-		cptr->res_count = 0;
-		memset( cptr->LRU, 0, NBLOCKS * sizeof(int) );
-	}
-}
-
-static int init( cachetype *cptr, int sector_size )
-{
-	cache_clear( cptr );
-	cptr->sector_size = sector_size;
-	cptr->blocks = (char *)VirtualAlloc(
-			NULL, NBLOCKS*sector_size,
-			MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
-	cptr->block = (int *)VirtualAlloc(
-			NULL, NBLOCKS*sizeof(int),
-			MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
-	cptr->LRU = (DWORD *)VirtualAlloc(
-			NULL, NBLOCKS*sizeof(DWORD),
-			MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
-	return(cptr->blocks != NULL);
-}
-
-static void final( cachetype *cptr )
-{
-	if(cptr->blocks) {
-		VirtualFree( cptr->blocks, 0, MEM_RELEASE  );
-		cptr->blocks = 0;
-	}
-	if(cptr->block) {
-		VirtualFree( cptr->block, 0, MEM_RELEASE  );
-		cptr->block = 0;
-	}
-	if(cptr->LRU) {
-		VirtualFree( cptr->LRU, 0, MEM_RELEASE  );
-		cptr->LRU = 0;
-	}
-	cptr->inited = 0;
-}
-
-void cache_init( cachetype *cptr )
-{
-	cptr->inited = 0;
-}
-
-void cache_final( cachetype *cptr )
-{
-	if(cptr->inited) {
-		final( cptr );
-		cptr->inited = 0;
-	}
-}
-
-static int in_cache( cachetype *cptr, int block )
-{
-	int i;
-	for(i=cptr->res_count-1; i>=0; i--) {
-		if(cptr->block[i] == block) return(i);
-	}
-	return(-1);
-}
-
-static int get_LRU( cachetype *cptr )
-{
-	int i, result = 0;
-	DWORD mtime = cptr->LRU[0];
-
-	for(i=1; i<NBLOCKS; i++) {
-		if(cptr->LRU[i] < mtime) {
-			mtime = cptr->LRU[i];
-			result = i;
-		}
-	}
-	return(result);
-}
-
-void cache_put( cachetype *cptr, int block, char *buf, int ss )
-{
-	int inx;
-
-	if(!cptr->inited) {
-		if(!init(cptr,ss)) return;
-		cptr->inited = 1;
-	}
-	inx = in_cache( cptr, block );
-	if(inx < 0) {
-		if(cptr->res_count == NBLOCKS) {
-			inx = get_LRU( cptr );
-		} else {
-			inx = cptr->res_count++;
-		}
-		cptr->block[inx] = block;
-	}
-	cptr->LRU[inx] = GetTickCount();
-	memcpy( cptr->blocks + inx * ss, buf, ss );
-}
-
-int cache_get( cachetype *cptr, int block, char *buf )
-{
-	int inx;
-
-	if(!cptr->inited) return(0);
-
-	inx = in_cache( cptr, block );
-	if(inx >= 0) {
-		memcpy( buf, cptr->blocks + inx * cptr->sector_size, cptr->sector_size );
-		return(1);
-	} else {
-		return(0);
-	}
-}
-
-void cache_remove( cachetype *cptr, int block, int ss )
-{
-	int inx, from;
-
-	if(!cptr->inited) {
-		if(!init(cptr,ss)) return;
-		cptr->inited = 1;
-	}
-	inx = in_cache( cptr, block );
-	if(inx >= 0) {
-		if(cptr->res_count > 1) {
-			from = cptr->res_count-1;
-			cptr->block[inx] = cptr->block[from];
-			cptr->LRU[inx]   = cptr->LRU[from];
-			memcpy(
-				cptr->blocks + inx  * cptr->sector_size,
-				cptr->blocks + from * cptr->sector_size,
-				cptr->sector_size
-			);
-		}
-		cptr->res_count--;
-	}
-}
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
+/*
+ *  cache.cpp - simple floppy/cd cache for Win32
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+	Note that this is particularly silly cache code
+	and doesn't even use hash buckets. It is sufficient
+	for floppies and maybe emulated cd's but that's it.
+*/
+
+#include "sysdeps.h"
+#include "windows.h"
+#include "cache.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
+#endif
+
+void cache_clear( cachetype *cptr )
+{
+	if(cptr->inited) {
+		cptr->res_count = 0;
+		memset( cptr->LRU, 0, NBLOCKS * sizeof(int) );
+	}
+}
+
+static int init( cachetype *cptr, int sector_size )
+{
+	cache_clear( cptr );
+	cptr->sector_size = sector_size;
+	cptr->blocks = (char *)VirtualAlloc(
+			NULL, NBLOCKS*sector_size,
+			MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
+	cptr->block = (int *)VirtualAlloc(
+			NULL, NBLOCKS*sizeof(int),
+			MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
+	cptr->LRU = (DWORD *)VirtualAlloc(
+			NULL, NBLOCKS*sizeof(DWORD),
+			MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
+	return(cptr->blocks != NULL);
+}
+
+static void final( cachetype *cptr )
+{
+	if(cptr->blocks) {
+		VirtualFree( cptr->blocks, 0, MEM_RELEASE  );
+		cptr->blocks = 0;
+	}
+	if(cptr->block) {
+		VirtualFree( cptr->block, 0, MEM_RELEASE  );
+		cptr->block = 0;
+	}
+	if(cptr->LRU) {
+		VirtualFree( cptr->LRU, 0, MEM_RELEASE  );
+		cptr->LRU = 0;
+	}
+	cptr->inited = 0;
+}
+
+void cache_init( cachetype *cptr )
+{
+	cptr->inited = 0;
+}
+
+void cache_final( cachetype *cptr )
+{
+	if(cptr->inited) {
+		final( cptr );
+		cptr->inited = 0;
+	}
+}
+
+static int in_cache( cachetype *cptr, int block )
+{
+	int i;
+	for(i=cptr->res_count-1; i>=0; i--) {
+		if(cptr->block[i] == block) return(i);
+	}
+	return(-1);
+}
+
+static int get_LRU( cachetype *cptr )
+{
+	int i, result = 0;
+	DWORD mtime = cptr->LRU[0];
+
+	for(i=1; i<NBLOCKS; i++) {
+		if(cptr->LRU[i] < mtime) {
+			mtime = cptr->LRU[i];
+			result = i;
+		}
+	}
+	return(result);
+}
+
+void cache_put( cachetype *cptr, int block, char *buf, int ss )
+{
+	int inx;
+
+	if(!cptr->inited) {
+		if(!init(cptr,ss)) return;
+		cptr->inited = 1;
+	}
+	inx = in_cache( cptr, block );
+	if(inx < 0) {
+		if(cptr->res_count == NBLOCKS) {
+			inx = get_LRU( cptr );
+		} else {
+			inx = cptr->res_count++;
+		}
+		cptr->block[inx] = block;
+	}
+	cptr->LRU[inx] = GetTickCount();
+	memcpy( cptr->blocks + inx * ss, buf, ss );
+}
+
+int cache_get( cachetype *cptr, int block, char *buf )
+{
+	int inx;
+
+	if(!cptr->inited) return(0);
+
+	inx = in_cache( cptr, block );
+	if(inx >= 0) {
+		memcpy( buf, cptr->blocks + inx * cptr->sector_size, cptr->sector_size );
+		return(1);
+	} else {
+		return(0);
+	}
+}
+
+void cache_remove( cachetype *cptr, int block, int ss )
+{
+	int inx, from;
+
+	if(!cptr->inited) {
+		if(!init(cptr,ss)) return;
+		cptr->inited = 1;
+	}
+	inx = in_cache( cptr, block );
+	if(inx >= 0) {
+		if(cptr->res_count > 1) {
+			from = cptr->res_count-1;
+			cptr->block[inx] = cptr->block[from];
+			cptr->LRU[inx]   = cptr->LRU[from];
+			memcpy(
+				cptr->blocks + inx  * cptr->sector_size,
+				cptr->blocks + from * cptr->sector_size,
+				cptr->sector_size
+			);
+		}
+		cptr->res_count--;
+	}
+}
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
--- macemu/SheepShaver/src/Windows/cdenable/cache.h
+++ sheepshaver/SheepShaver/src/Windows/cdenable/cache.h
@@ -1,50 +1,50 @@
-/*
- *  cache.cpp - simple floppy/cd cache for Win32
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _CACHE_H_
-#define _CACHE_H_
-#define NBLOCKS 1000
-
-typedef struct {
-	int inited;
-	int res_count;
-	int sector_size;
-	char *blocks;
-	int *block;
-	DWORD *LRU;
-} cachetype;
-
-void cache_init( cachetype *cptr );
-void cache_clear( cachetype *cptr );
-void cache_final( cachetype *cptr );
-int cache_get( cachetype *cptr, int block, char *buf );
-void cache_put( cachetype *cptr, int block, char *buf, int ss );
-void cache_remove( cachetype *cptr, int block, int ss );
-#endif
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
+/*
+ *  cache.cpp - simple floppy/cd cache for Win32
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _CACHE_H_
+#define _CACHE_H_
+#define NBLOCKS 1000
+
+typedef struct {
+	int inited;
+	int res_count;
+	int sector_size;
+	char *blocks;
+	int *block;
+	DWORD *LRU;
+} cachetype;
+
+void cache_init( cachetype *cptr );
+void cache_clear( cachetype *cptr );
+void cache_final( cachetype *cptr );
+int cache_get( cachetype *cptr, int block, char *buf );
+void cache_put( cachetype *cptr, int block, char *buf, int ss );
+void cache_remove( cachetype *cptr, int block, int ss );
+#endif
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
--- macemu/SheepShaver/src/Windows/cdenable/cdenable.h
+++ sheepshaver/SheepShaver/src/Windows/cdenable/cdenable.h
@@ -1,60 +1,60 @@
-/*
- *  cdenable.h - cdenable.vxd definitions
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-// max read requests, if larger -> STATUS_INVALID_PARAMETER
-#define CDENABLE_MAX_TRANSFER_SIZE (0x10000)
-
-
-// A structure representing the instance information associated with
-// a particular device
-typedef struct _DEVICE_EXTENSION
-{
-  // not needed.
-  ULONG  StateVariable;
-} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
-
-
-// Define the various device type values.  Note that values used by Microsoft
-// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
-// by customers.
-#define FILE_DEVICE_CDENABLE  0x00008301
-
-
-// Target NT version, internal version
-#define CDENABLE_CURRENT_VERSION  0x04000100
-
-
-// Macro definition for defining IOCTL and FSCTL function control codes.  Note
-// that function codes 0-2047 are reserved for Microsoft Corporation, and
-// 2048-4095 are reserved for customers.
-#define CDENABLE_IOCTL_READ           0x830
-#define CDENABLE_IOCTL_GET_VERSION    0x831
-
-
-#define IOCTL_CDENABLE_READ         CTL_CODE(FILE_DEVICE_CDENABLE,  \
-                                             CDENABLE_IOCTL_READ,  \
-                                             METHOD_BUFFERED,       \
-                                             FILE_ANY_ACCESS)
-#define IOCTL_CDENABLE_GET_VERSION  CTL_CODE(FILE_DEVICE_CDENABLE,  \
-                                             CDENABLE_IOCTL_GET_VERSION,  \
-                                             METHOD_BUFFERED,       \
-                                             FILE_ANY_ACCESS)
+/*
+ *  cdenable.h - cdenable.vxd definitions
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+// max read requests, if larger -> STATUS_INVALID_PARAMETER
+#define CDENABLE_MAX_TRANSFER_SIZE (0x10000)
+
+
+// A structure representing the instance information associated with
+// a particular device
+typedef struct _DEVICE_EXTENSION
+{
+  // not needed.
+  ULONG  StateVariable;
+} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
+
+
+// Define the various device type values.  Note that values used by Microsoft
+// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
+// by customers.
+#define FILE_DEVICE_CDENABLE  0x00008301
+
+
+// Target NT version, internal version
+#define CDENABLE_CURRENT_VERSION  0x04000100
+
+
+// Macro definition for defining IOCTL and FSCTL function control codes.  Note
+// that function codes 0-2047 are reserved for Microsoft Corporation, and
+// 2048-4095 are reserved for customers.
+#define CDENABLE_IOCTL_READ           0x830
+#define CDENABLE_IOCTL_GET_VERSION    0x831
+
+
+#define IOCTL_CDENABLE_READ         CTL_CODE(FILE_DEVICE_CDENABLE,  \
+                                             CDENABLE_IOCTL_READ,  \
+                                             METHOD_BUFFERED,       \
+                                             FILE_ANY_ACCESS)
+#define IOCTL_CDENABLE_GET_VERSION  CTL_CODE(FILE_DEVICE_CDENABLE,  \
+                                             CDENABLE_IOCTL_GET_VERSION,  \
+                                             METHOD_BUFFERED,       \
+                                             FILE_ANY_ACCESS)
--- macemu/SheepShaver/src/Windows/cdenable/eject_nt.cpp
+++ sheepshaver/SheepShaver/src/Windows/cdenable/eject_nt.cpp
@@ -1,189 +1,190 @@
-/*
- *  eject_nt.cpp - cd eject routines for WinNT (derived from MS samples)
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-
-#include <winioctl.h>
-
-// Prototypes
-
-extern "C" {
-
-#include "eject_nt.h"
-
-LPTSTR szVolumeFormat = TEXT("\\\\.\\%c:");
-LPTSTR szRootFormat = TEXT("%c:\\");
-LPTSTR szErrorFormat = TEXT("Error %d: %s\n");
-
-void ReportError(LPTSTR szMsg)
-{
-   // _tprintf(szErrorFormat, GetLastError(), szMsg);
-}
-
-HANDLE OpenVolume(TCHAR cDriveLetter)
-{
-   HANDLE hVolume;
-   UINT uDriveType;
-   TCHAR szVolumeName[8];
-   TCHAR szRootName[5];
-   DWORD dwAccessFlags;
-
-   wsprintf(szRootName, szRootFormat, cDriveLetter);
-
-   uDriveType = GetDriveType(szRootName);
-   switch(uDriveType) {
-   case DRIVE_REMOVABLE:
-       dwAccessFlags = GENERIC_READ | GENERIC_WRITE;
-       break;
-   case DRIVE_CDROM:
-       dwAccessFlags = GENERIC_READ;
-       break;
-   default:
-       // _tprintf(TEXT("Cannot eject.  Drive type is incorrect.\n"));
-       return INVALID_HANDLE_VALUE;
-   }
-
-   wsprintf(szVolumeName, szVolumeFormat, cDriveLetter);
-
-   hVolume = CreateFile(   szVolumeName,
-                           dwAccessFlags,
-                           FILE_SHARE_READ | FILE_SHARE_WRITE,
-                           NULL,
-                           OPEN_EXISTING,
-                           0,
-                           NULL );
-   if (hVolume == INVALID_HANDLE_VALUE)
-       ReportError(TEXT("CreateFile"));
-
-   return hVolume;
-}
-
-BOOL CloseVolume(HANDLE hVolume)
-{
-   return CloseHandle(hVolume);
-}
-
-#define LOCK_TIMEOUT        1000       // 1 second
-#define LOCK_RETRIES        20
-
-BOOL LockVolume(HANDLE hVolume)
-{
-   DWORD dwBytesReturned;
-   DWORD dwSleepAmount;
-   int nTryCount;
-
-   dwSleepAmount = LOCK_TIMEOUT / LOCK_RETRIES;
-
-   // Do this in a loop until a timeout period has expired
-   for (nTryCount = 0; nTryCount < LOCK_RETRIES; nTryCount++) {
-       if (DeviceIoControl(hVolume,
-                           FSCTL_LOCK_VOLUME,
-                           NULL, 0,
-                           NULL, 0,
-                           &dwBytesReturned,
-                           NULL))
-           return TRUE;
-
-       Sleep(dwSleepAmount);
-   }
-
-   return FALSE;
-}
-
-BOOL DismountVolume(HANDLE hVolume)
-{
-   DWORD dwBytesReturned;
-
-   return DeviceIoControl( hVolume,
-                           FSCTL_DISMOUNT_VOLUME,
-                           NULL, 0,
-                           NULL, 0,
-                           &dwBytesReturned,
-                           NULL);
-}
-
-BOOL PreventRemovalOfVolume(HANDLE hVolume, BOOL fPreventRemoval)
-{
-   DWORD dwBytesReturned;
-   PREVENT_MEDIA_REMOVAL PMRBuffer;
-
-   PMRBuffer.PreventMediaRemoval = fPreventRemoval;
-
-   return DeviceIoControl( hVolume,
-                           IOCTL_STORAGE_MEDIA_REMOVAL,
-                           &PMRBuffer, sizeof(PREVENT_MEDIA_REMOVAL),
-                           NULL, 0,
-                           &dwBytesReturned,
-                           NULL);
-}
-
-BOOL AutoEjectVolume( HANDLE hVolume, BOOL reload )
-{
-   DWORD dwBytesReturned;
-
-   return DeviceIoControl( hVolume,
-                           reload ? IOCTL_STORAGE_LOAD_MEDIA : IOCTL_STORAGE_EJECT_MEDIA,
-                           NULL, 0,
-                           NULL, 0,
-                           &dwBytesReturned,
-                           NULL);
-}
-
-BOOL EjectVolume( TCHAR cDriveLetter, BOOL reload )
-{
-   HANDLE hVolume;
-
-   BOOL fRemoveSafely = FALSE;
-   BOOL fAutoEject = FALSE;
-
-   // Open the volume.
-   hVolume = OpenVolume(cDriveLetter);
-   if (hVolume == INVALID_HANDLE_VALUE)
-       return FALSE;
-
-   // Lock and dismount the volume.
-   if (LockVolume(hVolume) && DismountVolume(hVolume)) {
-       fRemoveSafely = TRUE;
-
-       // Set prevent removal to false and eject the volume.
-       if (PreventRemovalOfVolume(hVolume, FALSE) &&
-           AutoEjectVolume(hVolume,reload))
-           fAutoEject = TRUE;
-   }
-
-   // Close the volume so other processes can use the drive.
-   if (!CloseVolume(hVolume))
-       return FALSE;
-
-   /*
-	 if (fAutoEject)
-       printf("Media in Drive %c has been ejected safely.\n", cDriveLetter);
-   else {
-       if (fRemoveSafely)
-           printf("Media in Drive %c can be safely removed.\n", cDriveLetter);
-   }
-	 */
-
-   return TRUE;
-}
-
-} // extern "C"
+/*
+ *  eject_nt.cpp - cd eject routines for WinNT (derived from MS samples)
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+
+#include "windows.h"
+#include <winioctl.h>
+
+// Prototypes
+
+extern "C" {
+
+#include "eject_nt.h"
+
+LPTSTR szVolumeFormat = TEXT("\\\\.\\%c:");
+LPTSTR szRootFormat = TEXT("%c:\\");
+LPTSTR szErrorFormat = TEXT("Error %d: %s\n");
+
+void ReportError(LPTSTR szMsg)
+{
+   // _tprintf(szErrorFormat, GetLastError(), szMsg);
+}
+
+HANDLE OpenVolume(TCHAR cDriveLetter)
+{
+   HANDLE hVolume;
+   UINT uDriveType;
+   TCHAR szVolumeName[8];
+   TCHAR szRootName[5];
+   DWORD dwAccessFlags;
+
+   wsprintf(szRootName, szRootFormat, cDriveLetter);
+
+   uDriveType = GetDriveType(szRootName);
+   switch(uDriveType) {
+   case DRIVE_REMOVABLE:
+       dwAccessFlags = GENERIC_READ | GENERIC_WRITE;
+       break;
+   case DRIVE_CDROM:
+       dwAccessFlags = GENERIC_READ;
+       break;
+   default:
+       // _tprintf(TEXT("Cannot eject.  Drive type is incorrect.\n"));
+       return INVALID_HANDLE_VALUE;
+   }
+
+   wsprintf(szVolumeName, szVolumeFormat, cDriveLetter);
+
+   hVolume = CreateFile(   szVolumeName,
+                           dwAccessFlags,
+                           FILE_SHARE_READ | FILE_SHARE_WRITE,
+                           NULL,
+                           OPEN_EXISTING,
+                           0,
+                           NULL );
+   if (hVolume == INVALID_HANDLE_VALUE)
+       ReportError(TEXT("CreateFile"));
+
+   return hVolume;
+}
+
+BOOL CloseVolume(HANDLE hVolume)
+{
+   return CloseHandle(hVolume);
+}
+
+#define LOCK_TIMEOUT        1000       // 1 second
+#define LOCK_RETRIES        20
+
+BOOL LockVolume(HANDLE hVolume)
+{
+   DWORD dwBytesReturned;
+   DWORD dwSleepAmount;
+   int nTryCount;
+
+   dwSleepAmount = LOCK_TIMEOUT / LOCK_RETRIES;
+
+   // Do this in a loop until a timeout period has expired
+   for (nTryCount = 0; nTryCount < LOCK_RETRIES; nTryCount++) {
+       if (DeviceIoControl(hVolume,
+                           FSCTL_LOCK_VOLUME,
+                           NULL, 0,
+                           NULL, 0,
+                           &dwBytesReturned,
+                           NULL))
+           return TRUE;
+
+       Sleep(dwSleepAmount);
+   }
+
+   return FALSE;
+}
+
+BOOL DismountVolume(HANDLE hVolume)
+{
+   DWORD dwBytesReturned;
+
+   return DeviceIoControl( hVolume,
+                           FSCTL_DISMOUNT_VOLUME,
+                           NULL, 0,
+                           NULL, 0,
+                           &dwBytesReturned,
+                           NULL);
+}
+
+BOOL PreventRemovalOfVolume(HANDLE hVolume, BOOL fPreventRemoval)
+{
+   DWORD dwBytesReturned;
+   PREVENT_MEDIA_REMOVAL PMRBuffer;
+
+   PMRBuffer.PreventMediaRemoval = fPreventRemoval;
+
+   return DeviceIoControl( hVolume,
+                           IOCTL_STORAGE_MEDIA_REMOVAL,
+                           &PMRBuffer, sizeof(PREVENT_MEDIA_REMOVAL),
+                           NULL, 0,
+                           &dwBytesReturned,
+                           NULL);
+}
+
+BOOL AutoEjectVolume( HANDLE hVolume, BOOL reload )
+{
+   DWORD dwBytesReturned;
+
+   return DeviceIoControl( hVolume,
+                           reload ? IOCTL_STORAGE_LOAD_MEDIA : IOCTL_STORAGE_EJECT_MEDIA,
+                           NULL, 0,
+                           NULL, 0,
+                           &dwBytesReturned,
+                           NULL);
+}
+
+BOOL EjectVolume( TCHAR cDriveLetter, BOOL reload )
+{
+   HANDLE hVolume;
+
+   BOOL fRemoveSafely = FALSE;
+   BOOL fAutoEject = FALSE;
+
+   // Open the volume.
+   hVolume = OpenVolume(cDriveLetter);
+   if (hVolume == INVALID_HANDLE_VALUE)
+       return FALSE;
+
+   // Lock and dismount the volume.
+   if (LockVolume(hVolume) && DismountVolume(hVolume)) {
+       fRemoveSafely = TRUE;
+
+       // Set prevent removal to false and eject the volume.
+       if (PreventRemovalOfVolume(hVolume, FALSE) &&
+           AutoEjectVolume(hVolume,reload))
+           fAutoEject = TRUE;
+   }
+
+   // Close the volume so other processes can use the drive.
+   if (!CloseVolume(hVolume))
+       return FALSE;
+
+   /*
+	 if (fAutoEject)
+       printf("Media in Drive %c has been ejected safely.\n", cDriveLetter);
+   else {
+       if (fRemoveSafely)
+           printf("Media in Drive %c can be safely removed.\n", cDriveLetter);
+   }
+	 */
+
+   return TRUE;
+}
+
+} // extern "C"
--- macemu/SheepShaver/src/Windows/cdenable/eject_nt.h
+++ sheepshaver/SheepShaver/src/Windows/cdenable/eject_nt.h
@@ -1,44 +1,44 @@
-/*
- *  eject_nt.cpp - cd eject routines for WinNT (derived from MS samples)
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _EJECT_NT_H_
-#define _EJECT_NT_H_
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-BOOL EjectVolume(TCHAR cDriveLetter,BOOL reload);
-
-HANDLE OpenVolume(TCHAR cDriveLetter);
-BOOL LockVolume(HANDLE hVolume);
-BOOL DismountVolume(HANDLE hVolume);
-BOOL PreventRemovalOfVolume(HANDLE hVolume, BOOL fPrevent);
-BOOL AutoEjectVolume(HANDLE hVolume,BOOL reload);
-BOOL CloseVolume(HANDLE hVolume);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif //_EJECT_NT_H_
+/*
+ *  eject_nt.cpp - cd eject routines for WinNT (derived from MS samples)
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _EJECT_NT_H_
+#define _EJECT_NT_H_
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+BOOL EjectVolume(TCHAR cDriveLetter,BOOL reload);
+
+HANDLE OpenVolume(TCHAR cDriveLetter);
+BOOL LockVolume(HANDLE hVolume);
+BOOL DismountVolume(HANDLE hVolume);
+BOOL PreventRemovalOfVolume(HANDLE hVolume, BOOL fPrevent);
+BOOL AutoEjectVolume(HANDLE hVolume,BOOL reload);
+BOOL CloseVolume(HANDLE hVolume);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif //_EJECT_NT_H_
--- macemu/SheepShaver/src/Windows/cdenable/ntcd.cpp
+++ sheepshaver/SheepShaver/src/Windows/cdenable/ntcd.cpp
@@ -1,344 +1,345 @@
-/*
- *  ntcd.cpp - Interface to cdenable.sys driver
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-
-extern "C" {
-
-#include <winioctl.h>
-#include <winsvc.h>
-#include "ntcd.h"
-#include "cdenable.h"
-
-static LPCTSTR sDriverShort   = TEXT("cdenable");
-static LPCTSTR sDriverLong    = TEXT("System32\\Drivers\\cdenable.sys");
-static LPCTSTR sCompleteName  = TEXT("\\\\.\\cdenable");
-
-#ifdef _DEBUG
-#define new DEBUG_NEW
-#undef THIS_FILE
-static char THIS_FILE[] = __FILE__;
-#endif
-
-// Start type must be SERVICE_AUTO_START or lower, in order
-// it to start automatically and allow the mechanism work
-// for users with no admin rights.
-static BOOL InstallDriver(
-  IN SC_HANDLE  SchSCManager,
-  IN LPCTSTR    DriverName,
-  IN LPCTSTR    ServiceExe
-)
-{
-  SC_HANDLE  schService;
-  DWORD      err;
-
-  schService = CreateService (
-		SchSCManager,          // SCManager database
-    DriverName,            // name of service
-    DriverName,            // name to display
-    SERVICE_ALL_ACCESS,    // desired access
-    SERVICE_KERNEL_DRIVER, // service type
-		SERVICE_AUTO_START,		 // SERVICE_DEMAND_START,  // start type
-    SERVICE_ERROR_NORMAL,  // error control type
-    ServiceExe,            // service's binary
-    NULL,                  // no load ordering group
-    NULL,                  // no tag identifier
-    NULL,                  // no dependencies
-    NULL,                  // LocalSystem account
-    NULL                   // no password
-    );
-
-  if (schService == NULL) {
-      err = GetLastError();
-      if (err == ERROR_SERVICE_EXISTS) {
-				  return TRUE;
-      } else {
-		      return FALSE;
-      }
-  }
-  CloseServiceHandle (schService);
-  return TRUE;
-}
-
-static BOOL RemoveDriver(
-  IN SC_HANDLE  SchSCManager,
-  IN LPCTSTR    DriverName
-)
-{
-  SC_HANDLE  schService;
-  BOOL       ret;
-
-  schService = OpenService (SchSCManager,
-                            DriverName,
-                            SERVICE_ALL_ACCESS
-                            );
-  if (schService == NULL) return FALSE;
-  ret = DeleteService (schService);
-  CloseServiceHandle (schService);
-  return ret;
-}
-
-static BOOL StartDriver(
-  IN SC_HANDLE  SchSCManager,
-  IN LPCTSTR    DriverName
-) {
-  SC_HANDLE  schService;
-  BOOL       ret;
-  DWORD      err;
-
-  schService = OpenService (SchSCManager,
-                            DriverName,
-                            SERVICE_ALL_ACCESS
-                            );
-  if (schService == NULL) return FALSE;
-  ret = StartService (schService,    // service identifier
-                      0,             // number of arguments
-                      NULL           // pointer to arguments
-                      );
-  if(ret == 0) {
-    err = GetLastError();
-    if (err == ERROR_SERVICE_ALREADY_RUNNING) {
-			ret = TRUE;
-    } else {
-			ret = FALSE;
-		}
-  }
-  CloseServiceHandle (schService);
-  return ret;
-}
-
-static BOOL StopDriver(
-  IN SC_HANDLE  SchSCManager,
-  IN LPCTSTR    DriverName
-)
-{
-  SC_HANDLE       schService;
-  BOOL            ret;
-  SERVICE_STATUS  serviceStatus;
-
-  schService = OpenService (SchSCManager,
-                            DriverName,
-                            SERVICE_ALL_ACCESS
-                            );
-  if (schService == NULL) return FALSE;
-  ret = ControlService (schService,
-                        SERVICE_CONTROL_STOP,
-                        &serviceStatus
-                        );
-  CloseServiceHandle (schService);
-  return ret;
-}
-
-static BOOL __cdecl start_driver( void )
-{
-	SC_HANDLE   schSCManager;
-	BOOL ret = FALSE;
-
-	schSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
-	if(!schSCManager) return(FALSE);
-	if(!InstallDriver( schSCManager, sDriverShort, sDriverLong )) {
-		CloseServiceHandle( schSCManager );
-		return(FALSE);
-	}
-	ret = StartDriver( schSCManager, sDriverShort );
-	if(!ret) {
-		(void)RemoveDriver( schSCManager, sDriverShort );
-	}
-	CloseServiceHandle( schSCManager );
-	return( ret );
-}
-
-static BOOL __cdecl stop_driver( void )
-{
-	SC_HANDLE   schSCManager;
-	BOOL ret = FALSE;
-
-	schSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
-	if(!schSCManager) return(FALSE);
-	if(StopDriver( schSCManager, sDriverShort )) ret = TRUE;
-	CloseServiceHandle( schSCManager );
-	return( ret );
-}
-
-static BOOL __cdecl remove_driver( void )
-{
-	SC_HANDLE   schSCManager;
-	BOOL ret = FALSE;
-
-	schSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
-	if(!schSCManager) return(FALSE);
-	if(RemoveDriver( schSCManager, sDriverShort )) ret = TRUE;
-	CloseServiceHandle( schSCManager );
-	return( ret );
-}
-
-
-
-// Exported stuff begins
-
-int CdenableSysReadCdBytes( HANDLE h, DWORD start, DWORD count, char *buf )
-{
-  HANDLE   hDevice;
-  int      ret;
-	DWORD		 nb;
-	DWORD    in_buffer[10];
-	DWORD    out_buffer[10];
-
-  ret = 0;
-
-	in_buffer[0] = (DWORD)h;
-	in_buffer[1] = (DWORD)start;
-	in_buffer[2] = (DWORD)count;
-	in_buffer[3] = (DWORD)buf;
-	out_buffer[0] = 0;
-
-  hDevice = CreateFile (sCompleteName,
-                        GENERIC_READ | GENERIC_WRITE,
-                        0,
-                        NULL,
-                        OPEN_EXISTING,
-                        FILE_ATTRIBUTE_NORMAL,
-                        NULL
-                        );
-
-  if (hDevice == ((HANDLE)-1)) {
-    ret = 0;
-	} else {
-		if ( DeviceIoControl(	hDevice,
-					IOCTL_CDENABLE_READ,
-					(LPVOID)in_buffer, 16,
-					(LPVOID)out_buffer, 4,
-					&nb, NULL ) )
-		{
-			if(out_buffer[0] != 0) ret = count;
-		}
-    CloseHandle (hDevice);
-  }
-
-  return ret;
-}
-
-int CdenableSysReadCdSectors( HANDLE h, DWORD start, DWORD count, char *buf )
-{
-	return( CdenableSysReadCdBytes( h, (start<<11), (count<<11), buf ) );
-}
-
-int CdenableSysWriteCdBytes( HANDLE h, DWORD start, DWORD count, char *buf )
-{
-	return( 0 );
-
-	/*
-  HANDLE   hDevice;
-  int      ret;
-	DWORD		 nb;
-	DWORD    in_buffer[10];
-	DWORD    out_buffer[10];
-
-  ret = 0;
-
-	in_buffer[0] = (DWORD)h;
-	in_buffer[1] = (DWORD)start;
-	in_buffer[2] = (DWORD)count;
-	in_buffer[3] = (DWORD)buf;
-	out_buffer[0] = 0;
-
-  hDevice = CreateFile (sCompleteName,
-                        GENERIC_READ | GENERIC_WRITE,
-                        0,
-                        NULL,
-                        OPEN_EXISTING,
-                        FILE_ATTRIBUTE_NORMAL,
-                        NULL
-                        );
-
-  if (hDevice == ((HANDLE)-1)) {
-    ret = 0;
-	} else {
-		if ( DeviceIoControl(	hDevice,
-					IOCTL_CDENABLE_WRITE,
-					(LPVOID)in_buffer, 16,
-					(LPVOID)out_buffer, 4,
-					&nb, NULL ) )
-		{
-			if(out_buffer[0] != 0) ret = count;
-		}
-    CloseHandle (hDevice);
-  }
-
-  return ret;
-	*/
-}
-
-int CdenableSysWriteCdSectors( HANDLE h, DWORD start, DWORD count, char *buf )
-{
-	// return( CdenableSysWriteCdBytes( h, (start<<11), (count<<11), buf ) );
-	return( 0 );
-}
-
-BOOL CdenableSysInstallStart(void)
-{
-	return(start_driver());
-}
-
-void CdenableSysStopRemove(void)
-{
-	stop_driver();
-	remove_driver();
-}
-
-DWORD CdenableSysGetVersion( void )
-{
-  HANDLE   hDevice;
-  DWORD    ret;
-	DWORD		 nb;
-	DWORD    out_buffer[10];
-
-  ret = 0;
-	out_buffer[0] = 0;
-  hDevice = CreateFile (sCompleteName,
-                        GENERIC_READ | GENERIC_WRITE,
-                        0,
-                        NULL,
-                        OPEN_EXISTING,
-                        FILE_ATTRIBUTE_NORMAL,
-                        NULL
-                        );
-  if (hDevice == ((HANDLE)-1)) {
-    ret = 0;
-	} else {
-		if ( DeviceIoControl(	hDevice,
-					IOCTL_CDENABLE_GET_VERSION,
-					NULL, 0,
-					(LPVOID)out_buffer, 4,
-					&nb, NULL ) )
-		{
-			ret = out_buffer[0];
-		}
-    CloseHandle (hDevice);
-  }
-  return ret;
-}
-
-#ifdef __cplusplus
-} //extern "C"
-#endif
-
+/*
+ *  ntcd.cpp - Interface to cdenable.sys driver
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include <windows.h>
+
+extern "C" {
+
+#include <winioctl.h>
+#include <winsvc.h>
+#include "ntcd.h"
+#include "cdenable.h"
+
+static char *sDriverShort   = "cdenable";
+static char *sDriverLong  = "System32\\Drivers\\cdenable.sys";
+static char *sCompleteName  = "\\\\.\\cdenable";
+
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
+#endif
+
+// Start type must be SERVICE_AUTO_START or lower, in order
+// it to start automatically and allow the mechanism work
+// for users with no admin rights.
+static BOOL InstallDriver(
+  IN SC_HANDLE  SchSCManager,
+  IN LPCTSTR    DriverName,
+  IN LPCTSTR    ServiceExe
+)
+{
+  SC_HANDLE  schService;
+  DWORD      err;
+
+  schService = CreateService (
+		SchSCManager,          // SCManager database
+    DriverName,            // name of service
+    DriverName,            // name to display
+    SERVICE_ALL_ACCESS,    // desired access
+    SERVICE_KERNEL_DRIVER, // service type
+		SERVICE_AUTO_START,		 // SERVICE_DEMAND_START,  // start type
+    SERVICE_ERROR_NORMAL,  // error control type
+    ServiceExe,            // service's binary
+    NULL,                  // no load ordering group
+    NULL,                  // no tag identifier
+    NULL,                  // no dependencies
+    NULL,                  // LocalSystem account
+    NULL                   // no password
+    );
+
+  if (schService == NULL) {
+      err = GetLastError();
+      if (err == ERROR_SERVICE_EXISTS) {
+				  return TRUE;
+      } else {
+		      return FALSE;
+      }
+  }
+  CloseServiceHandle (schService);
+  return TRUE;
+}
+
+static BOOL RemoveDriver(
+  IN SC_HANDLE  SchSCManager,
+  IN LPCTSTR    DriverName
+)
+{
+  SC_HANDLE  schService;
+  BOOL       ret;
+
+  schService = OpenService (SchSCManager,
+                            DriverName,
+                            SERVICE_ALL_ACCESS
+                            );
+  if (schService == NULL) return FALSE;
+  ret = DeleteService (schService);
+  CloseServiceHandle (schService);
+  return ret;
+}
+
+static BOOL StartDriver(
+  IN SC_HANDLE  SchSCManager,
+  IN LPCTSTR    DriverName
+) {
+  SC_HANDLE  schService;
+  BOOL       ret;
+  DWORD      err;
+
+  schService = OpenService (SchSCManager,
+                            DriverName,
+                            SERVICE_ALL_ACCESS
+                            );
+  if (schService == NULL) return FALSE;
+  ret = StartService (schService,    // service identifier
+                      0,             // number of arguments
+                      NULL           // pointer to arguments
+                      );
+  if(ret == 0) {
+    err = GetLastError();
+    if (err == ERROR_SERVICE_ALREADY_RUNNING) {
+			ret = TRUE;
+    } else {
+			ret = FALSE;
+		}
+  }
+  CloseServiceHandle (schService);
+  return ret;
+}
+
+static BOOL StopDriver(
+  IN SC_HANDLE  SchSCManager,
+  IN LPCTSTR    DriverName
+)
+{
+  SC_HANDLE       schService;
+  BOOL            ret;
+  SERVICE_STATUS  serviceStatus;
+
+  schService = OpenService (SchSCManager,
+                            DriverName,
+                            SERVICE_ALL_ACCESS
+                            );
+  if (schService == NULL) return FALSE;
+  ret = ControlService (schService,
+                        SERVICE_CONTROL_STOP,
+                        &serviceStatus
+                        );
+  CloseServiceHandle (schService);
+  return ret;
+}
+
+static BOOL __cdecl start_driver( void )
+{
+	SC_HANDLE   schSCManager;
+	BOOL ret = FALSE;
+
+	schSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
+	if(!schSCManager) return(FALSE);
+	if(!InstallDriver( schSCManager, sDriverShort, sDriverLong )) {
+		CloseServiceHandle( schSCManager );
+		return(FALSE);
+	}
+	ret = StartDriver( schSCManager, sDriverShort );
+	if(!ret) {
+		(void)RemoveDriver( schSCManager, sDriverShort );
+	}
+	CloseServiceHandle( schSCManager );
+	return( ret );
+}
+
+static BOOL __cdecl stop_driver( void )
+{
+	SC_HANDLE   schSCManager;
+	BOOL ret = FALSE;
+
+	schSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
+	if(!schSCManager) return(FALSE);
+	if(StopDriver( schSCManager, sDriverShort )) ret = TRUE;
+	CloseServiceHandle( schSCManager );
+	return( ret );
+}
+
+static BOOL __cdecl remove_driver( void )
+{
+	SC_HANDLE   schSCManager;
+	BOOL ret = FALSE;
+
+	schSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
+	if(!schSCManager) return(FALSE);
+	if(RemoveDriver( schSCManager, sDriverShort )) ret = TRUE;
+	CloseServiceHandle( schSCManager );
+	return( ret );
+}
+
+
+
+// Exported stuff begins
+
+int CdenableSysReadCdBytes( HANDLE h, DWORD start, DWORD count, char *buf )
+{
+  HANDLE   hDevice;
+  int      ret;
+	DWORD		 nb;
+	DWORD    in_buffer[10];
+	DWORD    out_buffer[10];
+
+  ret = 0;
+
+	in_buffer[0] = (DWORD)h;
+	in_buffer[1] = (DWORD)start;
+	in_buffer[2] = (DWORD)count;
+	in_buffer[3] = (DWORD)buf;
+	out_buffer[0] = 0;
+
+  hDevice = CreateFile (sCompleteName,
+                        GENERIC_READ | GENERIC_WRITE,
+                        0,
+                        NULL,
+                        OPEN_EXISTING,
+                        FILE_ATTRIBUTE_NORMAL,
+                        NULL
+                        );
+
+  if (hDevice == ((HANDLE)-1)) {
+    ret = 0;
+	} else {
+		if ( DeviceIoControl(	hDevice,
+					IOCTL_CDENABLE_READ,
+					(LPVOID)in_buffer, 16,
+					(LPVOID)out_buffer, 4,
+					&nb, NULL ) )
+		{
+			if(out_buffer[0] != 0) ret = count;
+		}
+    CloseHandle (hDevice);
+  }
+
+  return ret;
+}
+
+int CdenableSysReadCdSectors( HANDLE h, DWORD start, DWORD count, char *buf )
+{
+	return( CdenableSysReadCdBytes( h, (start<<11), (count<<11), buf ) );
+}
+
+int CdenableSysWriteCdBytes( HANDLE h, DWORD start, DWORD count, char *buf )
+{
+	return( 0 );
+
+	/*
+  HANDLE   hDevice;
+  int      ret;
+	DWORD		 nb;
+	DWORD    in_buffer[10];
+	DWORD    out_buffer[10];
+
+  ret = 0;
+
+	in_buffer[0] = (DWORD)h;
+	in_buffer[1] = (DWORD)start;
+	in_buffer[2] = (DWORD)count;
+	in_buffer[3] = (DWORD)buf;
+	out_buffer[0] = 0;
+
+  hDevice = CreateFile (sCompleteName,
+                        GENERIC_READ | GENERIC_WRITE,
+                        0,
+                        NULL,
+                        OPEN_EXISTING,
+                        FILE_ATTRIBUTE_NORMAL,
+                        NULL
+                        );
+
+  if (hDevice == ((HANDLE)-1)) {
+    ret = 0;
+	} else {
+		if ( DeviceIoControl(	hDevice,
+					IOCTL_CDENABLE_WRITE,
+					(LPVOID)in_buffer, 16,
+					(LPVOID)out_buffer, 4,
+					&nb, NULL ) )
+		{
+			if(out_buffer[0] != 0) ret = count;
+		}
+    CloseHandle (hDevice);
+  }
+
+  return ret;
+	*/
+}
+
+int CdenableSysWriteCdSectors( HANDLE h, DWORD start, DWORD count, char *buf )
+{
+	// return( CdenableSysWriteCdBytes( h, (start<<11), (count<<11), buf ) );
+	return( 0 );
+}
+
+BOOL CdenableSysInstallStart(void)
+{
+	return(start_driver());
+}
+
+void CdenableSysStopRemove(void)
+{
+	stop_driver();
+	remove_driver();
+}
+
+DWORD CdenableSysGetVersion( void )
+{
+  HANDLE   hDevice;
+  DWORD    ret;
+	DWORD		 nb;
+	DWORD    out_buffer[10];
+
+  ret = 0;
+	out_buffer[0] = 0;
+  hDevice = CreateFile (sCompleteName,
+                        GENERIC_READ | GENERIC_WRITE,
+                        0,
+                        NULL,
+                        OPEN_EXISTING,
+                        FILE_ATTRIBUTE_NORMAL,
+                        NULL
+                        );
+  if (hDevice == ((HANDLE)-1)) {
+    ret = 0;
+	} else {
+		if ( DeviceIoControl(	hDevice,
+					IOCTL_CDENABLE_GET_VERSION,
+					NULL, 0,
+					(LPVOID)out_buffer, 4,
+					&nb, NULL ) )
+		{
+			ret = out_buffer[0];
+		}
+    CloseHandle (hDevice);
+  }
+  return ret;
+}
+
+#ifdef __cplusplus
+} //extern "C"
+#endif
+
--- macemu/SheepShaver/src/Windows/cdenable/ntcd.h
+++ sheepshaver/SheepShaver/src/Windows/cdenable/ntcd.h
@@ -1,99 +1,99 @@
-/*
- *  ntcd.h - Interface to cdenable.sys driver
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-/*
-		Installs the driver, if not already installed.
-		Starts the driver, if not already running.
-
-		You can either always call "CdenableSysInstallStart" when your
-		program fires up and "CdenableSysStopRemove" when it terminates,
-		or just let the installation program call "CdenableSysInstallStart"
-		and leave it always be present.
-
-		I recommend the latter option. Calling "CdenableSysInstallStart"
-		always doesn't hurt anything, it will immediately return
-		with success if the service is running.
-
-		Returns non-zero if installation/startup was succesfull,
-		zero if anything failed.
-		Returns non-zero also if the driver was already running.
-
-		The file "cdenable.sys" must already have been copied to
-		the directory "System32\Drivers"
-*/
-
-#ifndef _NT_CD_H_
-#define _NT_CD_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-BOOL CdenableSysInstallStart(void);
-
-
-/*
-		Stops and removes the driver. See above.
-		This must be called when new version of the driver is updated.
-*/
-void CdenableSysStopRemove(void);
-
-
-/*
-		HANDLE h: returned from CreateFile ( "\\\\.\\X:", GENERIC_READ, ... );
-		Returns the bytes actually read (==count), 0 on failure.
-		NOTE: in my code, start and count are always aligned to
-		sector boundaries (2048 bytes).
-		I cannot guarantee that this works if they are not.
-		Max read is 64 kb.
-		Synchronous read, but quite fast.
-*/
-int CdenableSysReadCdBytes( HANDLE h, DWORD start, DWORD count, char *buf );
-
-
-/*
-		Same as SysReadCdBytes, but "start" and "count" are in 2048 byte
-		sectors.
-*/
-int CdenableSysReadCdSectors( HANDLE h, DWORD start, DWORD count, char *buf );
-
-
-/*
-	Ditto for writing stuff.
-	Not a cd of course but removable & hd media are supported now.
-*/
-int CdenableSysWriteCdBytes( HANDLE h, DWORD start, DWORD count, char *buf );
-int CdenableSysWriteCdSectors( HANDLE h, DWORD start, DWORD count, char *buf );
-
-
-/*
-		Returns CDENABLE_CURRENT_VERSION (of the driver).
-*/
-DWORD CdenableSysGetVersion( void );
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif //_NT_CD_H_
+/*
+ *  ntcd.h - Interface to cdenable.sys driver
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+/*
+		Installs the driver, if not already installed.
+		Starts the driver, if not already running.
+
+		You can either always call "CdenableSysInstallStart" when your
+		program fires up and "CdenableSysStopRemove" when it terminates,
+		or just let the installation program call "CdenableSysInstallStart"
+		and leave it always be present.
+
+		I recommend the latter option. Calling "CdenableSysInstallStart"
+		always doesn't hurt anything, it will immediately return
+		with success if the service is running.
+
+		Returns non-zero if installation/startup was succesfull,
+		zero if anything failed.
+		Returns non-zero also if the driver was already running.
+
+		The file "cdenable.sys" must already have been copied to
+		the directory "System32\Drivers"
+*/
+
+#ifndef _NT_CD_H_
+#define _NT_CD_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+BOOL CdenableSysInstallStart(void);
+
+
+/*
+		Stops and removes the driver. See above.
+		This must be called when new version of the driver is updated.
+*/
+void CdenableSysStopRemove(void);
+
+
+/*
+		HANDLE h: returned from CreateFile ( "\\\\.\\X:", GENERIC_READ, ... );
+		Returns the bytes actually read (==count), 0 on failure.
+		NOTE: in my code, start and count are always aligned to
+		sector boundaries (2048 bytes).
+		I cannot guarantee that this works if they are not.
+		Max read is 64 kb.
+		Synchronous read, but quite fast.
+*/
+int CdenableSysReadCdBytes( HANDLE h, DWORD start, DWORD count, char *buf );
+
+
+/*
+		Same as SysReadCdBytes, but "start" and "count" are in 2048 byte
+		sectors.
+*/
+int CdenableSysReadCdSectors( HANDLE h, DWORD start, DWORD count, char *buf );
+
+
+/*
+	Ditto for writing stuff.
+	Not a cd of course but removable & hd media are supported now.
+*/
+int CdenableSysWriteCdBytes( HANDLE h, DWORD start, DWORD count, char *buf );
+int CdenableSysWriteCdSectors( HANDLE h, DWORD start, DWORD count, char *buf );
+
+
+/*
+		Returns CDENABLE_CURRENT_VERSION (of the driver).
+*/
+DWORD CdenableSysGetVersion( void );
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif //_NT_CD_H_
--- macemu/SheepShaver/src/Windows/clip_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/clip_windows.cpp
@@ -21,6 +21,8 @@
 #include "sysdeps.h"
 
 #include <vector>
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
 
 #include "macos_util.h"
 #include "clip.h"
@@ -177,15 +179,7 @@
 	CloseClipboard();
 }
 
-/*
- * Mac application zeroes clipboard
- */
 
-void ZeroScrap()
-{
-
-}
-
 /*
  *  Mac application reads clipboard
  */
@@ -234,7 +228,7 @@
 
 						// Convert text from ISO-Latin1 to Mac charset
 						uint8 *p = Mac2HostAddr(scrap_area);
-						for (uint32 i = 0; i < length; i++) {
+						for (int i = 0; i < length; i++) {
 							uint8 c = data[i];
 							if (c < 0x80) {
 								if (c == 0)
@@ -260,7 +254,7 @@
 						0x2f, 0x3c, 0, 0, 0, 0,		// move.l	#outbuf,-(sp)
 						0xa9, 0xfe,					// PutScrap()
 						0x58, 0x8f,					// addq.l	#4,sp
-						uint8(M68K_RTS >> 8), uint8(M68K_RTS)
+						M68K_RTS >> 8, M68K_RTS
 					};
 					uint32 proc_area = Host2MacAddr(proc);
 					WriteMacInt32(proc_area +  6, out_length);
Only in sheepshaver/: SheepShaver/src/Windows/config.h
--- macemu/SheepShaver/src/Windows/configure.ac
+++ sheepshaver/SheepShaver/src/Windows/configure.ac
@@ -1,266 +1,266 @@
-dnl Process this file with autoconf to produce a configure script.
-dnl Written in 2002 by Christian Bauer
-
-AC_INIT([SheepShaver], 2.3, [Christian.Bauer@uni-mainz.de], SheepShaver)
-AC_CONFIG_SRCDIR(main_windows.cpp)
-AC_CONFIG_AUX_DIR(../Unix)
-AC_PREREQ(2.52)
-AC_CONFIG_HEADER(config.h)
-
-dnl Canonical system information.
-AC_CANONICAL_HOST
-AC_CANONICAL_TARGET
-
-dnl Options.
-AC_ARG_ENABLE(jit,          [  --enable-jit            enable JIT compiler [default=yes]], [WANT_JIT=$enableval], [WANT_JIT=yes])
-AC_ARG_WITH(gtk,          [  --with-gtk              use GTK user interface [default=yes]], [WANT_GTK=$withval], [WANT_GTK=yes])
-
-dnl Checks for programs.
-AC_PROG_CC
-AC_PROG_CPP
-AC_PROG_CXX
-AC_PROG_MAKE_SET
-AC_PROG_EGREP
-AC_PROG_LN_S
-AC_PATH_PROG(PERL, [perl])
-AC_CHECK_TOOL(WINDRES, windres)
-
-dnl We use GTK+ if possible.
-if [[ "x$WANT_GTK" = "xyes" ]]; then
-  AM_PATH_GTK_2_0(1.3.15, [], [
-    AC_MSG_WARN([Could not find GTK+ 2.0, disabling user interface.])
-    WANT_GTK=no
-  ])
-fi
-AC_SUBST(WANT_GTK)
-
-dnl We use 64-bit file size support if possible.
-AC_SYS_LARGEFILE
-
-dnl Checks for header files.
-AC_HEADER_STDC
-
-dnl Checks for typedefs, structures, and compiler characteristics.
-AC_C_BIGENDIAN
-AC_C_CONST
-AC_C_INLINE
-AC_CHECK_SIZEOF(short, 2)
-AC_CHECK_SIZEOF(int, 4)
-AC_CHECK_SIZEOF(long, 4)
-AC_CHECK_SIZEOF(long long, 8)
-AC_CHECK_SIZEOF(float, 4)
-AC_CHECK_SIZEOF(double, 8)
-AC_CHECK_SIZEOF(void *, 4)
-AC_TYPE_OFF_T
-AC_CHECK_TYPES(loff_t)
-AC_TYPE_SIZE_T
-
-dnl Checks for library functions.
-AC_CHECK_FUNCS(strdup strerror)
-AC_CHECK_FUNCS(exp2f log2f exp2 log2)
-AC_CHECK_FUNCS(floorf roundf ceilf truncf)
-AC_CHECK_FUNCS(floor round ceil trunc)
-
-dnl Define a macro that translates a yesno-variable into a C macro definition
-dnl to be put into the config.h file
-dnl $1 -- the macro to define
-dnl $2 -- the value to translate
-dnl $3 -- template name
-AC_DEFUN([AC_TRANSLATE_DEFINE], [
-    if [[ "x$2" = "xyes" -o "x$2" = "xguessing yes" ]]; then
-        AC_DEFINE($1, 1, $3)
-    fi
-])
-
-dnl Check that VirtualAlloc(), VirtualProtect() work
-AC_CACHE_CHECK([whether VirtualProtect works],
-  ac_cv_VirtualProtect_works, [
-  AC_LANG_SAVE
-  AC_LANG_CPLUSPLUS
-  ac_cv_VirtualProtect_works=yes
-  dnl First the tests that should segfault
-  for test_def in NONE_READ NONE_WRITE READ_WRITE; do
-    AC_TRY_RUN([
-      #define HAVE_WIN32_VM 1
-      #define CONFIGURE_TEST_VM_MAP
-      #define TEST_VM_PROT_$test_def
-      #include "../Unix/vm_alloc.cpp"
-    ], ac_cv_VirtualProtect_works=no, rm -f core,
-    dnl When cross-compiling, assume it works
-    ac_cv_VirtualProtect_works="yes"
-    )
-  done
-  AC_TRY_RUN([
-    #define HAVE_WIN32_VM 1
-    #define CONFIGURE_TEST_VM_MAP
-    #define TEST_VM_PROT_RDWR_WRITE
-    #include "../Unix/vm_alloc.cpp"
-  ], , ac_cv_VirtualProtect_works=no,
-  dnl When cross-compiling, assume it works
-  ac_cv_VirtualProtect_works="yes"
-  )
-  AC_LANG_RESTORE
-  ]
-)
-if [[ "x$ac_cv_VirtualProtect_works" = "xyes" ]]; then
-  AC_DEFINE(HAVE_WIN32_VM, 1, [Define if your system has a working Win32-based memory allocator.])
-else
-  AC_MSG_ERROR([Sorry, Windows VM functions don't work as expected on your system.])
-fi
-
-dnl Check if Windows exceptions are supported.
-AC_CACHE_CHECK([whether your system supports Windows exceptions],
-  ac_cv_have_win32_exceptions, [
-  AC_LANG_SAVE
-  AC_LANG_CPLUSPLUS
-  AC_TRY_RUN([
-    #define HAVE_WIN32_EXCEPTIONS 1
-    #define CONFIGURE_TEST_SIGSEGV_RECOVERY
-    #include "../Unix/vm_alloc.cpp"
-    #include "../Unix/sigsegv.cpp"
-  ],
-  ac_cv_have_win32_exceptions=yes,
-  ac_cv_have_win32_exceptions=no,
-  dnl When cross-compiling, assume it works
-  ac_cv_have_win32_exceptions="yes"
-  )
-  AC_LANG_RESTORE
-  ]
-)
-if [[ "x$ac_cv_have_win32_exceptions" = "xyes" ]]; then
-  AC_DEFINE(HAVE_WIN32_EXCEPTIONS, 1, [Define if your system supports Windows exceptions.])
-else
-  AC_MSG_ERROR([Sorry, Windows exceptions don't work as expected on your system.])
-fi
-
-dnl Check if we can ignore the fault (instruction skipping in SIGSEGV handler)
-AC_CACHE_CHECK([whether we can skip instruction in SIGSEGV handler],
-  ac_cv_have_skip_instruction, [
-  AC_LANG_SAVE
-  AC_LANG_CPLUSPLUS
-  AC_TRY_RUN([
-    #define HAVE_SIGSEGV_SKIP_INSTRUCTION 1
-    #define CONFIGURE_TEST_SIGSEGV_RECOVERY
-    #include "../Unix/vm_alloc.cpp"
-    #include "../Unix/sigsegv.cpp"
-  ], ac_cv_have_skip_instruction=yes, ac_cv_have_skip_instruction=no,
-  dnl When cross-compiling, assume it works
-  ac_cv_have_skip_instruction="yes"
-  )
-  AC_LANG_RESTORE
-  ]
-)
-AC_TRANSLATE_DEFINE(HAVE_SIGSEGV_SKIP_INSTRUCTION, "$ac_cv_have_skip_instruction",
-  [Define if we can ignore the fault (instruction skipping in SIGSEGV handler).])
-
-dnl We really want VOSF (Video on SEGV Signals) screen updates acceleration
-AC_DEFINE(ENABLE_VOSF, 1, [Define if using video enabled on SEGV signals.])
-
-dnl Check for GCC 2.7 or higher.
-HAVE_GCC27=no
-AC_MSG_CHECKING(for GCC 2.7 or higher)
-AC_EGREP_CPP(xyes,
-[#if __GNUC__ - 1 > 1 || __GNUC_MINOR__ - 1 > 5
-  xyes
-#endif
-], [AC_MSG_RESULT(yes); HAVE_GCC27=yes], AC_MSG_RESULT(no))
-
-dnl Check for GCC 3.0 or higher.
-HAVE_GCC30=no
-AC_MSG_CHECKING(for GCC 3.0 or higher)
-AC_EGREP_CPP(xyes,
-[#if __GNUC__ >= 3
-  xyes
-#endif
-], [AC_MSG_RESULT(yes); HAVE_GCC30=yes], AC_MSG_RESULT(no))
-
-dnl Add -fno-strict-aliasing for slirp sources
-if [[ "x$HAVE_GCC30" = "xyes" ]]; then
-  SAVED_CFLAGS="$CFLAGS"
-  CFLAGS="$CFLAGS -fno-strict-aliasing"
-  AC_CACHE_CHECK([whether the compiler supports -fno-strict-aliasing],
-    ac_cv_gcc_no_strict_aliasing, [
-    AC_TRY_COMPILE([],[],
-      [ac_cv_gcc_no_strict_aliasing=yes; AC_SUBST(SLIRP_CFLAGS, "-fno-strict-aliasing")],
-      [ac_cv_gcc_no_strict_aliasing=no])
-  ])
-  CFLAGS="$SAVED_CFLAGS"
-fi
-
-dnl CPU emulator sources
-CPUSRCS="\
-    ../kpx_cpu/src/mathlib/ieeefp.cpp \
-    ../kpx_cpu/src/mathlib/mathlib.cpp \
-    ../kpx_cpu/src/cpu/ppc/ppc-cpu.cpp \
-    ../kpx_cpu/src/cpu/ppc/ppc-decode.cpp \
-    ../kpx_cpu/src/cpu/ppc/ppc-execute.cpp \
-    ../kpx_cpu/src/cpu/ppc/ppc-translate.cpp \
-    ../kpx_cpu/src/utils/utils-cpuinfo.cpp"
-CPPFLAGS="$CPPFLAGS -I../kpx_cpu/include -I../kpx_cpu/src"
-
-dnl Enable JIT compiler, if possible
-USE_DYNGEN="no"
-if [[ "x$WANT_JIT" = "xyes" ]]; then
-  case $host_cpu in
-  i?86)
-    DYNGEN_OP_FLAGS="-fomit-frame-pointer -mpreferred-stack-boundary=2"
-    if [[ "x$HAVE_GCC30" = "xyes" ]]; then
-      DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -falign-functions=0"
-    else
-      DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -malign-functions=0"
-    fi
-    ;;
-  esac
-  USE_DYNGEN="yes"
-  DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -finline-limit=10000 -g0"
-  if [[ "x$HAVE_GCC30" = "xyes" ]]; then
-    DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -fno-reorder-blocks -fno-optimize-sibling-calls"
-  fi
-  AC_DEFINE(ENABLE_DYNGEN, 1, [Define to enable dyngen engine])
-  DYNGENSRCS="\
-    ../kpx_cpu/src/cpu/jit/dyngen.c \
-    ../kpx_cpu/src/cpu/jit/cxxdemangle.cpp"
-  CPUSRCS="\
-    ../kpx_cpu/src/cpu/jit/jit-cache.cpp \
-    ../kpx_cpu/src/cpu/jit/basic-dyngen.cpp \
-    ../kpx_cpu/src/cpu/ppc/ppc-dyngen.cpp \
-    ../kpx_cpu/src/cpu/ppc/ppc-jit.cpp $CPUSRCS"
-  CPPFLAGS="$CPPFLAGS -DUSE_JIT"
-fi
-CPUSRCS="$CPUSRCS ../kpx_cpu/sheepshaver_glue.cpp ../kpx_cpu/ppc-dis.c"
-
-dnl Use the dummy prefs file.
-CPUSRCS="$CPUSRCS ../dummy/prefs_dummy.cpp"
-
-dnl We really want SDL for now
-AC_CHECK_TOOL(sdl_config, sdl-config, [AC_MSG_ERROR([Sorry, you currently need SDL for this port])])
-SDL_CFLAGS=`$sdl_config --cflags`
-AC_SUBST(SDL_CFLAGS)
-SDL_LIBS=`$sdl_config --libs`
-AC_SUBST(SDL_LIBS)
-AC_DEFINE(USE_SDL, 1, [Define to enble SDL support])
-AC_DEFINE(USE_SDL_VIDEO, 1, [Define to enable SDL video graphics support])
-AC_DEFINE(USE_SDL_AUDIO, 1, [Define to enable SDL audio support])
-
-dnl Remove the "-g" option if set for GCC.
-if [[ "x$HAVE_GCC27" = "xyes" ]]; then
-  CFLAGS=`echo $CFLAGS | sed -e 's/-g\b//g'`
-  CXXFLAGS=`echo $CXXFLAGS | sed -e 's/-g\b//g'`
-fi
-
-dnl Generate Makefile.
-AC_SUBST(PERL)
-AC_SUBST(USE_DYNGEN)
-AC_SUBST(DYNGENSRCS)
-AC_SUBST(DYNGEN_OP_FLAGS)
-AC_SUBST(CPUSRCS)
-AC_OUTPUT([Makefile])
-
-dnl Print summary.
-echo
-echo SheepShaver configuration summary:
-echo
-echo Enable JIT compiler .............. : $WANT_JIT
-echo GTK user interface ............... : $WANT_GTK
-echo
-echo "Configuration done. Now type \"make\"."
+dnl Process this file with autoconf to produce a configure script.
+dnl Written in 2002 by Christian Bauer
+
+AC_INIT([SheepShaver], 2.3, [Christian.Bauer@uni-mainz.de], SheepShaver)
+AC_CONFIG_SRCDIR(main_windows.cpp)
+AC_CONFIG_AUX_DIR(../Unix)
+AC_PREREQ(2.52)
+AC_CONFIG_HEADER(config.h)
+
+dnl Checks for programs.
+AC_PROG_CC
+AC_PROG_CPP
+AC_PROG_CXX
+AC_PROG_MAKE_SET
+AC_PROG_EGREP
+AC_PROG_LN_S
+AC_PATH_PROG(PERL, [perl])
+AC_CHECK_TOOL(WINDRES, windres)
+
+dnl Canonical system information.
+AC_CANONICAL_HOST
+AC_CANONICAL_TARGET
+
+dnl Options.
+AC_ARG_ENABLE(jit,          [  --enable-jit            enable JIT compiler [default=yes]], [WANT_JIT=$enableval], [WANT_JIT=yes])
+AC_ARG_WITH(gtk,          [  --with-gtk              use GTK user interface [default=yes]], [WANT_GTK=$withval], [WANT_GTK=yes])
+
+dnl We use GTK+ if possible.
+if [[ "x$WANT_GTK" = "xyes" ]]; then
+  AM_PATH_GTK_2_0(2.16.0, [], [
+    AC_MSG_WARN([Could not find GTK+ 2.0, disabling user interface.])
+    WANT_GTK=no
+  ])
+fi
+AC_SUBST(WANT_GTK)
+
+dnl We use 64-bit file size support if possible.
+AC_SYS_LARGEFILE
+
+dnl Checks for header files.
+AC_HEADER_STDC
+
+dnl Checks for typedefs, structures, and compiler characteristics.
+AC_C_BIGENDIAN
+AC_C_CONST
+AC_C_INLINE
+AC_CHECK_SIZEOF(short, 2)
+AC_CHECK_SIZEOF(int, 4)
+AC_CHECK_SIZEOF(long, 4)
+AC_CHECK_SIZEOF(long long, 8)
+AC_CHECK_SIZEOF(float, 4)
+AC_CHECK_SIZEOF(double, 8)
+AC_CHECK_SIZEOF(void *, 4)
+AC_TYPE_OFF_T
+AC_CHECK_TYPES(loff_t)
+AC_TYPE_SIZE_T
+
+dnl Checks for library functions.
+AC_CHECK_FUNCS(strdup strerror)
+AC_CHECK_FUNCS(exp2f log2f exp2 log2)
+AC_CHECK_FUNCS(floorf roundf ceilf truncf)
+AC_CHECK_FUNCS(floor round ceil trunc)
+
+dnl Define a macro that translates a yesno-variable into a C macro definition
+dnl to be put into the config.h file
+dnl $1 -- the macro to define
+dnl $2 -- the value to translate
+dnl $3 -- template name
+AC_DEFUN([AC_TRANSLATE_DEFINE], [
+    if [[ "x$2" = "xyes" -o "x$2" = "xguessing yes" ]]; then
+        AC_DEFINE($1, 1, $3)
+    fi
+])
+
+dnl Check that VirtualAlloc(), VirtualProtect() work
+AC_CACHE_CHECK([whether VirtualProtect works],
+  ac_cv_VirtualProtect_works, [
+  AC_LANG_SAVE
+  AC_LANG_CPLUSPLUS
+  ac_cv_VirtualProtect_works=yes
+  dnl First the tests that should segfault
+  for test_def in NONE_READ NONE_WRITE READ_WRITE; do
+    AC_TRY_RUN([
+      #define HAVE_WIN32_VM 1
+      #define CONFIGURE_TEST_VM_MAP
+      #define TEST_VM_PROT_$test_def
+      #include "../Unix/vm_alloc.cpp"
+    ], ac_cv_VirtualProtect_works=no, rm -f core,
+    dnl When cross-compiling, assume it works
+    ac_cv_VirtualProtect_works="yes"
+    )
+  done
+  AC_TRY_RUN([
+    #define HAVE_WIN32_VM 1
+    #define CONFIGURE_TEST_VM_MAP
+    #define TEST_VM_PROT_RDWR_WRITE
+    #include "../Unix/vm_alloc.cpp"
+  ], , ac_cv_VirtualProtect_works=no,
+  dnl When cross-compiling, assume it works
+  ac_cv_VirtualProtect_works="yes"
+  )
+  AC_LANG_RESTORE
+  ]
+)
+if [[ "x$ac_cv_VirtualProtect_works" = "xyes" ]]; then
+  AC_DEFINE(HAVE_WIN32_VM, 1, [Define if your system has a working Win32-based memory allocator.])
+else
+  AC_MSG_ERROR([Sorry, Windows VM functions don't work as expected on your system.])
+fi
+
+dnl Check if Windows exceptions are supported.
+AC_CACHE_CHECK([whether your system supports Windows exceptions],
+  ac_cv_have_win32_exceptions, [
+  AC_LANG_SAVE
+  AC_LANG_CPLUSPLUS
+  AC_TRY_RUN([
+    #define HAVE_WIN32_EXCEPTIONS 1
+    #define CONFIGURE_TEST_SIGSEGV_RECOVERY
+    #include "../Unix/vm_alloc.cpp"
+    #include "../Unix/sigsegv.cpp"
+  ],
+  ac_cv_have_win32_exceptions=yes,
+  ac_cv_have_win32_exceptions=no,
+  dnl When cross-compiling, assume it works
+  ac_cv_have_win32_exceptions="yes"
+  )
+  AC_LANG_RESTORE
+  ]
+)
+if [[ "x$ac_cv_have_win32_exceptions" = "xyes" ]]; then
+  AC_DEFINE(HAVE_WIN32_EXCEPTIONS, 1, [Define if your system supports Windows exceptions.])
+else
+  AC_MSG_ERROR([Sorry, Windows exceptions don't work as expected on your system.])
+fi
+
+dnl Check if we can ignore the fault (instruction skipping in SIGSEGV handler)
+AC_CACHE_CHECK([whether we can skip instruction in SIGSEGV handler],
+  ac_cv_have_skip_instruction, [
+  AC_LANG_SAVE
+  AC_LANG_CPLUSPLUS
+  AC_TRY_RUN([
+    #define HAVE_SIGSEGV_SKIP_INSTRUCTION 1
+    #define CONFIGURE_TEST_SIGSEGV_RECOVERY
+    #include "../Unix/vm_alloc.cpp"
+    #include "../Unix/sigsegv.cpp"
+  ], ac_cv_have_skip_instruction=yes, ac_cv_have_skip_instruction=no,
+  dnl When cross-compiling, assume it works
+  ac_cv_have_skip_instruction="yes"
+  )
+  AC_LANG_RESTORE
+  ]
+)
+AC_TRANSLATE_DEFINE(HAVE_SIGSEGV_SKIP_INSTRUCTION, "$ac_cv_have_skip_instruction",
+  [Define if we can ignore the fault (instruction skipping in SIGSEGV handler).])
+
+dnl We really want VOSF (Video on SEGV Signals) screen updates acceleration
+AC_DEFINE(ENABLE_VOSF, 1, [Define if using video enabled on SEGV signals.])
+
+dnl Check for GCC 2.7 or higher.
+HAVE_GCC27=no
+AC_MSG_CHECKING(for GCC 2.7 or higher)
+AC_EGREP_CPP(xyes,
+[#if __GNUC__ - 1 > 1 || __GNUC_MINOR__ - 1 > 5
+  xyes
+#endif
+], [AC_MSG_RESULT(yes); HAVE_GCC27=yes], AC_MSG_RESULT(no))
+
+dnl Check for GCC 3.0 or higher.
+HAVE_GCC30=no
+AC_MSG_CHECKING(for GCC 3.0 or higher)
+AC_EGREP_CPP(xyes,
+[#if __GNUC__ >= 3
+  xyes
+#endif
+], [AC_MSG_RESULT(yes); HAVE_GCC30=yes], AC_MSG_RESULT(no))
+
+dnl Add -fno-strict-aliasing for slirp sources
+if [[ "x$HAVE_GCC30" = "xyes" ]]; then
+  SAVED_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -fno-strict-aliasing"
+  AC_CACHE_CHECK([whether the compiler supports -fno-strict-aliasing],
+    ac_cv_gcc_no_strict_aliasing, [
+    AC_TRY_COMPILE([],[],
+      [ac_cv_gcc_no_strict_aliasing=yes; AC_SUBST(SLIRP_CFLAGS, "-fno-strict-aliasing")],
+      [ac_cv_gcc_no_strict_aliasing=no])
+  ])
+  CFLAGS="$SAVED_CFLAGS"
+fi
+
+dnl CPU emulator sources
+CPUSRCS="\
+    ../kpx_cpu/src/mathlib/ieeefp.cpp \
+    ../kpx_cpu/src/mathlib/mathlib.cpp \
+    ../kpx_cpu/src/cpu/ppc/ppc-cpu.cpp \
+    ../kpx_cpu/src/cpu/ppc/ppc-decode.cpp \
+    ../kpx_cpu/src/cpu/ppc/ppc-execute.cpp \
+    ../kpx_cpu/src/cpu/ppc/ppc-translate.cpp \
+    ../kpx_cpu/src/utils/utils-cpuinfo.cpp"
+CPPFLAGS="$CPPFLAGS -I../kpx_cpu/include -I../kpx_cpu/src"
+
+dnl Enable JIT compiler, if possible
+USE_DYNGEN="no"
+if [[ "x$WANT_JIT" = "xyes" ]]; then
+  case $host_cpu in
+  i?86)
+    DYNGEN_OP_FLAGS="-fomit-frame-pointer -mpreferred-stack-boundary=2"
+    if [[ "x$HAVE_GCC30" = "xyes" ]]; then
+      DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -falign-functions=0"
+    else
+      DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -malign-functions=0"
+    fi
+    ;;
+  esac
+  USE_DYNGEN="yes"
+  DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -finline-limit=10000 -g0"
+  if [[ "x$HAVE_GCC30" = "xyes" ]]; then
+    DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -fno-reorder-blocks -fno-optimize-sibling-calls"
+  fi
+  AC_DEFINE(ENABLE_DYNGEN, 1, [Define to enable dyngen engine])
+  DYNGENSRCS="\
+    ../kpx_cpu/src/cpu/jit/dyngen.c \
+    ../kpx_cpu/src/cpu/jit/cxxdemangle.cpp"
+  CPUSRCS="\
+    ../kpx_cpu/src/cpu/jit/jit-cache.cpp \
+    ../kpx_cpu/src/cpu/jit/basic-dyngen.cpp \
+    ../kpx_cpu/src/cpu/ppc/ppc-dyngen.cpp \
+    ../kpx_cpu/src/cpu/ppc/ppc-jit.cpp $CPUSRCS"
+  CPPFLAGS="$CPPFLAGS -DUSE_JIT"
+fi
+CPUSRCS="$CPUSRCS ../kpx_cpu/sheepshaver_glue.cpp"
+
+dnl Use the dummy prefs file.
+CPUSRCS="$CPUSRCS ../dummy/prefs_dummy.cpp"
+
+dnl We really want SDL for now
+AC_CHECK_TOOL(sdl_config, sdl-config, [AC_MSG_ERROR([Sorry, you currently need SDL for this port])])
+SDL_CFLAGS=`$sdl_config --cflags`
+AC_SUBST(SDL_CFLAGS)
+SDL_LIBS=`$sdl_config --libs`
+AC_SUBST(SDL_LIBS)
+AC_DEFINE(USE_SDL, 1, [Define to enble SDL support])
+AC_DEFINE(USE_SDL_VIDEO, 1, [Define to enable SDL video graphics support])
+AC_DEFINE(USE_SDL_AUDIO, 1, [Define to enable SDL audio support])
+
+dnl Remove the "-g" option if set for GCC.
+if [[ "x$HAVE_GCC27" = "xyes" ]]; then
+  CFLAGS=`echo $CFLAGS | sed -e 's/-g\b//g'`
+  CXXFLAGS=`echo $CXXFLAGS | sed -e 's/-g\b//g'`
+fi
+
+dnl Generate Makefile.
+AC_SUBST(PERL)
+AC_SUBST(USE_DYNGEN)
+AC_SUBST(DYNGENSRCS)
+AC_SUBST(DYNGEN_OP_FLAGS)
+AC_SUBST(CPUSRCS)
+AC_OUTPUT([Makefile])
+
+dnl Print summary.
+echo
+echo SheepShaver configuration summary:
+echo
+echo Enable JIT compiler .............. : $WANT_JIT
+echo GTK user interface ............... : $WANT_GTK
+echo
+echo "Configuration done. Now type \"make\"."
--- macemu/SheepShaver/src/Windows/ether_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/ether_windows.cpp
@@ -22,6 +22,8 @@
 
 #include "sysdeps.h"
 
+#include <algorithm>
+
 #include <process.h>
 #include <windowsx.h>
 #include <winioctl.h>
@@ -38,7 +40,7 @@
 #include "b2ether/inc/b2ether_hl.h"
 #include "ether_windows.h"
 #include "router/router.h"
-#include "util_windows.h"
+#include "kernel_windows.h"
 #include "libslirp.h"
 
 // Define to let the slirp library determine the right timeout for select()
@@ -168,7 +170,7 @@
 static HANDLE int_send_now = 0;
 
 // Prototypes
-static LPADAPTER tap_open_adapter(LPCTSTR dev_name);
+static LPADAPTER tap_open_adapter(const char *dev_name);
 static void tap_close_adapter(LPADAPTER fd);
 static bool tap_check_version(LPADAPTER fd);
 static bool tap_set_status(LPADAPTER fd, ULONG status);
@@ -218,7 +220,7 @@
 
 bool ether_init(void)
 {
-	TCHAR buf[256];
+	char str[256];
 
 	// Do nothing if no Ethernet device specified
 	const char *name = PrefsFindString("ether");
@@ -248,21 +250,22 @@
 	// Initialize slirp library
 	if (net_if_type == NET_IF_SLIRP) {
 		if (slirp_init() < 0) {
-			WarningAlert(GetString(STR_SLIRP_NO_DNS_FOUND_WARN));
+			sprintf(str, GetString(STR_SLIRP_NO_DNS_FOUND_WARN));
+			WarningAlert(str);
 			return false;
 		}
 	}
 
 	// Open ethernet device
-	decltype(tstr(std::declval<const char*>())) dev_name;
+	const char *dev_name;
 	switch (net_if_type) {
 	case NET_IF_B2ETHER:
-		dev_name = tstr(PrefsFindString("etherguid"));
+		dev_name = PrefsFindString("etherguid");
 		if (dev_name == NULL || strcmp(name, "b2ether") != 0)
-			dev_name = tstr(name);
+			dev_name = name;
 		break;
 	case NET_IF_TAP:
-		dev_name = tstr(PrefsFindString("etherguid"));
+		dev_name = PrefsFindString("etherguid");
 		break;
 	}
 	if (net_if_type == NET_IF_B2ETHER) {
@@ -271,17 +274,17 @@
 			goto open_error;
 		}
 
-		fd = PacketOpenAdapter( dev_name.get(), ether_multi_mode );
+		fd = PacketOpenAdapter( dev_name, ether_multi_mode );
 		if (!fd) {
-			_sntprintf(buf, lengthof(buf), TEXT("Could not open ethernet adapter %s."), dev_name.get());
-			WarningAlert(buf);
+			sprintf(str, "Could not open ethernet adapter %s.", dev_name);
+			WarningAlert(str);
 			goto open_error;
 		}
 
 		// Get Ethernet address
 		if(!PacketGetMAC(fd,ether_addr,ether_use_permanent)) {
-			_sntprintf(buf, lengthof(buf), TEXT("Could not get hardware address of device %s. Ethernet is not available."), dev_name.get());
-			WarningAlert(buf);
+			sprintf(str, "Could not get hardware address of device %s. Ethernet is not available.", dev_name);
+			WarningAlert(str);
 			goto open_error;
 		}
 		D(bug("Real ethernet address %02x %02x %02x %02x %02x %02x\n", ether_addr[0], ether_addr[1], ether_addr[2], ether_addr[3], ether_addr[4], ether_addr[5]));
@@ -305,27 +308,28 @@
 			goto open_error;
 		}
 
-		fd = tap_open_adapter(dev_name.get());
+		fd = tap_open_adapter(dev_name);
 		if (!fd) {
-			_sntprintf(buf, lengthof(buf), TEXT("Could not open ethernet adapter %s."), dev_name.get());
-			WarningAlert(buf);
+			sprintf(str, "Could not open ethernet adapter %s.", dev_name);
+			WarningAlert(str);
 			goto open_error;
 		}
 
 		if (!tap_check_version(fd)) {
-			_sntprintf(buf, lengthof(buf), TEXT("Minimal TAP-Win32 version supported is %d.%d."), TAP_VERSION_MIN_MAJOR, TAP_VERSION_MIN_MINOR);
-			WarningAlert(buf);
+			sprintf(str, "Minimal TAP-Win32 version supported is %d.%d.", TAP_VERSION_MIN_MAJOR, TAP_VERSION_MIN_MINOR);
+			WarningAlert(str);
 			goto open_error;
 		}
 
 		if (!tap_set_status(fd, true)) {
-			WarningAlert("Could not set media status to connected.");
+			sprintf(str, "Could not set media status to connected.");
+			WarningAlert(str);
 			goto open_error;
 		}
 
 		if (!tap_get_mac(fd, ether_addr)) {
-			_sntprintf(buf, lengthof(buf), TEXT("Could not get hardware address of device %s. Ethernet is not available."), dev_name.get());
-			WarningAlert(buf);
+			sprintf(str, "Could not get hardware address of device %s. Ethernet is not available.", dev_name);
+			WarningAlert(str);
 			goto open_error;
 		}
 		D(bug("Real ethernet address %02x %02x %02x %02x %02x %02x\n", ether_addr[0], ether_addr[1], ether_addr[2], ether_addr[3], ether_addr[4], ether_addr[5]));
@@ -401,10 +405,26 @@
 	// No need to enter wait state if we can avoid it.
 	// These all terminate fast.
 
-	InitializeCriticalSectionAndSpinCount( &fetch_csection, 5000 );
-	InitializeCriticalSectionAndSpinCount( &queue_csection, 5000 );
-	InitializeCriticalSectionAndSpinCount( &send_csection, 5000 );
-	InitializeCriticalSectionAndSpinCount( &wpool_csection, 5000 );
+	if(pfnInitializeCriticalSectionAndSpinCount) {
+		pfnInitializeCriticalSectionAndSpinCount( &fetch_csection, 5000 );
+	} else {
+		InitializeCriticalSection( &fetch_csection );
+	}
+	if(pfnInitializeCriticalSectionAndSpinCount) {
+		pfnInitializeCriticalSectionAndSpinCount( &queue_csection, 5000 );
+	} else {
+		InitializeCriticalSection( &queue_csection );
+	}
+	if(pfnInitializeCriticalSectionAndSpinCount) {
+		pfnInitializeCriticalSectionAndSpinCount( &send_csection, 5000 );
+	} else {
+		InitializeCriticalSection( &send_csection );
+	}
+	if(pfnInitializeCriticalSectionAndSpinCount) {
+		pfnInitializeCriticalSectionAndSpinCount( &wpool_csection, 5000 );
+	} else {
+		InitializeCriticalSection( &wpool_csection );
+	}
 
 	ether_th = (HANDLE)_beginthreadex( 0, 0, ether_thread_feed_int, 0, 0, &ether_tid );
 	if (!ether_th) {
@@ -479,8 +499,8 @@
 	if(int_send_now) ReleaseSemaphore(int_send_now,1,NULL);
 
 	D(bug("CancelIO if needed\n"));
-	if (fd && fd->hFile)
-		CancelIo(fd->hFile);
+	if (fd && fd->hFile && pfnCancelIo)
+		pfnCancelIo(fd->hFile);
 
 	// Wait max 2 secs to shut down pending io. After that, kill them.
 	D(bug("Wait delay\n"));
@@ -974,7 +994,7 @@
 	return Packet;
 }
 
-unsigned int WINAPI ether_thread_write_packets(void *arg)
+static unsigned int WINAPI ether_thread_write_packets(void *arg)
 {
 	LPPACKET Packet;
 
@@ -1034,7 +1054,7 @@
 		memcpy( Packet->Buffer, packet, len );
 
 		EnterCriticalSection( &fetch_csection );
-		pending_packet_sz[echo_count] = min(sizeof(pending_packet),len);
+		pending_packet_sz[echo_count] = std::min<int>(sizeof(pending_packet),len);
 		memcpy( pending_packet[echo_count], packet, pending_packet_sz[echo_count] );
 		echo_count = (echo_count+1) & (~(MAX_ECHO-1));
 		LeaveCriticalSection( &fetch_csection );
@@ -1166,15 +1186,15 @@
  *  TAP-Win32 glue
  */
 
-static LPADAPTER tap_open_adapter(LPCTSTR dev_name)
+static LPADAPTER tap_open_adapter(const char *dev_name)
 {
 	fd = (LPADAPTER)GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof(*fd));
 	if (fd == NULL)
 		return NULL;
 
-	TCHAR dev_path[MAX_PATH];
-	_sntprintf(dev_path, lengthof(dev_path),
-			 TEXT("\\\\.\\Global\\%s.tap"), dev_name);
+	char dev_path[MAX_PATH];
+	snprintf(dev_path, sizeof(dev_path),
+			 "\\\\.\\Global\\%s.tap", dev_name);
 
 	HANDLE handle = CreateFile(
 		dev_path,
@@ -1228,7 +1248,7 @@
 	DWORD len = 0;
 	return DeviceIoControl(fd->hFile, TAP_IOCTL_SET_MEDIA_STATUS,
 						   &status, sizeof (status),
-						   &status, sizeof (status), &len, NULL) != FALSE;
+						   &status, sizeof (status), &len, NULL);
 }
 
 static bool tap_get_mac(LPADAPTER fd, LPBYTE addr)
@@ -1236,7 +1256,8 @@
 	DWORD len = 0;
 	return DeviceIoControl(fd->hFile, TAP_IOCTL_GET_MAC,
 						   addr, 6,
-						   addr, 6, &len, NULL) != FALSE;
+						   addr, 6, &len, NULL);
+						   
 }
 
 static VOID CALLBACK tap_write_completion(
@@ -1290,7 +1311,7 @@
 			recycle_write_packet(lpPacket);
 	}
 
-	return Result != FALSE;
+	return Result;
 }
 
 static bool tap_receive_packet(LPADAPTER fd, LPPACKET lpPacket, BOOLEAN Sync)
@@ -1329,7 +1350,7 @@
 			lpPacket->BytesReceived = 0;
 	}
 
-	return Result != FALSE;
+	return Result;
 }
 
 
@@ -1347,7 +1368,7 @@
 	enqueue_packet(packet, len);
 }
 
-unsigned int WINAPI slirp_receive_func(void *arg)
+static unsigned int WINAPI slirp_receive_func(void *arg)
 {
 	D(bug("slirp_receive_func\n"));
 	thread_active_2 = true;
@@ -1387,9 +1408,6 @@
 	return 0;
 }
 
-const uint8 ether_broadcast_addr[6] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
-const uint8 appletalk_broadcast_addr[6] = { 0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF };
-const uint8 appletalk_zone_multicast_prefix[5] = { 0x09, 0x00, 0x07, 0x00, 0x00 };
 
 /*
  *  Packet reception threads
@@ -1408,7 +1426,7 @@
 	D(bug("packet_read_completion bytes=%d, error code=%d\n",dwNumberOfBytesTransfered,dwErrorCode));
 
 	if(thread_active && !dwErrorCode) {
-		int count = min(dwNumberOfBytesTransfered,1514);
+		int count = std::min<int>(dwNumberOfBytesTransfered,1514);
 		if(count) {
 			int j = echo_count;
 			for(int i=MAX_ECHO; i; i--) {
@@ -1428,15 +1446,10 @@
 					break;
 				}
 			}
-			// XXX drop packets that we don't care about
+			// XXX drop packets that are not for us
 			if (net_if_type == NET_IF_TAP) {
-				if (memcmp((LPBYTE)lpPacket->Buffer, ether_addr, 6) != 0 &&
-					memcmp((LPBYTE)lpPacket->Buffer, ether_broadcast_addr, 6) != 0 &&
-					memcmp((LPBYTE)lpPacket->Buffer, appletalk_broadcast_addr, 6) != 0 &&
-					memcmp((LPBYTE)lpPacket->Buffer, appletalk_zone_multicast_prefix, 5) != 0
-					) {
+				if (memcmp((LPBYTE)lpPacket->Buffer, ether_addr, 6) != 0)
 					dwNumberOfBytesTransfered = 0;
-				}
 			}
 			if(dwNumberOfBytesTransfered) {
 				if(net_if_type != NET_IF_ROUTER || !router_read_packet((uint8 *)lpPacket->Buffer, dwNumberOfBytesTransfered)) {
@@ -1497,7 +1510,7 @@
 	}
 }
 
-unsigned int WINAPI ether_thread_get_packets_nt(void *arg)
+static unsigned int WINAPI ether_thread_get_packets_nt(void *arg)
 {
 	static uint8 packet[1514];
 	int i, packet_sz = 0;
@@ -1554,7 +1567,7 @@
 	return 0;
 }
 
-unsigned int WINAPI ether_thread_feed_int(void *arg)
+static unsigned int WINAPI ether_thread_feed_int(void *arg)
 {
 	bool looping;
 
--- macemu/SheepShaver/src/Windows/extfs_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/extfs_windows.cpp
@@ -18,19 +18,18 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "sysdeps.h"
-#include "main.h"
-#include "extfs.h"
-#include "extfs_defs.h"
-#include "posix_emu.h"
-
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
 
+#include "sysdeps.h"
+#include "extfs.h"
+#include "extfs_defs.h"
+#include "posix_emu.h"
 
+
 #define DEBUG 0
 #include "debug.h"
 
@@ -128,13 +127,8 @@
 	char helper_path[MAX_PATH_LENGTH];
 	make_helper_path(path, helper_path, add);
 
-	switch (flag & (_O_RDONLY | _O_WRONLY | _O_RDWR)) {
-	case _O_WRONLY:
-	case _O_RDWR:
+	if ((flag & O_ACCMODE) == O_RDWR || (flag & O_ACCMODE) == O_WRONLY)
 		flag |= O_CREAT;
-		break;
-	}
-
 	int fd = open(helper_path, flag, 0666);
 	if (fd < 0) {
 		if (/*errno == ENOENT &&*/ (flag & O_CREAT)) {
@@ -269,14 +263,6 @@
 
 void set_finfo(const char *path, uint32 finfo, uint32 fxinfo, bool is_dir)
 {
-	struct my_utimbuf times;
-	times.actime = MacTimeToTime(ReadMacInt32(finfo - ioFlFndrInfo + ioFlCrDat));
-	times.modtime = MacTimeToTime(ReadMacInt32(finfo - ioFlFndrInfo + ioFlMdDat));
-
-	if (utime(path, &times) < 0) {
-		D(bug("utime failed on %s, error %d\n", path, GetLastError()));
-	}
-
 	// Open Finder info file
 	int fd = open_finf(path, O_RDWR);
 	if (fd < 0)
@@ -303,7 +289,7 @@
 
 	// Get size
 	off_t size = lseek(fd, 0, SEEK_END);
-
+	
 	// Close file and return size
 	close(fd);
 	return size < 0 ? 0 : size;
Only in sheepshaver/: SheepShaver/src/Windows/inttypes.h
Only in sheepshaver/: SheepShaver/src/Windows/kernel_windows.cpp
Only in sheepshaver/: SheepShaver/src/Windows/kernel_windows.h
--- macemu/SheepShaver/src/Windows/main_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/main_windows.cpp
@@ -119,6 +119,9 @@
 extern void exit_emul_ppc(void);
 sigsegv_return_t sigsegv_handler(sigsegv_info_t *sip);
 
+#ifdef _MSC_VER
+#include "sigsegv.cpp"
+#endif
 
 /*
  *  Return signal stack base
@@ -347,7 +350,7 @@
 	rom_tmp = new uint8[ROM_SIZE];
 	ReadFile(rom_fh, (void *)rom_tmp, ROM_SIZE, &actual, NULL);
 	CloseHandle(rom_fh);
-
+	
 	// Decode Mac ROM
 	if (!DecodeROM(rom_tmp, actual)) {
 		if (rom_size != 4*1024*1024) {
@@ -359,7 +362,7 @@
 		}
 	}
 	delete[] rom_tmp;
-
+	
 	// Initialize native timers
 	timer_init();
 
@@ -387,7 +390,13 @@
 	// Get my thread ID and jump to ROM boot routine
 	emul_thread = GetCurrentThread();
 	D(bug("Jumping to ROM\n"));
-	jump_to_rom(ROMBase + 0x310000);
+#ifdef _MSC_VER
+	__try {
+#endif
+		jump_to_rom(ROMBase + 0x310000);
+#ifdef _MSC_VER
+	} __except (main_exception_filter(GetExceptionInformation())) {}
+#endif
 	D(bug("Returned from ROM\n"));
 
 quit:
@@ -599,7 +608,7 @@
 	}
 }
 
-static DWORD nvram_func(void *arg)
+static DWORD WINAPI nvram_func(void *arg)
 {
 	while (!nvram_thread_cancel) {
 		for (int i=0; i<60 && !nvram_thread_cancel; i++)
@@ -614,7 +623,7 @@
  *  60Hz thread (really 60.15Hz)
  */
 
-static DWORD tick_func(void *arg)
+static DWORD WINAPI tick_func(void *arg)
 {
 	int tick_counter = 0;
 	uint64 start = GetTicks_usec();
--- macemu/SheepShaver/src/Windows/posix_emu.cpp
+++ sheepshaver/SheepShaver/src/Windows/posix_emu.cpp
@@ -1,1150 +1,1167 @@
-/*
- *  posix_emu.cpp -- posix and virtual desktop
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+/*
+ *  posix_emu.cpp -- posix and virtual desktop
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+// TODO: UNC names. Customizable "Virtual Desktop" location.
+
+#include "sysdeps.h"
+#define NO_POSIX_API_HOOK
+#include "posix_emu.h"
+#include "user_strings.h"
+#include "util_windows.h"
+#include "main.h"
+#include "extfs_defs.h"
+#include "prefs.h"
+#include <ctype.h>
+
+
+#define DEBUG_EXTFS 0
+
+#if DEBUG_EXTFS
+
+// This must be always on.
+#define DEBUG 1
+#undef OutputDebugString
+#define OutputDebugString extfs_log_write
+extern void extfs_log_write( char *s );
+#define EXTFS_LOG_FILE_NAME "extfs.log"
+#include "debug.h"
+
+enum {
+	DB_EXTFS_NONE=0,
+	DB_EXTFS_NORMAL,
+	DB_EXTFS_LOUD
+};
+static int16 debug_extfs = DB_EXTFS_NONE;
+static HANDLE extfs_log_file = INVALID_HANDLE_VALUE;
+
+static void extfs_log_open( char *path )
+{
+	if(debug_extfs == DB_EXTFS_NONE) return;
+
+	DeleteFile( path );
+	extfs_log_file = CreateFile(
+			path,
+			GENERIC_READ|GENERIC_WRITE,
+			FILE_SHARE_READ,
+			NULL,
+			CREATE_ALWAYS,
+			// FILE_FLAG_WRITE_THROUGH|FILE_FLAG_NO_BUFFERING,
+			FILE_FLAG_WRITE_THROUGH,
+			NULL
+	);
+	if( extfs_log_file == INVALID_HANDLE_VALUE ) {
+		ErrorAlert( "Could not create the EXTFS log file." );
+	}
+}
+
+static void extfs_log_close( void )
+{
+	if(debug_extfs == DB_EXTFS_NONE) return;
+
+	if( extfs_log_file != INVALID_HANDLE_VALUE ) {
+		CloseHandle( extfs_log_file );
+		extfs_log_file = INVALID_HANDLE_VALUE;
+	}
+}
+
+static void extfs_log_write( char *s )
+{
+	DWORD bytes_written;
+
+	// should have been checked already.
+	if(debug_extfs == DB_EXTFS_NONE) return;
+
+	if( extfs_log_file != INVALID_HANDLE_VALUE ) {
+
+		DWORD count = strlen(s);
+		if (0 == WriteFile(extfs_log_file, s, count, &bytes_written, NULL) ||
+				(int)bytes_written != count)
+		{
+			extfs_log_close();
+			ErrorAlert( "extfs log file write error (out of disk space?). Log closed." );
+		} else {
+			FlushFileBuffers( extfs_log_file );
+		}
+	}
+}
+#else
+
+#define DEBUG 0
+#include "debug.h"
+
+#endif // DEBUG_EXTFS
+
+int my_errno = 0;
+
+#define VIRTUAL_ROOT_ID ((HANDLE)0xFFFFFFFE)
+
+static const char *desktop_name = "Virtual Desktop";
+static const char *custom_icon_name = "Icon\r";
+#define my_computer GetString(STR_EXTFS_VOLUME_NAME)
+
+static char lb1[MAX_PATH_LENGTH];
+static char lb2[MAX_PATH_LENGTH];
+
+#define MRP(path)	 translate(path,lb1)
+#define MRP2(path) translate(path,lb2)
+
+#define DISABLE_ERRORS UINT prevmode = SetErrorMode(SEM_NOOPENFILEERRORBOX|SEM_FAILCRITICALERRORS)
+#define RESTORE_ERRORS SetErrorMode(prevmode);
+
+static char host_drive_list[512];
+static char virtual_root[248]; // Not _MAX_PATH
+
+const uint8 my_comp_icon[2670] = {
+	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0xD8, 0x00, 0x00, 0x08, 0xD8, 0x00, 0x00, 0x00, 0x96,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x02, 0x00, 0x79, 0x79, 0x79, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xC0, 0xCC, 0xCC, 0xCC,
+	0xCC, 0xD7, 0x97, 0x97, 0x97, 0x97, 0x97, 0xC0, 0xC0, 0xC0, 0xC0, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
+	0xCD, 0xDB, 0xD9, 0x79, 0x79, 0x7E, 0x79, 0x0C, 0xDD, 0xCD, 0xDD, 0xCD, 0xCD, 0xDC, 0xDD, 0xCD,
+	0xCC, 0xED, 0xED, 0x97, 0x97, 0x97, 0x97, 0x0C, 0xE7, 0x78, 0x77, 0x97, 0x97, 0x97, 0x97, 0x97,
+	0xDC, 0xED, 0xDE, 0x79, 0x79, 0x79, 0x99, 0x0C, 0xD9, 0x7E, 0x5E, 0x65, 0x5E, 0x65, 0xD9, 0x79,
+	0xCD, 0xDE, 0xDD, 0x97, 0xE7, 0x9E, 0x77, 0xC0, 0x97, 0x9D, 0xCD, 0xCC, 0xC7, 0xCC, 0xE7, 0x97,
+	0xCC, 0xED, 0xEE, 0x79, 0x79, 0x79, 0x7E, 0xCC, 0x57, 0xD5, 0xD7, 0xD5, 0xDD, 0x5D, 0xD9, 0x7E,
+	0xCD, 0xDE, 0xDE, 0x79, 0x97, 0x97, 0x99, 0x0C, 0x87, 0xCD, 0x75, 0xC7, 0x5C, 0x7D, 0xD9, 0x79,
+	0xCD, 0xDD, 0xED, 0xE7, 0x7E, 0x79, 0x77, 0xCC, 0xE7, 0xB0, 0x00, 0xC0, 0x0C, 0xCD, 0xE7, 0x97,
+	0xDC, 0xED, 0xEE, 0x79, 0x97, 0x86, 0x79, 0xC0, 0xE7, 0xD0, 0x2C, 0xC1, 0xC2, 0xCD, 0xD9, 0x79,
+	0xCD, 0xDE, 0xDD, 0x97, 0x99, 0x79, 0x97, 0x0C, 0xE7, 0xB0, 0xD0, 0xDC, 0xCC, 0xCD, 0xD6, 0x87,
+	0xDD, 0xDE, 0xED, 0x79, 0x77, 0xE7, 0x79, 0x0C, 0x58, 0xDC, 0x0C, 0x0C, 0xCC, 0xCD, 0xE9, 0x79,
+	0xCD, 0xDD, 0xD5, 0x99, 0x97, 0x99, 0x79, 0xC0, 0x87, 0xD0, 0xC0, 0xC0, 0xC0, 0xCD, 0xD7, 0xE7,
+	0xDD, 0xDE, 0xD7, 0x97, 0x79, 0x77, 0xE7, 0x0C, 0xE7, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0x79, 0x79,
+	0xCD, 0xDE, 0xD9, 0x79, 0x97, 0xE9, 0x79, 0x0C, 0x97, 0x79, 0x79, 0x79, 0x79, 0x79, 0x97, 0x97,
+	0xDC, 0xED, 0xE7, 0x97, 0x79, 0x97, 0x97, 0x0C, 0xCD, 0xD7, 0xD7, 0xD7, 0xE7, 0xE7, 0x7E, 0x79,
+	0xCD, 0xDE, 0x79, 0x79, 0x97, 0x7E, 0x79, 0xC0, 0xCC, 0xCC, 0x0C, 0xCC, 0x0D, 0xCC, 0xDC, 0xDC,
+	0xDC, 0xED, 0x97, 0x97, 0x77, 0x99, 0x79, 0xCC, 0xCC, 0xCC, 0xDC, 0xCC, 0xDC, 0xCC, 0xCC, 0x8D,
+	0xCD, 0xDE, 0x79, 0x79, 0x96, 0x77, 0x97, 0x97, 0x97, 0x90, 0xCC, 0xCD, 0xCD, 0xDD, 0xDD, 0xCC,
+	0xDD, 0xD9, 0x76, 0x87, 0x97, 0x99, 0x7E, 0x7C, 0x0C, 0xCC, 0xDD, 0xDD, 0xED, 0xDE, 0xDD, 0xEE,
+	0xDE, 0xD5, 0xBD, 0xDE, 0x79, 0x79, 0x9C, 0xC0, 0xCC, 0xDD, 0xDD, 0xDD, 0xDE, 0xDD, 0xED, 0xDE,
+	0xDE, 0xDD, 0xDE, 0xDE, 0x79, 0x79, 0x70, 0xCD, 0xCC, 0xCC, 0xCC, 0xCC, 0xDC, 0xDD, 0xDD, 0xDD,
+	0xDD, 0xDD, 0xED, 0xED, 0x97, 0x97, 0x90, 0xCC, 0x8D, 0xCC, 0xDC, 0xCD, 0xCC, 0xCC, 0xCC, 0xCC,
+	0xCC, 0xEE, 0xDE, 0xDE, 0x79, 0x7E, 0x70, 0xCC, 0x88, 0xDC, 0xCC, 0xCC, 0xCD, 0xDD, 0xDD, 0xDC,
+	0xCD, 0xDD, 0xED, 0xED, 0x97, 0x97, 0xEC, 0xCC, 0xCC, 0xCC, 0xDC, 0xCC, 0xCD, 0xDD, 0xED, 0xDD,
+	0xDC, 0xED, 0xED, 0xEE, 0x79, 0x79, 0xDC, 0x0D, 0xCC, 0xDC, 0xCC, 0xCD, 0xCC, 0xCC, 0xCC, 0x0C,
+	0xDC, 0xDE, 0xDE, 0xED, 0x97, 0xDC, 0xCC, 0xDC, 0xCD, 0xCC, 0xDC, 0xCD, 0xCC, 0xCC, 0xCD, 0xCC,
+	0xCC, 0xED, 0xED, 0x79, 0xDD, 0xC0, 0xCD, 0xCC, 0xDC, 0xCD, 0xCC, 0xDC, 0xCC, 0xDC, 0xDD, 0xCD,
+	0xCD, 0xED, 0x97, 0x97, 0xDD, 0xCC, 0xCC, 0x00, 0xC0, 0xDD, 0xCD, 0xCC, 0xCC, 0xCD, 0xD0, 0xDC,
+	0xDD, 0xF7, 0x99, 0x79, 0x97, 0x9D, 0xDD, 0xDD, 0xCC, 0xC0, 0xCC, 0x0C, 0xDC, 0xDC, 0xCD, 0xCD,
+	0xDF, 0x79, 0x77, 0x97, 0x79, 0x79, 0x79, 0x79, 0xDD, 0xDE, 0xDC, 0xCC, 0xCC, 0xC0, 0xC0, 0xDD,
+	0xE9, 0x79, 0x97, 0x99, 0x97, 0xE7, 0xE7, 0x97, 0x97, 0x9D, 0x79, 0xDD, 0xDD, 0xDD, 0xCD, 0xDE,
+	0x79, 0x79, 0x7E, 0x77, 0x00, 0x00, 0x04, 0x00, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0xF5,
+	0xF5, 0xF5, 0xF5, 0xF5, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
+	0x2B, 0x2B, 0xF9, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0xF6,
+	0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF7, 0xF7, 0xF7,
+	0xF7, 0xF8, 0x81, 0xFA, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56,
+	0xF7, 0xF8, 0x81, 0x81, 0x81, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xA5, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
+	0xF8, 0xF8, 0x81, 0xFA, 0xFB, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xA5, 0xC2, 0xC2, 0xFB, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xFB, 0xC2, 0xC2, 0xC2,
+	0xF7, 0xF8, 0x81, 0x81, 0xFB, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0x2B,
+	0xA5, 0xC2, 0xC2, 0xFB, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x81, 0xC2, 0xC2, 0xC2,
+	0xF7, 0xF8, 0x81, 0x81, 0xFB, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0x2B,
+	0xA5, 0xC2, 0xF9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xF9, 0xFB, 0xC2, 0xC2, 0xC2,
+	0xF7, 0xF8, 0x81, 0x81, 0xFB, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xA5, 0xC2, 0xF9, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0xF9, 0x81, 0xC2, 0xC2, 0xC2,
+	0xF8, 0x56, 0xFA, 0x81, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xA5, 0xC2, 0xF9, 0xF5, 0xF5, 0xF5, 0xF6, 0xF6, 0xF6, 0xF6, 0x2B, 0xF9, 0xFB, 0xC2, 0xC2, 0xC2,
+	0xF8, 0x56, 0x81, 0x81, 0xFB, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xA5, 0xC2, 0xF9, 0xF5, 0x0A, 0xF6, 0x2B, 0x0A, 0xF6, 0x0A, 0x2B, 0xF9, 0x81, 0xC2, 0xC2, 0xC2,
+	0xF8, 0x56, 0x81, 0x81, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xA5, 0xC2, 0xF9, 0xF5, 0xF8, 0xF6, 0x56, 0xF7, 0xF7, 0xF8, 0x2B, 0xF9, 0x81, 0xC2, 0xC2, 0xC2,
+	0xF8, 0x56, 0x81, 0x81, 0xFB, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xA5, 0xC2, 0xF9, 0xF5, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0x2B, 0x2B, 0xF9, 0xFB, 0xC2, 0xC2, 0xC2,
+	0xF8, 0x56, 0xFA, 0x81, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xA5, 0xC2, 0xF9, 0xF6, 0xF6, 0xF5, 0xF6, 0xF6, 0xF6, 0xF6, 0x2B, 0xF9, 0x81, 0xC2, 0xC2, 0xC2,
+	0xF8, 0x56, 0x81, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xA5, 0xC2, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xC2, 0xC2, 0xC2, 0xC2,
+	0xF8, 0x56, 0x81, 0x81, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xA5, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
+	0xF8, 0x56, 0x81, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0xF7, 0x56, 0xF8, 0x7A, 0x7A, 0x9E, 0x9E, 0x9E, 0x9E, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
+	0xF8, 0x56, 0x81, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
+	0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF7, 0xF7, 0xF8, 0xF8,
+	0xF8, 0x56, 0x81, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF7, 0xF7,
+	0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0x56, 0xB9, 0xF8,
+	0xF8, 0x56, 0x81, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
+	0xC2, 0xC2, 0xC2, 0xF6, 0x2B, 0x2B, 0xF7, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0xF8,
+	0xF8, 0x56, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6,
+	0xF6, 0xF6, 0x2B, 0xF8, 0x56, 0xFA, 0xF9, 0x81, 0x81, 0x81, 0xFA, 0x81, 0x81, 0x81, 0xFB, 0x81,
+	0xFB, 0xFB, 0xFB, 0x81, 0xFA, 0xFA, 0xFA, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xF6, 0xF6,
+	0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFB,
+	0x81, 0xFB, 0xF9, 0xFA, 0xFA, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B, 0xF7,
+	0xF8, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF8, 0xF8, 0x56, 0x56, 0xF9, 0xF9, 0xF9, 0xFA,
+	0xFA, 0xFA, 0xFA, 0x81, 0x81, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B, 0xF7,
+	0x93, 0xA0, 0xF7, 0xF7, 0xF8, 0xF7, 0xF7, 0xF8, 0xF7, 0xF7, 0xF7, 0xF7, 0x2B, 0x2B, 0x2B, 0x2B,
+	0x2B, 0x2B, 0x81, 0xFB, 0x81, 0xFB, 0xFB, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B, 0xF7,
+	0xA0, 0xA0, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0x56, 0x56, 0xF9, 0xF9, 0xF9, 0xF8, 0xF7,
+	0xF7, 0xF7, 0xFB, 0xFB, 0x81, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B, 0xF7,
+	0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF9, 0xF9, 0xFB, 0xFB, 0xFB, 0xF8, 0xF9,
+	0xF9, 0xF7, 0x81, 0xFB, 0xFB, 0x81, 0xFB, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xF8, 0x2B, 0x2B, 0x56,
+	0x2B, 0x2B, 0xF9, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF8,
+	0xF8, 0xF7, 0xFB, 0xFB, 0x81, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xF8, 0xF8, 0xF6, 0xF6, 0xF9, 0xF8,
+	0x2B, 0xF9, 0xF8, 0x2B, 0xF9, 0x2B, 0x2B, 0xF9, 0x2B, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
+	0xF7, 0xF7, 0x81, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xF9, 0xF8, 0xF6, 0xF6, 0xF7, 0xF9, 0xF8, 0x2B,
+	0xF9, 0xF8, 0xF6, 0xF9, 0xF8, 0xF6, 0xF9, 0xF8, 0xF6, 0x2B, 0xF9, 0x2B, 0xF9, 0x56, 0x2B, 0xF9,
+	0x2B, 0xF9, 0xAC, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xFA, 0xF9, 0xF8, 0x2B, 0x2B, 0x2B, 0xF5, 0xF5,
+	0xF5, 0xF5, 0xF9, 0xF8, 0xF6, 0xF9, 0xF8, 0xF6, 0x2B, 0xF8, 0x2B, 0xF9, 0x56, 0x2B, 0x56, 0x2B,
+	0x56, 0x81, 0xAC, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xFA, 0xFA, 0xFA, 0xF9, 0xF8,
+	0xF8, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF5, 0x2B, 0xF9, 0xF6, 0xF9, 0xF8, 0xF7, 0xF9, 0x2B, 0xF9,
+	0x81, 0xAC, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
+	0xFA, 0xFA, 0xFA, 0xFA, 0xF9, 0xF8, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF5, 0xF5, 0xF5, 0x56, 0x81,
+	0xAC, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
+	0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xFA, 0xF9, 0xFA, 0xFA, 0xF9, 0xF9, 0xF8, 0xF8, 0x81, 0x81,
+	0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0x00, 0x00, 0x01, 0x00, 0x03, 0xFF, 0xFF, 0xE0,
+	0x02, 0x00, 0x00, 0x38, 0x02, 0xFF, 0xFF, 0x3C, 0x02, 0xFF, 0xFF, 0x3C, 0x02, 0xFF, 0xFF, 0x3C,
+	0x02, 0xF0, 0x0F, 0x3C, 0x02, 0xFF, 0xFF, 0x3C, 0x02, 0xFF, 0xFF, 0x7C, 0x02, 0xE0, 0x1F, 0x7C,
+	0x02, 0xE0, 0x1F, 0x7C, 0x02, 0xE0, 0x1F, 0x7C, 0x02, 0xE0, 0x1F, 0x7C, 0x02, 0xE0, 0x1F, 0x78,
+	0x02, 0xFF, 0xFF, 0x78, 0x02, 0xFF, 0xFF, 0x78, 0x02, 0x1F, 0xFF, 0x70, 0x02, 0x00, 0x00, 0x70,
+	0x03, 0xFF, 0xFF, 0xF0, 0x00, 0x0F, 0xFF, 0xE0, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0x1F, 0xFF, 0xFF,
+	0x02, 0x00, 0x3F, 0xFF, 0x02, 0x40, 0x00, 0x3F, 0x02, 0xC0, 0x7C, 0x3F, 0x02, 0x00, 0x7D, 0xBF,
+	0x0F, 0x20, 0x00, 0x3F, 0x32, 0x49, 0x00, 0x3C, 0xC4, 0x92, 0x2D, 0x70, 0xE0, 0x24, 0x1A, 0xE0,
+	0x1F, 0x00, 0xA5, 0xC0, 0x00, 0xFC, 0x03, 0x80, 0x00, 0x03, 0xFF, 0x00, 0x03, 0xFF, 0xFF, 0xE0,
+	0x03, 0xFF, 0xFF, 0xF8, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC,
+	0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC,
+	0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xF8,
+	0x03, 0xFF, 0xFF, 0xF8, 0x03, 0xFF, 0xFF, 0xF8, 0x03, 0xFF, 0xFF, 0xF0, 0x03, 0xFF, 0xFF, 0xF0,
+	0x03, 0xFF, 0xFF, 0xF0, 0x00, 0x1F, 0xFF, 0xE0, 0x01, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF,
+	0x07, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF,
+	0x0F, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xE0,
+	0x1F, 0xFF, 0xFF, 0xC0, 0x00, 0xFF, 0xFF, 0x80, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x40,
+	0x1F, 0xFC, 0x10, 0x06, 0x10, 0x06, 0x10, 0x06, 0x10, 0x06, 0x10, 0x06, 0x10, 0x06, 0x10, 0x04,
+	0x1F, 0xFC, 0x0F, 0xFE, 0x0F, 0xFF, 0x18, 0x67, 0x34, 0x06, 0x69, 0x64, 0x72, 0xC8, 0x3F, 0xF0,
+	0x1F, 0xFC, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFC,
+	0x1F, 0xFC, 0x07, 0xFF, 0x1F, 0xFF, 0x3F, 0xFF, 0x3F, 0xFF, 0x7F, 0xFE, 0xFF, 0xFC, 0x07, 0xF8,
+	0x00, 0x00, 0x00, 0x80, 0x79, 0x7C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCD, 0x97, 0x97, 0x90, 0xE7, 0x97,
+	0x97, 0x97, 0xDD, 0xD9, 0x79, 0x7C, 0xE7, 0xD5, 0x5E, 0x58, 0xCE, 0xD7, 0x97, 0x9C, 0xDD, 0x5D,
+	0x7D, 0xB7, 0xDD, 0x59, 0x79, 0x7C, 0x9D, 0x10, 0x1D, 0xD9, 0xCE, 0xD7, 0x97, 0x9C, 0xDD, 0x0C,
+	0xCC, 0xE7, 0xDD, 0xD9, 0x79, 0x7C, 0xED, 0xDD, 0xDD, 0x79, 0xCE, 0xE7, 0xE7, 0x90, 0xE7, 0x77,
+	0x97, 0x97, 0xDD, 0x79, 0x79, 0x7C, 0xCC, 0xDC, 0xCD, 0xC8, 0xDD, 0x97, 0x97, 0x99, 0x7C, 0xDD,
+	0xDD, 0xDE, 0xDE, 0xDE, 0x7E, 0x7C, 0xCC, 0xCC, 0xCD, 0xCD, 0xDD, 0xDE, 0x99, 0x0C, 0x8C, 0xCC,
+	0xCC, 0xCC, 0xCD, 0xED, 0x77, 0xCC, 0xCC, 0xCD, 0xDD, 0xED, 0xCE, 0xDE, 0x9C, 0xCD, 0xCD, 0xCD,
+	0x0D, 0xCC, 0xCE, 0xE7, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xCC, 0xDE, 0x99, 0x97, 0x97, 0x9D, 0xDD,
+	0xDD, 0xDE, 0xE9, 0x77, 0x00, 0x00, 0x01, 0x00, 0xC2, 0xC2, 0xC2, 0xF5, 0xF5, 0xF5, 0xF6, 0xF6,
+	0xF6, 0x2B, 0x2B, 0x2B, 0xF7, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xC2, 0xC2, 0xC2,
+	0xC2, 0xC2, 0xC2, 0xC2, 0xF8, 0x81, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xC2, 0x81, 0xAA,
+	0xAA, 0xAA, 0xFB, 0xC2, 0xF8, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xF9, 0x7F, 0x7F,
+	0x7F, 0x56, 0x81, 0xC2, 0xF8, 0x81, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xF9, 0x0A, 0xF6,
+	0x0A, 0x56, 0xFB, 0xC2, 0xF8, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xF9, 0xF6, 0xF6,
+	0xF6, 0x56, 0x81, 0xC2, 0x56, 0x81, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xF9, 0xF9, 0xF9,
+	0xF9, 0xF9, 0xC2, 0xC2, 0xF8, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xC2, 0xC2, 0xC2,
+	0xC2, 0xC2, 0xC2, 0xC2, 0x56, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0x2B, 0x2B, 0x2B, 0xF7, 0xF7,
+	0xF7, 0xF7, 0xF7, 0xB9, 0x56, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0x56, 0xF9,
+	0xFA, 0xFA, 0xFB, 0xFB, 0xFB, 0x81, 0xFA, 0x81, 0xC2, 0xC2, 0xC2, 0xF6, 0xF6, 0xF7, 0x2B, 0x2B,
+	0x2B, 0xF8, 0xF8, 0xF8, 0xF9, 0xFA, 0x81, 0xFB, 0xC2, 0xC2, 0xF5, 0xF7, 0x93, 0xF7, 0xF7, 0xF7,
+	0xF7, 0x2B, 0x2B, 0x2B, 0x2B, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xF5, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
+	0xF9, 0xFB, 0xFB, 0xF9, 0xF7, 0xFB, 0x81, 0xFB, 0xC2, 0xF6, 0xF8, 0xF9, 0x2B, 0xF9, 0x2B, 0xF9,
+	0xF6, 0xF8, 0x2B, 0xF8, 0xF7, 0xFB, 0xFB, 0xC2, 0xF9, 0xF7, 0xF9, 0xF7, 0xF9, 0xF7, 0xF9, 0x2B,
+	0xF9, 0x2B, 0xF8, 0x2B, 0x81, 0xAC, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF9, 0xF9, 0xF9,
+	0xF9, 0xF9, 0xF9, 0x81, 0xAC, 0xC2, 0xC2, 0xC2, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0xD8,
+	0x00, 0x00, 0x08, 0xD8, 0x00, 0x00, 0x00, 0x96, 0x02, 0x1C, 0xC1, 0xC4, 0x18, 0x9C, 0x00, 0x00,
+	0x00, 0x1C, 0x00, 0x96, 0x00, 0x05, 0x69, 0x63, 0x6C, 0x34, 0x00, 0x00, 0x00, 0x32, 0x69, 0x63,
+	0x6C, 0x38, 0x00, 0x00, 0x00, 0x3E, 0x49, 0x43, 0x4E, 0x23, 0x00, 0x00, 0x00, 0x4A, 0x69, 0x63,
+	0x73, 0x23, 0x00, 0x00, 0x00, 0x56, 0x69, 0x63, 0x73, 0x34, 0x00, 0x00, 0x00, 0x62, 0x69, 0x63,
+	0x73, 0x38, 0x00, 0x00, 0x00, 0x6E, 0xBF, 0xB9, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1C,
+	0xE2, 0x10, 0xBF, 0xB9, 0xFF, 0xFF, 0x00, 0x00, 0x02, 0x04, 0x02, 0x1C, 0xE1, 0xAC, 0xBF, 0xB9,
+	0xFF, 0xFF, 0x00, 0x00, 0x06, 0x08, 0x02, 0x1C, 0xE1, 0xA4, 0xBF, 0xB9, 0xFF, 0xFF, 0x00, 0x00,
+	0x07, 0x0C, 0x02, 0x1C, 0xE1, 0xF8, 0xBF, 0xB9, 0xFF, 0xFF, 0x00, 0x00, 0x07, 0x50, 0x02, 0x1C,
+	0xE1, 0xDC, 0xBF, 0xB9, 0xFF, 0xFF, 0x00, 0x00, 0x07, 0xD4, 0x02, 0x1C, 0xE1, 0xD0
+};
+
+static bool use_streams[ 'Z'-'A'+1 ];
+
+static bool is_ntfs_volume( char *rootdir )
+{
+	bool ret = false;
+	char tst_file[_MAX_PATH], tst_stream[_MAX_PATH];
+	sprintf( tst_file, "%sb2query.tmp", rootdir );
+	sprintf( tst_stream, "%s:AFP_AfpInfo", tst_file );
+	if(!exists(tst_file)) {
+		if(create_file( tst_file, 0 )) {
+			if(create_file( tst_stream, 0 )) {
+				ret = true;
+			}
+			DeleteFile( tst_file );
+		}
+	}
+	return ret;
+}
+
+
+// !!UNC
+void init_posix_emu(void)
+{
+	if(!validate_stat_struct) {
+		ErrorAlert( "Invalid struct my_stat -- edit posix_emu.h" );
+		QuitEmulator();
+	}
+
+#if DEBUG_EXTFS
+	debug_extfs = PrefsFindInt16("debugextfs");
+
+	debug_extfs = DB_EXTFS_LOUD;
+
+	if(debug_extfs != DB_EXTFS_NONE) {
+		extfs_log_open( EXTFS_LOG_FILE_NAME );
+	}
+#endif
+
+	// We cannot use ExtFS "RootPath" because of the virtual desktop.
+	if(PrefsFindBool("enableextfs")) {
+		PrefsReplaceString("extfs", "");
+	} else {
+		PrefsRemoveItem("extfs");
+		D(bug("extfs disabled by user\n"));
+#if DEBUG_EXTFS
+		extfs_log_close();
+#endif
+		return;
+	}
+
+	const char *extdrives = PrefsFindString("extdrives");
+
+	// Set up drive list.
+	int outinx = 0;
+	for( char letter = 'A'; letter <= 'Z'; letter++ ) {
+		if(extdrives && !strchr(extdrives,letter)) continue;
+		int i = (int)( letter - 'A' );
+		char rootdir[20];
+		wsprintf( rootdir, "%c:\\", letter );
+		use_streams[ letter - 'A' ] = false;
+		switch(GetDriveType(rootdir)) {
+			case DRIVE_FIXED:
+			case DRIVE_REMOTE:
+			case DRIVE_RAMDISK:
+				// TODO: NTFS AFP?
+				// fall
+			case DRIVE_REMOVABLE:
+			case DRIVE_CDROM:
+				if(outinx < sizeof(host_drive_list)) {
+					host_drive_list[outinx] = letter;
+					outinx += 2;
+				}
+		}
+	}
+
+	// Set up virtual desktop root.
+	// TODO: this should be customizable.
+	GetModuleFileName( NULL, virtual_root, sizeof(virtual_root) );
+	char *p = strrchr( virtual_root, '\\' );
+	if(p) {
+		*(++p) = 0;
+		strcat( virtual_root, desktop_name );
+	} else {
+		// should never happen
+		sprintf( virtual_root, "C:\\%s", desktop_name );
+	}
+	CreateDirectory( virtual_root, 0 );
+
+	// Set up an icon looking like "My Computer"
+	// Can be overwritten just like any other folder custom icon.
+	if(my_access(custom_icon_name,0) != 0) {
+		int fd = my_creat( custom_icon_name, 0 );
+		if(fd >= 0) {
+			my_close(fd);
+			fd = open_rfork( custom_icon_name, O_RDWR|O_CREAT );
+			if(fd >= 0) {
+				my_write( fd, my_comp_icon, sizeof(my_comp_icon) );
+				my_close(fd);
+				static uint8 host_finfo[SIZEOF_FInfo];
+				uint32 finfo = Host2MacAddr(host_finfo);
+				get_finfo(custom_icon_name, finfo, 0, false);
+				WriteMacInt16(finfo + fdFlags, kIsInvisible);
+				set_finfo(custom_icon_name, finfo, 0, false);
+				get_finfo(my_computer, finfo, 0, true);
+				WriteMacInt16(finfo + fdFlags, ReadMacInt16(finfo + fdFlags) | kHasCustomIcon);
+				set_finfo(my_computer, finfo, 0, true);
+			} else {
+				my_remove(custom_icon_name);
+			}
+		}
+	}
+}
+
+void final_posix_emu(void)
+{
+#if DEBUG_EXTFS
+	extfs_log_close();
+#endif
+}
+
+static void charset_host2mac( char *s )
+{
+	int i, len=strlen(s), code;
+
+	for( i=len-3; i>=0; i-- ) {
+		if( s[i] == '%' && isxdigit(s[i+1]) && isxdigit(s[i+2]) ) {
+			sscanf( &s[i], "%%%02X", &code );
+			memmove( &s[i], &s[i+2], strlen(&s[i+2])+1 );
+			s[i] = code;
+		}
+	}
+}
+
+static void charset_mac2host( char *s )
+{
+	int i, convert, len = strlen(s);
+
+	D(bug("charset_mac2host(%s)...\n", s));
+
+	for( i=len-1; i>=0; i-- ) {
+		convert = 0;
+		switch( (unsigned char)s[i] ) {
+			// case '\r': // handled by "default"
+			// case '\n':
+			// case '\t':
+			case '/':
+			// case '\\': // Backslash is tricky -- "s" is a full path!
+			// case ':':
+			case '*':
+			case '?':
+			case '"':
+			case '<':
+			case '>':
+			case '|':
+			case '%':
+				convert = 1;
+				break;
+			default:
+				if((unsigned char)s[i] < ' ') convert = 1;
+				break;
+		}
+		if(convert) {
+			char sml[10];
+			sprintf( sml, "%%%02X", s[i] );
+			memmove( &s[i+2], &s[i], strlen(&s[i])+1 );
+			memmove( &s[i], sml, 3 );
+		}
+	}
+	D(bug("charset_mac2host = %s\n", s));
+}
+
+static void make_mask(
+	char *mask,
+	const char *dir,
+	const char *a1,
+	const char *a2
+)
+{
+	strcpy( mask, dir );
+
+	int len = strlen(mask);
+	if( len && mask[len-1] != '\\' ) strcat( mask, "\\" );
+
+	if( a1 ) strcat( mask, a1 );
+	if( a2 ) strcat( mask, a2 );
+}
+
+// !!UNC
+static char *translate( const char *path, char *buffer )
+{
+	char *l = host_drive_list;
+	char *p = (char *)path;
+
+	while(*l) {
+		if(toupper(p[1]) == toupper(*l)) break;
+		l += strlen(l) + 1;
+	}
+
+	if(p[0] == '\\' && *l && (p[2] == 0 || p[2] == ':' || p[2] == '\\')) {
+		p += 2;
+		if(*p == ':') p++;
+		if(*p == '\\') p++;
+		sprintf( buffer, "%c:\\%s", *l, p );
+	} else {
+		if(*path == '\\') {
+			sprintf( buffer, "%s%s", virtual_root, path );
+		} else {
+			int len = strlen(path);
+			if(len == 0 || path[len-1] == '\\') {
+				make_mask( buffer, virtual_root, path, my_computer );
+			} else {
+				make_mask( buffer, virtual_root, path, 0 );
+			}
+		}
+	}
+	charset_mac2host( buffer );
+
+	return buffer;
+}
+
+// helpers
+static void strip_trailing_bs( char *path )
+{
+	int len = strlen(path);
+	if(len > 0 && path[len-1] == '\\') path[len-1] = 0;
+}
+
+#if 0 /* defined is util_windows.cpp */
+static int exists( const char *p )
+{
+	WIN32_FIND_DATA fdata;
+
+	int result = 0;
+
+	HANDLE h = FindFirstFile( p, &fdata );
+	if(h != INVALID_HANDLE_VALUE) {
+		result = 1;
+		FindClose( h );
+	}
+
+	D(bug("exists(%s) = %d\n", p, result));
+
+	return result;
+}
+#endif
+
+static int is_dir( char *p )
+{
+	WIN32_FIND_DATA fdata;
+
+	int result = 0;
+
+	HANDLE h = FindFirstFile( p, &fdata );
+	if(h != INVALID_HANDLE_VALUE) {
+		result = (fdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
+		FindClose( h );
+	}
+	return result;
+}
+
+static int myRemoveDirectory( const char *source )
+{
+	HANDLE fh;
+	WIN32_FIND_DATA FindFileData;
+	int ok, result = 1;
+	char mask[_MAX_PATH];
+
+	D(bug("removing folder %s\n", source));
+
+	make_mask( mask, source, "*.*", 0 );
+
+	fh = FindFirstFile( mask, &FindFileData );
+	ok = fh != INVALID_HANDLE_VALUE;
+	while(ok) {
+		make_mask( mask, source, FindFileData.cFileName, 0 );
+		D(bug("removing item %s\n", mask));
+		int isdir = (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
+		if(isdir) {
+			// must delete ".finf", ".rsrc" but not ".", ".."
+			if(strcmp(FindFileData.cFileName,".") && strcmp(FindFileData.cFileName,"..")) {
+				result = myRemoveDirectory( mask );
+				if(!result) break;
+			}
+		} else {
+			D(bug("DeleteFile %s\n", mask));
+			result = DeleteFile( mask );
+			if(!result) break;
+		}
+		ok = FindNextFile( fh, &FindFileData );
+	}
+	if(fh != INVALID_HANDLE_VALUE) FindClose( fh );
+	if(result) {
+		D(bug("RemoveDirectory %s\n", source));
+		result = RemoveDirectory( source );
+	}
+	return result;
+}
+
+static void make_folders( char *path )
+{
+	char local_path[_MAX_PATH], *p;
+	strcpy( local_path, path );
+	p = strrchr( local_path, '\\' );
+	if(p) {
+		*p = 0;
+		if(strlen(local_path) > 3) {
+			make_folders(local_path);
+			mkdir(local_path);
+		}
+	}
+}
+
+// !!UNC
+static bool is_same_drive( char *p1, char *p2 )
+{
+	return toupper(*p1) == toupper(*p2);
+}
+
+// Used when the drives are known to be different.
+// Can't use MoveFileEx() etc because of the Win9x limitations.
+// It would simulate CopyFile*() -- DeleteFile*() anyway
+int file_move_copy( char *src, char *dst, bool delete_old )
+{
+	int result = 0;
+	my_errno = 0;
+
+	D(bug("file_copy %s -> %s\n", src, dst));
+
+	// Fail if exists -- it's up to MacOS to move things to Trash
+	if(CopyFile(src,dst,TRUE)) {
+		if(delete_old && !DeleteFile(src)) {
+			result = -1;
+			my_errno = EACCES;
+		}
+	} else {
+		result = -1;
+		if(exists(src))
+			my_errno = EACCES;
+		else
+			my_errno = ENOENT;
+	}
+	return result;
+}
+
+int file_move( char *src, char *dst )
+{
+	return file_move_copy( src, dst, true );
+}
+
+int file_copy( char *src, char *dst )
+{
+	return file_move_copy( src, dst, false );
+}
+
+int folder_copy( char *folder_src, char *folder_dst )
+{
+	HANDLE fh;
+	WIN32_FIND_DATA FindFileData;
+	int ok, result = 0;
+	char mask[_MAX_PATH];
+
+	D(bug("copying folder %s -> \n", folder_src, folder_dst));
+
+	my_errno = 0;
+
+	if(!CreateDirectory( folder_dst, 0 )) {
+		my_errno = EACCES;
+		return -1;
+	}
+
+	make_mask( mask, folder_src, "*.*", 0 );
+
+	fh = FindFirstFile( mask, &FindFileData );
+	ok = fh != INVALID_HANDLE_VALUE;
+	while(ok) {
+		make_mask( mask, folder_src, FindFileData.cFileName, 0 );
+		int isdir = (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
+		char target[_MAX_PATH];
+		make_mask( target, folder_dst, FindFileData.cFileName, 0 );
+		D(bug("copying item %s -> %s\n", mask, target));
+		if(isdir) {
+			if(strcmp(FindFileData.cFileName,".") && strcmp(FindFileData.cFileName,"..")) {
+				result = folder_copy( mask, target );
+				if(result < 0) break;
+			}
+		} else {
+			result = file_copy( mask, target );
+			if(result < 0) break;
+		}
+		ok = FindNextFile( fh, &FindFileData );
+	}
+	if(fh != INVALID_HANDLE_VALUE) FindClose( fh );
+	return result;
+}
+
+// dir enumeration
+void closedir( struct DIR *d )
+{
+	DISABLE_ERRORS;
+	if(d) {
+		if(d->h != INVALID_HANDLE_VALUE && d->h != VIRTUAL_ROOT_ID) {
+			FindClose( d->h );
+		}
+		delete d;
+	}
+	RESTORE_ERRORS;
+}
+
+static int make_dentry( struct DIR *d )
+{
+	int ok = 0;
+
+	memset( &d->de, 0, sizeof(d->de) );
+	if(d->h != INVALID_HANDLE_VALUE) {
+		if( (d->FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 &&
+			   *d->FindFileData.cFileName == '.')
+		{
+			ok = 0;
+		} else {
+			strncpy( d->de.d_name, d->FindFileData.cFileName, sizeof(d->de.d_name)-1 );
+			d->de.d_name[sizeof(d->de.d_name)-1] = 0;
+			charset_host2mac( d->de.d_name );
+			ok = 1;
+		}
+	}
+	return ok;
+}
+
+struct dirent *readdir( struct DIR *d )
+{
+	DISABLE_ERRORS;
+
+	dirent *de = 0;
+
+	if(d) {
+		if(d->h != INVALID_HANDLE_VALUE) {
+			if(d->h == VIRTUAL_ROOT_ID) {
+				make_dentry(d);
+				de = &d->de;
+				d->vname_list += strlen(d->vname_list) + 1;
+				if(*d->vname_list) {
+					strcpy( d->FindFileData.cFileName, d->vname_list );
+					d->FindFileData.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
+				} else {
+					// Out of static drive entries. Continue with other stuff.
+					char mask[MAX_PATH_LENGTH];
+					make_mask( mask, virtual_root, "*.*", 0 );
+					d->h = FindFirstFile( mask, &d->FindFileData );
+				}
+			} else {
+				int done = 0;
+				do {
+					if(make_dentry(d)) {
+						de = &d->de;
+						done = 1;
+					}
+					if(!FindNextFile( d->h, &d->FindFileData )) {
+						FindClose( d->h );
+						d->h = INVALID_HANDLE_VALUE;
+						done = 1;
+					}
+				} while(!done);
+			}
+		}
+	}
+
+	if(de) {
+		D(bug("readdir found %s\n", de->d_name));
+	}
+
+	RESTORE_ERRORS;
+
+	return de;
+}
+
+struct DIR *opendir( const char *path )
+{
+	DISABLE_ERRORS;
+	DIR *d = new DIR;
+	if(d) {
+		memset( d, 0, sizeof(DIR) );
+		if(*path == 0) {
+			d->vname_list = host_drive_list;
+			if(d->vname_list) {
+				d->h = VIRTUAL_ROOT_ID;
+				strcpy( d->FindFileData.cFileName, d->vname_list );
+				d->FindFileData.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
+			} else {
+				d->h = INVALID_HANDLE_VALUE;
+			}
+		} else {
+			char mask[MAX_PATH_LENGTH];
+			make_mask( mask, MRP(path), "*.*", 0 );
+
+			D(bug("opendir path=%s, mask=%s\n", path, mask));
+
+			d->h = FindFirstFile( mask, &d->FindFileData );
+			if(d->h == INVALID_HANDLE_VALUE) {
+				delete d;
+				d = 0;
+			}
+		}
+	}
+
+	D(bug("opendir(%s,%s) = %08x\n", path, MRP(path), d));
+
+	RESTORE_ERRORS;
+
+	return d;
+}
+
+static void dump_stat( const struct my_stat *st )
+{
+	D(bug("stat: size = %ld, mode = %ld, a = %ld, m = %ld, c = %ld\n", st->st_size, st->st_mode, st->st_atime, st->st_mtime, st->st_ctime));
+}
+
+
+
+// Exported hook functions
+int my_stat( const char *path, struct my_stat *st )
+{
+	DISABLE_ERRORS;
+
+	int result;
+
+	if(*path == 0) {
+		/// virtual root
+		memset( st, 0, sizeof(struct my_stat) );
+		st->st_mode = _S_IFDIR;
+		result = 0;
+		my_errno = 0;
+	} else {
+		result = stat( MRP(path), (struct stat *)st );
+		if(result < 0) {
+			my_errno = errno;
+		} else {
+			my_errno = 0;
+		}
+	}
+
+	D(bug("stat(%s,%s) = %d\n", path, MRP(path), result));
+	if(result >= 0) dump_stat( st );
+	RESTORE_ERRORS;
+	return result;
+}
+
+int my_fstat( int fd, struct my_stat *st )
+{
+	DISABLE_ERRORS;
+	int result = fstat( fd, (struct stat *)st );
+	if(result < 0) {
+		my_errno = errno;
+	} else {
+		my_errno = 0;
+	}
+	D(bug("fstat(%d) = %d\n", fd, result));
+	if(result >= 0) dump_stat( st );
+	RESTORE_ERRORS;
+	return result;
+}
+
+int my_open( const char *path, int mode, ... )
+{
+	DISABLE_ERRORS;
+	int result;
+	char *p = MRP(path);
+
+	// Windows "open" does not handle _O_CREAT and _O_BINARY as it should
+	if(mode & _O_CREAT) {
+		if(exists(p)) {
+			result = open( p, mode & ~_O_CREAT );
+			D(bug("open-nocreat(%s,%s,%d) = %d\n", path, p, mode, result));
+		} else {
+			result = creat( p, _S_IWRITE|_S_IREAD );
+			if(result < 0) {
+				make_folders(p);
+				result = creat( p, _S_IWRITE|_S_IREAD );
+			}
+			D(bug("open-creat(%s,%s,%d) = %d\n", path, p, mode, result));
+		}
+	} else {
+		result = open( p, mode );
+		D(bug("open(%s,%s,%d) = %d\n", path, p, mode, result));
+	}
+	if(result < 0) {
+		my_errno = errno;
+	} else {
+		setmode(result, _O_BINARY);
+		my_errno = 0;
+	}
+	RESTORE_ERRORS;
+	return result;
+}
+
+int my_rename( const char *old_path, const char *new_path )
+{
+	DISABLE_ERRORS;
+	int result = -1;
+	char *p_old = MRP(old_path);
+	char *p_new = MRP2(new_path);
+
+	result = my_access(old_path,0);
+	if(result < 0) {
+		// my_errno already set
+	} else {
+		if(is_same_drive(p_old,p_new)) {
+			result = rename( p_old, p_new );
+			if(result != 0) { // by definition, rename may also return a positive value to indicate an error
+				my_errno = errno;
+			} else {
+				my_errno = 0;
+			}
+		} else {
+			if(is_dir(p_old)) {
+				result = folder_copy( p_old, p_new );
+				// my_errno already set
+				if(result >= 0) {
+					if(myRemoveDirectory( p_old )) {
+						my_errno = 0;
+						result = 0;
+					} else {
+						// there is no proper error code for this failure.
+						my_errno = EACCES;
+						result = -1;
+					}
+				}
+			} else {
+				result = file_move( p_old, p_new );
+				// my_errno already set
+			}
+		}
+	}
+	D(bug("rename(%s,%s,%s,%s) = %d\n", old_path, p_old, new_path, p_new, result));
+	RESTORE_ERRORS;
+	return result;
+}
+
+int my_access( const char *path, int mode )
+{
+	DISABLE_ERRORS;
+	char *p = MRP(path);
+	WIN32_FIND_DATA fdata;
+
+	int result;
+
+	if(is_dir(p)) {
+		// access does not work for folders.
+		HANDLE h = FindFirstFile( p, &fdata );
+		if(h != INVALID_HANDLE_VALUE) {
+			FindClose( h );
+			if(mode == W_OK) {
+				if( (fdata.dwFileAttributes & FILE_ATTRIBUTE_READONLY) == 0 ) {
+					result = 0;
+					my_errno = 0;
+				} else {
+					result = -1;
+					my_errno = EACCES;
+				}
+			} else {
+				result = 0;
+				my_errno = 0;
+			}
+		} else {
+			result = -1;
+			my_errno = ENOENT;
+		}
+	} else {
+		// W_OK, F_OK are ok.
+		result = access(p,mode);
+		if(result < 0) {
+			my_errno = errno;
+		} else {
+			my_errno = 0;
+		}
+	}
+
+	D(bug("access(%s,%s,%d) = %d\n", path, MRP(path), mode, result));
+	RESTORE_ERRORS;
+	return result;
+}
+
+int my_mkdir( const char *path, int mode )
+{
+	DISABLE_ERRORS;
+	char *p = MRP(path);
+	strip_trailing_bs(p);
+	int result = mkdir( p );
+	if(result < 0) {
+		make_folders(p);
+		result = mkdir( p );
+	}
+	if(result < 0) {
+		my_errno = errno;
+	} else {
+		my_errno = 0;
+	}
+	D(bug("mkdir(%s,%s,%d) = %d\n", path, p, mode, result));
+	RESTORE_ERRORS;
+	return result;
+}
+
+int my_remove( const char *path )
+{
+	DISABLE_ERRORS;
+	char *p = MRP(path);
+	strip_trailing_bs(p);
+	int result;
+	if(is_dir(p)) {
+		result = myRemoveDirectory( p );
+	} else {
+		D(bug("DeleteFile %s\n", p));
+		result = DeleteFile( p );
+	}
+	if(result) {
+		result = 0;
+		my_errno = 0;
+	} else {
+		result = -1;
+		if(exists(p)) {
+			my_errno = EACCES;
+		} else {
+			my_errno = ENOENT;
+		}
+	}
+	D(bug("remove(%s,%s) = %d\n", path, p, result));
+	RESTORE_ERRORS;
+	return result;
+}
+
+int my_creat( const char *path, int mode )
+{
+	DISABLE_ERRORS;
+	char *p = MRP(path);
+	int result = creat( p, _S_IWRITE|_S_IREAD ); // note mode
+	if(result < 0) {
+		make_folders(p);
+		result = creat( p, _S_IWRITE|_S_IREAD ); // note mode
+	}
+	if(result < 0) {
+		my_errno = errno;
+	} else {
+		setmode(result, _O_BINARY);
+		my_errno = 0;
+	}
+	D(bug("creat(%s,%s,%d) = %d\n", path, p, mode,result));
+	RESTORE_ERRORS;
+	return result;
+}
+
+int my_chsize( int fd, size_t sz )
+{
+	DISABLE_ERRORS;
+	int result = chsize(fd,sz);
+	if(result < 0) {
+		my_errno = errno;
+	} else {
+		my_errno = 0;
+	}
+	RESTORE_ERRORS;
+	return result;
+}
+
+int my_close( int fd )
+{
+	DISABLE_ERRORS;
+	int result = close(fd);
+	if(result < 0) {
+		my_errno = errno;
+	} else {
+		my_errno = 0;
+	}
+	RESTORE_ERRORS;
+	D(bug("close(%d) = %d\n", fd, result));
+	return result;
+}
+
+long my_lseek( int fd, long offset, int origin )
+{
+	DISABLE_ERRORS;
+	int result = lseek( fd, offset, origin );
+	if(result < 0) {
+		my_errno = errno;
+	} else {
+		my_errno = 0;
+	}
+	RESTORE_ERRORS;
+	return result;
+}
+
+int my_read( int fd, void *buffer, unsigned int count )
+{
+	DISABLE_ERRORS;
+	int result = read( fd, buffer, count );
+	if(result < 0) {
+		my_errno = errno;
+	} else {
+		my_errno = 0;
+	}
+	RESTORE_ERRORS;
+	D(bug("read(%ld,%08x,%ld) = %d\n", fd, buffer, count, result));
+
+	return result;
+}
+
+int my_write( int fd, const void *buffer, unsigned int count )
+{
+	DISABLE_ERRORS;
+	int result = write( fd, buffer, count );
+	if(result < 0) {
+		my_errno = errno;
+	} else {
+		my_errno = 0;
+	}
+	RESTORE_ERRORS;
+	D(bug("write(%ld,%08x,%ld) = %d\n", fd, buffer, count, result));
+	return result;
+}
 
-// TODO: UNC names. Customizable "Virtual Desktop" location.
+#ifdef _MSC_VER
 
-#include "sysdeps.h"
-#define NO_POSIX_API_HOOK
-#include "posix_emu.h"
-#include "user_strings.h"
-#include "util_windows.h"
-#include "main.h"
-#include "extfs_defs.h"
-#include "prefs.h"
-#include <ctype.h>
+#include <float.h>
 
-
-#define DEBUG_EXTFS 0
-
-#if DEBUG_EXTFS
-
-// This must be always on.
-#define DEBUG 1
-#undef OutputDebugString
-#define OutputDebugString extfs_log_write
-extern void extfs_log_write( char *s );
-#define EXTFS_LOG_FILE_NAME "extfs.log"
-#include "debug.h"
-
-enum {
-	DB_EXTFS_NONE=0,
-	DB_EXTFS_NORMAL,
-	DB_EXTFS_LOUD
-};
-static int16 debug_extfs = DB_EXTFS_NONE;
-static HANDLE extfs_log_file = INVALID_HANDLE_VALUE;
-
-static void extfs_log_open( char *path )
+double
+round(double x)
 {
-	if(debug_extfs == DB_EXTFS_NONE) return;
+	double t;
 
-	DeleteFile( path );
-	extfs_log_file = CreateFile(
-			path,
-			GENERIC_READ|GENERIC_WRITE,
-			FILE_SHARE_READ,
-			NULL,
-			CREATE_ALWAYS,
-			// FILE_FLAG_WRITE_THROUGH|FILE_FLAG_NO_BUFFERING,
-			FILE_FLAG_WRITE_THROUGH,
-			NULL
-	);
-	if( extfs_log_file == INVALID_HANDLE_VALUE ) {
-		ErrorAlert( "Could not create the EXTFS log file." );
-	}
-}
+	if (!_finite(x) || _isnan(x))
+		return (x);
 
-static void extfs_log_close( void )
-{
-	if(debug_extfs == DB_EXTFS_NONE) return;
-
-	if( extfs_log_file != INVALID_HANDLE_VALUE ) {
-		CloseHandle( extfs_log_file );
-		extfs_log_file = INVALID_HANDLE_VALUE;
-	}
-}
-
-static void extfs_log_write( char *s )
-{
-	DWORD bytes_written;
-
-	// should have been checked already.
-	if(debug_extfs == DB_EXTFS_NONE) return;
-
-	if( extfs_log_file != INVALID_HANDLE_VALUE ) {
-
-		DWORD count = strlen(s);
-		if (0 == WriteFile(extfs_log_file, s, count, &bytes_written, NULL) ||
-				(int)bytes_written != count)
-		{
-			extfs_log_close();
-			ErrorAlert( "extfs log file write error (out of disk space?). Log closed." );
-		} else {
-			FlushFileBuffers( extfs_log_file );
-		}
-	}
-}
-#else
-
-#define DEBUG 0
-#include "debug.h"
-
-#endif // DEBUG_EXTFS
-
-int my_errno = 0;
-
-#define VIRTUAL_ROOT_ID ((HANDLE)0xFFFFFFFE)
-
-static LPCTSTR desktop_name = TEXT("Virtual Desktop");
-static const char *custom_icon_name = "Icon\r";
-#define my_computer GetString(STR_EXTFS_VOLUME_NAME)
-
-static TCHAR lb1[MAX_PATH_LENGTH];
-static TCHAR lb2[MAX_PATH_LENGTH];
-
-#define MRP(path) translate(path,lb1)
-#define MRP2(path) translate(path,lb2)
-
-#define DISABLE_ERRORS UINT prevmode = SetErrorMode(SEM_NOOPENFILEERRORBOX|SEM_FAILCRITICALERRORS)
-#define RESTORE_ERRORS SetErrorMode(prevmode);
-
-static TCHAR host_drive_list[512];
-static TCHAR virtual_root[248]; // Not _MAX_PATH
-
-const uint8 my_comp_icon[2670] = {
-	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0xD8, 0x00, 0x00, 0x08, 0xD8, 0x00, 0x00, 0x00, 0x96,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x02, 0x00, 0x79, 0x79, 0x79, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xC0, 0xCC, 0xCC, 0xCC,
-	0xCC, 0xD7, 0x97, 0x97, 0x97, 0x97, 0x97, 0xC0, 0xC0, 0xC0, 0xC0, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
-	0xCD, 0xDB, 0xD9, 0x79, 0x79, 0x7E, 0x79, 0x0C, 0xDD, 0xCD, 0xDD, 0xCD, 0xCD, 0xDC, 0xDD, 0xCD,
-	0xCC, 0xED, 0xED, 0x97, 0x97, 0x97, 0x97, 0x0C, 0xE7, 0x78, 0x77, 0x97, 0x97, 0x97, 0x97, 0x97,
-	0xDC, 0xED, 0xDE, 0x79, 0x79, 0x79, 0x99, 0x0C, 0xD9, 0x7E, 0x5E, 0x65, 0x5E, 0x65, 0xD9, 0x79,
-	0xCD, 0xDE, 0xDD, 0x97, 0xE7, 0x9E, 0x77, 0xC0, 0x97, 0x9D, 0xCD, 0xCC, 0xC7, 0xCC, 0xE7, 0x97,
-	0xCC, 0xED, 0xEE, 0x79, 0x79, 0x79, 0x7E, 0xCC, 0x57, 0xD5, 0xD7, 0xD5, 0xDD, 0x5D, 0xD9, 0x7E,
-	0xCD, 0xDE, 0xDE, 0x79, 0x97, 0x97, 0x99, 0x0C, 0x87, 0xCD, 0x75, 0xC7, 0x5C, 0x7D, 0xD9, 0x79,
-	0xCD, 0xDD, 0xED, 0xE7, 0x7E, 0x79, 0x77, 0xCC, 0xE7, 0xB0, 0x00, 0xC0, 0x0C, 0xCD, 0xE7, 0x97,
-	0xDC, 0xED, 0xEE, 0x79, 0x97, 0x86, 0x79, 0xC0, 0xE7, 0xD0, 0x2C, 0xC1, 0xC2, 0xCD, 0xD9, 0x79,
-	0xCD, 0xDE, 0xDD, 0x97, 0x99, 0x79, 0x97, 0x0C, 0xE7, 0xB0, 0xD0, 0xDC, 0xCC, 0xCD, 0xD6, 0x87,
-	0xDD, 0xDE, 0xED, 0x79, 0x77, 0xE7, 0x79, 0x0C, 0x58, 0xDC, 0x0C, 0x0C, 0xCC, 0xCD, 0xE9, 0x79,
-	0xCD, 0xDD, 0xD5, 0x99, 0x97, 0x99, 0x79, 0xC0, 0x87, 0xD0, 0xC0, 0xC0, 0xC0, 0xCD, 0xD7, 0xE7,
-	0xDD, 0xDE, 0xD7, 0x97, 0x79, 0x77, 0xE7, 0x0C, 0xE7, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0x79, 0x79,
-	0xCD, 0xDE, 0xD9, 0x79, 0x97, 0xE9, 0x79, 0x0C, 0x97, 0x79, 0x79, 0x79, 0x79, 0x79, 0x97, 0x97,
-	0xDC, 0xED, 0xE7, 0x97, 0x79, 0x97, 0x97, 0x0C, 0xCD, 0xD7, 0xD7, 0xD7, 0xE7, 0xE7, 0x7E, 0x79,
-	0xCD, 0xDE, 0x79, 0x79, 0x97, 0x7E, 0x79, 0xC0, 0xCC, 0xCC, 0x0C, 0xCC, 0x0D, 0xCC, 0xDC, 0xDC,
-	0xDC, 0xED, 0x97, 0x97, 0x77, 0x99, 0x79, 0xCC, 0xCC, 0xCC, 0xDC, 0xCC, 0xDC, 0xCC, 0xCC, 0x8D,
-	0xCD, 0xDE, 0x79, 0x79, 0x96, 0x77, 0x97, 0x97, 0x97, 0x90, 0xCC, 0xCD, 0xCD, 0xDD, 0xDD, 0xCC,
-	0xDD, 0xD9, 0x76, 0x87, 0x97, 0x99, 0x7E, 0x7C, 0x0C, 0xCC, 0xDD, 0xDD, 0xED, 0xDE, 0xDD, 0xEE,
-	0xDE, 0xD5, 0xBD, 0xDE, 0x79, 0x79, 0x9C, 0xC0, 0xCC, 0xDD, 0xDD, 0xDD, 0xDE, 0xDD, 0xED, 0xDE,
-	0xDE, 0xDD, 0xDE, 0xDE, 0x79, 0x79, 0x70, 0xCD, 0xCC, 0xCC, 0xCC, 0xCC, 0xDC, 0xDD, 0xDD, 0xDD,
-	0xDD, 0xDD, 0xED, 0xED, 0x97, 0x97, 0x90, 0xCC, 0x8D, 0xCC, 0xDC, 0xCD, 0xCC, 0xCC, 0xCC, 0xCC,
-	0xCC, 0xEE, 0xDE, 0xDE, 0x79, 0x7E, 0x70, 0xCC, 0x88, 0xDC, 0xCC, 0xCC, 0xCD, 0xDD, 0xDD, 0xDC,
-	0xCD, 0xDD, 0xED, 0xED, 0x97, 0x97, 0xEC, 0xCC, 0xCC, 0xCC, 0xDC, 0xCC, 0xCD, 0xDD, 0xED, 0xDD,
-	0xDC, 0xED, 0xED, 0xEE, 0x79, 0x79, 0xDC, 0x0D, 0xCC, 0xDC, 0xCC, 0xCD, 0xCC, 0xCC, 0xCC, 0x0C,
-	0xDC, 0xDE, 0xDE, 0xED, 0x97, 0xDC, 0xCC, 0xDC, 0xCD, 0xCC, 0xDC, 0xCD, 0xCC, 0xCC, 0xCD, 0xCC,
-	0xCC, 0xED, 0xED, 0x79, 0xDD, 0xC0, 0xCD, 0xCC, 0xDC, 0xCD, 0xCC, 0xDC, 0xCC, 0xDC, 0xDD, 0xCD,
-	0xCD, 0xED, 0x97, 0x97, 0xDD, 0xCC, 0xCC, 0x00, 0xC0, 0xDD, 0xCD, 0xCC, 0xCC, 0xCD, 0xD0, 0xDC,
-	0xDD, 0xF7, 0x99, 0x79, 0x97, 0x9D, 0xDD, 0xDD, 0xCC, 0xC0, 0xCC, 0x0C, 0xDC, 0xDC, 0xCD, 0xCD,
-	0xDF, 0x79, 0x77, 0x97, 0x79, 0x79, 0x79, 0x79, 0xDD, 0xDE, 0xDC, 0xCC, 0xCC, 0xC0, 0xC0, 0xDD,
-	0xE9, 0x79, 0x97, 0x99, 0x97, 0xE7, 0xE7, 0x97, 0x97, 0x9D, 0x79, 0xDD, 0xDD, 0xDD, 0xCD, 0xDE,
-	0x79, 0x79, 0x7E, 0x77, 0x00, 0x00, 0x04, 0x00, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0xF5,
-	0xF5, 0xF5, 0xF5, 0xF5, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
-	0x2B, 0x2B, 0xF9, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0xF6,
-	0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF7, 0xF7, 0xF7,
-	0xF7, 0xF8, 0x81, 0xFA, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56,
-	0xF7, 0xF8, 0x81, 0x81, 0x81, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xA5, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
-	0xF8, 0xF8, 0x81, 0xFA, 0xFB, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xA5, 0xC2, 0xC2, 0xFB, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xFB, 0xC2, 0xC2, 0xC2,
-	0xF7, 0xF8, 0x81, 0x81, 0xFB, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0x2B,
-	0xA5, 0xC2, 0xC2, 0xFB, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x81, 0xC2, 0xC2, 0xC2,
-	0xF7, 0xF8, 0x81, 0x81, 0xFB, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0x2B,
-	0xA5, 0xC2, 0xF9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xF9, 0xFB, 0xC2, 0xC2, 0xC2,
-	0xF7, 0xF8, 0x81, 0x81, 0xFB, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xA5, 0xC2, 0xF9, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0xF9, 0x81, 0xC2, 0xC2, 0xC2,
-	0xF8, 0x56, 0xFA, 0x81, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xA5, 0xC2, 0xF9, 0xF5, 0xF5, 0xF5, 0xF6, 0xF6, 0xF6, 0xF6, 0x2B, 0xF9, 0xFB, 0xC2, 0xC2, 0xC2,
-	0xF8, 0x56, 0x81, 0x81, 0xFB, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xA5, 0xC2, 0xF9, 0xF5, 0x0A, 0xF6, 0x2B, 0x0A, 0xF6, 0x0A, 0x2B, 0xF9, 0x81, 0xC2, 0xC2, 0xC2,
-	0xF8, 0x56, 0x81, 0x81, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xA5, 0xC2, 0xF9, 0xF5, 0xF8, 0xF6, 0x56, 0xF7, 0xF7, 0xF8, 0x2B, 0xF9, 0x81, 0xC2, 0xC2, 0xC2,
-	0xF8, 0x56, 0x81, 0x81, 0xFB, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xA5, 0xC2, 0xF9, 0xF5, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0x2B, 0x2B, 0xF9, 0xFB, 0xC2, 0xC2, 0xC2,
-	0xF8, 0x56, 0xFA, 0x81, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xA5, 0xC2, 0xF9, 0xF6, 0xF6, 0xF5, 0xF6, 0xF6, 0xF6, 0xF6, 0x2B, 0xF9, 0x81, 0xC2, 0xC2, 0xC2,
-	0xF8, 0x56, 0x81, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xA5, 0xC2, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xC2, 0xC2, 0xC2, 0xC2,
-	0xF8, 0x56, 0x81, 0x81, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xA5, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
-	0xF8, 0x56, 0x81, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0xF7, 0x56, 0xF8, 0x7A, 0x7A, 0x9E, 0x9E, 0x9E, 0x9E, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
-	0xF8, 0x56, 0x81, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B,
-	0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF7, 0xF7, 0xF8, 0xF8,
-	0xF8, 0x56, 0x81, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF7, 0xF7,
-	0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0x56, 0xB9, 0xF8,
-	0xF8, 0x56, 0x81, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
-	0xC2, 0xC2, 0xC2, 0xF6, 0x2B, 0x2B, 0xF7, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0xF8,
-	0xF8, 0x56, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6,
-	0xF6, 0xF6, 0x2B, 0xF8, 0x56, 0xFA, 0xF9, 0x81, 0x81, 0x81, 0xFA, 0x81, 0x81, 0x81, 0xFB, 0x81,
-	0xFB, 0xFB, 0xFB, 0x81, 0xFA, 0xFA, 0xFA, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xF6, 0xF6,
-	0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFB,
-	0x81, 0xFB, 0xF9, 0xFA, 0xFA, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B, 0xF7,
-	0xF8, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF8, 0xF8, 0x56, 0x56, 0xF9, 0xF9, 0xF9, 0xFA,
-	0xFA, 0xFA, 0xFA, 0x81, 0x81, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B, 0xF7,
-	0x93, 0xA0, 0xF7, 0xF7, 0xF8, 0xF7, 0xF7, 0xF8, 0xF7, 0xF7, 0xF7, 0xF7, 0x2B, 0x2B, 0x2B, 0x2B,
-	0x2B, 0x2B, 0x81, 0xFB, 0x81, 0xFB, 0xFB, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B, 0xF7,
-	0xA0, 0xA0, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0x56, 0x56, 0xF9, 0xF9, 0xF9, 0xF8, 0xF7,
-	0xF7, 0xF7, 0xFB, 0xFB, 0x81, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF5, 0x2B, 0xF7,
-	0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF9, 0xF9, 0xFB, 0xFB, 0xFB, 0xF8, 0xF9,
-	0xF9, 0xF7, 0x81, 0xFB, 0xFB, 0x81, 0xFB, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xF8, 0x2B, 0x2B, 0x56,
-	0x2B, 0x2B, 0xF9, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF8,
-	0xF8, 0xF7, 0xFB, 0xFB, 0x81, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xF8, 0xF8, 0xF6, 0xF6, 0xF9, 0xF8,
-	0x2B, 0xF9, 0xF8, 0x2B, 0xF9, 0x2B, 0x2B, 0xF9, 0x2B, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
-	0xF7, 0xF7, 0x81, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xF9, 0xF8, 0xF6, 0xF6, 0xF7, 0xF9, 0xF8, 0x2B,
-	0xF9, 0xF8, 0xF6, 0xF9, 0xF8, 0xF6, 0xF9, 0xF8, 0xF6, 0x2B, 0xF9, 0x2B, 0xF9, 0x56, 0x2B, 0xF9,
-	0x2B, 0xF9, 0xAC, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xFA, 0xF9, 0xF8, 0x2B, 0x2B, 0x2B, 0xF5, 0xF5,
-	0xF5, 0xF5, 0xF9, 0xF8, 0xF6, 0xF9, 0xF8, 0xF6, 0x2B, 0xF8, 0x2B, 0xF9, 0x56, 0x2B, 0x56, 0x2B,
-	0x56, 0x81, 0xAC, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xFA, 0xFA, 0xFA, 0xF9, 0xF8,
-	0xF8, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF5, 0x2B, 0xF9, 0xF6, 0xF9, 0xF8, 0xF7, 0xF9, 0x2B, 0xF9,
-	0x81, 0xAC, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
-	0xFA, 0xFA, 0xFA, 0xFA, 0xF9, 0xF8, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0xF5, 0xF5, 0xF5, 0x56, 0x81,
-	0xAC, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
-	0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xFA, 0xF9, 0xFA, 0xFA, 0xF9, 0xF9, 0xF8, 0xF8, 0x81, 0x81,
-	0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0x00, 0x00, 0x01, 0x00, 0x03, 0xFF, 0xFF, 0xE0,
-	0x02, 0x00, 0x00, 0x38, 0x02, 0xFF, 0xFF, 0x3C, 0x02, 0xFF, 0xFF, 0x3C, 0x02, 0xFF, 0xFF, 0x3C,
-	0x02, 0xF0, 0x0F, 0x3C, 0x02, 0xFF, 0xFF, 0x3C, 0x02, 0xFF, 0xFF, 0x7C, 0x02, 0xE0, 0x1F, 0x7C,
-	0x02, 0xE0, 0x1F, 0x7C, 0x02, 0xE0, 0x1F, 0x7C, 0x02, 0xE0, 0x1F, 0x7C, 0x02, 0xE0, 0x1F, 0x78,
-	0x02, 0xFF, 0xFF, 0x78, 0x02, 0xFF, 0xFF, 0x78, 0x02, 0x1F, 0xFF, 0x70, 0x02, 0x00, 0x00, 0x70,
-	0x03, 0xFF, 0xFF, 0xF0, 0x00, 0x0F, 0xFF, 0xE0, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0x1F, 0xFF, 0xFF,
-	0x02, 0x00, 0x3F, 0xFF, 0x02, 0x40, 0x00, 0x3F, 0x02, 0xC0, 0x7C, 0x3F, 0x02, 0x00, 0x7D, 0xBF,
-	0x0F, 0x20, 0x00, 0x3F, 0x32, 0x49, 0x00, 0x3C, 0xC4, 0x92, 0x2D, 0x70, 0xE0, 0x24, 0x1A, 0xE0,
-	0x1F, 0x00, 0xA5, 0xC0, 0x00, 0xFC, 0x03, 0x80, 0x00, 0x03, 0xFF, 0x00, 0x03, 0xFF, 0xFF, 0xE0,
-	0x03, 0xFF, 0xFF, 0xF8, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC,
-	0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC,
-	0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xF8,
-	0x03, 0xFF, 0xFF, 0xF8, 0x03, 0xFF, 0xFF, 0xF8, 0x03, 0xFF, 0xFF, 0xF0, 0x03, 0xFF, 0xFF, 0xF0,
-	0x03, 0xFF, 0xFF, 0xF0, 0x00, 0x1F, 0xFF, 0xE0, 0x01, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF,
-	0x07, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF,
-	0x0F, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xE0,
-	0x1F, 0xFF, 0xFF, 0xC0, 0x00, 0xFF, 0xFF, 0x80, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x40,
-	0x1F, 0xFC, 0x10, 0x06, 0x10, 0x06, 0x10, 0x06, 0x10, 0x06, 0x10, 0x06, 0x10, 0x06, 0x10, 0x04,
-	0x1F, 0xFC, 0x0F, 0xFE, 0x0F, 0xFF, 0x18, 0x67, 0x34, 0x06, 0x69, 0x64, 0x72, 0xC8, 0x3F, 0xF0,
-	0x1F, 0xFC, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x1F, 0xFC,
-	0x1F, 0xFC, 0x07, 0xFF, 0x1F, 0xFF, 0x3F, 0xFF, 0x3F, 0xFF, 0x7F, 0xFE, 0xFF, 0xFC, 0x07, 0xF8,
-	0x00, 0x00, 0x00, 0x80, 0x79, 0x7C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCD, 0x97, 0x97, 0x90, 0xE7, 0x97,
-	0x97, 0x97, 0xDD, 0xD9, 0x79, 0x7C, 0xE7, 0xD5, 0x5E, 0x58, 0xCE, 0xD7, 0x97, 0x9C, 0xDD, 0x5D,
-	0x7D, 0xB7, 0xDD, 0x59, 0x79, 0x7C, 0x9D, 0x10, 0x1D, 0xD9, 0xCE, 0xD7, 0x97, 0x9C, 0xDD, 0x0C,
-	0xCC, 0xE7, 0xDD, 0xD9, 0x79, 0x7C, 0xED, 0xDD, 0xDD, 0x79, 0xCE, 0xE7, 0xE7, 0x90, 0xE7, 0x77,
-	0x97, 0x97, 0xDD, 0x79, 0x79, 0x7C, 0xCC, 0xDC, 0xCD, 0xC8, 0xDD, 0x97, 0x97, 0x99, 0x7C, 0xDD,
-	0xDD, 0xDE, 0xDE, 0xDE, 0x7E, 0x7C, 0xCC, 0xCC, 0xCD, 0xCD, 0xDD, 0xDE, 0x99, 0x0C, 0x8C, 0xCC,
-	0xCC, 0xCC, 0xCD, 0xED, 0x77, 0xCC, 0xCC, 0xCD, 0xDD, 0xED, 0xCE, 0xDE, 0x9C, 0xCD, 0xCD, 0xCD,
-	0x0D, 0xCC, 0xCE, 0xE7, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xCC, 0xDE, 0x99, 0x97, 0x97, 0x9D, 0xDD,
-	0xDD, 0xDE, 0xE9, 0x77, 0x00, 0x00, 0x01, 0x00, 0xC2, 0xC2, 0xC2, 0xF5, 0xF5, 0xF5, 0xF6, 0xF6,
-	0xF6, 0x2B, 0x2B, 0x2B, 0xF7, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xC2, 0xC2, 0xC2,
-	0xC2, 0xC2, 0xC2, 0xC2, 0xF8, 0x81, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xC2, 0x81, 0xAA,
-	0xAA, 0xAA, 0xFB, 0xC2, 0xF8, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xF9, 0x7F, 0x7F,
-	0x7F, 0x56, 0x81, 0xC2, 0xF8, 0x81, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xF9, 0x0A, 0xF6,
-	0x0A, 0x56, 0xFB, 0xC2, 0xF8, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xF9, 0xF6, 0xF6,
-	0xF6, 0x56, 0x81, 0xC2, 0x56, 0x81, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xF9, 0xF9, 0xF9,
-	0xF9, 0xF9, 0xC2, 0xC2, 0xF8, 0x81, 0xFB, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0xA5, 0xC2, 0xC2, 0xC2,
-	0xC2, 0xC2, 0xC2, 0xC2, 0x56, 0xFA, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0x2B, 0x2B, 0x2B, 0xF7, 0xF7,
-	0xF7, 0xF7, 0xF7, 0xB9, 0x56, 0x81, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF6, 0x56, 0xF9,
-	0xFA, 0xFA, 0xFB, 0xFB, 0xFB, 0x81, 0xFA, 0x81, 0xC2, 0xC2, 0xC2, 0xF6, 0xF6, 0xF7, 0x2B, 0x2B,
-	0x2B, 0xF8, 0xF8, 0xF8, 0xF9, 0xFA, 0x81, 0xFB, 0xC2, 0xC2, 0xF5, 0xF7, 0x93, 0xF7, 0xF7, 0xF7,
-	0xF7, 0x2B, 0x2B, 0x2B, 0x2B, 0xFB, 0x81, 0xFB, 0xC2, 0xC2, 0xF5, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
-	0xF9, 0xFB, 0xFB, 0xF9, 0xF7, 0xFB, 0x81, 0xFB, 0xC2, 0xF6, 0xF8, 0xF9, 0x2B, 0xF9, 0x2B, 0xF9,
-	0xF6, 0xF8, 0x2B, 0xF8, 0xF7, 0xFB, 0xFB, 0xC2, 0xF9, 0xF7, 0xF9, 0xF7, 0xF9, 0xF7, 0xF9, 0x2B,
-	0xF9, 0x2B, 0xF8, 0x2B, 0x81, 0xAC, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xF9, 0xF9, 0xF9,
-	0xF9, 0xF9, 0xF9, 0x81, 0xAC, 0xC2, 0xC2, 0xC2, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0xD8,
-	0x00, 0x00, 0x08, 0xD8, 0x00, 0x00, 0x00, 0x96, 0x02, 0x1C, 0xC1, 0xC4, 0x18, 0x9C, 0x00, 0x00,
-	0x00, 0x1C, 0x00, 0x96, 0x00, 0x05, 0x69, 0x63, 0x6C, 0x34, 0x00, 0x00, 0x00, 0x32, 0x69, 0x63,
-	0x6C, 0x38, 0x00, 0x00, 0x00, 0x3E, 0x49, 0x43, 0x4E, 0x23, 0x00, 0x00, 0x00, 0x4A, 0x69, 0x63,
-	0x73, 0x23, 0x00, 0x00, 0x00, 0x56, 0x69, 0x63, 0x73, 0x34, 0x00, 0x00, 0x00, 0x62, 0x69, 0x63,
-	0x73, 0x38, 0x00, 0x00, 0x00, 0x6E, 0xBF, 0xB9, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1C,
-	0xE2, 0x10, 0xBF, 0xB9, 0xFF, 0xFF, 0x00, 0x00, 0x02, 0x04, 0x02, 0x1C, 0xE1, 0xAC, 0xBF, 0xB9,
-	0xFF, 0xFF, 0x00, 0x00, 0x06, 0x08, 0x02, 0x1C, 0xE1, 0xA4, 0xBF, 0xB9, 0xFF, 0xFF, 0x00, 0x00,
-	0x07, 0x0C, 0x02, 0x1C, 0xE1, 0xF8, 0xBF, 0xB9, 0xFF, 0xFF, 0x00, 0x00, 0x07, 0x50, 0x02, 0x1C,
-	0xE1, 0xDC, 0xBF, 0xB9, 0xFF, 0xFF, 0x00, 0x00, 0x07, 0xD4, 0x02, 0x1C, 0xE1, 0xD0
-};
-
-static bool use_streams[ 'Z'-'A'+1 ];
-
-static bool is_ntfs_volume(LPCTSTR rootdir)
-{
-	bool ret = false;
-	TCHAR tst_file[_MAX_PATH], tst_stream[_MAX_PATH];
-	_sntprintf( tst_file, lengthof(tst_file), TEXT("%sb2query.tmp"), rootdir );
-	_sntprintf( tst_stream, lengthof(tst_stream), TEXT("%s:AFP_AfpInfo"), tst_file );
-	if(!exists(tst_file)) {
-		if(create_file( tst_file, 0 )) {
-			if(create_file( tst_stream, 0 )) {
-				ret = true;
-			}
-			DeleteFile( tst_file );
-		}
-	}
-	return ret;
-}
-
-
-// !!UNC
-void init_posix_emu(void)
-{
-	if(!validate_stat_struct) {
-		ErrorAlert( "Invalid struct my_stat -- edit posix_emu.h" );
-		QuitEmulator();
-	}
-
-#if DEBUG_EXTFS
-	debug_extfs = PrefsFindInt16("debugextfs");
-
-	debug_extfs = DB_EXTFS_LOUD;
-
-	if(debug_extfs != DB_EXTFS_NONE) {
-		extfs_log_open( EXTFS_LOG_FILE_NAME );
-	}
-#endif
-
-	// We cannot use ExtFS "RootPath" because of the virtual desktop.
-	if(PrefsFindBool("enableextfs")) {
-		PrefsReplaceString("extfs", "");
+	if (x >= 0.0) {
+		t = ceil(x);
+		if (t - x > 0.5)
+			t -= 1.0;
+		return (t);
 	} else {
-		PrefsRemoveItem("extfs");
-		D(bug("extfs disabled by user\n"));
-#if DEBUG_EXTFS
-		extfs_log_close();
-#endif
-		return;
+		t = ceil(-x);
+		if (t + x > 0.5)
+			t -= 1.0;
+		return (-t);
 	}
-
-	const char *extdrives = PrefsFindString("extdrives");
-
-	// Set up drive list.
-	size_t outinx = 0;
-	for( TCHAR letter = TEXT('A'); letter <= TEXT('Z'); letter++ ) {
-		if(extdrives && !strchr(extdrives,letter)) continue;
-		TCHAR rootdir[20];
-		_sntprintf( rootdir, lengthof(rootdir), TEXT("%c:\\"), letter );
-		use_streams[ letter - 'A' ] = false;
-		switch(GetDriveType(rootdir)) {
-			case DRIVE_FIXED:
-			case DRIVE_REMOTE:
-			case DRIVE_RAMDISK:
-				// TODO: NTFS AFP?
-				// fall
-			case DRIVE_REMOVABLE:
-			case DRIVE_CDROM:
-				if(outinx < lengthof(host_drive_list)) {
-					host_drive_list[outinx] = letter;
-					outinx += 2;
-				}
-		}
-	}
-
-	// Set up virtual desktop root.
-	// TODO: this should be customizable.
-	GetModuleFileName( NULL, virtual_root, lengthof(virtual_root) );
-	TCHAR *p = _tcsrchr( virtual_root, TEXT('\\') );
-	if(p) {
-		_tcscpy( ++p, desktop_name );
-	} else {
-		// should never happen
-		_sntprintf( virtual_root, lengthof(virtual_root), TEXT("C:\\%s"), desktop_name );
-	}
-	CreateDirectory( virtual_root, 0 );
-
-	// Set up an icon looking like "My Computer"
-	// Can be overwritten just like any other folder custom icon.
-	if(my_access(custom_icon_name,0) != 0) {
-		int fd = my_creat( custom_icon_name, 0 );
-		if(fd >= 0) {
-			my_close(fd);
-			fd = open_rfork( custom_icon_name, O_RDWR|O_CREAT );
-			if(fd >= 0) {
-				my_write( fd, my_comp_icon, sizeof(my_comp_icon) );
-				my_close(fd);
-				static uint8 host_finfo[SIZEOF_FInfo];
-				uint32 finfo = Host2MacAddr(host_finfo);
-				get_finfo(custom_icon_name, finfo, 0, false);
-				WriteMacInt16(finfo + fdFlags, kIsInvisible);
-				set_finfo(custom_icon_name, finfo, 0, false);
-				get_finfo(my_computer, finfo, 0, true);
-				WriteMacInt16(finfo + fdFlags, ReadMacInt16(finfo + fdFlags) | kHasCustomIcon);
-				set_finfo(my_computer, finfo, 0, true);
-			} else {
-				my_remove(custom_icon_name);
-			}
-		}
-	}
 }
 
-void final_posix_emu(void)
+float
+roundf(float x)
 {
-#if DEBUG_EXTFS
-	extfs_log_close();
-#endif
-}
+	float t;
 
-static void charset_host2mac( char *s )
-{
-	int i, len=strlen(s), code;
+	if (!_finite(x) || _isnan(x))
+		return (x);
 
-	for( i=len-3; i>=0; i-- ) {
-		if( s[i] == '%' && isxdigit(s[i+1]) && isxdigit(s[i+2]) ) {
-			sscanf( &s[i], "%%%02X", &code );
-			memmove( &s[i], &s[i+2], strlen(&s[i+2])+1 );
-			s[i] = code;
-		}
-	}
-}
-
-static void charset_mac2host( LPTSTR s )
-{
-	size_t len = _tcslen(s);
-
-	D(bug(TEXT("charset_mac2host(%s)...\n"), s));
-
-	for( size_t i=len; i-->0; ) {
-		bool convert = false;
-		switch( (unsigned char)s[i] ) {
-			// case '\r': // handled by "default"
-			// case '\n':
-			// case '\t':
-			case '/':
-			// case '\\': // Backslash is tricky -- "s" is a full path!
-			// case ':':
-			case '*':
-			case '?':
-			case '"':
-			case '<':
-			case '>':
-			case '|':
-			case '%':
-				convert = true;
-				break;
-			default:
-				if((unsigned char)s[i] < ' ') convert = true;
-				break;
-		}
-		if(convert) {
-			TCHAR sml[10];
-			_sntprintf( sml, lengthof(sml), TEXT("%%%02X"), s[i] );
-			memmove( &s[i+2], &s[i], (_tcslen(&s[i])+1) * sizeof(TCHAR) );
-			memmove( &s[i], sml, 3 * sizeof(TCHAR) );
-		}
-	}
-	D(bug(TEXT("charset_mac2host = %s\n"), s));
-}
-
-static void make_mask(
-	TCHAR *mask,
-	LPCTSTR dir,
-	LPCTSTR a1,
-	LPCTSTR a2
-)
-{
-	_tcscpy( mask, dir );
-
-	size_t len = _tcslen(mask);
-	if( len && mask[len-1] != '\\' ) _tcscat( mask, TEXT("\\") );
-
-	if( a1 ) _tcscat( mask, a1 );
-	if( a2 ) _tcscat( mask, a2 );
-}
-
-// !!UNC
-static LPTSTR translate( LPCTSTR path, TCHAR *buffer )
-{
-	TCHAR *l = host_drive_list;
-	const TCHAR *p = path;
-
-	while(*l) {
-		if(_totupper(p[1]) == _totupper(*l)) break;
-		l += _tcslen(l) + 1;
-	}
-
-	if(p[0] == TEXT('\\') && *l && (p[2] == 0 || p[2] == TEXT(':') || p[2] == TEXT('\\'))) {
-		p += 2;
-		if(*p == TEXT(':')) p++;
-		if(*p == TEXT('\\')) p++;
-		_sntprintf( buffer, MAX_PATH_LENGTH, TEXT("%c:\\%s"), *l, p );
+	if (x >= 0.0) {
+		t = ceilf(x);
+		if (t - x > 0.5)
+			t -= 1.0;
+		return (t);
 	} else {
-		if(*path == TEXT('\\')) {
-			_sntprintf( buffer, MAX_PATH_LENGTH, TEXT("%s%s"), virtual_root, path );
-		} else {
-			int len = _tcslen(path);
-			if(len == 0 || path[len-1] == TEXT('\\')) {
-				make_mask( buffer, virtual_root, path, tstr(my_computer).get() );
-			} else {
-				make_mask( buffer, virtual_root, path, 0 );
-			}
-		}
+		t = ceilf(-x);
+		if (t + x > 0.5)
+			t -= 1.0;
+		return (-t);
 	}
-	charset_mac2host( buffer );
-
-	return buffer;
 }
 
-// helpers
-static void strip_trailing_bs( LPTSTR path )
-{
-	size_t len = _tcslen(path);
-	if(len > 0 && path[len-1] == TEXT('\\')) path[len-1] = 0;
-}
-
-#if 0 /* defined is util_windows.cpp */
-static int exists( const char *p )
-{
-	WIN32_FIND_DATA fdata;
-
-	int result = 0;
-
-	HANDLE h = FindFirstFile( p, &fdata );
-	if(h != INVALID_HANDLE_VALUE) {
-		result = 1;
-		FindClose( h );
-	}
-
-	D(bug("exists(%s) = %d\n", p, result));
-
-	return result;
-}
 #endif
-
-static int is_dir( LPCTSTR p )
-{
-	WIN32_FIND_DATA fdata;
-
-	int result = 0;
-
-	HANDLE h = FindFirstFile( p, &fdata );
-	if(h != INVALID_HANDLE_VALUE) {
-		result = (fdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
-		FindClose( h );
-	}
-	return result;
-}
-
-static int myRemoveDirectory( LPCTSTR source )
-{
-	HANDLE fh;
-	WIN32_FIND_DATA FindFileData;
-	int ok, result = 1;
-	TCHAR mask[_MAX_PATH];
-
-	D(bug(TEXT("removing folder %s\n"), source));
-
-	make_mask( mask, source, TEXT("*.*"), 0 );
-
-	fh = FindFirstFile( mask, &FindFileData );
-	ok = fh != INVALID_HANDLE_VALUE;
-	while(ok) {
-		make_mask( mask, source, FindFileData.cFileName, 0 );
-		D(bug(TEXT("removing item %s\n"), mask));
-		int isdir = (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
-		if(isdir) {
-			// must delete ".finf", ".rsrc" but not ".", ".."
-			if(_tcscmp(FindFileData.cFileName,TEXT(".")) && _tcscmp(FindFileData.cFileName,TEXT(".."))) {
-				result = myRemoveDirectory( mask );
-				if(!result) break;
-			}
-		} else {
-			D(bug(TEXT("DeleteFile %s\n"), mask));
-			result = DeleteFile( mask );
-			if(!result) break;
-		}
-		ok = FindNextFile( fh, &FindFileData );
-	}
-	if(fh != INVALID_HANDLE_VALUE) FindClose( fh );
-	if(result) {
-		D(bug(TEXT("RemoveDirectory %s\n"), source));
-		result = RemoveDirectory( source );
-	}
-	return result;
-}
-
-static void make_folders( LPCTSTR path )
-{
-	TCHAR local_path[_MAX_PATH], *p;
-	_tcscpy( local_path, path );
-	p = _tcsrchr( local_path, TEXT('\\') );
-	if(p) {
-		*p = 0;
-		if(_tcslen(local_path) > 3) {
-			make_folders(local_path);
-			_tmkdir(local_path);
-		}
-	}
-}
-
-// !!UNC
-static bool is_same_drive( LPCTSTR p1, LPCTSTR p2 )
-{
-	return _totupper(*p1) == _totupper(*p2);
-}
-
-// Used when the drives are known to be different.
-// Can't use MoveFileEx() etc because of the Win9x limitations.
-// It would simulate CopyFile*() -- DeleteFile*() anyway
-static int file_move_copy( LPCTSTR src, LPCTSTR dst, bool delete_old )
-{
-	int result = 0;
-	my_errno = 0;
-
-	D(bug(TEXT("file_copy %s -> %s\n"), src, dst));
-
-	// Fail if exists -- it's up to MacOS to move things to Trash
-	if(CopyFile(src,dst,TRUE)) {
-		if(delete_old && !DeleteFile(src)) {
-			result = -1;
-			my_errno = EACCES;
-		}
-	} else {
-		result = -1;
-		if(exists(src))
-			my_errno = EACCES;
-		else
-			my_errno = ENOENT;
-	}
-	return result;
-}
-
-static int file_move( LPCTSTR src, LPCTSTR dst )
-{
-	return file_move_copy( src, dst, true );
-}
-
-static int file_copy( LPCTSTR src, LPCTSTR dst )
-{
-	return file_move_copy( src, dst, false );
-}
-
-static int folder_copy( LPCTSTR folder_src, LPCTSTR folder_dst )
-{
-	HANDLE fh;
-	WIN32_FIND_DATA FindFileData;
-	int ok, result = 0;
-	TCHAR mask[_MAX_PATH];
-
-	D(bug(TEXT("copying folder %s -> \n"), folder_src, folder_dst));
-
-	my_errno = 0;
-
-	if(!CreateDirectory( folder_dst, 0 )) {
-		my_errno = EACCES;
-		return -1;
-	}
-
-	make_mask( mask, folder_src, TEXT("*.*"), 0 );
-
-	fh = FindFirstFile( mask, &FindFileData );
-	ok = fh != INVALID_HANDLE_VALUE;
-	while(ok) {
-		make_mask( mask, folder_src, FindFileData.cFileName, 0 );
-		int isdir = (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
-		TCHAR target[_MAX_PATH];
-		make_mask( target, folder_dst, FindFileData.cFileName, 0 );
-		D(bug(TEXT("copying item %s -> %s\n"), mask, target));
-		if(isdir) {
-			if(_tcscmp(FindFileData.cFileName,TEXT(".")) && _tcscmp(FindFileData.cFileName,TEXT(".."))) {
-				result = folder_copy( mask, target );
-				if(result < 0) break;
-			}
-		} else {
-			result = file_copy( mask, target );
-			if(result < 0) break;
-		}
-		ok = FindNextFile( fh, &FindFileData );
-	}
-	if(fh != INVALID_HANDLE_VALUE) FindClose( fh );
-	return result;
-}
-
-// dir enumeration
-void closedir( struct DIR *d )
-{
-	DISABLE_ERRORS;
-	if(d) {
-		if(d->h != INVALID_HANDLE_VALUE && d->h != VIRTUAL_ROOT_ID) {
-			FindClose( d->h );
-		}
-		delete d;
-	}
-	RESTORE_ERRORS;
-}
-
-static int make_dentry( struct DIR *d )
-{
-	int ok = 0;
-
-	memset( &d->de, 0, sizeof(d->de) );
-	if(d->h != INVALID_HANDLE_VALUE) {
-		if( (d->FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 &&
-			   *d->FindFileData.cFileName == TEXT('.'))
-		{
-			ok = 0;
-		} else {
-			strlcpy( d->de.d_name, d->FindFileData.cFileName, lengthof(d->de.d_name) );
-			charset_host2mac( d->de.d_name );
-			ok = 1;
-		}
-	}
-	return ok;
-}
-
-struct dirent *readdir( struct DIR *d )
-{
-	DISABLE_ERRORS;
-
-	dirent *de = 0;
-
-	if(d) {
-		if(d->h != INVALID_HANDLE_VALUE) {
-			if(d->h == VIRTUAL_ROOT_ID) {
-				make_dentry(d);
-				de = &d->de;
-				d->vname_list += _tcslen(d->vname_list) + 1;
-				if(*d->vname_list) {
-					_tcscpy( d->FindFileData.cFileName, d->vname_list );
-					d->FindFileData.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
-				} else {
-					// Out of static drive entries. Continue with other stuff.
-					TCHAR mask[MAX_PATH_LENGTH];
-					make_mask( mask, virtual_root, TEXT("*.*"), 0 );
-					d->h = FindFirstFile( mask, &d->FindFileData );
-				}
-			} else {
-				int done = 0;
-				do {
-					if(make_dentry(d)) {
-						de = &d->de;
-						done = 1;
-					}
-					if(!FindNextFile( d->h, &d->FindFileData )) {
-						FindClose( d->h );
-						d->h = INVALID_HANDLE_VALUE;
-						done = 1;
-					}
-				} while(!done);
-			}
-		}
-	}
-
-	if(de) {
-		D(bug("readdir found %s\n", de->d_name));
-	}
-
-	RESTORE_ERRORS;
-
-	return de;
-}
-
-struct DIR *opendir( const char *path )
-{
-	DISABLE_ERRORS;
-	auto tpath = tstr(path);
-	DIR *d = new DIR;
-	if(d) {
-		memset( d, 0, sizeof(DIR) );
-		if(*tpath.get() == 0) {
-			d->vname_list = host_drive_list;
-			if(d->vname_list) {
-				d->h = VIRTUAL_ROOT_ID;
-				_tcscpy( d->FindFileData.cFileName, d->vname_list );
-				d->FindFileData.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
-			} else {
-				d->h = INVALID_HANDLE_VALUE;
-			}
-		} else {
-			TCHAR mask[MAX_PATH_LENGTH];
-			make_mask( mask, MRP(tpath.get()), TEXT("*.*"), 0 );
-
-			D(bug(TEXT("opendir path=%s, mask=%s\n"), tpath.get(), mask));
-
-			d->h = FindFirstFile( mask, &d->FindFileData );
-			if(d->h == INVALID_HANDLE_VALUE) {
-				delete d;
-				d = 0;
-			}
-		}
-	}
-
-	D(bug(TEXT("opendir(%s,%s) = %08x\n"), tpath.get(), MRP(tpath.get()), d));
-
-	RESTORE_ERRORS;
-
-	return d;
-}
-
-static void dump_stat( const struct my_stat *st )
-{
-	D(bug("stat: size = %ld, mode = %ld, a = %ld, m = %ld, c = %ld\n", st->st_size, st->st_mode, st->st_atime, st->st_mtime, st->st_ctime));
-}
-
-
-
-// Exported hook functions
-int my_stat( const char *path, struct my_stat *st )
-{
-	DISABLE_ERRORS;
-
-	auto tpath = tstr(path);
-	int result;
-
-	if(*tpath.get() == 0) {
-		/// virtual root
-		memset( st, 0, sizeof(struct my_stat) );
-		st->st_mode = _S_IFDIR;
-		result = 0;
-		my_errno = 0;
-	} else {
-		result = _tstat( MRP(tpath.get()), (struct _stat *)st );
-		if(result < 0) {
-			my_errno = errno;
-		} else {
-			my_errno = 0;
-		}
-	}
-
-	D(bug(TEXT("stat(%s,%s) = %d\n"), tpath.get(), MRP(tpath.get()), result));
-	if(result >= 0) dump_stat( st );
-	RESTORE_ERRORS;
-	return result;
-}
-
-int my_fstat( int fd, struct my_stat *st )
-{
-	DISABLE_ERRORS;
-	int result = _fstat( fd, (struct _stat *)st );
-	if(result < 0) {
-		my_errno = errno;
-	} else {
-		my_errno = 0;
-	}
-	D(bug("fstat(%d) = %d\n", fd, result));
-	if(result >= 0) dump_stat( st );
-	RESTORE_ERRORS;
-	return result;
-}
-
-int my_open( const char *path, int mode, ... )
-{
-	DISABLE_ERRORS;
-	int result;
-	auto tpath = tstr(path);
-	LPCTSTR p = MRP(tpath.get());
-
-	// Windows "open" does not handle _O_CREAT and _O_BINARY as it should
-	if(mode & _O_CREAT) {
-		if(exists(p)) {
-			result = _topen( p, mode & ~_O_CREAT );
-			D(bug(TEXT("open-nocreat(%s,%s,%d) = %d\n"), tpath.get(), p, mode, result));
-		} else {
-			result = _tcreat( p, _S_IWRITE|_S_IREAD );
-			if(result < 0) {
-				make_folders(p);
-				result = _tcreat( p, _S_IWRITE|_S_IREAD );
-			}
-			D(bug(TEXT("open-creat(%s,%s,%d) = %d\n"), tpath.get(), p, mode, result));
-		}
-	} else {
-		result = _topen( p, mode );
-		D(bug(TEXT("open(%s,%s,%d) = %d\n"), tpath.get(), p, mode, result));
-	}
-	if(result < 0) {
-		my_errno = errno;
-	} else {
-		setmode(result, _O_BINARY);
-		my_errno = 0;
-	}
-	RESTORE_ERRORS;
-	return result;
-}
-
-int my_rename( const char *old_path, const char *new_path )
-{
-	DISABLE_ERRORS;
-	int result = -1;
-	auto told_path = tstr(old_path);
-	auto tnew_path = tstr(new_path);
-	LPCTSTR p_old = MRP(told_path.get());
-	LPCTSTR p_new = MRP2(tnew_path.get());
-
-	result = my_access(old_path,0);
-	if(result < 0) {
-		// my_errno already set
-	} else {
-		if(is_same_drive(p_old,p_new)) {
-			result = _trename( p_old, p_new );
-			if(result != 0) { // by definition, rename may also return a positive value to indicate an error
-				my_errno = errno;
-			} else {
-				my_errno = 0;
-			}
-		} else {
-			if(is_dir(p_old)) {
-				result = folder_copy( p_old, p_new );
-				// my_errno already set
-				if(result >= 0) {
-					if(myRemoveDirectory( p_old )) {
-						my_errno = 0;
-						result = 0;
-					} else {
-						// there is no proper error code for this failure.
-						my_errno = EACCES;
-						result = -1;
-					}
-				}
-			} else {
-				result = file_move( p_old, p_new );
-				// my_errno already set
-			}
-		}
-	}
-	D(bug(TEXT("rename(%s,%s,%s,%s) = %d\n"), told_path.get(), p_old, tnew_path.get(), p_new, result));
-	RESTORE_ERRORS;
-	return result;
-}
-
-int my_access( const char *path, int mode )
-{
-	DISABLE_ERRORS;
-	auto tpath = tstr(path);
-	LPCTSTR p = MRP(tpath.get());
-	WIN32_FIND_DATA fdata;
-
-	int result;
-
-	if(is_dir(p)) {
-		// access does not work for folders.
-		HANDLE h = FindFirstFile( p, &fdata );
-		if(h != INVALID_HANDLE_VALUE) {
-			FindClose( h );
-			if(mode == W_OK) {
-				if( (fdata.dwFileAttributes & FILE_ATTRIBUTE_READONLY) == 0 ) {
-					result = 0;
-					my_errno = 0;
-				} else {
-					result = -1;
-					my_errno = EACCES;
-				}
-			} else {
-				result = 0;
-				my_errno = 0;
-			}
-		} else {
-			result = -1;
-			my_errno = ENOENT;
-		}
-	} else {
-		// W_OK, F_OK are ok.
-		result = _taccess(p,mode);
-		if(result < 0) {
-			my_errno = errno;
-		} else {
-			my_errno = 0;
-		}
-	}
-
-	D(bug(TEXT("access(%s,%s,%d) = %d\n"), tpath.get(), p, mode, result));
-	RESTORE_ERRORS;
-	return result;
-}
-
-int my_mkdir( const char *path, int mode )
-{
-	DISABLE_ERRORS;
-	auto tpath = tstr(path);
-	LPTSTR p = MRP(tpath.get());
-	strip_trailing_bs(p);
-	int result = _tmkdir( p );
-	if(result < 0) {
-		make_folders(p);
-		result = _tmkdir( p );
-	}
-	if(result < 0) {
-		my_errno = errno;
-	} else {
-		my_errno = 0;
-	}
-	D(bug(TEXT("mkdir(%s,%s,%d) = %d\n"), tpath.get(), p, mode, result));
-	RESTORE_ERRORS;
-	return result;
-}
-
-int my_remove( const char *path )
-{
-	DISABLE_ERRORS;
-	auto tpath = tstr(path);
-	LPTSTR p = MRP(tpath.get());
-	strip_trailing_bs(p);
-	int result;
-	if(is_dir(p)) {
-		result = myRemoveDirectory( p );
-	} else {
-		D(bug(TEXT("DeleteFile %s\n"), p));
-		result = DeleteFile( p );
-	}
-	if(result) {
-		result = 0;
-		my_errno = 0;
-	} else {
-		result = -1;
-		if(exists(p)) {
-			my_errno = EACCES;
-		} else {
-			my_errno = ENOENT;
-		}
-	}
-	D(bug(TEXT("remove(%s,%s) = %d\n"), tpath.get(), p, result));
-	RESTORE_ERRORS;
-	return result;
-}
-
-int my_creat( const char *path, int mode )
-{
-	DISABLE_ERRORS;
-	auto tpath = tstr(path);
-	LPCTSTR p = MRP(tpath.get());
-	int result = _tcreat( p, _S_IWRITE|_S_IREAD ); // note mode
-	if(result < 0) {
-		make_folders(p);
-		result = _tcreat( p, _S_IWRITE|_S_IREAD ); // note mode
-	}
-	if(result < 0) {
-		my_errno = errno;
-	} else {
-		setmode(result, _O_BINARY);
-		my_errno = 0;
-	}
-	D(bug(TEXT("creat(%s,%s,%d) = %d\n"), tpath.get(), p, mode,result));
-	RESTORE_ERRORS;
-	return result;
-}
-
-int my_chsize( int fd, size_t sz )
-{
-	DISABLE_ERRORS;
-	int result = chsize(fd,sz);
-	if(result < 0) {
-		my_errno = errno;
-	} else {
-		my_errno = 0;
-	}
-	RESTORE_ERRORS;
-	return result;
-}
-
-int my_close( int fd )
-{
-	DISABLE_ERRORS;
-	int result = close(fd);
-	if(result < 0) {
-		my_errno = errno;
-	} else {
-		my_errno = 0;
-	}
-	RESTORE_ERRORS;
-	D(bug("close(%d) = %d\n", fd, result));
-	return result;
-}
-
-long my_lseek( int fd, long offset, int origin )
-{
-	DISABLE_ERRORS;
-	int result = lseek( fd, offset, origin );
-	if(result < 0) {
-		my_errno = errno;
-	} else {
-		my_errno = 0;
-	}
-	RESTORE_ERRORS;
-	return result;
-}
-
-int my_read( int fd, void *buffer, unsigned int count )
-{
-	DISABLE_ERRORS;
-	int result = read( fd, buffer, count );
-	if(result < 0) {
-		my_errno = errno;
-	} else {
-		my_errno = 0;
-	}
-	RESTORE_ERRORS;
-	D(bug("read(%ld,%08x,%ld) = %d\n", fd, buffer, count, result));
-
-	return result;
-}
-
-int my_write( int fd, const void *buffer, unsigned int count )
-{
-	DISABLE_ERRORS;
-	int result = write( fd, buffer, count );
-	if(result < 0) {
-		my_errno = errno;
-	} else {
-		my_errno = 0;
-	}
-	RESTORE_ERRORS;
-	D(bug("write(%ld,%08x,%ld) = %d\n", fd, buffer, count, result));
-	return result;
-}
-
-static FILETIME get_file_time(time_t time) {
-	FILETIME ft;
-	unsigned long long result = 11644473600LL;
-	result += time;
-	result *= 10000000LL;
-	ft.dwHighDateTime = (result >> 32);
-	ft.dwLowDateTime = (result & 0xFFFFFFFF);
-	return ft;
-}
-
-int my_utime( const char *path, struct my_utimbuf * my_times )
-{
-	auto tpath = tstr(path);
-	LPCTSTR p = MRP(tpath.get());
-	HANDLE f = CreateFile(p, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
-	if (f != INVALID_HANDLE_VALUE) {
-		FILETIME crTime = get_file_time(my_times->actime);
-		FILETIME modTime = get_file_time(my_times->modtime);
-		SetFileTime(f, &crTime, NULL, &modTime);
-		CloseHandle(f);
-		return 0;
-	}
-	return -1;
-}
--- macemu/SheepShaver/src/Windows/posix_emu.h
+++ sheepshaver/SheepShaver/src/Windows/posix_emu.h
@@ -1,130 +1,122 @@
-/*
- *  posix_emu.h
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <fcntl.h>
-#include <errno.h>
-#include <io.h>
-#include <direct.h>
-#include <sys/stat.h>
-
-#include "extfs.h"
-
-void init_posix_emu(void);
-void final_posix_emu(void);
-
-typedef struct dirent {
-	char d_name[MAX_PATH_LENGTH];
-} dirent;
-
-typedef struct DIR {
-	HANDLE h;
-	WIN32_FIND_DATA FindFileData;
-	dirent de;
-	TCHAR *vname_list;
-} DIR;
-
-// emulated
-DIR *opendir( const char *path );
-void closedir( DIR *d );
-struct dirent *readdir( DIR *d );
-
-// access() mode: exists?
-#ifndef F_OK
-#define F_OK 0
-#endif
-// access() mode: can do r/w?
-#ifndef W_OK
-#define W_OK 6
-#endif
-
-// hook stat functions to create virtual desktop
-// because of errno all used funcs must be hooked.
-int my_stat( const char *, struct my_stat * );
-int my_fstat( int, struct my_stat * );
-int my_open( const char *, int, ... );
-int my_rename( const char *, const char * );
-int my_access( const char *, int );
-int my_mkdir( const char *path, int mode );
-int my_remove( const char * );
-int my_creat( const char *path, int mode );
-int my_creat( const char *path, int mode );
-int my_close( int fd );
-long my_lseek( int fd, long, int);
-int my_read( int fd, void *, unsigned int);
-int my_write( int fd, const void *, unsigned int);
-int my_chsize( int fd, unsigned int size );
-int my_locking( int fd, int mode, long nbytes );
-int my_utime( const char *path, struct my_utimbuf * );
-
-extern int my_errno;
-
-// must hook all other functions that manipulate file names
-#ifndef NO_POSIX_API_HOOK
-#define stat my_stat
-#define fstat my_fstat
-#define open my_open
-#define rename my_rename
-#define access my_access
-#define mkdir my_mkdir
-#define remove my_remove
-#define creat my_creat
-#define close my_close
-#define lseek my_lseek
-#define read my_read
-#define write my_write
-#define ftruncate my_chsize
-#define locking my_locking
-#define utime my_utime
-
-#undef errno
-#define errno my_errno
-#endif //!NO_POSIX_API_HOOK
-
-#ifndef S_ISDIR
-#define S_ISDIR(stat_mode) (((stat_mode) & _S_IFDIR) != 0)
-#endif
-
-// can't #define "stat" unless there's a replacement for "struct stat"
-struct my_stat {
-  _dev_t st_dev;
-  _ino_t st_ino;
-  unsigned short st_mode;
-  short st_nlink;
-  short st_uid;
-  short st_gid;
-  _dev_t st_rdev;
-  _off_t st_size;
-  time_t st_atime;
-  time_t st_mtime;
-  time_t st_ctime;
-};
-
-struct my_utimbuf
-{
-	time_t actime;      // access time
-	time_t modtime;     // modification time
-};
-
-// Your compiler may have different "struct stat" -> edit "struct my_stat"
-#define validate_stat_struct ( sizeof(struct my_stat) == sizeof(struct stat) )
-
-#define st_crtime st_ctime
+/*
+ *  posix_emu.h
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <fcntl.h>
+#include <errno.h>
+#include <io.h>
+#include <direct.h>
+#include <sys/stat.h>
+
+#include "extfs.h"
+
+void init_posix_emu(void);
+void final_posix_emu(void);
+
+typedef struct dirent {
+	char d_name[MAX_PATH_LENGTH];
+} dirent;
+
+typedef struct DIR {
+	HANDLE h;
+	WIN32_FIND_DATA FindFileData;
+	dirent de;
+	char *vname_list;
+} DIR;
+
+// emulated
+DIR *opendir( const char *path );
+void closedir( DIR *d );
+struct dirent *readdir( DIR *d );
+
+// access() mode: exists?
+#ifndef F_OK
+#define F_OK 0
+#endif
+// access() mode: can do r/w?
+#ifndef W_OK
+#define W_OK 6
+#endif
+
+// hook stat functions to create virtual desktop
+// because of errno all used funcs must be hooked.
+int my_stat( const char *, struct my_stat * );
+int my_fstat( int, struct my_stat * );
+int my_open( const char *, int, ... );
+int my_rename( const char *, const char * );
+int my_access( const char *, int );
+int my_mkdir( const char *path, int mode );
+int my_remove( const char * );
+int my_creat( const char *path, int mode );
+int my_creat( const char *path, int mode );
+int my_close( int fd );
+long my_lseek( int fd, long, int);
+int my_read( int fd, void *, unsigned int);
+int my_write( int fd, const void *, unsigned int);
+int my_chsize( int fd, unsigned int size );
+int my_locking( int fd, int mode, long nbytes );
+
+extern int my_errno;
+
+// must hook all other functions that manipulate file names
+#ifndef NO_POSIX_API_HOOK
+#define stat my_stat
+#define fstat my_fstat
+#define open my_open
+#define rename my_rename
+#define access my_access
+#define mkdir my_mkdir
+#define remove my_remove
+#define creat my_creat
+#define close my_close
+#define lseek my_lseek
+#define read my_read
+#define write my_write
+#define ftruncate my_chsize
+#define locking my_locking
+
+#undef errno
+#define errno my_errno
+#endif //!NO_POSIX_API_HOOK
+
+#ifndef S_ISDIR
+#define S_ISDIR(stat_mode) (((stat_mode) & _S_IFDIR) != 0)
+#endif
+
+// can't #define "stat" unless there's a replacement for "struct stat"
+struct my_stat {
+  _dev_t st_dev;
+  _ino_t st_ino;
+  unsigned short st_mode;
+  short st_nlink;
+  short st_uid;
+  short st_gid;
+  _dev_t st_rdev;
+  _off_t st_size;
+  time_t st_atime;
+  time_t st_mtime;
+  time_t st_ctime;
+};
+
+// Your compiler may have different "struct stat" -> edit "struct my_stat"
+#define validate_stat_struct ( sizeof(struct my_stat) == sizeof(struct stat) )
+
+#define st_crtime st_ctime
--- macemu/SheepShaver/src/Windows/prefs_editor_gtk.cpp
+++ sheepshaver/SheepShaver/src/Windows/prefs_editor_gtk.cpp
@@ -217,14 +217,14 @@
 	label = gtk_label_new(GetString(label_id));
 	gtk_widget_show(label);
 	gtk_table_attach(GTK_TABLE(table), label, 0, 1, row, row + 1, (GtkAttachOptions)0, (GtkAttachOptions)0, 4, 4);
-
+	
 	combo = gtk_combo_new();
 	gtk_widget_show(combo);
 	gtk_combo_set_popdown_strings(GTK_COMBO(combo), glist);
 
 	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), default_value);
 	gtk_table_attach(GTK_TABLE(table), combo, 1, 2, row, row + 1, (GtkAttachOptions)(GTK_FILL | GTK_EXPAND), (GtkAttachOptions)0, 4, 4);
-
+	
 	return combo;
 }
 
@@ -256,7 +256,7 @@
 	gtk_table_attach(GTK_TABLE(table), box, 1, 2, row, row + 1, (GtkAttachOptions)(GTK_FILL | GTK_EXPAND), (GtkAttachOptions)0, 4, 4);
 
 	entry = gtk_entry_new();
-	gtk_entry_set_text(GTK_ENTRY(entry), str);
+	gtk_entry_set_text(GTK_ENTRY(entry), str); 
 	gtk_widget_show(entry);
 	gtk_box_pack_start(GTK_BOX(box), entry, TRUE, TRUE, 0);
 
@@ -310,7 +310,7 @@
 		str = "";
 
 	entry = gtk_entry_new();
-	gtk_entry_set_text(GTK_ENTRY(entry), str);
+	gtk_entry_set_text(GTK_ENTRY(entry), str); 
 	gtk_widget_show(entry);
 	gtk_box_pack_start(GTK_BOX(box), entry, TRUE, TRUE, 0);
 	return entry;
@@ -342,14 +342,14 @@
 	label = gtk_label_new(GetString(label_id));
 	gtk_widget_show(label);
 	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 0);
-
+	
 	combo = gtk_combo_new();
 	gtk_widget_show(combo);
 	gtk_combo_set_popdown_strings(GTK_COMBO(combo), glist);
-
+	
 	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), default_value);
 	gtk_box_pack_start(GTK_BOX(box), combo, TRUE, TRUE, 0);
-
+	
 	return combo;
 }
 
@@ -364,7 +364,7 @@
 	return make_combobox(top, label_id, default_value, glist);
 }
 
-
+ 
 /*
  *  Show preferences editor
  *  Returns true when user clicked on "Start", false otherwise
@@ -558,30 +558,6 @@
 	selected_volume = row;
 }
 
-// Something dropped on volume list
-static void drag_data_received(GtkWidget *list, GdkDragContext *drag_context, gint x, gint y, GtkSelectionData *data, 
-	guint info, guint time, gpointer user_data)
-{
-	// reordering drags have already been handled by clist
-	if (data->type == gdk_atom_intern("gtk-clist-drag-reorder", true)) {
-		return;
-	}
-
-	// get URIs from the drag selection data and add them
-	gchar ** uris = g_strsplit((gchar *)(data->data), "\r\n", -1);
-	for (gchar ** uri = uris; *uri != NULL; uri++) {
-		if (strlen(*uri) < 7) continue;
-		if (strncmp("file://", *uri, 7) != 0) continue;
-
-		gchar * filename = g_filename_from_uri(*uri, NULL, NULL);
-		if (filename) {
-			gtk_clist_append(GTK_CLIST(volume_list), &filename);
-			g_free(filename);
-		}
-	}
-	g_strfreev(uris);
-}
-
 // Volume selected for addition
 static void add_volume_ok(GtkWidget *button, file_req_assoc *assoc)
 {
@@ -725,12 +701,6 @@
 	gtk_clist_set_shadow_type(GTK_CLIST(volume_list), GTK_SHADOW_NONE);
 	gtk_clist_set_reorderable(GTK_CLIST(volume_list), true);
 	gtk_signal_connect(GTK_OBJECT(volume_list), "select_row", GTK_SIGNAL_FUNC(cl_selected), NULL);
-
-	// also support volume files dragged onto the list from outside
-	gtk_drag_dest_add_uri_targets(volume_list);
-	// add a drop handler to get dropped files; don't supersede the drop handler for reordering
-	gtk_signal_connect_after(GTK_OBJECT(volume_list), "drag_data_received", GTK_SIGNAL_FUNC(drag_data_received), NULL);
-
 	char *str;
 	int32 index = 0;
 	while ((str = const_cast<char *>(PrefsFindString("disk", index++))) != NULL)
@@ -861,13 +831,13 @@
 #if USE_JIT
 	GtkWidget *box, *table, *label, *menu;
 	char str[32];
-
+	
 	box = make_pane(top, STR_JIT_PANE_TITLE);
 	make_checkbox(box, STR_JIT_CTRL, "jit", GTK_SIGNAL_FUNC(tb_jit));
-
+	
 #ifndef SHEEPSHAVER
 	w_jit_fpu = make_checkbox(box, STR_JIT_FPU_CTRL, "jitfpu", GTK_SIGNAL_FUNC(tb_jit_fpu));
-
+	
 	// Translation cache size
 	static const combo_desc options[] = {
 		STR_JIT_CACHE_SIZE_2MB_LAB,
@@ -878,7 +848,7 @@
 	};
 	sprintf(str, "%d", PrefsFindInt32("jitcachesize"));
 	w_jit_cache_size = make_combobox(box, STR_JIT_CACHE_SIZE_CTRL, str, options);
-
+	
 	// Lazy translation cache invalidation
 	w_jit_lazy_flush = make_checkbox(box, STR_JIT_LAZY_CINV_CTRL, "jitlazyflush", GTK_SIGNAL_FUNC(tb_jit_lazy_flush));
 
@@ -887,11 +857,11 @@
 #endif
 
 	set_jit_sensitive();
-#endif
 
 #ifdef SHEEPSHAVER
 	make_checkbox(box, STR_JIT_68K_CTRL, "jit68k", GTK_SIGNAL_FUNC(tb_jit_68k));
 #endif
+#endif
 }
 
 /*
@@ -1131,7 +1101,7 @@
 		sprintf(str, "%d", dis_width);
 	else
 		strcpy(str, GetString(STR_SIZE_MAX_LAB));
-	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str);
+	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str); 
 	gtk_table_attach(GTK_TABLE(table), combo, 1, 2, 2, 3, (GtkAttachOptions)GTK_FILL, (GtkAttachOptions)0, 4, 4);
 	w_display_x = GTK_COMBO(combo)->entry;
 
@@ -1152,7 +1122,7 @@
 		sprintf(str, "%d", dis_height);
 	else
 		strcpy(str, GetString(STR_SIZE_MAX_LAB));
-	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str);
+	gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), str); 
 	gtk_table_attach(GTK_TABLE(table), combo, 1, 2, 3, 4, (GtkAttachOptions)GTK_FILL, (GtkAttachOptions)0, 4, 4);
 	w_display_y = GTK_COMBO(combo)->entry;
 
@@ -1231,7 +1201,7 @@
 		str = "";
 
 	w_keycode_file = gtk_entry_new();
-	gtk_entry_set_text(GTK_ENTRY(w_keycode_file), str);
+	gtk_entry_set_text(GTK_ENTRY(w_keycode_file), str); 
 	gtk_widget_show(w_keycode_file);
 	gtk_box_pack_start(GTK_BOX(hbox), w_keycode_file, TRUE, TRUE, 0);
 
--- macemu/SheepShaver/src/Windows/router/arp.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/arp.cpp
@@ -1,96 +1,95 @@
-/*
- *  arp.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "main.h"
-#include "cpu_emulation.h"
-#include "prefs.h"
-#include "ether_windows.h"
-#include "ether.h"
-#include "router.h"
-#include "router_types.h"
-#include "iphelp.h"
-#include "arp.h"
-#include "icmp.h"
-#include "dump.h"
-
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-
-// ARP queries can be replied immediately.
-
-bool write_arp( arp_t *req, int len )
-{
-  D(bug("write_arp() len=%d, htype=%d, ptype=%04x, opcode=%d, halen=%d, palen=%d\r\n",len, ntohs(req->htype), ntohs(req->ptype), ntohs(req->opcode), req->halen, req->palen));
-
-	start_icmp_listen();
-
-	bool result = false;
-
-	if( len >= sizeof(arp_t) &&
-			req->htype == htons(arp_hwtype_enet) &&
-			req->ptype == htons(mac_type_ip4) &&
-			req->opcode == htons(arp_request) &&
-			req->halen == 6 &&
-			req->palen == 4
-	)
-	{
-		if(memcmp( req->srcp, req->dstp, 4 ) == 0) {
-			// No reply. MacOS is making sure that there are no duplicate ip addresses.
-			// Update localhost (==Mac) ip address (needed by incoming icmp)
-			macos_ip_address = ntohl( *((uint32 *)&req->srcp[0]) );
-			D(bug("Mac ip: %02x %02x %02x %02x\r\n", req->srcp[0], req->srcp[1], req->srcp[2], req->srcp[3]));
-		} else {
-			arp_t arp;
-
-			D(bug("Source NIC: %02x %02x %02x %02x\r\n", req->srcp[0], req->srcp[1], req->srcp[2], req->srcp[3]));
-			D(bug("Dest   NIC: %02x %02x %02x %02x\r\n", req->dstp[0], req->dstp[1], req->dstp[2], req->dstp[3]));
-
-			// memcpy( arp.mac.dest, req->mac.src, 6 );
-			memcpy( arp.mac.dest, ether_addr, 6 );
-			memcpy( arp.mac.src, router_mac_addr, 6 );
-			arp.mac.type = htons(mac_type_arp);
-			arp.htype = htons(arp_hwtype_enet);
-			arp.ptype = htons(mac_type_ip4);
-			arp.halen = 6;
-			arp.palen = 4;
-			arp.opcode = htons(arp_reply);
-			memcpy( arp.srch, router_mac_addr, 6 );
-			memcpy( arp.srcp, req->dstp, 4 );
-			// memcpy( arp.dsth, req->srch, 6 );
-			memcpy( arp.dsth, ether_addr, 6 );
-			memcpy( arp.dstp, req->srcp, 4 );
-
-			// Update here, too, just in case.
-			macos_ip_address = ntohl( *((uint32 *)&req->srcp[0]) );
-
-			enqueue_packet( (uint8 *)&arp, sizeof(arp) );
-		}
-		result = true;
-	}
-	return result;
-}
+/*
+ *  arp.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include "cpu_emulation.h"
+#include "prefs.h"
+#include "ether_windows.h"
+#include "ether.h"
+#include "router.h"
+#include "router_types.h"
+#include "iphelp.h"
+#include "arp.h"
+#include "icmp.h"
+#include "dump.h"
+
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+
+// ARP queries can be replied immediately.
+
+bool write_arp( arp_t *req, int len )
+{
+  D(bug("write_arp() len=%d, htype=%d, ptype=%04x, opcode=%d, halen=%d, palen=%d\r\n",len, ntohs(req->htype), ntohs(req->ptype), ntohs(req->opcode), req->halen, req->palen));
+
+	start_icmp_listen();
+
+	bool result = false;
+
+	if( len >= sizeof(arp_t) &&
+			req->htype == htons(arp_hwtype_enet) &&
+			req->ptype == htons(mac_type_ip4) &&
+			req->opcode == htons(arp_request) &&	
+			req->halen == 6 &&
+			req->palen == 4
+	)
+	{
+		if(memcmp( req->srcp, req->dstp, 4 ) == 0) {
+			// No reply. MacOS is making sure that there are no duplicate ip addresses.
+			// Update localhost (==Mac) ip address (needed by incoming icmp)
+			macos_ip_address = ntohl( *((uint32 *)&req->srcp[0]) );
+			D(bug("Mac ip: %02x %02x %02x %02x\r\n", req->srcp[0], req->srcp[1], req->srcp[2], req->srcp[3]));
+		} else {
+			arp_t arp;
+
+			D(bug("Source NIC: %02x %02x %02x %02x\r\n", req->srcp[0], req->srcp[1], req->srcp[2], req->srcp[3]));
+			D(bug("Dest   NIC: %02x %02x %02x %02x\r\n", req->dstp[0], req->dstp[1], req->dstp[2], req->dstp[3]));
+
+			// memcpy( arp.mac.dest, req->mac.src, 6 );
+			memcpy( arp.mac.dest, ether_addr, 6 );
+			memcpy( arp.mac.src, router_mac_addr, 6 );
+			arp.mac.type = htons(mac_type_arp);
+			arp.htype = htons(arp_hwtype_enet);
+			arp.ptype = htons(mac_type_ip4);
+			arp.halen = 6;
+			arp.palen = 4;
+			arp.opcode = htons(arp_reply);
+			memcpy( arp.srch, router_mac_addr, 6 );
+			memcpy( arp.srcp, req->dstp, 4 );
+			// memcpy( arp.dsth, req->srch, 6 );
+			memcpy( arp.dsth, ether_addr, 6 );
+			memcpy( arp.dstp, req->srcp, 4 );
+
+			// Update here, too, just in case.
+			macos_ip_address = ntohl( *((uint32 *)&req->srcp[0]) );
+
+			enqueue_packet( (uint8 *)&arp, sizeof(arp) );
+		}
+		result = true;
+	}
+	return result;
+}
--- macemu/SheepShaver/src/Windows/router/arp.h
+++ sheepshaver/SheepShaver/src/Windows/router/arp.h
@@ -1,28 +1,28 @@
-/*
- *  arp.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _ARP_H_
-#define _ARP_H_
-
-bool write_arp( arp_t *req, int len );
-
-#endif // _ARP_H_
+/*
+ *  arp.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _ARP_H_
+#define _ARP_H_
+
+bool write_arp( arp_t *req, int len );
+
+#endif // _ARP_H_
--- macemu/SheepShaver/src/Windows/router/dump.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/dump.cpp
@@ -1,50 +1,49 @@
-/*
- *  dump.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "main.h"
-#include "dump.h"
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-
-void dump_bytes( uint8 *packet, int length )
-{
-#if DEBUG
-	char buf[1000], sm[10];
-
-	*buf = 0;
-
-	if(length > 256) length = 256;
-
-  for (int i=0; i<length; i++) {
-    sprintf(sm,"%02x", (int)packet[i]);
-		strcat( buf, sm );
-  }
-	strcat( buf, "\r\n" );
-  bug(buf);
-#endif
-}
+/*
+ *  dump.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include "dump.h"
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+
+void dump_bytes( uint8 *packet, int length )
+{
+#if DEBUG
+	char buf[1000], sm[10];
+
+	*buf = 0;
+
+	if(length > 256) length = 256;
+
+  for (int i=0; i<length; i++) {
+    sprintf(sm,"%02x", (int)packet[i]);
+		strcat( buf, sm );
+  }
+	strcat( buf, "\r\n" );
+  bug(buf);
+#endif
+}
--- macemu/SheepShaver/src/Windows/router/dump.h
+++ sheepshaver/SheepShaver/src/Windows/router/dump.h
@@ -1,30 +1,30 @@
-/*
- *  dump.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _DUMP_H_
-#define _DUMP_H_
-
-#define DEBUG 0
-
-void dump_bytes( uint8 *packet, int length );
-
-#endif // _DUMP_H_
+/*
+ *  dump.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _DUMP_H_
+#define _DUMP_H_
+
+#define DEBUG 0
+
+void dump_bytes( uint8 *packet, int length );
+
+#endif // _DUMP_H_
--- macemu/SheepShaver/src/Windows/router/dynsockets.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/dynsockets.cpp
@@ -1,185 +1,184 @@
-/*
- *  dynsockets.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "main.h"
-#include "dynsockets.h"
-#include "dump.h"
-#include "main.h"
-
-
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-
-#include "debug.h"
-
-
-/*
-	Cannot link statically to winsock. We need ws2, but there are
-	Win95 b2 users who can't (or won't) upgrade.
-*/
-
-static LPCTSTR wslib = TEXT("WS2_32.DLL");
-
-static HMODULE hWinsock32 = 0;
-static WSADATA WSAData;
-
-int (WSAAPI *_WSAStartup) (WORD, LPWSADATA) = 0;
-int (WSAAPI *_WSACleanup) (void) = 0;
-int (WSAAPI *_gethostname) (char *, int) = 0;
-char * (WSAAPI *_inet_ntoa) (struct in_addr) = 0;
-struct hostent * (WSAAPI *_gethostbyname) (const char *) = 0;
-int (WSAAPI *_send) (SOCKET, const char *, int, int) = 0;
-int (WSAAPI *_sendto) (SOCKET, const char *, int, int, const struct sockaddr *, int) = 0;
-int (WSAAPI *_recv) (SOCKET, char *, int, int) = 0;
-int (WSAAPI *_recvfrom) (SOCKET, char *, int, int, struct sockaddr *, int *) = 0;
-int (WSAAPI *_listen) (SOCKET, int) = 0;
-SOCKET (WSAAPI *_accept) (SOCKET, struct sockaddr *, int *) = 0;
-SOCKET (WSAAPI *_socket) (int, int, int) = 0;
-int (WSAAPI *_bind) (SOCKET, const struct sockaddr *, int) = 0;
-int (WSAAPI *_WSAAsyncSelect) (SOCKET, HWND, u_int, long) = 0;
-int (WSAAPI *_closesocket) (SOCKET) = 0;
-int (WSAAPI *_getsockname) (SOCKET, struct sockaddr *, int *) = 0;
-int (WSAAPI *_WSARecvFrom) (SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, struct sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) = 0;
-int (WSAAPI *_WSAGetLastError) (void) = 0;
-int (WSAAPI *_WSAConnect) (SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS) = 0;
-int (WSAAPI *_setsockopt) (SOCKET, int, int, const char *, int) = 0;
-int (WSAAPI *_WSAEventSelect) (SOCKET, WSAEVENT, long) = 0;
-WSAEVENT (WSAAPI *_WSACreateEvent) (void) = 0;
-BOOL (WSAAPI *_WSACloseEvent) (WSAEVENT) = 0;
-BOOL (WSAAPI *_WSAResetEvent) (WSAEVENT) = 0;
-int (WSAAPI *_WSAEnumNetworkEvents) (SOCKET, WSAEVENT, LPWSANETWORKEVENTS) = 0;
-int (WSAAPI *_shutdown) (SOCKET, int) = 0;
-int (WSAAPI *_WSASend) (SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) = 0;
-int (WSAAPI *_WSARecv) (SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) = 0;
-unsigned long (WSAAPI *_inet_addr) (const char *) = 0;
-
-static bool load_sockets()
-{
-	bool result = false;
-
-	hWinsock32 = LoadLibrary( wslib );
-	if(!hWinsock32) {
-		ErrorAlert("Could not load Winsock libraries; router module is not available. Please install Windows sockets 2.");
-	} else {
-		_WSAStartup = (int (WSAAPI *)(WORD, LPWSADATA))GetProcAddress( hWinsock32, "WSAStartup" );
-		_WSACleanup = (int (WSAAPI *)(void))GetProcAddress( hWinsock32, "WSACleanup" );
-		_gethostname = (int (WSAAPI *)(char *, int))GetProcAddress( hWinsock32, "gethostname" );
-		_inet_ntoa = (char * (WSAAPI *)(struct in_addr))GetProcAddress( hWinsock32, "inet_ntoa" );
-		_gethostbyname = (struct hostent * (WSAAPI *)(const char *))GetProcAddress( hWinsock32, "gethostbyname" );
-		_send = (int (WSAAPI *)(SOCKET, const char *, int, int))GetProcAddress( hWinsock32, "send" );
-		_sendto = (int (WSAAPI *)(SOCKET, const char *, int, int, const struct sockaddr *, int))GetProcAddress( hWinsock32, "sendto" );
-		_recv = (int (WSAAPI *)(SOCKET, char *, int, int))GetProcAddress( hWinsock32, "recv" );
-		_recvfrom = (int (WSAAPI *)(SOCKET, char *, int, int, struct sockaddr *, int *))GetProcAddress( hWinsock32, "recvfrom" );
-		_listen = (int (WSAAPI *)(SOCKET, int))GetProcAddress( hWinsock32, "listen" );
-		_accept = (SOCKET (WSAAPI *)(SOCKET, struct sockaddr *, int *))GetProcAddress( hWinsock32, "accept" );
-		_socket = (SOCKET (WSAAPI *)(int, int, int))GetProcAddress( hWinsock32, "socket" );
-		_bind = (int (WSAAPI *)(SOCKET, const struct sockaddr *, int))GetProcAddress( hWinsock32, "bind" );
-		_WSAAsyncSelect = (int (WSAAPI *)(SOCKET, HWND, u_int, long))GetProcAddress( hWinsock32, "WSAAsyncSelect" );
-		_closesocket = (int (WSAAPI *)(SOCKET))GetProcAddress( hWinsock32, "closesocket" );
-		_getsockname = (int (WSAAPI *)(SOCKET, struct sockaddr *, int *))GetProcAddress( hWinsock32, "getsockname" );
-		_WSARecvFrom = (int (WSAAPI *)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, struct sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))GetProcAddress( hWinsock32, "WSARecvFrom" );
-		_WSAGetLastError = (int (WSAAPI *)(void))GetProcAddress( hWinsock32, "WSAGetLastError" );
-		_WSAConnect = (int (WSAAPI *)(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS))GetProcAddress( hWinsock32, "WSAConnect" );
-		_setsockopt = (int (WSAAPI *)(SOCKET, int, int, const char *, int))GetProcAddress( hWinsock32, "setsockopt" );
-		_WSAEventSelect = (int (WSAAPI *)(SOCKET, WSAEVENT, long))GetProcAddress( hWinsock32, "WSAEventSelect" );
-		_WSACreateEvent = (WSAEVENT (WSAAPI *)(void))GetProcAddress( hWinsock32, "WSACreateEvent" );
-		_WSACloseEvent = (BOOL (WSAAPI *)(WSAEVENT))GetProcAddress( hWinsock32, "WSACloseEvent" );
-		_WSAResetEvent = (BOOL (WSAAPI *)(WSAEVENT))GetProcAddress( hWinsock32, "WSAResetEvent" );
-		_WSAEnumNetworkEvents = (BOOL (WSAAPI *)(SOCKET, WSAEVENT, LPWSANETWORKEVENTS))GetProcAddress( hWinsock32, "WSAEnumNetworkEvents" );
- 		_shutdown = (int (WSAAPI *)(SOCKET, int))GetProcAddress( hWinsock32, "shutdown" );
- 		_WSASend = (int (WSAAPI *)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))GetProcAddress( hWinsock32, "WSASend" );
- 		_WSARecv = (int (WSAAPI *)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))GetProcAddress( hWinsock32, "WSARecv" );
- 		_inet_addr = (unsigned long (WSAAPI *)(const char *))GetProcAddress( hWinsock32, "inet_addr" );
-
-		if( _WSAStartup && _WSACleanup && _gethostname && _inet_ntoa && _gethostbyname &&
-				_send && _sendto && _recv && _recvfrom && _listen && _accept && _socket && _bind &&
-				_WSAAsyncSelect && _closesocket && _getsockname && _WSARecvFrom && _WSAGetLastError &&
-				_WSAConnect && _setsockopt && _WSAEventSelect && _WSACreateEvent && _WSACloseEvent &&
-				_WSAResetEvent && _WSAEnumNetworkEvents && _shutdown && _WSASend && _WSARecv && _inet_addr
-		)
-		{
-			result = true;
-		} else {
-			ErrorAlert("Could not find required entry points; router module is not available. Please install Windows sockets 2.");
-		}
-	}
-
-	return result;
-}
-
-bool dynsockets_init(void)
-{
-	bool result = false;
-	if(load_sockets()) {
-		if( (_WSAStartup(MAKEWORD(2,0), &WSAData)) != 0 ||
-				LOBYTE( WSAData.wVersion ) != 2 ||
-        HIBYTE( WSAData.wVersion ) != 0 )
-		{
-			ErrorAlert("Could not start Windows sockets version 2.");
-		} else {
-			result = true;
-		}
-	}
-	return result;
-}
-
-void dynsockets_final(void)
-{
-	if(hWinsock32) {
-		_WSACleanup();
-		FreeLibrary( hWinsock32 );
-		hWinsock32 = 0;
-	}
-	_WSAStartup = 0;
-	_WSACleanup = 0;
-	_gethostname = 0;
-	_inet_ntoa = 0;
-	_gethostbyname = 0;
-	_send = 0;
-	_sendto = 0;
-	_recv = 0;
-	_recvfrom = 0;
-	_listen = 0;
-	_accept = 0;
-	_socket = 0;
-	_bind = 0;
-	_WSAAsyncSelect = 0;
-	_closesocket = 0;
-	_getsockname = 0;
-	_WSARecvFrom = 0;
-	_WSAGetLastError = 0;
-	_WSAConnect = 0;
-	_setsockopt = 0;
-	_WSAEventSelect = 0;
-	_WSACreateEvent = 0;
-	_WSACloseEvent = 0;
-	_WSAResetEvent = 0;
-	_WSAEnumNetworkEvents = 0;
-	_shutdown = 0;
-	_WSASend = 0;
-	_WSARecv = 0;
-	_inet_addr = 0;
-}
+/*
+ *  dynsockets.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include "dynsockets.h"
+#include "dump.h"
+#include "main.h"
+
+
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+
+#include "debug.h"
+
+
+/*
+	Cannot link statically to winsock. We need ws2, but there are
+	Win95 b2 users who can't (or won't) upgrade.
+*/
+
+static const char *wslib = "WS2_32.DLL";
+
+static HMODULE hWinsock32 = 0;
+static WSADATA WSAData;
+
+int (WSAAPI *_WSAStartup) (WORD, LPWSADATA) = 0;
+int (WSAAPI *_WSACleanup) (void) = 0;
+int (WSAAPI *_gethostname) (char *, int) = 0;
+char * (WSAAPI *_inet_ntoa) (struct in_addr) = 0;
+struct hostent * (WSAAPI *_gethostbyname) (const char *) = 0;
+int (WSAAPI *_send) (SOCKET, const char *, int, int) = 0;
+int (WSAAPI *_sendto) (SOCKET, const char *, int, int, const struct sockaddr *, int) = 0;
+int (WSAAPI *_recv) (SOCKET, char *, int, int) = 0;
+int (WSAAPI *_recvfrom) (SOCKET, char *, int, int, struct sockaddr *, int *) = 0;
+int (WSAAPI *_listen) (SOCKET, int) = 0;
+SOCKET (WSAAPI *_accept) (SOCKET, struct sockaddr *, int *) = 0;
+SOCKET (WSAAPI *_socket) (int, int, int) = 0;
+int (WSAAPI *_bind) (SOCKET, const struct sockaddr *, int) = 0;
+int (WSAAPI *_WSAAsyncSelect) (SOCKET, HWND, u_int, long) = 0;
+int (WSAAPI *_closesocket) (SOCKET) = 0;
+int (WSAAPI *_getsockname) (SOCKET, struct sockaddr *, int *) = 0;
+int (WSAAPI *_WSARecvFrom) (SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, struct sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) = 0;
+int (WSAAPI *_WSAGetLastError) (void) = 0;
+int (WSAAPI *_WSAConnect) (SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS) = 0;
+int (WSAAPI *_setsockopt) (SOCKET, int, int, const char *, int) = 0;
+int (WSAAPI *_WSAEventSelect) (SOCKET, WSAEVENT, long) = 0;
+WSAEVENT (WSAAPI *_WSACreateEvent) (void) = 0;
+BOOL (WSAAPI *_WSACloseEvent) (WSAEVENT) = 0;
+BOOL (WSAAPI *_WSAResetEvent) (WSAEVENT) = 0;
+int (WSAAPI *_WSAEnumNetworkEvents) (SOCKET, WSAEVENT, LPWSANETWORKEVENTS) = 0;
+int (WSAAPI *_shutdown) (SOCKET, int) = 0;
+int (WSAAPI *_WSASend) (SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) = 0;
+int (WSAAPI *_WSARecv) (SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) = 0;
+unsigned long (WSAAPI *_inet_addr) (const char *) = 0;
+
+static bool load_sockets()
+{
+	bool result = false;
+
+	hWinsock32 = LoadLibrary( wslib );
+	if(!hWinsock32) {
+		ErrorAlert("Could not load Winsock libraries; router module is not available. Please install Windows sockets 2.");
+	} else {
+		_WSAStartup = (int (WSAAPI *)(WORD, LPWSADATA))GetProcAddress( hWinsock32, "WSAStartup" );
+		_WSACleanup = (int (WSAAPI *)(void))GetProcAddress( hWinsock32, "WSACleanup" );
+		_gethostname = (int (WSAAPI *)(char *, int))GetProcAddress( hWinsock32, "gethostname" );
+		_inet_ntoa = (char * (WSAAPI *)(struct in_addr))GetProcAddress( hWinsock32, "inet_ntoa" );
+		_gethostbyname = (struct hostent * (WSAAPI *)(const char *))GetProcAddress( hWinsock32, "gethostbyname" );
+		_send = (int (WSAAPI *)(SOCKET, const char *, int, int))GetProcAddress( hWinsock32, "send" );
+		_sendto = (int (WSAAPI *)(SOCKET, const char *, int, int, const struct sockaddr *, int))GetProcAddress( hWinsock32, "sendto" );
+		_recv = (int (WSAAPI *)(SOCKET, char *, int, int))GetProcAddress( hWinsock32, "recv" );
+		_recvfrom = (int (WSAAPI *)(SOCKET, char *, int, int, struct sockaddr *, int *))GetProcAddress( hWinsock32, "recvfrom" );
+		_listen = (int (WSAAPI *)(SOCKET, int))GetProcAddress( hWinsock32, "listen" );
+		_accept = (SOCKET (WSAAPI *)(SOCKET, struct sockaddr *, int *))GetProcAddress( hWinsock32, "accept" );
+		_socket = (SOCKET (WSAAPI *)(int, int, int))GetProcAddress( hWinsock32, "socket" );
+		_bind = (int (WSAAPI *)(SOCKET, const struct sockaddr *, int))GetProcAddress( hWinsock32, "bind" );
+		_WSAAsyncSelect = (int (WSAAPI *)(SOCKET, HWND, u_int, long))GetProcAddress( hWinsock32, "WSAAsyncSelect" );
+		_closesocket = (int (WSAAPI *)(SOCKET))GetProcAddress( hWinsock32, "closesocket" );
+		_getsockname = (int (WSAAPI *)(SOCKET, struct sockaddr *, int *))GetProcAddress( hWinsock32, "getsockname" );
+		_WSARecvFrom = (int (WSAAPI *)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, struct sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))GetProcAddress( hWinsock32, "WSARecvFrom" );
+		_WSAGetLastError = (int (WSAAPI *)(void))GetProcAddress( hWinsock32, "WSAGetLastError" );
+		_WSAConnect = (int (WSAAPI *)(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS))GetProcAddress( hWinsock32, "WSAConnect" );
+		_setsockopt = (int (WSAAPI *)(SOCKET, int, int, const char *, int))GetProcAddress( hWinsock32, "setsockopt" );
+		_WSAEventSelect = (int (WSAAPI *)(SOCKET, WSAEVENT, long))GetProcAddress( hWinsock32, "WSAEventSelect" );
+		_WSACreateEvent = (WSAEVENT (WSAAPI *)(void))GetProcAddress( hWinsock32, "WSACreateEvent" );
+		_WSACloseEvent = (BOOL (WSAAPI *)(WSAEVENT))GetProcAddress( hWinsock32, "WSACloseEvent" );
+		_WSAResetEvent = (BOOL (WSAAPI *)(WSAEVENT))GetProcAddress( hWinsock32, "WSAResetEvent" );
+		_WSAEnumNetworkEvents = (BOOL (WSAAPI *)(SOCKET, WSAEVENT, LPWSANETWORKEVENTS))GetProcAddress( hWinsock32, "WSAEnumNetworkEvents" );
+ 		_shutdown = (int (WSAAPI *)(SOCKET, int))GetProcAddress( hWinsock32, "shutdown" );
+ 		_WSASend = (int (WSAAPI *)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))GetProcAddress( hWinsock32, "WSASend" );
+ 		_WSARecv = (int (WSAAPI *)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))GetProcAddress( hWinsock32, "WSARecv" );
+ 		_inet_addr = (unsigned long (WSAAPI *)(const char *))GetProcAddress( hWinsock32, "inet_addr" );
+ 		
+		if( _WSAStartup && _WSACleanup && _gethostname && _inet_ntoa && _gethostbyname &&
+				_send && _sendto && _recv && _recvfrom && _listen && _accept && _socket && _bind &&
+				_WSAAsyncSelect && _closesocket && _getsockname && _WSARecvFrom && _WSAGetLastError &&
+				_WSAConnect && _setsockopt && _WSAEventSelect && _WSACreateEvent && _WSACloseEvent &&
+				_WSAResetEvent && _WSAEnumNetworkEvents && _shutdown && _WSASend && _WSARecv && _inet_addr
+		)
+		{
+			result = true;
+		} else {
+			ErrorAlert("Could not find required entry points; router module is not available. Please install Windows sockets 2.");
+		}
+	}
+
+	return result;
+}
+
+bool dynsockets_init(void)
+{
+	bool result = false;
+	if(load_sockets()) {
+		if( (_WSAStartup(MAKEWORD(2,0), &WSAData)) != 0 ||
+				LOBYTE( WSAData.wVersion ) != 2 ||
+        HIBYTE( WSAData.wVersion ) != 0 )
+		{
+			ErrorAlert("Could not start Windows sockets version 2.");
+		} else {
+			result = true;
+		}
+	}
+	return result;
+}
+
+void dynsockets_final(void)
+{
+	if(hWinsock32) {
+		_WSACleanup();
+		FreeLibrary( hWinsock32 );
+		hWinsock32 = 0;
+	}
+	_WSAStartup = 0;
+	_WSACleanup = 0;
+	_gethostname = 0;
+	_inet_ntoa = 0;
+	_gethostbyname = 0;
+	_send = 0;
+	_sendto = 0;
+	_recv = 0;
+	_recvfrom = 0;
+	_listen = 0;
+	_accept = 0;
+	_socket = 0;
+	_bind = 0;
+	_WSAAsyncSelect = 0;
+	_closesocket = 0;
+	_getsockname = 0;
+	_WSARecvFrom = 0;
+	_WSAGetLastError = 0;
+	_WSAConnect = 0;
+	_setsockopt = 0;
+	_WSAEventSelect = 0;
+	_WSACreateEvent = 0;
+	_WSACloseEvent = 0;
+	_WSAResetEvent = 0;
+	_WSAEnumNetworkEvents = 0;
+	_shutdown = 0;
+	_WSASend = 0;
+	_WSARecv = 0;
+	_inet_addr = 0;
+}
--- macemu/SheepShaver/src/Windows/router/dynsockets.h
+++ sheepshaver/SheepShaver/src/Windows/router/dynsockets.h
@@ -1,59 +1,59 @@
-/*
- *  dynsockets.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _DYNSOCKETS_H_
-#define _DYNSOCKETS_H_
-
-bool dynsockets_init(void);
-void dynsockets_final(void);
-
-extern int (WSAAPI *_WSAStartup) (WORD, LPWSADATA);
-extern int (WSAAPI *_WSACleanup) (void);
-extern int (WSAAPI *_gethostname) (char *, int);
-extern char * (WSAAPI *_inet_ntoa) (struct in_addr);
-extern struct hostent * (WSAAPI *_gethostbyname) (const char *);
-extern int (WSAAPI *_send) (SOCKET, const char *, int, int);
-extern int (WSAAPI *_sendto) (SOCKET, const char *, int, int, const struct sockaddr *, int);
-extern int (WSAAPI *_recv) (SOCKET, char *, int, int);
-extern int (WSAAPI *_recvfrom) (SOCKET, char *, int, int, struct sockaddr *, int *);
-extern int (WSAAPI *_listen) (SOCKET, int);
-extern SOCKET (WSAAPI *_accept) (SOCKET, struct sockaddr *, int *);
-extern SOCKET (WSAAPI *_socket) (int, int, int);
-extern int (WSAAPI *_bind) (SOCKET, const struct sockaddr *, int);
-extern int (WSAAPI *_WSAAsyncSelect) (SOCKET, HWND, u_int, long);
-extern int (WSAAPI *_closesocket) (SOCKET);
-extern int (WSAAPI *_getsockname) (SOCKET, struct sockaddr *, int *);
-extern int (WSAAPI *_WSARecvFrom) (SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, struct sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
-extern int (WSAAPI *_WSAGetLastError) (void);
-extern int (WSAAPI *_WSAConnect) (SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS);
-extern int (WSAAPI *_setsockopt) (SOCKET, int, int, const char *, int);
-extern int (WSAAPI *_WSAEventSelect) (SOCKET, WSAEVENT, long);
-extern WSAEVENT (WSAAPI *_WSACreateEvent) (void);
-extern BOOL (WSAAPI *_WSACloseEvent) (WSAEVENT);
-extern BOOL (WSAAPI *_WSAResetEvent) (WSAEVENT);
-extern int (WSAAPI *_WSAEnumNetworkEvents) (SOCKET, WSAEVENT, LPWSANETWORKEVENTS);
-extern int (WSAAPI *_shutdown) (SOCKET, int);
-extern int (WSAAPI *_WSASend) (SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
-extern int (WSAAPI *_WSARecv) (SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
-extern unsigned long (WSAAPI *_inet_addr) (const char *);
-
-#endif // _DYNSOCKETS_H_
+/*
+ *  dynsockets.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _DYNSOCKETS_H_
+#define _DYNSOCKETS_H_
+
+bool dynsockets_init(void);
+void dynsockets_final(void);
+
+extern int (WSAAPI *_WSAStartup) (WORD, LPWSADATA);
+extern int (WSAAPI *_WSACleanup) (void);
+extern int (WSAAPI *_gethostname) (char *, int);
+extern char * (WSAAPI *_inet_ntoa) (struct in_addr);
+extern struct hostent * (WSAAPI *_gethostbyname) (const char *);
+extern int (WSAAPI *_send) (SOCKET, const char *, int, int);
+extern int (WSAAPI *_sendto) (SOCKET, const char *, int, int, const struct sockaddr *, int);
+extern int (WSAAPI *_recv) (SOCKET, char *, int, int);
+extern int (WSAAPI *_recvfrom) (SOCKET, char *, int, int, struct sockaddr *, int *);
+extern int (WSAAPI *_listen) (SOCKET, int);
+extern SOCKET (WSAAPI *_accept) (SOCKET, struct sockaddr *, int *);
+extern SOCKET (WSAAPI *_socket) (int, int, int);
+extern int (WSAAPI *_bind) (SOCKET, const struct sockaddr *, int);
+extern int (WSAAPI *_WSAAsyncSelect) (SOCKET, HWND, u_int, long);
+extern int (WSAAPI *_closesocket) (SOCKET);
+extern int (WSAAPI *_getsockname) (SOCKET, struct sockaddr *, int *);
+extern int (WSAAPI *_WSARecvFrom) (SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, struct sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
+extern int (WSAAPI *_WSAGetLastError) (void);
+extern int (WSAAPI *_WSAConnect) (SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS);
+extern int (WSAAPI *_setsockopt) (SOCKET, int, int, const char *, int);
+extern int (WSAAPI *_WSAEventSelect) (SOCKET, WSAEVENT, long);
+extern WSAEVENT (WSAAPI *_WSACreateEvent) (void);
+extern BOOL (WSAAPI *_WSACloseEvent) (WSAEVENT);
+extern BOOL (WSAAPI *_WSAResetEvent) (WSAEVENT);
+extern int (WSAAPI *_WSAEnumNetworkEvents) (SOCKET, WSAEVENT, LPWSANETWORKEVENTS);
+extern int (WSAAPI *_shutdown) (SOCKET, int);
+extern int (WSAAPI *_WSASend) (SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
+extern int (WSAAPI *_WSARecv) (SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
+extern unsigned long (WSAAPI *_inet_addr) (const char *);
+
+#endif // _DYNSOCKETS_H_
--- macemu/SheepShaver/src/Windows/router/ftp.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/ftp.cpp
@@ -1,193 +1,192 @@
-/*
- *  ftp.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "main.h"
-#include <ctype.h>
-#include "dump.h"
-#include "prefs.h"
-#include "ftp.h"
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-static int m_ftp_port_count = 0;
-#define MAX_FTP_PORTS 100
-static uint16 m_ftp_ports[MAX_FTP_PORTS];
-
-bool ftp_is_ftp_port( uint16 port )
-{
-	for( int i=0; i<m_ftp_port_count; i++ ) {
-		if( m_ftp_ports[i] == port ) return true;
-	}
-	return false;
-}
-
-void init_ftp()
-{
-	const char *str = PrefsFindString("ftp_port_list");
-
-	if(str) {
-		char *ftp = new char [ strlen(str) + 1 ];
-		if(ftp) {
-			strcpy( ftp, str );
-			char *p = ftp;
-			while( p && *p ) {
-				char *pp = strchr( p, ',' );
-				if(pp) *pp++ = 0;
-				if( m_ftp_port_count < MAX_FTP_PORTS ) {
-					m_ftp_ports[m_ftp_port_count++] = (uint16)strtoul(p,0,0);
-				}
-				p = pp;
-			}
-			delete [] ftp;
-		}
-	}
-}
-
-void ftp_modify_port_command(
-	char *buf,
-	int &count,
-	const uint32 max_size,
-	const uint32 ip,
-	const uint16 port,
-	const bool is_pasv
-)
-{
-	if( max_size < 100 ) {
-		// impossible
-		return;
-	}
-
-	sprintf(
-		buf,
-		(is_pasv ? "227 Entering Passive Mode (%d,%d,%d,%d,%d,%d).%c%c" : "PORT %d,%d,%d,%d,%d,%d%c%c"),
-		ip >> 24,
-		(ip >> 16) & 0xFF,
-		(ip >> 8) & 0xFF,
-		ip & 0xFF,
-		(port >> 8) & 0xFF,
-		port & 0xFF,
-		0x0d, 0x0a
-	);
-
-	count = strlen(buf);
-
-	D(bug("ftp_modify_port_command: \"%s\"\r\n", buf ));
-}
-
-// this should be robust. rather skip it than do anything dangerous.
-void ftp_parse_port_command(
-	char *buf,
-	uint32 count,
-	uint16 &ftp_data_port,
-	bool is_pasv
-)
-{
-	ftp_data_port = 0;
-
-	if( !count ) return;
-
-	uint8 b[100];
-	uint32 ftp_ip = 0;
-
-	// make it a c-string
-	if( count >= sizeof(b) ) count = sizeof(b)-1;
-	memcpy( b, buf, count );
-	b[ count ] = 0;
-
-	for( uint32 i=0; i<count; i++ ) {
-		if( b[i] < ' ' || b[i] > 'z' ) {
-			b[i] = ' ';
-		} else {
-			b[i] = tolower(b[i]);
-		}
-	}
-
-	// D(bug("FTP: \"%s\"\r\n", b ));
-
-	char *s = (char *)b;
-
-	while( *s == ' ' ) s++;
-
-	if(is_pasv) {
-		/*
-		LOCAL SERVER: ..227 Entering Passive Mode (192,168,0,2,6,236). 0d 0a
-		*/
-		if( atoi(s) == 227 && strstr(s,"passive") ) {
-			while( *s && *s != '(' ) s++;
-			if( *s++ == 0 ) s = 0;
-		} else {
-			s = 0;
-		}
-	} else {
-		/*
-		LOCAL CLIENT: PORT 192,168,0,1,14,147 0d 0a
-		*/
-		if( strncmp(s,"port ",5) == 0 ) {
-			s += 5;
-		} else {
-			s = 0;
-		}
-	}
-
-	if(s && *s) {
-		// get remote ip (used only for verification)
-		for( uint32 i=0; i<4; i++ ) {
-			while( *s == ' ' ) s++;
-			if(!isdigit(*s)) {
-				ftp_ip = 0;
-				break;
-			}
-			ftp_ip = (ftp_ip << 8) + atoi(s);
-			while( *s && *s != ',' ) s++;
-			if(!*s) {
-				ftp_ip = 0;
-				break;
-			}
-			s++;
-		}
-
-		if(ftp_ip) {
-			// get local port
-			for( uint32 i=0; i<2; i++ ) {
-				while( *s == ' ' ) s++;
-				if(!isdigit(*s)) {
-					ftp_data_port = 0;
-					break;
-				}
-				ftp_data_port = (ftp_data_port << 8) + atoi(s);
-				while( *s && *s != ',' && *s != ')' ) s++;
-				if(!*s)
-					break;
-				else
-					s++;
-			}
-		}
-	}
-	if(ftp_data_port) {
-		D(bug("ftp_parse_port_command: \"%s\"; port is %d\r\n", b, ftp_data_port ));
-	}
-}
+/*
+ *  ftp.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include <ctype.h>
+#include "dump.h"
+#include "prefs.h"
+#include "ftp.h"
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+static int m_ftp_port_count = 0;
+#define MAX_FTP_PORTS 100
+static uint16 m_ftp_ports[MAX_FTP_PORTS];
+
+bool ftp_is_ftp_port( uint16 port )
+{
+	for( int i=0; i<m_ftp_port_count; i++ ) {
+		if( m_ftp_ports[i] == port ) return true;
+	}
+	return false;
+}
+
+void init_ftp()
+{
+	const char *str = PrefsFindString("ftp_port_list");
+
+	if(str) {
+		char *ftp = new char [ strlen(str) + 1 ];
+		if(ftp) {
+			strcpy( ftp, str );
+			char *p = ftp;
+			while( p && *p ) {
+				char *pp = strchr( p, ',' );
+				if(pp) *pp++ = 0;
+				if( m_ftp_port_count < MAX_FTP_PORTS ) {
+					m_ftp_ports[m_ftp_port_count++] = (uint16)strtoul(p,0,0);
+				}
+				p = pp;
+			}
+			delete [] ftp;
+		}
+	}
+}
+
+void ftp_modify_port_command( 
+	char *buf,
+	int &count,
+	const uint32 max_size,
+	const uint32 ip,
+	const uint16 port,
+	const bool is_pasv
+)
+{
+	if( max_size < 100 ) {
+		// impossible
+		return;
+	}
+
+	sprintf( 
+		buf, 
+		(is_pasv ? "227 Entering Passive Mode (%d,%d,%d,%d,%d,%d).%c%c" : "PORT %d,%d,%d,%d,%d,%d%c%c"),
+		ip >> 24,
+		(ip >> 16) & 0xFF,
+		(ip >> 8) & 0xFF,
+		ip & 0xFF,
+		(port >> 8) & 0xFF,
+		port & 0xFF,
+		0x0d, 0x0a
+	);
+
+	count = strlen(buf);
+
+	D(bug("ftp_modify_port_command: \"%s\"\r\n", buf ));
+}
+
+// this should be robust. rather skip it than do anything dangerous.
+void ftp_parse_port_command(
+	char *buf,
+	uint32 count,
+	uint16 &ftp_data_port,
+	bool is_pasv
+)
+{
+	ftp_data_port = 0;
+
+	if( !count ) return;
+
+	uint8 b[100];
+	uint32 ftp_ip = 0;
+
+	// make it a c-string
+	if( count >= sizeof(b) ) count = sizeof(b)-1;
+	memcpy( b, buf, count );
+	b[ count ] = 0;
+
+	for( uint32 i=0; i<count; i++ ) {
+		if( b[i] < ' ' || b[i] > 'z' ) {
+			b[i] = ' ';
+		} else {
+			b[i] = tolower(b[i]);
+		}
+	}
+
+	// D(bug("FTP: \"%s\"\r\n", b ));
+
+	char *s = (char *)b;
+
+	while( *s == ' ' ) s++;
+
+	if(is_pasv) {
+		/*
+		LOCAL SERVER: ..227 Entering Passive Mode (192,168,0,2,6,236). 0d 0a
+		*/
+		if( atoi(s) == 227 && strstr(s,"passive") ) {
+			while( *s && *s != '(' ) s++;
+			if( *s++ == 0 ) s = 0;
+		} else {
+			s = 0;
+		}
+	} else {
+		/*
+		LOCAL CLIENT: PORT 192,168,0,1,14,147 0d 0a
+		*/
+		if( strncmp(s,"port ",5) == 0 ) {
+			s += 5;
+		} else {
+			s = 0;
+		}
+	}
+
+	if(s && *s) {
+		// get remote ip (used only for verification)
+		for( uint32 i=0; i<4; i++ ) {
+			while( *s == ' ' ) s++;
+			if(!isdigit(*s)) {
+				ftp_ip = 0;
+				break;
+			}
+			ftp_ip = (ftp_ip << 8) + atoi(s);
+			while( *s && *s != ',' ) s++;
+			if(!*s) {
+				ftp_ip = 0;
+				break;
+			}
+			s++;
+		}
+
+		if(ftp_ip) {
+			// get local port
+			for( uint32 i=0; i<2; i++ ) {
+				while( *s == ' ' ) s++;
+				if(!isdigit(*s)) {
+					ftp_data_port = 0;
+					break;
+				}
+				ftp_data_port = (ftp_data_port << 8) + atoi(s);
+				while( *s && *s != ',' && *s != ')' ) s++;
+				if(!*s) 
+					break; 
+				else 
+					s++;
+			}
+		}
+	}
+	if(ftp_data_port) {
+		D(bug("ftp_parse_port_command: \"%s\"; port is %d\r\n", b, ftp_data_port ));
+	}
+}
--- macemu/SheepShaver/src/Windows/router/ftp.h
+++ sheepshaver/SheepShaver/src/Windows/router/ftp.h
@@ -1,50 +1,50 @@
-/*
- *  ftp.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _FTP_H_
-#define _FTP_H_
-
-// Read the preferences.
-void init_ftp();
-
-// Compares against a list provided by the user.
-bool ftp_is_ftp_port( uint16 port );
-
-// Determine whether this is a ftp client PORT command or ftp server entering to passive mode.
-void ftp_parse_port_command(
-	char *buf,
-	uint32 count,
-	uint16 &ftp_data_port,
-	bool is_pasv
-);
-
-// Build a new command using ip and port.
-void ftp_modify_port_command(
-	char *buf,
-	int &count,
-	const uint32 max_size,
-	const uint32 ip,
-	const uint16 port,
-	const bool is_pasv
-);
-
-#endif // _FTP_H_
+/*
+ *  ftp.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _FTP_H_
+#define _FTP_H_
+
+// Read the preferences.
+void init_ftp();
+
+// Compares against a list provided by the user.
+bool ftp_is_ftp_port( uint16 port );
+
+// Determine whether this is a ftp client PORT command or ftp server entering to passive mode.
+void ftp_parse_port_command(
+	char *buf,
+	uint32 count,
+	uint16 &ftp_data_port,
+	bool is_pasv
+);
+
+// Build a new command using ip and port.
+void ftp_modify_port_command( 
+	char *buf,
+	int &count,
+	const uint32 max_size,
+	const uint32 ip,
+	const uint16 port,
+	const bool is_pasv
+);
+
+#endif // _FTP_H_
--- macemu/SheepShaver/src/Windows/router/icmp.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/icmp.cpp
@@ -1,221 +1,220 @@
-/*
- *  icmp.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "main.h"
-#include "cpu_emulation.h"
-#include "ws2tcpip.h"
-#include "prefs.h"
-#include "ether_windows.h"
-#include "ether.h"
-#include "router.h"
-#include "router_types.h"
-#include "dynsockets.h"
-#include "ipsocket.h"
-#include "iphelp.h"
-#include "icmp.h"
-#include "dump.h"
-
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-
-// Saved for cleanup.
-static socket_t *icmp_incoming_s = 0;
-
-
-void stop_icmp_listen()
-{
-	if(icmp_incoming_s) {
-		delete icmp_incoming_s;
-		icmp_incoming_s = 0;
-	}
-}
-
-void start_icmp_listen()
-{
-	if(!icmp_incoming_s) {
-		icmp_incoming_s = new socket_t(IPPROTO_ICMP);
-
-		icmp_incoming_s->permanent = TRUE;
-		icmp_incoming_s->s = _socket( AF_INET, SOCK_RAW, IPPROTO_ICMP );
-
-		memset( &icmp_incoming_s->from, 0, icmp_incoming_s->from_len );
-		icmp_incoming_s->from.sin_family = AF_INET;
-
-		if(icmp_incoming_s->s == INVALID_SOCKET) {
-			D(bug("Failed to create icmp listening socket (NT/no admin?)\r\n" ));
-			delete icmp_incoming_s;
-			icmp_incoming_s = 0;
-		} else {
-			D(bug("icmp listening socket created\r\n" ));
-			raw_sockets_available = true;
-			struct sockaddr_in to;
-			memset( &to, 0, sizeof(to) );
-			to.sin_family = AF_INET;
-			if(	_bind ( icmp_incoming_s->s, (const struct sockaddr *)&to, sizeof(to) ) == SOCKET_ERROR ) {
-				D(bug("Listening to inbound icmp failed, error code = %d\r\n", _WSAGetLastError() ));
-				_closesocket( icmp_incoming_s->s );
-				delete icmp_incoming_s;
-				icmp_incoming_s = 0;
-			} else {
-				D(bug("icmp listening socket bound\r\n" ));
-				if(!icmp_incoming_s->b_recfrom()) {
-					D(bug("b_recfrom() from inbound icmp failed, error code = %d\r\n", _WSAGetLastError() ));
-					// _closesocket( icmp_incoming_s->s );
-					// delete icmp_incoming_s;
-					// icmp_incoming_s = 0;
-				}
-			}
-		}
-	}
-}
-
-void CALLBACK icmp_read_completion(
-	DWORD error,
-	DWORD bytes_read,
-	LPWSAOVERLAPPED lpOverlapped,
-	DWORD flags
-)
-{
-  D(bug("icmp_read_completion(error=0x%x, bytes_read=%d, flags=0x%x)\r\n", error, bytes_read, flags));
-
-	socket_t *cmpl = (socket_t *)lpOverlapped->hEvent;
-
-	if(error == 0 && macos_ip_address != 0) {
-		if(bytes_read > 1460) {
-		  D(bug("discarding oversized icmp packet, size = \r\n", bytes_read));
-		} else {
-			int icmp_size = sizeof(mac_t) + bytes_read;
-			icmp_t *icmp = (icmp_t *)malloc( icmp_size );
-			if(icmp) {
-				mac_t *mac = (mac_t *)icmp;
-				ip_t *ip = (ip_t *)icmp;
-
-				memcpy( mac->dest, ether_addr, 6 );
-				memcpy( mac->src, router_mac_addr, 6 );
-				mac->type = htons(mac_type_ip4);
-
-				// Copy payload (used by ICMP checksum)
-				memcpy( (char *)icmp + sizeof(mac_t), cmpl->buffers[0].buf, bytes_read );
-
-				switch( icmp->type ) {
-					// May need to patch the returned ip header.
-					case icmp_Destination_unreachable:
-					case icmp_Source_quench:
-					case icmp_Redirect:
-					case icmp_Time_exceeded:
-					case icmp_Parameter_problem:
-						ip_t *ip_if = (ip_t *)( (char *)icmp + sizeof(icmp_t) + sizeof(uint32) - sizeof(mac_t) );
-
-						// This would be needed (traceroute)
-						// ip_if->ident = ??;
-
-						// Cannot fix some fields, this should be enough:
-						ip_if->src = htonl(macos_ip_address);
-
-						if(ip_if->proto == ip_proto_udp) {
-							udp_t *udp_if = (udp_t *)ip_if;
-							// udp_if->src_port = ... don't know!;
-						} else if(ip_if->proto == ip_proto_tcp) {
-							tcp_t *tcp_if = (tcp_t *)ip_if;
-							// tcp_if->src_port = ... don't know!;
-						}
-						break;
-				}
-
-				make_icmp_checksum( icmp, icmp_size );
-
-				// Replace the target ip address
-				ip->dest = htonl(macos_ip_address);
-				ip->ttl--;
-				make_ip4_checksum( ip );
-
-				dump_bytes( (uint8 *)icmp, icmp_size );
-
-				if( ip->ttl == 0 ) {
-					D(bug("icmp packet ttl expired\r\n"));
-				} else {
-					enqueue_packet( (uint8 *)icmp, icmp_size );
-				}
-				free(icmp);
-			}
-		}
-	}
-
-	memset( &cmpl->from, 0, cmpl->from_len );
-
-	if(is_router_shutting_down) {
-		delete cmpl;
-	} else if(cmpl->s == INVALID_SOCKET || !cmpl->b_recfrom()) {
-		// delete cmpl;
-	}
-}
-
-void write_icmp( icmp_t *icmp, int len )
-{
-	struct in_addr ia;
-	ia.s_addr = icmp->ip.dest;
-	D(bug("write_icmp(%s)\r\n", _inet_ntoa(ia) ));
-
-	if(!raw_sockets_available) {
-		D(bug("write_icmp() cannot proceed, raw sockets not available\r\n" ));
-		return;
-	}
-
-	if(len < sizeof(icmp_t)) {
-	  D(bug("Too small icmp packet(%d), dropped\r\n", len));
-		return;
-	}
-
-	// must be updated, ttl changed
-	make_icmp_checksum( icmp, len );
-
-	SOCKET s = _socket( AF_INET, SOCK_RAW, IPPROTO_ICMP );
-	if(s != INVALID_SOCKET) {
-		struct sockaddr_in to;
-		memset( &to, 0, sizeof(to) );
-		to.sin_family = AF_INET;
-		to.sin_addr.s_addr = icmp->ip.dest;
-
-		char *data = (char *)icmp + sizeof(ip_t);
-		int dlen = len - sizeof(ip_t);
-
-		int ttl = icmp->ip.ttl;
-		if(_setsockopt( s, IPPROTO_IP, IP_TTL, (const char *)&ttl, sizeof(int) ) == SOCKET_ERROR  ) {
-			D(bug("could not set ttl to %d.\r\n", ttl));
-		} else {
-			D(bug("ttl set to %d.\r\n", ttl));
-		}
-
-		if(SOCKET_ERROR == _sendto( s, data, dlen, 0, (struct sockaddr *)&to, sizeof(to) )) {
-			D(bug("Failed to send icmp via raw socket\r\n" ));
-		}
-		_closesocket(s);
-	} else {
-		D(bug("Could not create raw socket for icmp\r\n" ));
-	}
-}
+/*
+ *  icmp.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include "cpu_emulation.h"
+#include "ws2tcpip.h"
+#include "prefs.h"
+#include "ether_windows.h"
+#include "ether.h"
+#include "router.h"
+#include "router_types.h"
+#include "dynsockets.h"
+#include "ipsocket.h"
+#include "iphelp.h"
+#include "icmp.h"
+#include "dump.h"
+
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+
+// Saved for cleanup.
+static socket_t *icmp_incoming_s = 0;
+
+
+void stop_icmp_listen()
+{
+	if(icmp_incoming_s) {
+		delete icmp_incoming_s;
+		icmp_incoming_s = 0;
+	}
+}
+
+void start_icmp_listen()
+{
+	if(!icmp_incoming_s) {
+		icmp_incoming_s = new socket_t(IPPROTO_ICMP);
+
+		icmp_incoming_s->permanent = TRUE;
+		icmp_incoming_s->s = _socket( AF_INET, SOCK_RAW, IPPROTO_ICMP );
+		
+		memset( &icmp_incoming_s->from, 0, icmp_incoming_s->from_len );
+		icmp_incoming_s->from.sin_family = AF_INET;
+
+		if(icmp_incoming_s->s == INVALID_SOCKET) {
+			D(bug("Failed to create icmp listening socket (NT/no admin?)\r\n" ));
+			delete icmp_incoming_s;
+			icmp_incoming_s = 0;
+		} else {
+			D(bug("icmp listening socket created\r\n" ));
+			raw_sockets_available = true;
+			struct sockaddr_in to;
+			memset( &to, 0, sizeof(to) );
+			to.sin_family = AF_INET;
+			if(	_bind ( icmp_incoming_s->s, (const struct sockaddr *)&to, sizeof(to) ) == SOCKET_ERROR ) {
+				D(bug("Listening to inbound icmp failed, error code = %d\r\n", _WSAGetLastError() ));
+				_closesocket( icmp_incoming_s->s );
+				delete icmp_incoming_s;
+				icmp_incoming_s = 0;
+			} else {
+				D(bug("icmp listening socket bound\r\n" ));
+				if(!icmp_incoming_s->b_recfrom()) {
+					D(bug("b_recfrom() from inbound icmp failed, error code = %d\r\n", _WSAGetLastError() ));
+					// _closesocket( icmp_incoming_s->s );
+					// delete icmp_incoming_s;
+					// icmp_incoming_s = 0;
+				}
+			}
+		}
+	}
+}
+
+void CALLBACK icmp_read_completion(
+	DWORD error,
+	DWORD bytes_read,
+	LPWSAOVERLAPPED lpOverlapped,
+	DWORD flags
+)
+{
+  D(bug("icmp_read_completion(error=0x%x, bytes_read=%d, flags=0x%x)\r\n", error, bytes_read, flags));
+
+	socket_t *cmpl = (socket_t *)lpOverlapped->hEvent;
+
+	if(error == 0 && macos_ip_address != 0) {
+		if(bytes_read > 1460) {
+		  D(bug("discarding oversized icmp packet, size = \r\n", bytes_read));
+		} else {
+			int icmp_size = sizeof(mac_t) + bytes_read;
+			icmp_t *icmp = (icmp_t *)malloc( icmp_size );
+			if(icmp) {
+				mac_t *mac = (mac_t *)icmp;
+				ip_t *ip = (ip_t *)icmp;
+
+				memcpy( mac->dest, ether_addr, 6 );
+				memcpy( mac->src, router_mac_addr, 6 );
+				mac->type = htons(mac_type_ip4);
+
+				// Copy payload (used by ICMP checksum)
+				memcpy( (char *)icmp + sizeof(mac_t), cmpl->buffers[0].buf, bytes_read );
+
+				switch( icmp->type ) {
+					// May need to patch the returned ip header.
+					case icmp_Destination_unreachable:
+					case icmp_Source_quench:
+					case icmp_Redirect:
+					case icmp_Time_exceeded:
+					case icmp_Parameter_problem:
+						ip_t *ip_if = (ip_t *)( (char *)icmp + sizeof(icmp_t) + sizeof(uint32) - sizeof(mac_t) );
+
+						// This would be needed (traceroute)
+						// ip_if->ident = ??;
+
+						// Cannot fix some fields, this should be enough:
+						ip_if->src = htonl(macos_ip_address);
+
+						if(ip_if->proto == ip_proto_udp) {
+							udp_t *udp_if = (udp_t *)ip_if;
+							// udp_if->src_port = ... don't know!;
+						} else if(ip_if->proto == ip_proto_tcp) {
+							tcp_t *tcp_if = (tcp_t *)ip_if;
+							// tcp_if->src_port = ... don't know!;
+						}
+						break;
+				}
+
+				make_icmp_checksum( icmp, icmp_size );
+
+				// Replace the target ip address
+				ip->dest = htonl(macos_ip_address);
+				ip->ttl--;
+				make_ip4_checksum( ip );
+
+				dump_bytes( (uint8 *)icmp, icmp_size );
+
+				if( ip->ttl == 0 ) {
+					D(bug("icmp packet ttl expired\r\n"));
+				} else {
+					enqueue_packet( (uint8 *)icmp, icmp_size );
+				}
+				free(icmp);
+			}
+		}
+	}
+
+	memset( &cmpl->from, 0, cmpl->from_len );
+
+	if(is_router_shutting_down) {
+		delete cmpl;
+	} else if(cmpl->s == INVALID_SOCKET || !cmpl->b_recfrom()) {
+		// delete cmpl;
+	}
+}
+
+void write_icmp( icmp_t *icmp, int len )
+{
+	struct in_addr ia;
+	ia.s_addr = icmp->ip.dest;
+	D(bug("write_icmp(%s)\r\n", _inet_ntoa(ia) ));
+
+	if(!raw_sockets_available) {
+		D(bug("write_icmp() cannot proceed, raw sockets not available\r\n" ));
+		return;
+	}
+
+	if(len < sizeof(icmp_t)) {
+	  D(bug("Too small icmp packet(%d), dropped\r\n", len));
+		return;
+	}
+
+	// must be updated, ttl changed
+	make_icmp_checksum( icmp, len );
+
+	SOCKET s = _socket( AF_INET, SOCK_RAW, IPPROTO_ICMP );
+	if(s != INVALID_SOCKET) {
+		struct sockaddr_in to;
+		memset( &to, 0, sizeof(to) );
+		to.sin_family = AF_INET;
+		to.sin_addr.s_addr = icmp->ip.dest;
+
+		char *data = (char *)icmp + sizeof(ip_t);
+		int dlen = len - sizeof(ip_t);
+
+		int ttl = icmp->ip.ttl;
+		if(_setsockopt( s, IPPROTO_IP, IP_TTL, (const char *)&ttl, sizeof(int) ) == SOCKET_ERROR  ) {
+			D(bug("could not set ttl to %d.\r\n", ttl));
+		} else {
+			D(bug("ttl set to %d.\r\n", ttl));
+		}
+
+		if(SOCKET_ERROR == _sendto( s, data, dlen, 0, (struct sockaddr *)&to, sizeof(to) )) {
+			D(bug("Failed to send icmp via raw socket\r\n" ));
+		}
+		_closesocket(s);
+	} else {
+		D(bug("Could not create raw socket for icmp\r\n" ));
+	}
+}
--- macemu/SheepShaver/src/Windows/router/icmp.h
+++ sheepshaver/SheepShaver/src/Windows/router/icmp.h
@@ -1,38 +1,38 @@
-/*
- *  icmp.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _ICMP_H_
-#define _ICMP_H_
-
-void start_icmp_listen();
-void stop_icmp_listen();
-
-void write_icmp( icmp_t *icmp, int len );
-
-void CALLBACK icmp_read_completion(
-	DWORD error,
-	DWORD bytes_read,
-	LPWSAOVERLAPPED lpOverlapped,
-	DWORD flags
-);
-
-#endif // _ICMP_H_
+/*
+ *  icmp.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _ICMP_H_
+#define _ICMP_H_
+
+void start_icmp_listen();
+void stop_icmp_listen();
+
+void write_icmp( icmp_t *icmp, int len );
+
+void CALLBACK icmp_read_completion(
+	DWORD error,
+	DWORD bytes_read,
+	LPWSAOVERLAPPED lpOverlapped,
+	DWORD flags
+);
+
+#endif // _ICMP_H_
--- macemu/SheepShaver/src/Windows/router/iphelp.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/iphelp.cpp
@@ -1,236 +1,235 @@
-/*
- *  iphelp.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "main.h"
-#include "cpu_emulation.h"
-#include "ether_windows.h"
-#include "ether.h"
-#include "router.h"
-#include "router_types.h"
-#include "tcp.h"
-#include "icmp.h"
-#include "udp.h"
-#include "iphelp.h"
-#include "dump.h"
-
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-
-void make_icmp_checksum( icmp_t *icmp, int len )
-{
-	icmp->checksum = 0;
-
-	uint16 sz = (len-sizeof(ip_t))/2;
-	uint16 *p = (uint16 *)( (uint8 *)icmp + sizeof(ip_t) );
-
-	uint32 sum32 = 0;
-	for( int i=0; i<sz; i++ ) {
-		sum32 += ntohs(p[i]);
-	}
-
-	while( HIWORD(sum32) ) {
-		sum32 = HIWORD(sum32) + LOWORD(sum32);
-	}
-	sum32 = ~sum32;
-	icmp->checksum = htons((uint16)sum32);
-}
-
-void make_tcp_checksum( tcp_t *tcp, int len )
-{
-	tcp->checksum = 0;
-
-	int tcp_len = len - sizeof(ip_t);
-	uint16 sz = tcp_len/2;
-	uint16 *p = (uint16 *)( (uint8 *)tcp + sizeof(ip_t) );
-
-	uint32 sum32 = 0;
-	for( int i=0; i<sz; i++ ) {
-		sum32 += ntohs(p[i]);
-	}
-
-	if(len & 1) {
-		uint8 *p8 = (uint8 *)p;
-		sum32 += p8[tcp_len-1] << 8;
-	}
-
-	pseudo_ip_t pseudo;
-	pseudo.src_lo = LOWORD(ntohl(tcp->ip.src));
-	pseudo.src_hi = HIWORD(ntohl(tcp->ip.src));
-	pseudo.dest_lo = LOWORD(ntohl(tcp->ip.dest));
-	pseudo.dest_hi = HIWORD(ntohl(tcp->ip.dest));
-	pseudo.proto = (uint16)tcp->ip.proto;
-	pseudo.msg_len = tcp->header_len >> 2;
-
-	int datalen = len - sizeof(tcp_t);
-	pseudo.msg_len += datalen;
-
-	p = (uint16 *)&pseudo;
-
-	for( int i=0; i<sizeof(pseudo_ip_t)/2; i++ ) {
-		sum32 += p[i];
-	}
-
-	while( HIWORD(sum32) ) {
-		sum32 = HIWORD(sum32) + LOWORD(sum32);
-	}
-	sum32 = ~sum32;
-	tcp->checksum = htons((uint16)sum32);
-}
-
-void make_ip4_checksum( ip_t *ip )
-{
-	ip->checksum = 0;
-	uint16 sz = ip->header_len * 2;
-	uint16 *p = (uint16 *)( (uint8 *)ip + sizeof(mac_t) );
-
-	uint32 sum32 = 0;
-	for( int i=0; i<sz; i++ ) {
-		sum32 += ntohs(p[i]);
-	}
-
-	while( HIWORD(sum32) ) {
-		sum32 = HIWORD(sum32) + LOWORD(sum32);
-	}
-
-	sum32 = ~sum32;
-	ip->checksum = htons((uint16)sum32);
-}
-
-void make_udp_checksum( udp_t *udp )
-{
-	udp->checksum = 0;
-	return;
-
-	// UDP checksums are optional.
-
-	/*
-	uint16 sz = ntohs(udp->msg_len) / 2;
-	uint16 *p = (uint16 *)( (uint8 *)udp + sizeof(ip_t) );
-
-	uint32 sum32 = 0;
-	for( int i=0; i<sz; i++ ) {
-		sum32 += ntohs(p[i]);
-	}
-
-	// last byte??
-
-	pseudo_ip_t pseudo;
-	pseudo.src_lo = LOWORD(ntohl(udp->ip.src));
-	pseudo.src_hi = HIWORD(ntohl(udp->ip.src));
-	pseudo.dest_lo = LOWORD(ntohl(udp->ip.dest));
-	pseudo.dest_hi = HIWORD(ntohl(udp->ip.dest));
-	pseudo.proto = (uint16)udp->ip.proto;
-	pseudo.msg_len = ntohs(udp->msg_len); // ???
-
-	p = (uint16 *)&pseudo;
-
-	for( i=0; i<sizeof(pseudo_ip_t)/2; i++ ) {
-		sum32 += p[i];
-	}
-
-	while( HIWORD(sum32) ) {
-		sum32 = HIWORD(sum32) + LOWORD(sum32);
-	}
-	sum32 = ~sum32;
-	udp->checksum = htons((uint16)sum32);
-	*/
-}
-
-void error_winsock_2_icmp( int err, ip_t *ip_err, int dlen_err )
-{
-	int type = -1, code = -1, msg_size = 0;
-
-	switch( err ) {
-		case WSAEHOSTUNREACH:
-		case WSAETIMEDOUT:
-			type = icmp_Destination_unreachable;
-			code = 1;	// Host unreachable
-			msg_size = (ip_err->header_len << 2) + 4 + 8; // ip header + unused + 64 msg bits
-			break;
-		case WSAENETDOWN:
-		case WSAENETUNREACH:
-			type = icmp_Destination_unreachable;
-			code = 0;	// Network unreachable
-			msg_size = (ip_err->header_len << 2) + 4 + 8; // ip header + unused + 64 msg bits
-			break;
-		case WSAETTLEXCEEDED:
-			type = icmp_Time_exceeded;
-			code = 0;		// Transit TTL exceeded
-			msg_size = (ip_err->header_len << 2) + 4 + 8; // ip header + unused + 64 msg bits
-			break;
-	}
-
-	if(type >= 0 && macos_ip_address != 0) {
-	  D(bug("sending icmp error reply. type=%d, code=%d, msg_size=%d\r\n", type, code, msg_size));
-
-		int icmp_size = sizeof(icmp_t) + msg_size;
-
-		icmp_t *icmp = (icmp_t *)malloc( icmp_size );
-		if(icmp) {
-			mac_t *mac = (mac_t *)icmp;
-			ip_t *ip = (ip_t *)icmp;
-
-			memcpy( mac->dest, ether_addr, 6 );
-			memcpy( mac->src, router_mac_addr, 6 );
-			mac->type = htons(mac_type_ip4);
-
-			ip->version = 4;
-			ip->header_len = 5;
-			ip->tos = 0;
-			ip->total_len = htons(sizeof(icmp_t) - sizeof(mac_t) + msg_size);
-
-			ip->ident = htons(next_ip_ident_number++);
-			ip->flags_n_frag_offset = 0;
-			ip->ttl = 128;
-			ip->proto = ip_proto_icmp;
-			ip->src = htonl(router_ip_address);
-			ip->dest = htonl(macos_ip_address);
-			make_ip4_checksum( ip );
-
-			icmp->type = type;
-			icmp->code = code;
-
-			// zero out the unused field
-			memset( (char *)icmp + sizeof(icmp_t), 0, sizeof(uint32) );
-
-			// copy 64 bits of original message
-			memcpy(
-				(char *)icmp + sizeof(icmp_t) + sizeof(uint32),
-				(char *)ip_err + sizeof(mac_t),
-				msg_size
-			);
-
-			make_icmp_checksum( icmp, icmp_size );
-
-			dump_bytes( (uint8 *)icmp, icmp_size );
-
-			enqueue_packet( (uint8 *)icmp, icmp_size );
-			free(icmp);
-		}
-	}
-}
+/*
+ *  iphelp.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include "cpu_emulation.h"
+#include "ether_windows.h"
+#include "ether.h"
+#include "router.h"
+#include "router_types.h"
+#include "tcp.h"
+#include "icmp.h"
+#include "udp.h"
+#include "iphelp.h"
+#include "dump.h"
+
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+
+void make_icmp_checksum( icmp_t *icmp, int len )
+{
+	icmp->checksum = 0;
+
+	uint16 sz = (len-sizeof(ip_t))/2;
+	uint16 *p = (uint16 *)( (uint8 *)icmp + sizeof(ip_t) );
+
+	uint32 sum32 = 0;
+	for( int i=0; i<sz; i++ ) {
+		sum32 += ntohs(p[i]);
+	}
+
+	while( HIWORD(sum32) ) {
+		sum32 = HIWORD(sum32) + LOWORD(sum32);
+	}
+	sum32 = ~sum32;
+	icmp->checksum = htons((uint16)sum32);
+}
+
+void make_tcp_checksum( tcp_t *tcp, int len )
+{
+	tcp->checksum = 0;
+
+	int tcp_len = len - sizeof(ip_t);
+	uint16 sz = tcp_len/2;
+	uint16 *p = (uint16 *)( (uint8 *)tcp + sizeof(ip_t) );
+
+	uint32 sum32 = 0;
+	for( int i=0; i<sz; i++ ) {
+		sum32 += ntohs(p[i]);
+	}
+
+	if(len & 1) {
+		uint8 *p8 = (uint8 *)p;
+		sum32 += p8[tcp_len-1] << 8;
+	}
+
+	pseudo_ip_t pseudo;
+	pseudo.src_lo = LOWORD(ntohl(tcp->ip.src));
+	pseudo.src_hi = HIWORD(ntohl(tcp->ip.src));
+	pseudo.dest_lo = LOWORD(ntohl(tcp->ip.dest));
+	pseudo.dest_hi = HIWORD(ntohl(tcp->ip.dest));
+	pseudo.proto = (uint16)tcp->ip.proto;
+	pseudo.msg_len = tcp->header_len >> 2;
+
+	int datalen = len - sizeof(tcp_t);
+	pseudo.msg_len += datalen;
+
+	p = (uint16 *)&pseudo;
+
+	for( int i=0; i<sizeof(pseudo_ip_t)/2; i++ ) {
+		sum32 += p[i];
+	}
+
+	while( HIWORD(sum32) ) {
+		sum32 = HIWORD(sum32) + LOWORD(sum32);
+	}
+	sum32 = ~sum32;
+	tcp->checksum = htons((uint16)sum32);
+}
+
+void make_ip4_checksum( ip_t *ip )
+{
+	ip->checksum = 0;
+	uint16 sz = ip->header_len * 2;
+	uint16 *p = (uint16 *)( (uint8 *)ip + sizeof(mac_t) );
+
+	uint32 sum32 = 0;
+	for( int i=0; i<sz; i++ ) {
+		sum32 += ntohs(p[i]);
+	}
+
+	while( HIWORD(sum32) ) {
+		sum32 = HIWORD(sum32) + LOWORD(sum32);
+	}
+
+	sum32 = ~sum32;
+	ip->checksum = htons((uint16)sum32);
+}
+
+void make_udp_checksum( udp_t *udp )
+{
+	udp->checksum = 0;
+	return;
+
+	// UDP checksums are optional.
+
+	/*
+	uint16 sz = ntohs(udp->msg_len) / 2;
+	uint16 *p = (uint16 *)( (uint8 *)udp + sizeof(ip_t) );
+
+	uint32 sum32 = 0;
+	for( int i=0; i<sz; i++ ) {
+		sum32 += ntohs(p[i]);
+	}
+
+	// last byte??
+
+	pseudo_ip_t pseudo;
+	pseudo.src_lo = LOWORD(ntohl(udp->ip.src));
+	pseudo.src_hi = HIWORD(ntohl(udp->ip.src));
+	pseudo.dest_lo = LOWORD(ntohl(udp->ip.dest));
+	pseudo.dest_hi = HIWORD(ntohl(udp->ip.dest));
+	pseudo.proto = (uint16)udp->ip.proto;
+	pseudo.msg_len = ntohs(udp->msg_len); // ???
+
+	p = (uint16 *)&pseudo;
+
+	for( i=0; i<sizeof(pseudo_ip_t)/2; i++ ) {
+		sum32 += p[i];
+	}
+
+	while( HIWORD(sum32) ) {
+		sum32 = HIWORD(sum32) + LOWORD(sum32);
+	}
+	sum32 = ~sum32;
+	udp->checksum = htons((uint16)sum32);
+	*/
+}
+
+void error_winsock_2_icmp( int err, ip_t *ip_err, int dlen_err )
+{
+	int type = -1, code = -1, msg_size = 0;
+
+	switch( err ) {
+		case WSAEHOSTUNREACH:
+		case WSAETIMEDOUT:
+			type = icmp_Destination_unreachable;
+			code = 1;	// Host unreachable
+			msg_size = (ip_err->header_len << 2) + 4 + 8; // ip header + unused + 64 msg bits
+			break;
+		case WSAENETDOWN:
+		case WSAENETUNREACH:
+			type = icmp_Destination_unreachable;
+			code = 0;	// Network unreachable
+			msg_size = (ip_err->header_len << 2) + 4 + 8; // ip header + unused + 64 msg bits
+			break;
+		case WSAETTLEXCEEDED:
+			type = icmp_Time_exceeded;
+			code = 0;		// Transit TTL exceeded
+			msg_size = (ip_err->header_len << 2) + 4 + 8; // ip header + unused + 64 msg bits
+			break;
+	}
+
+	if(type >= 0 && macos_ip_address != 0) {
+	  D(bug("sending icmp error reply. type=%d, code=%d, msg_size=%d\r\n", type, code, msg_size));
+
+		int icmp_size = sizeof(icmp_t) + msg_size;
+
+		icmp_t *icmp = (icmp_t *)malloc( icmp_size );
+		if(icmp) {
+			mac_t *mac = (mac_t *)icmp;
+			ip_t *ip = (ip_t *)icmp;
+
+			memcpy( mac->dest, ether_addr, 6 );
+			memcpy( mac->src, router_mac_addr, 6 );
+			mac->type = htons(mac_type_ip4);
+
+			ip->version = 4;
+			ip->header_len = 5;
+			ip->tos = 0;
+			ip->total_len = htons(sizeof(icmp_t) - sizeof(mac_t) + msg_size);
+
+			ip->ident = htons(next_ip_ident_number++);
+			ip->flags_n_frag_offset = 0;
+			ip->ttl = 128;
+			ip->proto = ip_proto_icmp;
+			ip->src = htonl(router_ip_address);
+			ip->dest = htonl(macos_ip_address);
+			make_ip4_checksum( ip );
+
+			icmp->type = type;
+			icmp->code = code;
+
+			// zero out the unused field
+			memset( (char *)icmp + sizeof(icmp_t), 0, sizeof(uint32) );
+
+			// copy 64 bits of original message
+			memcpy( 
+				(char *)icmp + sizeof(icmp_t) + sizeof(uint32),
+				(char *)ip_err + sizeof(mac_t),
+				msg_size
+			);
+
+			make_icmp_checksum( icmp, icmp_size );
+
+			dump_bytes( (uint8 *)icmp, icmp_size );
+
+			enqueue_packet( (uint8 *)icmp, icmp_size );
+			free(icmp);
+		}
+	}
+}
--- macemu/SheepShaver/src/Windows/router/iphelp.h
+++ sheepshaver/SheepShaver/src/Windows/router/iphelp.h
@@ -1,36 +1,36 @@
-/*
- *  iphelp.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _IPHELP_H_
-#define _IPHELP_H_
-
-// Fake ttl exceeded code.
-#define WSAETTLEXCEEDED  (WSABASEERR + 1999 + 17)
-
-void error_winsock_2_icmp( int err, ip_t *ip_err, int dlen_err );
-
-void make_icmp_checksum( icmp_t *icmp, int len );
-void make_ip4_checksum( ip_t *ip );
-void make_udp_checksum( udp_t *udp );
-void make_tcp_checksum( tcp_t *tcp, int len );
-
-#endif // _IPHELP_H_
+/*
+ *  iphelp.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _IPHELP_H_
+#define _IPHELP_H_
+
+// Fake ttl exceeded code.
+#define WSAETTLEXCEEDED  (WSABASEERR + 1999 + 17)
+
+void error_winsock_2_icmp( int err, ip_t *ip_err, int dlen_err );
+
+void make_icmp_checksum( icmp_t *icmp, int len );
+void make_ip4_checksum( ip_t *ip );
+void make_udp_checksum( udp_t *udp );
+void make_tcp_checksum( tcp_t *tcp, int len );
+
+#endif // _IPHELP_H_
--- macemu/SheepShaver/src/Windows/router/ipsocket.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/ipsocket.cpp
@@ -1,266 +1,265 @@
-/*
- *  ipsocket.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "main.h"
-#include "cpu_emulation.h"
-#include "ws2tcpip.h"
-#include "prefs.h"
-#include "ether_windows.h"
-#include "ether.h"
-#include "router.h"
-#include "router_types.h"
-#include "dynsockets.h"
-#include "ipsocket.h"
-#include "icmp.h"
-#include "tcp.h"
-#include "udp.h"
-#include "dump.h"
-
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-
-socket_t::socket_t( int _proto )
-{
-	s = INVALID_SOCKET;
-	proto = _proto;
-
-	ip_src = ip_dest = 0;
-	src_port = dest_port = 0;
-
-	memset( &overlapped, 0, sizeof(overlapped) );
-	overlapped.hEvent = (HANDLE)this;
-
-	bytes_received = 0;
-	flags = 0;
-	from_len = sizeof(struct sockaddr_in);
-	memset( &from, 0, sizeof(from) );
-	from.sin_family = AF_INET;
-
-	buffer_count = 1;
-	buffers[0].len = 1460;
-	buffers[0].buf = new char [buffers[0].len];
-
-	out_buffers[0].len = 1460;
-	out_buffers[0].buf = new char [out_buffers[0].len];
-
-	socket_ttl = GetTickCount() + 60000L;
-	permanent = false;
-}
-
-socket_t::~socket_t()
-{
-	if(s != INVALID_SOCKET) {
-		_closesocket( s ); // slam!
-		s = INVALID_SOCKET;
-	}
-	delete [] out_buffers[0].buf;
-	delete [] buffers[0].buf;
-}
-
-int socket_t::WSARecvFrom()
-{
-	return _WSARecvFrom(
-		s,
-		buffers,
-		buffer_count,
-		&bytes_received,
-		&flags,
-		(struct sockaddr *)&from,
-		&from_len,
-		&overlapped,
-		proto == IPPROTO_UDP ? udp_read_completion : icmp_read_completion
-	);
-}
-
-bool socket_t::b_recfrom()
-{
-	bool result;
-
-	int ret = WSARecvFrom();
-
-	if(ret == SOCKET_ERROR) {
-		int socket_error = _WSAGetLastError();
-		if(socket_error == WSA_IO_PENDING) {
-			D(bug("WSARecvFrom() i/o pending\r\n"));
-			result = true;
-		} else {
-			D(bug("_WSAGetLastError() returned %d\r\n", socket_error));
-			result = false;
-		}
-	} else /*if(ret == 0) */ {
-		D(bug("WSARecvFrom() ok\r\n"));
-		// Completion routine call is already scheduled.
-		result = true;
-	}
-	return result;
-}
-
-void socket_t::set_ttl( uint8 ttl )
-{
-	int _ttl = ttl; // defensive programming, I know VCx
-
-	if(_setsockopt( s, IPPROTO_IP, IP_TTL, (const char *)&_ttl, sizeof(int) ) == SOCKET_ERROR  ) {
-		D(bug("could not set ttl to %d.\r\n", ttl));
-	} else {
-		D(bug("ttl set to %d.\r\n", ttl));
-	}
-}
-
-
-#define MAX_OPEN_SOCKETS 1024
-static socket_t *all_sockets[MAX_OPEN_SOCKETS];
-static int open_sockets = 0;
-
-int get_socket_index( uint16 src_port, uint16 dest_port, int proto )
-{
-	int result = -1;
-	for( int i=0; i<open_sockets; i++ ) {
-		socket_t *cmpl = all_sockets[i];
-		if(cmpl->src_port == src_port && cmpl->dest_port == dest_port && cmpl->proto == proto ) {
-			result = i;
-			break;
-		}
-	}
-	return result;
-}
-
-int get_socket_index( uint16 src_port, int proto )
-{
-	int result = -1;
-	for( int i=0; i<open_sockets; i++ ) {
-		socket_t *cmpl = all_sockets[i];
-		if(cmpl->src_port == src_port && cmpl->proto == proto ) {
-			result = i;
-			break;
-		}
-	}
-	return result;
-}
-
-int get_socket_index( socket_t *cmpl )
-{
-	int result = -1;
-	for( int i=0; i<open_sockets; i++ ) {
-		if(cmpl == all_sockets[i]) {
-			result = i;
-			break;
-		}
-	}
-	return result;
-}
-
-void delete_socket( socket_t *cmpl )
-{
-  D(bug("deleting socket(%d,%d)\r\n", cmpl->src_port, cmpl->dest_port));
-
-	EnterCriticalSection( &router_section );
-	int i = get_socket_index( cmpl );
-	if( i >= 0 ) {
-		delete all_sockets[i];
-		all_sockets[i] = all_sockets[--open_sockets];
-	} else {
-	  D(bug("Deleted socket not in table!\r\n"));
-		// delete cmpl;
-	}
-	LeaveCriticalSection( &router_section );
-}
-
-socket_t *find_socket( uint16 src_port, uint16 dest_port, int proto )
-{
-	socket_t *result = 0;
-	EnterCriticalSection( &router_section );
-	int i = get_socket_index( src_port, dest_port, proto );
-	if( i >= 0 ) {
-		result = all_sockets[i];
-	} else {
-		i = get_socket_index( src_port, proto );
-		if( i >= 0 ) {
-			delete_socket( all_sockets[i] );
-		}
-	}
-	LeaveCriticalSection( &router_section );
-
-  D(bug("find_socket(%d,%d): %s\r\n", src_port, dest_port, result ? "found" : "not found"));
-
-	return result;
-}
-
-void add_socket( socket_t *cmpl )
-{
-  D(bug("adding socket(%d,%d)\r\n", cmpl->src_port, cmpl->dest_port));
-
-	EnterCriticalSection( &router_section );
-	if( open_sockets < MAX_OPEN_SOCKETS ) {
-		all_sockets[open_sockets++] = cmpl;
-	} else {
-		// Urgchiyuppijee! (that's finnish language, meaning "do something about this")
-		delete all_sockets[0];
-		all_sockets[0] = cmpl;
-	}
-	LeaveCriticalSection( &router_section );
-}
-
-void close_old_sockets()
-{
-	DWORD now = GetTickCount();
-
-	EnterCriticalSection( &router_section );
-	for( int i=open_sockets-1; i>=0; i-- ) {
-		socket_t *cmpl = all_sockets[i];
-		if( !cmpl->permanent && now >= cmpl->socket_ttl ) {
-		  D(bug("expiring socket(%d,%d)\r\n", cmpl->src_port, cmpl->dest_port));
-			if(cmpl->s == INVALID_SOCKET) {
-				delete all_sockets[i];
-				all_sockets[i] = all_sockets[--open_sockets];
-			} else {
-				// read completion will deallocate
-				_closesocket( cmpl->s );
-			}
-		}
-	}
-	LeaveCriticalSection( &router_section );
-}
-
-void close_all_sockets()
-{
-  D(bug("closing all(%d) sockets\r\n", open_sockets));
-
-	EnterCriticalSection( &router_section );
-	for( int i=0; i<open_sockets; i++ ) {
-		socket_t *cmpl = all_sockets[i];
-	  D(bug("closing socket(%d,%d)\r\n", cmpl->src_port, cmpl->dest_port));
-		if(cmpl->s == INVALID_SOCKET) {
-			delete all_sockets[i];
-			all_sockets[i] = all_sockets[--open_sockets];
-		} else {
-			// read completion will deallocate
-			_closesocket( cmpl->s );
-		}
-	}
-	LeaveCriticalSection( &router_section );
-}
+/*
+ *  ipsocket.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include "cpu_emulation.h"
+#include "ws2tcpip.h"
+#include "prefs.h"
+#include "ether_windows.h"
+#include "ether.h"
+#include "router.h"
+#include "router_types.h"
+#include "dynsockets.h"
+#include "ipsocket.h"
+#include "icmp.h"
+#include "tcp.h"
+#include "udp.h"
+#include "dump.h"
+
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+
+socket_t::socket_t( int _proto )
+{
+	s = INVALID_SOCKET;
+	proto = _proto;
+
+	ip_src = ip_dest = 0;
+	src_port = dest_port = 0;
+
+	memset( &overlapped, 0, sizeof(overlapped) );
+	overlapped.hEvent = (HANDLE)this;
+
+	bytes_received = 0;
+	flags = 0;
+	from_len = sizeof(struct sockaddr_in);
+	memset( &from, 0, sizeof(from) );
+	from.sin_family = AF_INET;
+
+	buffer_count = 1;
+	buffers[0].len = 1460;
+	buffers[0].buf = new char [buffers[0].len];
+	
+	out_buffers[0].len = 1460;
+	out_buffers[0].buf = new char [out_buffers[0].len];
+
+	socket_ttl = GetTickCount() + 60000L;
+	permanent = false;
+}
+
+socket_t::~socket_t()
+{
+	if(s != INVALID_SOCKET) {
+		_closesocket( s ); // slam!
+		s = INVALID_SOCKET;
+	}
+	delete [] out_buffers[0].buf;
+	delete [] buffers[0].buf;
+}
+
+int socket_t::WSARecvFrom()
+{
+	return _WSARecvFrom(
+		s,                                               
+		buffers,
+		buffer_count,
+		&bytes_received,
+		&flags,
+		(struct sockaddr *)&from,
+		&from_len,
+		&overlapped,
+		proto == IPPROTO_UDP ? udp_read_completion : icmp_read_completion
+	);
+}
+
+bool socket_t::b_recfrom()
+{
+	bool result;
+
+	int ret = WSARecvFrom();
+
+	if(ret == SOCKET_ERROR) {
+		int socket_error = _WSAGetLastError();
+		if(socket_error == WSA_IO_PENDING) {
+			D(bug("WSARecvFrom() i/o pending\r\n"));
+			result = true;
+		} else {
+			D(bug("_WSAGetLastError() returned %d\r\n", socket_error));
+			result = false;
+		}
+	} else /*if(ret == 0) */ {
+		D(bug("WSARecvFrom() ok\r\n"));
+		// Completion routine call is already scheduled.
+		result = true;
+	}
+	return result;
+}
+
+void socket_t::set_ttl( uint8 ttl )
+{
+	int _ttl = ttl; // defensive programming, I know VCx
+
+	if(_setsockopt( s, IPPROTO_IP, IP_TTL, (const char *)&_ttl, sizeof(int) ) == SOCKET_ERROR  ) {
+		D(bug("could not set ttl to %d.\r\n", ttl));
+	} else {
+		D(bug("ttl set to %d.\r\n", ttl));
+	}
+}
+
+
+#define MAX_OPEN_SOCKETS 1024
+static socket_t *all_sockets[MAX_OPEN_SOCKETS];
+static int open_sockets = 0;
+
+int get_socket_index( uint16 src_port, uint16 dest_port, int proto )
+{
+	int result = -1;
+	for( int i=0; i<open_sockets; i++ ) {
+		socket_t *cmpl = all_sockets[i];
+		if(cmpl->src_port == src_port && cmpl->dest_port == dest_port && cmpl->proto == proto ) {
+			result = i;
+			break;
+		}
+	}
+	return result;
+}
+
+int get_socket_index( uint16 src_port, int proto )
+{
+	int result = -1;
+	for( int i=0; i<open_sockets; i++ ) {
+		socket_t *cmpl = all_sockets[i];
+		if(cmpl->src_port == src_port && cmpl->proto == proto ) {
+			result = i;
+			break;
+		}
+	}
+	return result;
+}
+
+int get_socket_index( socket_t *cmpl )
+{
+	int result = -1;
+	for( int i=0; i<open_sockets; i++ ) {
+		if(cmpl == all_sockets[i]) {
+			result = i;
+			break;
+		}
+	}
+	return result;
+}
+
+void delete_socket( socket_t *cmpl )
+{
+  D(bug("deleting socket(%d,%d)\r\n", cmpl->src_port, cmpl->dest_port));
+
+	EnterCriticalSection( &router_section );
+	int i = get_socket_index( cmpl );
+	if( i >= 0 ) {
+		delete all_sockets[i];
+		all_sockets[i] = all_sockets[--open_sockets];
+	} else {
+	  D(bug("Deleted socket not in table!\r\n"));
+		// delete cmpl;
+	}
+	LeaveCriticalSection( &router_section );
+}
+
+socket_t *find_socket( uint16 src_port, uint16 dest_port, int proto )
+{
+	socket_t *result = 0;
+	EnterCriticalSection( &router_section );
+	int i = get_socket_index( src_port, dest_port, proto );
+	if( i >= 0 ) {
+		result = all_sockets[i];
+	} else {
+		i = get_socket_index( src_port, proto );
+		if( i >= 0 ) {
+			delete_socket( all_sockets[i] );
+		}
+	}
+	LeaveCriticalSection( &router_section );
+
+  D(bug("find_socket(%d,%d): %s\r\n", src_port, dest_port, result ? "found" : "not found"));
+
+	return result;
+}
+
+void add_socket( socket_t *cmpl )
+{
+  D(bug("adding socket(%d,%d)\r\n", cmpl->src_port, cmpl->dest_port));
+
+	EnterCriticalSection( &router_section );
+	if( open_sockets < MAX_OPEN_SOCKETS ) {
+		all_sockets[open_sockets++] = cmpl;
+	} else {
+		// Urgchiyuppijee! (that's finnish language, meaning "do something about this")
+		delete all_sockets[0];
+		all_sockets[0] = cmpl;
+	}
+	LeaveCriticalSection( &router_section );
+}
+
+void close_old_sockets()
+{
+	DWORD now = GetTickCount();
+
+	EnterCriticalSection( &router_section );
+	for( int i=open_sockets-1; i>=0; i-- ) {
+		socket_t *cmpl = all_sockets[i];
+		if( !cmpl->permanent && now >= cmpl->socket_ttl ) {
+		  D(bug("expiring socket(%d,%d)\r\n", cmpl->src_port, cmpl->dest_port));
+			if(cmpl->s == INVALID_SOCKET) {
+				delete all_sockets[i];
+				all_sockets[i] = all_sockets[--open_sockets];
+			} else {
+				// read completion will deallocate
+				_closesocket( cmpl->s );
+			}
+		}
+	}
+	LeaveCriticalSection( &router_section );
+}
+
+void close_all_sockets()
+{
+  D(bug("closing all(%d) sockets\r\n", open_sockets));
+
+	EnterCriticalSection( &router_section );
+	for( int i=0; i<open_sockets; i++ ) {
+		socket_t *cmpl = all_sockets[i];
+	  D(bug("closing socket(%d,%d)\r\n", cmpl->src_port, cmpl->dest_port));
+		if(cmpl->s == INVALID_SOCKET) {
+			delete all_sockets[i];
+			all_sockets[i] = all_sockets[--open_sockets];
+		} else {
+			// read completion will deallocate
+			_closesocket( cmpl->s );
+		}
+	}
+	LeaveCriticalSection( &router_section );
+}
--- macemu/SheepShaver/src/Windows/router/ipsocket.h
+++ sheepshaver/SheepShaver/src/Windows/router/ipsocket.h
@@ -1,66 +1,66 @@
-/*
- *  ipsocket.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _IPSOCKET_H_
-#define _IPSOCKET_H_
-
-class socket_t {
-public:
-	socket_t( int _proto );
-	~socket_t();
-	bool b_recfrom();
-	void set_ttl( uint8 ttl );
-
-protected:
-	int WSARecvFrom();
-
-public:
-	SOCKET s;				// Always a valid socket
-	BOOL permanent; // T: a user-defined listening socket,
-	int proto;			// udp/icmp
-	WSABUF buffers[1];
-	WSABUF out_buffers[1];
-	DWORD buffer_count;
-	DWORD bytes_received;
-	DWORD flags;
-	struct sockaddr_in from;
-	int from_len;
-	WSAOVERLAPPED overlapped;
-	uint32 ip_src;
-	uint32 ip_dest;
-	uint16 src_port;
-	uint16 dest_port;
-	DWORD socket_ttl;
-};
-
-
-int get_socket_index( uint16 src_port, uint16 dest_port, int proto );
-int get_socket_index( uint16 src_port, int proto );
-int get_socket_index( socket_t *cmpl );
-void delete_socket( socket_t *cmpl );
-socket_t *find_socket( uint16 src_port, uint16 dest_port, int proto );
-void add_socket( socket_t *cmpl );
-void close_old_sockets();
-void close_all_sockets();
-
-
-#endif // _IPSOCKET_H_
+/*
+ *  ipsocket.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _IPSOCKET_H_
+#define _IPSOCKET_H_
+
+class socket_t {
+public:
+	socket_t( int _proto );
+	~socket_t();
+	bool b_recfrom();
+	void set_ttl( uint8 ttl );
+
+protected:
+	int WSARecvFrom();
+
+public:
+	SOCKET s;				// Always a valid socket
+	BOOL permanent; // T: a user-defined listening socket, 
+	int proto;			// udp/icmp
+	WSABUF buffers[1];
+	WSABUF out_buffers[1];
+	DWORD buffer_count;
+	DWORD bytes_received;
+	DWORD flags;
+	struct sockaddr_in from;
+	int from_len;
+	WSAOVERLAPPED overlapped;
+	uint32 ip_src;
+	uint32 ip_dest;
+	uint16 src_port;
+	uint16 dest_port;
+	DWORD socket_ttl;
+};
+
+
+int get_socket_index( uint16 src_port, uint16 dest_port, int proto );
+int get_socket_index( uint16 src_port, int proto );
+int get_socket_index( socket_t *cmpl );
+void delete_socket( socket_t *cmpl );
+socket_t *find_socket( uint16 src_port, uint16 dest_port, int proto );
+void add_socket( socket_t *cmpl );
+void close_old_sockets();
+void close_all_sockets();
+
+
+#endif // _IPSOCKET_H_
--- macemu/SheepShaver/src/Windows/router/mib/interfaces.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/mib/interfaces.cpp
@@ -1,69 +1,68 @@
-/*
- *  interfaces.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "main.h"
-#include "interfaces.h"
-#include "../dump.h"
-#include "mibaccess.h"
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-static UINT ip_array[100];
-static UINT ip_array_sz = 0;
-
-void init_interfaces()
-{
-	MibII _mibs(false);
-
-	ip_array_sz = sizeof(ip_array) / sizeof(ip_array[0]);
-
-	if(_mibs.Init()) {
-		_mibs.GetIPAddress( ip_array, ip_array_sz );
-	}
-
-	if(ip_array_sz == 0) {
-		ip_array_sz = 1;
-		ip_array[0] = 0; // localhost
-	}
-
-	D(bug("init_interfaces() found %d interfaces.\r\n", ip_array_sz));
-}
-
-void final_interfaces()
-{
-	// Currently nothing to do.
-}
-
-int get_ip_count()
-{
-	return ip_array_sz;
-}
-
-uint32 get_ip_by_index( int index )
-{
-	return index >= 0 && index < (int)ip_array_sz ? ip_array[index] : 0;
-}
+/*
+ *  interfaces.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include "interfaces.h"
+#include "../dump.h"
+#include "mibaccess.h"
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+static UINT ip_array[100];
+static UINT ip_array_sz = 0;
+
+void init_interfaces()
+{
+	MibII _mibs(false);
+
+	ip_array_sz = sizeof(ip_array) / sizeof(ip_array[0]);
+
+	if(_mibs.Init()) {
+		_mibs.GetIPAddress( ip_array, ip_array_sz );
+	}
+
+	if(ip_array_sz == 0) {
+		ip_array_sz = 1;
+		ip_array[0] = 0; // localhost
+	}
+
+	D(bug("init_interfaces() found %d interfaces.\r\n", ip_array_sz));
+}
+
+void final_interfaces()
+{
+	// Currently nothing to do.
+}
+
+int get_ip_count()
+{
+	return ip_array_sz;
+}
+
+uint32 get_ip_by_index( int index )
+{
+	return index >= 0 && index < (int)ip_array_sz ? ip_array[index] : 0;
+}
--- macemu/SheepShaver/src/Windows/router/mib/interfaces.h
+++ sheepshaver/SheepShaver/src/Windows/router/mib/interfaces.h
@@ -1,35 +1,35 @@
-/*
- *  intercafes.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _INTERFACES_H_
-#define _INTERFACES_H_
-
-// A wrapper to the MibII class. Enumerates all ip interfaces
-// currently in this computer. The interface list is not static.
-
-void init_interfaces();
-void final_interfaces();
-
-int get_ip_count();
-uint32 get_ip_by_index( int index );
-
-#endif // _INTERFACES_H_
+/*
+ *  intercafes.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _INTERFACES_H_
+#define _INTERFACES_H_
+
+// A wrapper to the MibII class. Enumerates all ip interfaces
+// currently in this computer. The interface list is not static.
+
+void init_interfaces();
+void final_interfaces();
+
+int get_ip_count();
+uint32 get_ip_by_index( int index );
+
+#endif // _INTERFACES_H_
--- macemu/SheepShaver/src/Windows/router/mib/mibaccess.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/mib/mibaccess.cpp
@@ -1,308 +1,308 @@
-/*
- *  MibAccess.cpp
- *
- *	The original code by Stas Khirman modified by Lauri Pesonen, December, 2000:
- *
- *	SnmpUtilVarBindFree(), SnmpUtilOidNCmp() and SnmpUtilOidCpy() now loaded from
- *	"snmpapi.dll" dynamically instead of linking statically.
- *
- *	MibII ctor now takes a parameter whether to load Winsock or not.
- *	WSAStartup maintains an internal reference counter so it would have been ok
- *	to let it load always.
- *
- *	Fixed a bug where the return value of LoadLibrary() was compared against
- *	HINSTANCE_ERROR instead of NULL.
- *
- *	Removed some type conversion warnings by casting.
- *
- *	Added a check in MibExtLoad ctor that the function entry points were found.
- *
- *	Added a check in GetIPMask() and GetIPAddress() that the library was loaded
- *	before accessing the functions.
- *
- *	Changed the return type of GetIPAddress() and GetIPMask() from BOOL  to void
- *	as they always returned TRUE.
- *
- */
-
-/************************************************************************/
-/*      Copyright (C) Stas Khirman 1998.  All rights reserved.          */
-/*      Written by Stas Khirman (staskh@rocketmail.com).                */
-/*					  and											    */
-/*                 Raz Galili (razgalili@hotmail.com)				    */
-/*                                                                      */
-/*      Free software: no warranty; use anywhere is ok; spread the      */
-/*      sources; note any modifications; share variations and           */
-/*      derivatives (including sending to staskh@rocketmail.com).       */
-/*                                                                      */
-/************************************************************************/
-
-/*
- *  MibAccess.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "sysdeps.h"
-#include "main.h"
-#include "mibaccess.h"
-#include "../dynsockets.h"
-#include "../dump.h"
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-MibExtLoad::MibExtLoad( LPCTSTR MibDllName, LPCTSTR SnmpDllName )
-{
-	m_Init = NULL;
-
-	m_InitEx = NULL;
-	m_Query = NULL;
-	m_Trap = NULL;
-
-	m_hInst_snmputil = NULL;
-
-	m_SnmpUtilVarBindFree = NULL;
-	m_SnmpUtilOidNCmp = NULL;
-	m_SnmpUtilOidCpy = NULL;
-
-	m_hInst = LoadLibrary( MibDllName );
-	if(!m_hInst) {
-		D(bug(TEXT("MIB: library %s could not be loaded.\r\n"), MibDllName));
-		return;
-	}
-	D(bug(TEXT("MIB: library %s loaded ok.\r\n"), MibDllName));
-
-	m_Init	=	(pSnmpExtensionInit)GetProcAddress(m_hInst ,"SnmpExtensionInit");
-	m_InitEx=	(pSnmpExtensionInitEx)GetProcAddress(m_hInst ,"SnmpExtensionInitEx");
-	m_Query	=	(pSnmpExtensionQuery)GetProcAddress(m_hInst ,"SnmpExtensionQuery");
-	m_Trap	=	(pSnmpExtensionTrap)GetProcAddress(m_hInst ,"SnmpExtensionTrap");
-
-	if( !m_Init || !m_InitEx || !m_Query || !m_Trap )
-	{
-		D(bug(TEXT("MIB: required entry points not found in library %s.\r\n"), MibDllName));
-		FreeLibrary( m_hInst );
-		m_hInst = NULL;
-	}
-
-	m_hInst_snmputil = LoadLibrary( SnmpDllName );
-	if(!m_hInst_snmputil){
-		D(bug(TEXT("MIB: library %s could not be loaded.\r\n"), SnmpDllName));
-		FreeLibrary( m_hInst );
-		m_hInst = NULL;
-		return;
-	}
-	D(bug(TEXT("MIB: library %s loaded ok.\r\n"), SnmpDllName));
-
-	m_SnmpUtilVarBindFree = (VOID (SNMP_FUNC_TYPE *)(SnmpVarBind *))GetProcAddress( m_hInst_snmputil, "SnmpUtilVarBindFree" );
-	m_SnmpUtilOidNCmp = (SNMPAPI (SNMP_FUNC_TYPE *)(AsnObjectIdentifier *, AsnObjectIdentifier *, UINT))GetProcAddress( m_hInst_snmputil, "SnmpUtilOidNCmp" );
-	m_SnmpUtilOidCpy = (SNMPAPI (SNMP_FUNC_TYPE *)(AsnObjectIdentifier *, AsnObjectIdentifier *))GetProcAddress( m_hInst_snmputil, "SnmpUtilOidCpy" );
-
-	if( !m_SnmpUtilVarBindFree || !m_SnmpUtilOidNCmp || !m_SnmpUtilOidCpy )
-	{
-		D(bug(TEXT("MIB: required entry points not found in library %s.\r\n"), SnmpDllName));
-		FreeLibrary( m_hInst );
-		FreeLibrary( m_hInst_snmputil );
-		m_hInst = NULL;
-		m_hInst_snmputil = NULL;
-	}
-
-	#undef SNMP_FreeVarBind
-	#undef SNMP_oidncmp
-	#undef SNMP_oidcpy
-
-	#define SNMP_FreeVarBind   m_SnmpUtilVarBindFree
-	#define SNMP_oidncmp       m_SnmpUtilOidNCmp
-	#define SNMP_oidcpy        m_SnmpUtilOidCpy
-}
-
-MibExtLoad::~MibExtLoad()
-{
-	if( m_hInst ) {
-		FreeLibrary( m_hInst );
-		m_hInst = NULL;
-	}
-	if( m_hInst_snmputil ) {
-		FreeLibrary( m_hInst_snmputil );
-		m_hInst_snmputil = NULL;
-	}
-}
-
-BOOL MibExtLoad::Init(DWORD dwTimeZeroReference,HANDLE *hPollForTrapEvent,AsnObjectIdentifier *supportedView)
-{
-	if(m_hInst && m_Init)
-		return m_Init(dwTimeZeroReference,hPollForTrapEvent,supportedView);
-	return FALSE;
-}
-BOOL MibExtLoad::InitEx(AsnObjectIdentifier *supportedView)
-{
-	if(m_hInst && m_InitEx)
-		return m_InitEx(supportedView);
-
-	return FALSE;
-}
-
-BOOL MibExtLoad::Query(BYTE requestType,OUT RFC1157VarBindList *variableBindings,
-					   AsnInteger *errorStatus,AsnInteger *errorIndex)
-{
-	if(m_hInst && m_Query)
-		return m_Query(requestType,variableBindings,errorStatus,errorIndex);
-
-	return FALSE;
-}
-
-BOOL MibExtLoad::Trap(AsnObjectIdentifier *enterprise, AsnInteger *genericTrap,
-					  AsnInteger *specificTrap, AsnTimeticks *timeStamp,
-					  RFC1157VarBindList  *variableBindings)
-{
-	if(m_hInst && m_Trap)
-		return m_Trap(enterprise, genericTrap,specificTrap, timeStamp, variableBindings);
-
-	return FALSE;
-}
-
-MibII::MibII(bool load_winsock) : MibExtLoad(TEXT("inetmib1.dll"), TEXT("snmpapi.dll"))
-{
-  WSADATA wsa;
-	m_load_winsock = load_winsock;
-	if(load_winsock) {
-		int err = _WSAStartup( 0x0101, &wsa );
-	}
-}
-
-MibII::~MibII()
-{
-  if(m_load_winsock) _WSACleanup();
-}
-
-BOOL MibII::Init()
-{
-	HANDLE PollForTrapEvent;
-	AsnObjectIdentifier SupportedView;
-
-	return MibExtLoad::Init(GetTickCount(),&PollForTrapEvent,&SupportedView);
-
-}
-
-
-void MibII::GetIPAddress( UINT IpArray[], UINT &IpArraySize )
-{
-	if(!m_hInst) {
-		IpArraySize = 0;
-		return;
-	}
-
-	UINT OID_ipAdEntAddr[] = { 1, 3, 6, 1, 2, 1, 4 , 20, 1 ,1 };
-	AsnObjectIdentifier MIB_ipAdEntAddr = { sizeof(OID_ipAdEntAddr)/sizeof(UINT), OID_ipAdEntAddr };
-	RFC1157VarBindList  varBindList;
-	RFC1157VarBind      varBind[1];
-	AsnInteger          errorStatus;
-	AsnInteger          errorIndex;
-	AsnObjectIdentifier MIB_NULL = {0,0};
-	BOOL                Exit;
-	int                 ret;
-	int                 IpCount=0;
-	DWORD               dtmp;
-
-	varBindList.list = varBind;
-	varBindList.len  = 1;
-	varBind[0].name  = MIB_NULL;
-	SNMP_oidcpy(&varBind[0].name,&MIB_ipAdEntAddr);
-	Exit = FALSE;
-
-	IpCount=0;
-	while(!Exit){
-		ret = Query(ASN_RFC1157_GETNEXTREQUEST,&varBindList,&errorStatus,&errorIndex);
-
-		if(!ret)
-			Exit=TRUE;
-		else{
-			ret = SNMP_oidncmp(&varBind[0].name,&MIB_ipAdEntAddr,MIB_ipAdEntAddr.idLength);
-			if(ret!=0){
-				Exit=TRUE;
-			}
-			else{
-				dtmp = *((DWORD *)varBind[0].value.asnValue.address.stream);
-				IpArray[IpCount] = dtmp;
-				IpCount++;
-				if(IpCount>=(int)IpArraySize)
-					Exit = TRUE;
-			}
-		}
-	}
-
-	IpArraySize = IpCount;
-
-	SNMP_FreeVarBind(&varBind[0]);
-}
-
-void MibII::GetIPMask( UINT IpArray[], UINT &IpArraySize )
-{
-	if(!m_hInst) {
-		IpArraySize = 0;
-		return;
-	}
-
-	UINT OID_ipAdEntMask[] = { 1, 3, 6, 1, 2, 1, 4 , 20, 1 ,3 };
-	AsnObjectIdentifier MIB_ipAdEntMask = { sizeof(OID_ipAdEntMask)/sizeof(UINT), OID_ipAdEntMask };
-	RFC1157VarBindList  varBindList;
-	RFC1157VarBind      varBind[1];
-	AsnInteger          errorStatus;
-	AsnInteger          errorIndex;
-	AsnObjectIdentifier MIB_NULL = {0,0};
-	BOOL                Exit;
-	int                 ret;
-	int                 IpCount=0;
-	DWORD               dtmp;
-
-	varBindList.list = varBind;
-	varBindList.len  = 1;
-	varBind[0].name  = MIB_NULL;
-	SNMP_oidcpy(&varBind[0].name,&MIB_ipAdEntMask);
-	Exit = FALSE;
-
-	IpCount=0;
-	while(!Exit){
-		ret = Query(ASN_RFC1157_GETNEXTREQUEST,&varBindList,&errorStatus,&errorIndex);
-
-		if(!ret)
-			Exit=TRUE;
-		else{
-			ret = SNMP_oidncmp(&varBind[0].name,&MIB_ipAdEntMask,MIB_ipAdEntMask.idLength);
-			if(ret!=0){
-				Exit=TRUE;
-			}
-			else{
-				dtmp = *((DWORD *)varBind[0].value.asnValue.address.stream);
-				IpArray[IpCount] = dtmp;
-				IpCount++;
-				if(IpCount>=(int)IpArraySize)
-					Exit = TRUE;
-			}
-		}
-	}
-
-	IpArraySize = IpCount;
-
-	SNMP_FreeVarBind(&varBind[0]);
-}
+/*
+ *  MibAccess.cpp
+ *
+ *	The original code by Stas Khirman modified by Lauri Pesonen, December, 2000:
+ *	
+ *	SnmpUtilVarBindFree(), SnmpUtilOidNCmp() and SnmpUtilOidCpy() now loaded from
+ *	"snmpapi.dll" dynamically instead of linking statically.
+ *	
+ *	MibII ctor now takes a parameter whether to load Winsock or not.
+ *	WSAStartup maintains an internal reference counter so it would have been ok
+ *	to let it load always.
+ *	
+ *	Fixed a bug where the return value of LoadLibrary() was compared against
+ *	HINSTANCE_ERROR instead of NULL.
+ *	
+ *	Removed some type conversion warnings by casting.
+ *	
+ *	Added a check in MibExtLoad ctor that the function entry points were found.
+ *	
+ *	Added a check in GetIPMask() and GetIPAddress() that the library was loaded
+ *	before accessing the functions.
+ *	
+ *	Changed the return type of GetIPAddress() and GetIPMask() from BOOL  to void
+ *	as they always returned TRUE.
+ *	
+ */
+
+/************************************************************************/
+/*      Copyright (C) Stas Khirman 1998.  All rights reserved.          */
+/*      Written by Stas Khirman (staskh@rocketmail.com).                */
+/*					  and											    */
+/*                 Raz Galili (razgalili@hotmail.com)				    */
+/*                                                                      */
+/*      Free software: no warranty; use anywhere is ok; spread the      */
+/*      sources; note any modifications; share variations and           */
+/*      derivatives (including sending to staskh@rocketmail.com).       */
+/*                                                                      */
+/************************************************************************/
+
+/*
+ *  MibAccess.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include "sysdeps.h"
+#include "mibaccess.h"
+#include "../dynsockets.h"
+#include "../dump.h"
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+MibExtLoad::MibExtLoad( LPSTR MibDllName, LPSTR SnmpDllName )
+{
+	
+	m_Init = NULL;
+
+	m_InitEx = NULL;
+	m_Query = NULL;	
+	m_Trap = NULL;
+
+	m_hInst_snmputil = NULL;
+
+	m_SnmpUtilVarBindFree = NULL;
+	m_SnmpUtilOidNCmp = NULL;
+	m_SnmpUtilOidCpy = NULL;
+	
+	m_hInst = LoadLibrary( MibDllName );
+	if(!m_hInst) {
+		D(bug("MIB: library %s could not be loaded.\r\n", MibDllName));
+		return;
+	}
+	D(bug("MIB: library %s loaded ok.\r\n", MibDllName));
+
+	m_Init	=	(pSnmpExtensionInit)GetProcAddress(m_hInst ,"SnmpExtensionInit");
+	m_InitEx=	(pSnmpExtensionInitEx)GetProcAddress(m_hInst ,"SnmpExtensionInitEx");
+	m_Query	=	(pSnmpExtensionQuery)GetProcAddress(m_hInst ,"SnmpExtensionQuery");
+	m_Trap	=	(pSnmpExtensionTrap)GetProcAddress(m_hInst ,"SnmpExtensionTrap");
+
+	if( !m_Init || !m_InitEx || !m_Query || !m_Trap )
+	{
+		D(bug("MIB: required entry points not found in library %s.\r\n", MibDllName));
+		FreeLibrary( m_hInst );
+		m_hInst = NULL;
+	}
+
+	m_hInst_snmputil = LoadLibrary( SnmpDllName );
+	if(!m_hInst_snmputil){
+		D(bug("MIB: library %s could not be loaded.\r\n", SnmpDllName));
+		FreeLibrary( m_hInst );
+		m_hInst = NULL;
+		return;
+	}
+	D(bug("MIB: library %s loaded ok.\r\n", SnmpDllName));
+
+	m_SnmpUtilVarBindFree = (VOID (SNMP_FUNC_TYPE *)(SnmpVarBind *))GetProcAddress( m_hInst_snmputil, "SnmpUtilVarBindFree" );
+	m_SnmpUtilOidNCmp = (SNMPAPI (SNMP_FUNC_TYPE *)(AsnObjectIdentifier *, AsnObjectIdentifier *, UINT))GetProcAddress( m_hInst_snmputil, "SnmpUtilOidNCmp" );
+	m_SnmpUtilOidCpy = (SNMPAPI (SNMP_FUNC_TYPE *)(AsnObjectIdentifier *, AsnObjectIdentifier *))GetProcAddress( m_hInst_snmputil, "SnmpUtilOidCpy" );
+
+	if( !m_SnmpUtilVarBindFree || !m_SnmpUtilOidNCmp || !m_SnmpUtilOidCpy )
+	{
+		D(bug("MIB: required entry points not found in library %s.\r\n", SnmpDllName));
+		FreeLibrary( m_hInst );
+		FreeLibrary( m_hInst_snmputil );
+		m_hInst = NULL;
+		m_hInst_snmputil = NULL;
+	}
+
+	#undef SNMP_FreeVarBind
+	#undef SNMP_oidncmp
+	#undef SNMP_oidcpy
+
+	#define SNMP_FreeVarBind   m_SnmpUtilVarBindFree
+	#define SNMP_oidncmp       m_SnmpUtilOidNCmp
+	#define SNMP_oidcpy        m_SnmpUtilOidCpy
+}
+
+MibExtLoad::~MibExtLoad()
+{
+	if( m_hInst ) {
+		FreeLibrary( m_hInst );
+		m_hInst = NULL;
+	}
+	if( m_hInst_snmputil ) {
+		FreeLibrary( m_hInst_snmputil );
+		m_hInst_snmputil = NULL;
+	}
+}
+
+BOOL MibExtLoad::Init(DWORD dwTimeZeroReference,HANDLE *hPollForTrapEvent,AsnObjectIdentifier *supportedView)
+{
+	if(m_hInst && m_Init)
+		return m_Init(dwTimeZeroReference,hPollForTrapEvent,supportedView);
+	return FALSE;
+}
+BOOL MibExtLoad::InitEx(AsnObjectIdentifier *supportedView)
+{
+	if(m_hInst && m_InitEx)
+		return m_InitEx(supportedView);
+	
+	return FALSE;
+}
+
+BOOL MibExtLoad::Query(BYTE requestType,OUT RFC1157VarBindList *variableBindings,
+					   AsnInteger *errorStatus,AsnInteger *errorIndex)
+{
+	if(m_hInst && m_Query)
+		return m_Query(requestType,variableBindings,errorStatus,errorIndex);
+	
+	return FALSE;
+}
+
+BOOL MibExtLoad::Trap(AsnObjectIdentifier *enterprise, AsnInteger *genericTrap,
+					  AsnInteger *specificTrap, AsnTimeticks *timeStamp, 
+					  RFC1157VarBindList  *variableBindings)
+{
+	if(m_hInst && m_Trap)
+		return m_Trap(enterprise, genericTrap,specificTrap, timeStamp, variableBindings);
+	
+	return FALSE;
+}
+
+MibII::MibII( bool load_winsock ):MibExtLoad("inetmib1.dll","snmpapi.dll")
+{
+  WSADATA wsa;
+	m_load_winsock = load_winsock;
+	if(load_winsock) {
+		int err = _WSAStartup( 0x0101, &wsa );  
+	}
+}
+
+MibII::~MibII()
+{
+  if(m_load_winsock) _WSACleanup();
+}
+
+BOOL MibII::Init()
+{
+	HANDLE PollForTrapEvent;
+	AsnObjectIdentifier SupportedView;
+
+	return MibExtLoad::Init(GetTickCount(),&PollForTrapEvent,&SupportedView);
+
+}
+
+
+void MibII::GetIPAddress( UINT IpArray[], UINT &IpArraySize )
+{
+	if(!m_hInst) {
+		IpArraySize = 0;
+		return;
+	}
+	
+	UINT OID_ipAdEntAddr[] = { 1, 3, 6, 1, 2, 1, 4 , 20, 1 ,1 };
+	AsnObjectIdentifier MIB_ipAdEntAddr = { sizeof(OID_ipAdEntAddr)/sizeof(UINT), OID_ipAdEntAddr };
+	RFC1157VarBindList  varBindList;
+	RFC1157VarBind      varBind[1];
+	AsnInteger          errorStatus;
+	AsnInteger          errorIndex;
+	AsnObjectIdentifier MIB_NULL = {0,0};
+	BOOL                Exit;
+	int                 ret;
+	int                 IpCount=0;
+	DWORD               dtmp;
+	
+	varBindList.list = varBind;
+	varBindList.len  = 1;
+	varBind[0].name  = MIB_NULL;
+	SNMP_oidcpy(&varBind[0].name,&MIB_ipAdEntAddr);
+	Exit = FALSE;
+	
+	IpCount=0;
+	while(!Exit){
+		ret = Query(ASN_RFC1157_GETNEXTREQUEST,&varBindList,&errorStatus,&errorIndex);
+		
+		if(!ret)
+			Exit=TRUE;
+		else{
+			ret = SNMP_oidncmp(&varBind[0].name,&MIB_ipAdEntAddr,MIB_ipAdEntAddr.idLength);
+			if(ret!=0){
+				Exit=TRUE;
+			}
+			else{
+				dtmp = *((DWORD *)varBind[0].value.asnValue.address.stream);
+				IpArray[IpCount] = dtmp;
+				IpCount++;
+				if(IpCount>=(int)IpArraySize)
+					Exit = TRUE;
+			}
+		}
+	}
+	
+	IpArraySize = IpCount;
+	
+	SNMP_FreeVarBind(&varBind[0]);
+}
+
+void MibII::GetIPMask( UINT IpArray[], UINT &IpArraySize )
+{
+	if(!m_hInst) {
+		IpArraySize = 0;
+		return;
+	}
+	
+	UINT OID_ipAdEntMask[] = { 1, 3, 6, 1, 2, 1, 4 , 20, 1 ,3 };
+	AsnObjectIdentifier MIB_ipAdEntMask = { sizeof(OID_ipAdEntMask)/sizeof(UINT), OID_ipAdEntMask };
+	RFC1157VarBindList  varBindList;
+	RFC1157VarBind      varBind[1];
+	AsnInteger          errorStatus;
+	AsnInteger          errorIndex;
+	AsnObjectIdentifier MIB_NULL = {0,0};
+	BOOL                Exit;
+	int                 ret;
+	int                 IpCount=0;
+	DWORD               dtmp;
+	
+	varBindList.list = varBind;
+	varBindList.len  = 1;
+	varBind[0].name  = MIB_NULL;
+	SNMP_oidcpy(&varBind[0].name,&MIB_ipAdEntMask);
+	Exit = FALSE;
+	
+	IpCount=0;
+	while(!Exit){
+		ret = Query(ASN_RFC1157_GETNEXTREQUEST,&varBindList,&errorStatus,&errorIndex);
+		
+		if(!ret)
+			Exit=TRUE;
+		else{
+			ret = SNMP_oidncmp(&varBind[0].name,&MIB_ipAdEntMask,MIB_ipAdEntMask.idLength);
+			if(ret!=0){
+				Exit=TRUE;
+			}
+			else{
+				dtmp = *((DWORD *)varBind[0].value.asnValue.address.stream);
+				IpArray[IpCount] = dtmp;
+				IpCount++;
+				if(IpCount>=(int)IpArraySize)
+					Exit = TRUE;
+			}
+		}
+	}
+	
+	IpArraySize = IpCount;
+	
+	SNMP_FreeVarBind(&varBind[0]);
+}
--- macemu/SheepShaver/src/Windows/router/mib/mibaccess.h
+++ sheepshaver/SheepShaver/src/Windows/router/mib/mibaccess.h
@@ -1,83 +1,83 @@
-//////////////////////////////////////////////////////
-// FILE  : MibAccess.h
-//
-//
-
-#ifndef _SNMP_ACCESS_H_
-#define _SNMP_ACCESS_H_
-
-#include <snmp.h>
-#ifndef SNMP_FUNC_TYPE
-#define SNMP_FUNC_TYPE WINAPI
-#endif
-
-//////////////////////////////////////////////////////////////
-// Definition of pointers to the four functions in the Mib Dll
-//
-typedef BOOL (WINAPI *pSnmpExtensionInit)(
-										  IN  DWORD               dwTimeZeroReference,
-										  OUT HANDLE              *hPollForTrapEvent,
-										  OUT AsnObjectIdentifier *supportedView);
-
-typedef BOOL (WINAPI *pSnmpExtensionTrap)(
-										  OUT AsnObjectIdentifier *enterprise,
-										  OUT AsnInteger          *genericTrap,
-										  OUT AsnInteger          *specificTrap,
-										  OUT AsnTimeticks        *timeStamp,
-										  OUT RFC1157VarBindList  *variableBindings);
-
-typedef BOOL (WINAPI *pSnmpExtensionQuery)(
-										   IN BYTE                   requestType,
-										   IN OUT RFC1157VarBindList *variableBindings,
-										   OUT AsnInteger            *errorStatus,
-										   OUT AsnInteger            *errorIndex);
-
-typedef BOOL (WINAPI *pSnmpExtensionInitEx)(OUT AsnObjectIdentifier *supportedView);
-
-
-class MibExtLoad
-{
-public:
-	MibExtLoad( LPCTSTR MibDllName, LPCTSTR SnmpDllName );
-	~MibExtLoad();
-	BOOL Init(DWORD dwTimeZeroReference,HANDLE *hPollForTrapEvent,AsnObjectIdentifier *supportedView);
-	BOOL InitEx(AsnObjectIdentifier *supportedView);
-	BOOL Query(BYTE requestType,OUT RFC1157VarBindList *variableBindings,
-			AsnInteger *errorStatus,AsnInteger *errorIndex);
-
-	BOOL Trap(AsnObjectIdentifier *enterprise, AsnInteger *genericTrap,
-		AsnInteger *specificTrap, AsnTimeticks *timeStamp,
-		RFC1157VarBindList  *variableBindings);
-
-public:
-	HINSTANCE             m_hInst;
-	HINSTANCE             m_hInst_snmputil;
-
-private:
-	pSnmpExtensionInit    m_Init;
-	pSnmpExtensionInitEx  m_InitEx;
-	pSnmpExtensionQuery   m_Query;
-	pSnmpExtensionTrap    m_Trap;
-
-public:
-	VOID (SNMP_FUNC_TYPE *m_SnmpUtilVarBindFree) (SnmpVarBind *);
-	SNMPAPI (SNMP_FUNC_TYPE *m_SnmpUtilOidNCmp) (AsnObjectIdentifier *, AsnObjectIdentifier *, UINT);
-	SNMPAPI (SNMP_FUNC_TYPE *m_SnmpUtilOidCpy) (AsnObjectIdentifier *, AsnObjectIdentifier *);
-};
-
-
-class MibII: public MibExtLoad
-{
-public:
-	MibII( bool load_winsock );
-	~MibII();
-	BOOL Init();
-
-	void GetIPAddress(UINT IpArray[],UINT &IpArraySize);
-	void GetIPMask(UINT IpArray[],UINT &IpArraySize);
-
-protected:
-	bool m_load_winsock;
-};
-
-#endif
+//////////////////////////////////////////////////////
+// FILE  : MibAccess.h
+//
+//
+
+#ifndef _SNMP_ACCESS_H_
+#define _SNMP_ACCESS_H_
+
+#include <snmp.h>
+#ifndef SNMP_FUNC_TYPE
+#define SNMP_FUNC_TYPE WINAPI
+#endif
+
+//////////////////////////////////////////////////////////////
+// Definition of pointers to the four functions in the Mib Dll
+//
+typedef BOOL (WINAPI *pSnmpExtensionInit)(
+										  IN  DWORD               dwTimeZeroReference,
+										  OUT HANDLE              *hPollForTrapEvent,
+										  OUT AsnObjectIdentifier *supportedView);
+
+typedef BOOL (WINAPI *pSnmpExtensionTrap)(
+										  OUT AsnObjectIdentifier *enterprise,
+										  OUT AsnInteger          *genericTrap,
+										  OUT AsnInteger          *specificTrap,
+										  OUT AsnTimeticks        *timeStamp,
+										  OUT RFC1157VarBindList  *variableBindings);
+
+typedef BOOL (WINAPI *pSnmpExtensionQuery)(
+										   IN BYTE                   requestType,
+										   IN OUT RFC1157VarBindList *variableBindings,
+										   OUT AsnInteger            *errorStatus,
+										   OUT AsnInteger            *errorIndex);
+
+typedef BOOL (WINAPI *pSnmpExtensionInitEx)(OUT AsnObjectIdentifier *supportedView);
+
+
+class MibExtLoad
+{
+public:
+	MibExtLoad( LPSTR MibDllName, LPSTR SnmpDllName );
+	~MibExtLoad();
+	BOOL Init(DWORD dwTimeZeroReference,HANDLE *hPollForTrapEvent,AsnObjectIdentifier *supportedView);
+	BOOL InitEx(AsnObjectIdentifier *supportedView);
+	BOOL Query(BYTE requestType,OUT RFC1157VarBindList *variableBindings,
+			AsnInteger *errorStatus,AsnInteger *errorIndex);
+
+	BOOL Trap(AsnObjectIdentifier *enterprise, AsnInteger *genericTrap, 
+		AsnInteger *specificTrap, AsnTimeticks *timeStamp, 
+		RFC1157VarBindList  *variableBindings);
+
+public:
+	HINSTANCE             m_hInst;
+	HINSTANCE             m_hInst_snmputil;
+
+private:	
+	pSnmpExtensionInit    m_Init;
+	pSnmpExtensionInitEx  m_InitEx;
+	pSnmpExtensionQuery   m_Query;
+	pSnmpExtensionTrap    m_Trap;
+
+public:
+	VOID (SNMP_FUNC_TYPE *m_SnmpUtilVarBindFree) (SnmpVarBind *);
+	SNMPAPI (SNMP_FUNC_TYPE *m_SnmpUtilOidNCmp) (AsnObjectIdentifier *, AsnObjectIdentifier *, UINT);
+	SNMPAPI (SNMP_FUNC_TYPE *m_SnmpUtilOidCpy) (AsnObjectIdentifier *, AsnObjectIdentifier *);
+};
+
+
+class MibII: public MibExtLoad
+{
+public:
+	MibII( bool load_winsock );
+	~MibII();
+	BOOL Init();
+
+	void GetIPAddress(UINT IpArray[],UINT &IpArraySize);
+	void GetIPMask(UINT IpArray[],UINT &IpArraySize);
+
+protected:
+	bool m_load_winsock;
+};
+
+#endif
--- macemu/SheepShaver/src/Windows/router/router.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/router.cpp
@@ -1,201 +1,202 @@
-/*
- *  router.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*
- *  This could be implemented by writing three (9x,nt,2k)
- *  NDIS filter drivers. No thanks.
- *  But this is not easy either.
- */
-
-#include "sysdeps.h"
-#include "main.h"
-
-#include <process.h>
-
-#include "cpu_emulation.h"
-#include "prefs.h"
-#include "ether_windows.h"
-#include "ether.h"
-#include "router.h"
-#include "router_types.h"
-#include "dynsockets.h"
-#include "ipsocket.h"
-#include "iphelp.h"
-#include "arp.h"
-#include "icmp.h"
-#include "udp.h"
-#include "tcp.h"
-#include "ftp.h"
-#include "mib/interfaces.h"
-#include "dump.h"
-
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-
-uint16 next_ip_ident_number = 1;
-uint32 macos_ip_address = 0;
-const uint8 router_mac_addr[6] = { '4', '2', '6', '7', '7', '9' };
-uint32 router_ip_address = 0;
-bool raw_sockets_available = false;
-
-
-
-// Protected data.
-CRITICAL_SECTION router_section;
-bool is_router_shutting_down = false;
-static HANDLE r_handle = 0;
-static unsigned int rh_tid = 0;
-
-
-static void write_ip4( ip_t *ip, int len )
-{
-	if(len < sizeof(ip_t)) {
-	  D(bug("Too small ip packet(%d), dropped\r\n", len));
-	} else {
-		uint8 proto = ip->proto;
-
-		// This is a router, decrement the hop count
-		if( --ip->ttl == 0 ) {
-			// Most likely this is some Mac traceroute app
-		  D(bug("ip packet ttl expired, proto=%d.\r\n", proto));
-			error_winsock_2_icmp( WSAETTLEXCEEDED, ip, len );
-		} else {
-			switch( proto ) {
-				case ip_proto_icmp:
-					write_icmp( (icmp_t *)ip, len );
-					break;
-				case ip_proto_tcp:
-					write_tcp( (tcp_t *)ip, len );
-					break;
-				case ip_proto_udp:
-					write_udp( (udp_t *)ip, len );
-					break;
-				default:
-				  D(bug("write_ip4() len=%d, proto=%d\r\n", len, proto));
-					break;
-			}
-		}
-	}
-}
-
-bool router_write_packet(uint8 *packet, int len)
-{
-	bool result = false;
-
-	if( len >= 14 ) {
-		switch( ntohs( ((mac_t *)packet)->type ) ) {
-			case mac_type_ip4:
-				write_ip4( (ip_t *)packet, len );
-				result = true;
-				break;
-			case mac_type_ip6:
-			  D(bug("write_ip6() len=%d; unsupported.\r\n", len));
-				result = true;
-				break;
-			case mac_type_arp:
-				result = write_arp( (arp_t *)packet, len );
-				break;
-		}
-	}
-	return result;
-}
-
-bool router_read_packet(uint8 *packet, int len)
-{
-	bool result = false;
-
-	if( len >= 14 ) {
-		switch( ntohs( ((mac_t *)packet)->type ) ) {
-			case mac_type_ip4:
-			case mac_type_ip6:
-			case mac_type_arp:
-				result = true;
-				break;
-		}
-	}
-	return result;
-}
-
-/*
-	This has nothing to do with TCP TIME_WAITs or CLOSE_WAITs,
-	the thread is needed to close down expired udp sockets.
-	Arguably an ugly hack, but needed since there is no way to
-	listen to all ports w/o writing another ndis filter driver
-*/
-static unsigned int WINAPI router_expire_thread(void *arg)
-{
-	while(!is_router_shutting_down) {
-		close_old_sockets();
-		Sleep(1000);
-	}
-	return 0;
-}
-
-bool router_init(void)
-{
-	InitializeCriticalSection( &router_section );
-
-	if(dynsockets_init()) {
-		char me[128];
-		if( _gethostname(me, sizeof(me)) == SOCKET_ERROR ) {
-			D(bug("gethostname() failed, error = %d\r\n", _WSAGetLastError()));
-		} else {
-			struct hostent *hent = _gethostbyname(me);
-			if( hent == NULL ) {
-				D(bug("gethostbyname() failed, error = %d\r\n", _WSAGetLastError()));
-			} else {
-				struct in_addr *ina = (struct in_addr *) *hent->h_addr_list;
-				router_ip_address = ntohl(ina->s_addr);
-			  D(bug("router protocol address seems to be %s (used only in icmp error messages)\r\n", _inet_ntoa(*ina)));
-			}
-		}
-		is_router_shutting_down = false;
-		r_handle = (HANDLE)_beginthreadex( 0, 0, router_expire_thread, 0, 0, &rh_tid );
-		init_interfaces();
-		init_tcp();
-		init_udp();
-		init_ftp();
-		return true;
-	}
-
-	return false;
-}
-
-void router_final(void)
-{
-	final_interfaces();
-	stop_icmp_listen();
-	close_all_sockets();
-	if(r_handle) {
-		is_router_shutting_down = true;
-		WaitForSingleObject( r_handle, INFINITE );
-		final_tcp();
-		final_udp();
-		dynsockets_final();
-	}
-	DeleteCriticalSection( &router_section );
-}
+/*
+ *  router.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ *  This could be implemented by writing three (9x,nt,2k)
+ *  NDIS filter drivers. No thanks.
+ *  But this is not easy either.
+ */
+
+#include "sysdeps.h"
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <process.h>
+
+#include "cpu_emulation.h"
+#include "prefs.h"
+#include "ether_windows.h"
+#include "ether.h"
+#include "router.h"
+#include "router_types.h"
+#include "dynsockets.h"
+#include "ipsocket.h"
+#include "iphelp.h"
+#include "arp.h"
+#include "icmp.h"
+#include "udp.h"
+#include "tcp.h"
+#include "ftp.h"
+#include "mib/interfaces.h"
+#include "dump.h"
+
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+
+uint16 next_ip_ident_number = 1;
+uint32 macos_ip_address = 0;
+const uint8 router_mac_addr[6] = { '4', '2', '6', '7', '7', '9' };
+uint32 router_ip_address = 0;
+bool raw_sockets_available = false;
+
+
+
+// Protected data.
+CRITICAL_SECTION router_section;
+bool is_router_shutting_down = false;
+static HANDLE r_handle = 0;
+static unsigned int rh_tid = 0;
+
+
+static void write_ip4( ip_t *ip, int len )
+{
+	if(len < sizeof(ip_t)) {
+	  D(bug("Too small ip packet(%d), dropped\r\n", len));
+	} else {
+		uint8 proto = ip->proto;
+
+		// This is a router, decrement the hop count
+		if( --ip->ttl == 0 ) {
+			// Most likely this is some Mac traceroute app
+		  D(bug("ip packet ttl expired, proto=%d.\r\n", proto));
+			error_winsock_2_icmp( WSAETTLEXCEEDED, ip, len );
+		} else {
+			switch( proto ) {
+				case ip_proto_icmp:
+					write_icmp( (icmp_t *)ip, len );
+					break;
+				case ip_proto_tcp:
+					write_tcp( (tcp_t *)ip, len );
+					break;
+				case ip_proto_udp:
+					write_udp( (udp_t *)ip, len );
+					break;
+				default:
+				  D(bug("write_ip4() len=%d, proto=%d\r\n", len, proto));
+					break;
+			}
+		}
+	}
+}
+
+bool router_write_packet(uint8 *packet, int len)
+{
+	bool result = false;
+
+	if( len >= 14 ) {
+		switch( ntohs( ((mac_t *)packet)->type ) ) {
+			case mac_type_ip4:
+				write_ip4( (ip_t *)packet, len );
+				result = true;
+				break;
+			case mac_type_ip6:
+			  D(bug("write_ip6() len=%d; unsupported.\r\n", len));
+				result = true;
+				break;
+			case mac_type_arp:
+				result = write_arp( (arp_t *)packet, len );
+				break;
+		}
+	}
+	return result;
+}
+
+bool router_read_packet(uint8 *packet, int len)
+{
+	bool result = false;
+
+	if( len >= 14 ) {
+		switch( ntohs( ((mac_t *)packet)->type ) ) {
+			case mac_type_ip4:
+			case mac_type_ip6:
+			case mac_type_arp:
+				result = true;
+				break;
+		}
+	}
+	return result;
+}
+
+/*
+	This has nothing to do with TCP TIME_WAITs or CLOSE_WAITs,
+	the thread is needed to close down expired udp sockets.
+	Arguably an ugly hack, but needed since there is no way to
+	listen to all ports w/o writing another ndis filter driver
+*/
+static unsigned int WINAPI router_expire_thread(void *arg)
+{
+	while(!is_router_shutting_down) {
+		close_old_sockets();
+		Sleep(1000);
+	}
+	return 0;
+}
+
+bool router_init(void)
+{
+	InitializeCriticalSection( &router_section );
+
+	if(dynsockets_init()) {
+		char me[128];
+		if( _gethostname(me, sizeof(me)) == SOCKET_ERROR ) {
+			D(bug("gethostname() failed, error = %d\r\n", _WSAGetLastError()));
+		} else {
+			struct hostent *hent = _gethostbyname(me);
+			if( hent == NULL ) {
+				D(bug("gethostbyname() failed, error = %d\r\n", _WSAGetLastError()));
+			} else {
+				struct in_addr *ina = (struct in_addr *) *hent->h_addr_list;
+				router_ip_address = ntohl(ina->s_addr);
+			  D(bug("router protocol address seems to be %s (used only in icmp error messages)\r\n", _inet_ntoa(*ina)));
+			} 
+		}
+		is_router_shutting_down = false;
+		r_handle = (HANDLE)_beginthreadex( 0, 0, router_expire_thread, 0, 0, &rh_tid );
+		init_interfaces();
+		init_tcp();
+		init_udp();
+		init_ftp();
+		return true;
+	}
+
+	return false;
+}
+
+void router_final(void)
+{
+	final_interfaces();
+	stop_icmp_listen();
+	close_all_sockets();
+	if(r_handle) {
+		is_router_shutting_down = true;
+		WaitForSingleObject( r_handle, INFINITE );
+		final_tcp();
+		final_udp();
+		dynsockets_final();
+	}
+	DeleteCriticalSection( &router_section );
+}
--- macemu/SheepShaver/src/Windows/router/router.h
+++ sheepshaver/SheepShaver/src/Windows/router/router.h
@@ -1,54 +1,54 @@
-/*
- *  router.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _ROUTER_H_
-#define _ROUTER_H_
-
-extern bool is_router_shutting_down;
-extern CRITICAL_SECTION router_section;
-
-// Increased by one for each ip packet sent to the emulated enet interface.
-extern uint16 next_ip_ident_number;
-
-// Used by incoming icmp packets and internal icmp messages. Host byte order.
-extern uint32 macos_ip_address;
-
-// The magic constant
-extern const uint8 router_mac_addr[6];
-
-// Used by internal icmp messages. Host byte order.
-extern uint32 router_ip_address;
-
-// False under NT/Win2k if the user has no admin rights
-extern bool raw_sockets_available;
-
-
-
-// Interface exposed to ether_windows module.
-bool router_init(void);
-void router_final(void);
-
-// Both of these return true if the ethernet module should drop the packet.
-bool router_write_packet(uint8 *packet, int len);
-bool router_read_packet(uint8 *packet, int len);
-
-#endif // _ROUTER_H_
+/*
+ *  router.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _ROUTER_H_
+#define _ROUTER_H_
+
+extern bool is_router_shutting_down;
+extern CRITICAL_SECTION router_section;
+
+// Increased by one for each ip packet sent to the emulated enet interface.
+extern uint16 next_ip_ident_number;
+
+// Used by incoming icmp packets and internal icmp messages. Host byte order.
+extern uint32 macos_ip_address;
+
+// The magic constant
+extern const uint8 router_mac_addr[6];
+
+// Used by internal icmp messages. Host byte order.
+extern uint32 router_ip_address;
+
+// False under NT/Win2k if the user has no admin rights
+extern bool raw_sockets_available;
+
+
+
+// Interface exposed to ether_windows module.
+bool router_init(void);
+void router_final(void);
+
+// Both of these return true if the ethernet module should drop the packet.
+bool router_write_packet(uint8 *packet, int len);
+bool router_read_packet(uint8 *packet, int len);
+
+#endif // _ROUTER_H_
--- macemu/SheepShaver/src/Windows/router/router_types.h
+++ sheepshaver/SheepShaver/src/Windows/router/router_types.h
@@ -1,187 +1,187 @@
-/*
- *  router_types.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _ROUTER_TYPES_H_
-#define _ROUTER_TYPES_H_
-
-#pragma pack(push, 1)
-
-
-// --------------------------- MAC ---------------------------
-typedef struct {
-	uint8 dest[6];
-	uint8 src[6];
-	uint16 type;
-} mac_t;
-
-enum {
-	mac_type_llc_ipx_limit	= 0x05DC, // <= mac_type_llc_ipx_limit -->> 802.3 MAC frame
-	mac_type_ip4						= 0x0800,
-	mac_type_arp						= 0x0806,
-	mac_type_rarp						= 0x8035,
-	mac_type_ip6						= 0x86DD,
-	mac_type_loopback				= 0x9000
-};
-
-// --------------------------- ARP ---------------------------
-typedef struct {
-	mac_t mac;
-	uint16 htype;
-	uint16 ptype;
-	uint8 halen;
-	uint8 palen;
-	uint16 opcode;
-	uint8 srch[6];	// size for ethernet
-	uint8 srcp[4];	// size for ip
-	uint8 dsth[6];	// size for ethernet
-	uint8 dstp[4];	// size for ip
-} arp_t;
-
-enum {
-	arp_request = 1,
-	arp_reply = 2
-};
-enum {
-	arp_hwtype_enet = 1
-};
-
-// --------------------------- IP4 ---------------------------
-typedef struct {
-	mac_t mac;
-	uint8 header_len:4;
-	uint8 version:4;
-	uint8 tos;
-	uint16 total_len;
-	uint16 ident;
-	uint16 flags_n_frag_offset; // foffset 0..11, flags 12..15
-	uint8 ttl;
-	uint8 proto;
-	uint16 checksum;
-	uint32 src;
-	uint32 dest;
-	// ip options, size = 4 * header_len - 20
-} ip_t;
-
-// Protocol STD numbers
-enum {
-	ip_proto_icmp		= IPPROTO_ICMP,
-	ip_proto_tcp		= IPPROTO_TCP,
-	ip_proto_udp		= IPPROTO_UDP
-};
-
-// --------------------------- ICMP ---------------------------
-typedef struct {
-	ip_t ip;
-	uint8 type;
-	uint8 code;
-	uint16 checksum;
-	// data
-} icmp_t;
-
-enum {
-	icmp_Echo_reply	= 0,
-	icmp_Destination_unreachable	= 3,
-	icmp_Source_quench	= 4,
-	icmp_Redirect	= 5,
-	icmp_Echo	= 8,
-	icmp_Router_advertisement	= 9,
-	icmp_Router_solicitation	= 10,
-	icmp_Time_exceeded	= 11,
-	icmp_Parameter_problem	= 12,
-	icmp_Time_Stamp_request	= 13,
-	icmp_Time_Stamp_reply	= 14,
-	icmp_Information_request_obsolete	= 15,
-	icmp_Information_reply_obsolete	= 16,
-	icmp_Address_mask_request	= 17,
-	icmp_Address_mask_reply	= 18,
-	icmp_Traceroute	= 30,
-	icmp_Datagram_conversion_error	= 31,
-	icmp_Mobile_host_redirect	= 32,
-	icmp_IPv6_Where_Are_You	= 33,
-	icmp_IPv6_I_Am_Here	= 34,
-	icmp_Mobile_registration_request	= 35,
-	icmp_Mobile_registration_reply	= 36,
-	icmp_Domain_name_request	= 37,
-	icmp_Domain_name_reply	= 38,
-	icmp_SKIP	= 39,
-	icmp_Photuris	= 40
-};
-
-// --------------------------- TCP ---------------------------
-typedef struct {
-	ip_t ip;
-	uint16 src_port;
-	uint16 dest_port;
-	uint32 seq;
-	uint32 ack;
-	uint8 header_len;	// note: some reserved bits
-	uint8 flags;			// note: some reserved bits
-	uint16 window;
-	uint16 checksum;
-	uint16 urgent_ptr;
-	// options + padding: size = dataoffset*4-20
-	// data
-} tcp_t;
-
-enum {
-	tcp_flags_URG = 0x20,	// The urgent pointer field is significant in this segment.
-	tcp_flags_ACK = 0x10,	// The acknowledgment field is significant in this segment.
-	tcp_flags_PSH = 0x08,	// Push function.
-	tcp_flags_RST = 0x04,	// Resets the connection.
-	tcp_flags_SYN = 0x02,	// Synchronizes the sequence numbers.
-	tcp_flags_FIN = 0x01	// No more data from sender.
-};
-
-enum {
-	tcp_state_closed,
-	tcp_state_listen,
-	tcp_state_syn_sent,
-	tcp_state_syn_rcvd,
-	tcp_state_established,
-	tcp_state_close_wait,
-	tcp_state_last_ack,
-	tcp_state_finwait_1,
-	tcp_state_finwait_2,
-	tcp_state_closing,
-	tcp_state_time_wait
-};
-
-// --------------------------- UDP ---------------------------
-typedef struct {
-	ip_t ip;
-	uint16 src_port;
-	uint16 dest_port;
-	uint16 msg_len;
-	uint16 checksum;
-	// data
-} udp_t;
-
-typedef struct {
-	uint16 src_lo, src_hi;
-	uint16 dest_lo, dest_hi;
-	uint16 proto;
-	uint16 msg_len;
-} pseudo_ip_t;
-
-#pragma pack(pop)
-
-#endif // _ROUTER_TYPES_H_
+/*
+ *  router_types.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _ROUTER_TYPES_H_
+#define _ROUTER_TYPES_H_
+
+#pragma pack(1)
+
+
+// --------------------------- MAC ---------------------------
+typedef struct {
+	uint8 dest[6];
+	uint8 src[6];
+	uint16 type;
+} ATTRIBUTE_PACKED mac_t;
+
+enum {
+	mac_type_llc_ipx_limit	= 0x05DC, // <= mac_type_llc_ipx_limit -->> 802.3 MAC frame
+	mac_type_ip4						= 0x0800,
+	mac_type_arp						= 0x0806,
+	mac_type_rarp						= 0x8035,
+	mac_type_ip6						= 0x86DD,
+	mac_type_loopback				= 0x9000
+};
+
+// --------------------------- ARP ---------------------------
+typedef struct {
+	mac_t mac;
+	uint16 htype;
+	uint16 ptype;
+	uint8 halen;
+	uint8 palen;
+	uint16 opcode;
+	uint8 srch[6];	// size for ethernet
+	uint8 srcp[4];	// size for ip
+	uint8 dsth[6];	// size for ethernet
+	uint8 dstp[4];	// size for ip
+} ATTRIBUTE_PACKED arp_t;
+
+enum {
+	arp_request = 1,
+	arp_reply = 2
+};
+enum {
+	arp_hwtype_enet = 1
+};
+
+// --------------------------- IP4 ---------------------------
+typedef struct {
+	mac_t mac;
+	uint8 header_len:4;
+	uint8 version:4;
+	uint8 tos;
+	uint16 total_len;
+	uint16 ident;
+	uint16 flags_n_frag_offset; // foffset 0..11, flags 12..15
+	uint8 ttl;
+	uint8 proto;
+	uint16 checksum;
+	uint32 src;
+	uint32 dest;
+	// ip options, size = 4 * header_len - 20
+} ATTRIBUTE_PACKED ip_t;
+
+// Protocol STD numbers
+enum {
+	ip_proto_icmp		= IPPROTO_ICMP,
+	ip_proto_tcp		= IPPROTO_TCP,
+	ip_proto_udp		= IPPROTO_UDP
+};
+
+// --------------------------- ICMP ---------------------------
+typedef struct {
+	ip_t ip;
+	uint8 type;
+	uint8 code;
+	uint16 checksum;
+	// data
+} ATTRIBUTE_PACKED icmp_t;
+
+enum {
+	icmp_Echo_reply	= 0,
+	icmp_Destination_unreachable	= 3,
+	icmp_Source_quench	= 4,
+	icmp_Redirect	= 5,
+	icmp_Echo	= 8,
+	icmp_Router_advertisement	= 9,
+	icmp_Router_solicitation	= 10,
+	icmp_Time_exceeded	= 11,
+	icmp_Parameter_problem	= 12,
+	icmp_Time_Stamp_request	= 13,
+	icmp_Time_Stamp_reply	= 14,
+	icmp_Information_request_obsolete	= 15,
+	icmp_Information_reply_obsolete	= 16,
+	icmp_Address_mask_request	= 17,
+	icmp_Address_mask_reply	= 18,
+	icmp_Traceroute	= 30,
+	icmp_Datagram_conversion_error	= 31,
+	icmp_Mobile_host_redirect	= 32,
+	icmp_IPv6_Where_Are_You	= 33,
+	icmp_IPv6_I_Am_Here	= 34,
+	icmp_Mobile_registration_request	= 35,
+	icmp_Mobile_registration_reply	= 36,
+	icmp_Domain_name_request	= 37,
+	icmp_Domain_name_reply	= 38,
+	icmp_SKIP	= 39,
+	icmp_Photuris	= 40
+};
+
+// --------------------------- TCP ---------------------------
+typedef struct {
+	ip_t ip;
+	uint16 src_port;
+	uint16 dest_port;
+	uint32 seq;
+	uint32 ack;
+	uint8 header_len;	// note: some reserved bits
+	uint8 flags;			// note: some reserved bits
+	uint16 window;
+	uint16 checksum;
+	uint16 urgent_ptr;
+	// options + padding: size = dataoffset*4-20
+	// data
+} ATTRIBUTE_PACKED tcp_t;
+
+enum {
+	tcp_flags_URG = 0x20,	// The urgent pointer field is significant in this segment.
+	tcp_flags_ACK = 0x10,	// The acknowledgment field is significant in this segment.
+	tcp_flags_PSH = 0x08,	// Push function.
+	tcp_flags_RST = 0x04,	// Resets the connection.
+	tcp_flags_SYN = 0x02,	// Synchronizes the sequence numbers.
+	tcp_flags_FIN = 0x01	// No more data from sender.
+};
+
+enum {
+	tcp_state_closed,
+	tcp_state_listen,
+	tcp_state_syn_sent,
+	tcp_state_syn_rcvd,
+	tcp_state_established,
+	tcp_state_close_wait,
+	tcp_state_last_ack,
+	tcp_state_finwait_1,
+	tcp_state_finwait_2,
+	tcp_state_closing,
+	tcp_state_time_wait
+};
+
+// --------------------------- UDP ---------------------------
+typedef struct {
+	ip_t ip;
+	uint16 src_port;
+	uint16 dest_port;
+	uint16 msg_len;
+	uint16 checksum;
+	// data
+} ATTRIBUTE_PACKED udp_t;
+
+typedef struct {
+	uint16 src_lo, src_hi;
+	uint16 dest_lo, dest_hi;
+	uint16 proto;
+	uint16 msg_len;
+} ATTRIBUTE_PACKED pseudo_ip_t;
+
+#pragma pack()
+
+#endif // _ROUTER_TYPES_H_
--- macemu/SheepShaver/src/Windows/router/tcp.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/tcp.cpp
@@ -1,1605 +1,1607 @@
-/*
- *  tcp.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*
- *  Features implemented:
- *		state machine, flow control, sequence numbers, RST/SYN/FIN/ACK/PSH
- *
- *  Features not implemented:
- *		oob data, urgent pointer, window sliding, some options
- *		"Half-Nagle" implementation is a bit weird (mac-router interface; winsock has it on by default)
- *
- *
- *  All possible tcp state machine transitions:
- *
- *		CLOSED ->	LISTEN						passive open
- *		CLOSED ->	SYN_SENT					active open				SYN->
- *
- *		LISTEN ->	SYN_SENT					send data					SYN->
- *		LISTEN ->	SYN_RCVD					->SYN							SYN+ACK->
- *
- *		SYN_SENT ->	SYN_RCVD				->SYN							SYN+ACK->
- *		SYN_SENT ->	ESTABLISHED			->SYN+ACK					ACK->
- *		SYN_SENT ->	CLOSED					close/timeout
- *
- *		SYN_RCVD ->	CLOSED					timeout						RST->
- *		SYN_RCVD ->	LISTEN					->RST
- *		SYN_RCVD ->	ESTABLISHED			->ACK
- *		SYN_RCVD ->	FINWAIT_1				close							FIN->
- *
- *		ESTABLISHED -> FINWAIT_1		close							FIN->
- *		ESTABLISHED -> CLOSE_WAIT		->FIN							ACK->
- *
- *		CLOSE_WAIT -> LAST_ACK			close							FIN->
- *
- *		LAST_ACK -> CLOSED					->ACK
- *
- *		FINWAIT_1 -> CLOSING				->FIN							ACK->
- *		FINWAIT_1 -> FINWAIT_2			->ACK
- *		FINWAIT_1 -> TIME_WAIT			->FIN+ACK					ACK->
- *
- *		FINWAIT_2 -> TIME_WAIT			->FIN							ACK->
- *
- *		CLOSING -> TIME_WAIT				->ACK
- *
- *		TIME_WAIT -> CLOSED					timeout (2*msl)
- *
- */
-
-#include "sysdeps.h"
-#include "main.h"
-
-#include <process.h>
-
-#include "cpu_emulation.h"
-#include "ws2tcpip.h"
-#include "ether_windows.h"
-#include "ether.h"
-#include "prefs.h"
-#include "router.h"
-#include "router_types.h"
-#include "dynsockets.h"
-#include "iphelp.h"
-#include "tcp.h"
-#include "dump.h"
-#include "mib/interfaces.h"
-#include "ftp.h"
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-// If you need more, use multiple threads.
-#define MAX_SOCKETS MAXIMUM_WAIT_OBJECTS
-
-// If true, always sends the PSH tcp flag with data.
-// Otherwise only when a full buffer was received.
-#define PUSH_ALWAYS 0
-
-// In milliseconds. A TCP implementation should implement
-// this dynamically, adapting the timeout value to match to the
-// averaged packet round-trip time.
-#define RESEND_TIMEOUT 750
-
-// Just time out incoming connections after 5 secs if Mac has no time to reply
-// No backlogs.
-#define SYN_FLOOD_PROTECTION_TIMEOUT 5000
-
-const int MAX_SEGMENT_SIZE = 1460;
-
-// Shorthands
-#define ISSET(f,x) ( ((f) & (x)) != 0 )
-#define ISCLEAR(f,x) ( ((f) & (x)) == 0 )
-
-// Local aliases
-#define URG tcp_flags_URG
-#define ACK tcp_flags_ACK
-#define PSH tcp_flags_PSH
-#define RST tcp_flags_RST
-#define SYN tcp_flags_SYN
-#define FIN tcp_flags_FIN
-
-// Local aliases
-#define CLOSED 			tcp_state_closed
-#define LISTEN 			tcp_state_listen
-#define SYN_SENT 		tcp_state_syn_sent
-#define SYN_RCVD 		tcp_state_syn_rcvd
-#define ESTABLISHED tcp_state_established
-#define CLOSE_WAIT 	tcp_state_close_wait
-#define LAST_ACK 		tcp_state_last_ack
-#define FINWAIT_1 	tcp_state_finwait_1
-#define FINWAIT_2 	tcp_state_finwait_2
-#define CLOSING 		tcp_state_closing
-#define TIME_WAIT 	tcp_state_time_wait
-
-// For debugging only
-static const char *_tcp_state_name[] = {
-	"CLOSED",
-	"LISTEN",
-	"SYN_SENT",
-	"SYN_RCVD",
-	"ESTABLISHED",
-	"CLOSE_WAIT",
-	"LAST_ACK",
-	"FINWAIT_1",
-	"FINWAIT_2",
-	"CLOSING",
-	"TIME_WAIT"
-};
-#define STATENAME(i) _tcp_state_name[i]
-
-static CRITICAL_SECTION tcp_section;
-
-typedef struct {
-	SOCKET s;
-	int state;
-
-	uint32 ip_src;											// "source" is the mac, dest is the remote host,
-	uint32 ip_dest;											// no matter who opened the connection.
-	uint16 src_port;										// all in host byte order.
-	uint16 dest_port;
-
-	struct sockaddr_in from;						// remote host address, network byte order.
-	int from_len;
-
-	// note: no true windows sliding, only one buffer.
-	WSABUF buffers_read[1];							// data from remote host to Mac
-	DWORD buffer_count_read;
-	DWORD bytes_received;
-	DWORD flags_read;
-	WSAOVERLAPPED overlapped_read;
-
-	WSABUF buffers_write[1];						// data from Mac to remote host
-	DWORD buffer_count_write;
-	DWORD bytes_written;
-	DWORD flags_write;
-	WSAOVERLAPPED overlapped_write;
-
-	bool remote_closed;									// remote will not send any more data
-	bool accept_more_data_from_mac;			// are we ready to accept more data from mac
-
-	uint32 seq_in;											// will ack this mac sequence number
-	uint32 seq_out;											// next sequence number to mac (unless a resend is needed)
-	uint32 mac_ack;											// mac has acked this byte count. can be used to determined when to send some more data
-
-	uint32 bytes_to_send;								// total send block size
-	uint32 bytes_remaining_to_send;			// unsent byte count
-
-	uint16 mac_window;									// mac tcp receive window, slides according to the window principle
-	uint16 our_window;									// not really used
-	uint16 mac_mss;											// maximum segment size that mac reported at SYN handshaking
-
-	// resend info
-	uint32 last_seq_out;								// remember last packet seq number if a resend is needed
-	uint32 resend_timeout;							// currently set t0 0.75 secs but not updated
-	uint32 stream_to_mac_stalled_until;	// tick count indicating resend time
-
-	DWORD time_wait;										// do a graceful close after MSL*2
-	DWORD msl;
-
-	int child;
-
-	WSAEVENT ev;												// used to signal remote-initiated close and host-initiated connect.
-
-	bool in_use;
-} tcp_socket_t;
-
-static tcp_socket_t sockets[MAX_SOCKETS];
-
-typedef struct {
-	SOCKET s;
-	uint16 port;
-	uint32 ip;
-	uint32 iface;
-	bool once;
-	int parent;
-	WSAEVENT ev;
-} tcp_listening_socket_t;
-
-static tcp_listening_socket_t l_sockets[MAX_SOCKETS];
-
-static void CALLBACK tcp_read_completion(
-	DWORD error,
-	DWORD bytes_read,
-	LPWSAOVERLAPPED lpOverlapped,
-	DWORD flags
-);
-
-static void CALLBACK tcp_write_completion(
-	DWORD error,
-	DWORD bytes_read,
-	LPWSAOVERLAPPED lpOverlapped,
-	DWORD flags
-);
-
-// socket utilities assume that the critical section has already been entered.
-static void free_socket( const int t )
-{
-	_WSAResetEvent( sockets[t].ev );
-	if(sockets[t].s != INVALID_SOCKET) {
-		_closesocket( sockets[t].s );
-		sockets[t].s = INVALID_SOCKET;
-	}
-	sockets[t].state = CLOSED;
-	sockets[t].stream_to_mac_stalled_until = 0;
-	sockets[t].in_use = false;
-	sockets[t].time_wait = 0;
-
-	// if there was an attached listening socket (ftp), close it.
-	int lst = sockets[t].child;
-	if( lst >= 0 ) {
-		if(l_sockets[lst].s != INVALID_SOCKET) {
-		  D(bug("  closing listening socket %d\r\n", lst));
-			_closesocket( l_sockets[lst].s );
-			l_sockets[lst].s = INVALID_SOCKET;
-		}
-		l_sockets[lst].port = 0;
-		l_sockets[lst].parent = -1;
-	}
-	sockets[t].child = -1;
-}
-
-static int alloc_socket()
-{
-	static int last_allocated_socket = -1;
-
-	int i = last_allocated_socket;
-	for( int j=0; j<MAX_SOCKETS; j++ ) {
-		if( ++i >= MAX_SOCKETS ) i = 0;
-		if( !sockets[i].in_use ) {
-			D(bug("<%d> Socket allocated\r\n", i));
-
-			last_allocated_socket = i;
-			sockets[i].in_use = true;
-
-			sockets[i].s = INVALID_SOCKET;
-			sockets[i].state = CLOSED;
-			sockets[i].remote_closed = false;
-
-			sockets[i].accept_more_data_from_mac = false;
-
-			sockets[i].ip_src = sockets[i].ip_dest = 0;
-			// sockets[i].src_port = sockets[i].dest_port = 0;
-
-			memset( &sockets[i].overlapped_read, 0, sizeof(sockets[i].overlapped_read) );
-			sockets[i].overlapped_read.hEvent = (HANDLE)i;
-			memset( &sockets[i].overlapped_write, 0, sizeof(sockets[i].overlapped_write) );
-			sockets[i].overlapped_write.hEvent = (HANDLE)i;
-
-			sockets[i].bytes_received = 0;
-			sockets[i].bytes_written = 0;
-
-			sockets[i].flags_read = 0;
-			sockets[i].flags_write = 0;
-
-			// sockets[i].from_len = sizeof(struct sockaddr_in);
-			// memset( &sockets[i].from, 0, sizeof(sockets[i].from) );
-			// sockets[i].from.sin_family = AF_INET;
-
-			sockets[i].buffer_count_read = 1;
-			sockets[i].buffers_read[0].len = MAX_SEGMENT_SIZE;
-			if(!sockets[i].buffers_read[0].buf) {
-				sockets[i].buffers_read[0].buf = new char [sockets[i].buffers_read[0].len];
-			}
-
-			sockets[i].buffer_count_write = 1;
-			sockets[i].buffers_write[0].len = MAX_SEGMENT_SIZE;
-			if(!sockets[i].buffers_write[0].buf) {
-				sockets[i].buffers_write[0].buf = new char [sockets[i].buffers_write[0].len];
-			}
-
-			sockets[i].mac_window = MAX_SEGMENT_SIZE; // updated for all mac datagrams
-			sockets[i].our_window = MAX_SEGMENT_SIZE; // should use about 8-16 kB, really
-			sockets[i].mac_mss = 0;			// not known yet
-
-			sockets[i].time_wait = 0;
-			sockets[i].msl = 5000L;			// The round-trip time can be hard to estimate.
-
-			sockets[i].seq_in = 0;
-			sockets[i].seq_out = 0x00000001;
-			sockets[i].mac_ack = 0;
-			sockets[i].stream_to_mac_stalled_until = 0;
-
-			sockets[i].resend_timeout = RESEND_TIMEOUT;
-
-			sockets[i].child = -1;
-
-			break;
-		}
-	}
-	if(i == MAX_SOCKETS) {
-		D(bug("Out of free sockets\r\n"));
-		i = -1;
-	}
-	return i;
-}
-
-static int alloc_new_socket( const uint16 src_port, const uint16 dest_port, const uint32 ip_dest )
-{
-	int t = alloc_socket();
-
-	if(t >= 0) {
-		sockets[t].s = _socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
-		if(sockets[t].s == INVALID_SOCKET) {
-			free_socket( t );
-			t = -1;
-		} else {
-			sockets[t].src_port = src_port;
-			sockets[t].dest_port = dest_port;
-
-			sockets[t].from_len = sizeof(sockets[t].from);
-			memset( &sockets[t].from, 0, sockets[t].from_len );
-			sockets[t].from.sin_family = AF_INET;
-			sockets[t].from.sin_port = htons(dest_port);
-			sockets[t].from.sin_addr.s_addr = htonl(ip_dest);
-
-			struct sockaddr_in to;
-			memset( &to, 0, sizeof(to) );
-			to.sin_family = AF_INET;
-
-			if(	_bind ( sockets[t].s, (const struct sockaddr *)&to, sizeof(to) ) == 0 ) {
-				D(bug("<%d> socket bound\r\n", t));
-			} else {
-				if( _WSAGetLastError() == WSAEINPROGRESS ) {
-					D(bug("<%d> bind: a blocking call is in progress.\r\n", t));
-				} else {
-					D(bug("<%d> bind failed with error code %d\r\n", t, _WSAGetLastError()));
-				}
-				free_socket( t );
-				t = -1;
-			}
-		}
-	}
-	return t;
-}
-
-static int get_socket_index( const uint16 src_port, const uint16 dest_port )
-{
-	for( int i=0; i<MAX_SOCKETS; i++ ) {
-		if(sockets[i].in_use && sockets[i].src_port == src_port && sockets[i].dest_port == dest_port ) {
-			return i;
-		}
-	}
-	return -1;
-}
-
-static int get_socket_index( const uint16 src_port )
-{
-	for( int i=0; i<MAX_SOCKETS; i++ ) {
-		if(sockets[i].in_use && sockets[i].src_port == src_port ) {
-			return i;
-		}
-	}
-	return -1;
-}
-
-static int find_socket( const uint16 src_port, const uint16 dest_port )
-{
-	int i = get_socket_index( src_port, dest_port );
-	if( i < 0 ) {
-		i = get_socket_index( src_port );
-		if( i >= 0 ) {
-			if( sockets[i].s == INVALID_SOCKET ) {
-			  D(bug("find_socket reusing slot %d...\r\n", i));
-				sockets[i].in_use = false;
-			} else {
-			  D(bug("find_socket forcing close %d...\r\n", i));
-				free_socket( i );
-			}
-			i = -1;
-		}
-	}
-
-  D(bug("<%d> find_socket(%d,%d): %s\r\n", i, src_port, dest_port, i>=0 ? "found" : "not found"));
-
-	return i;
-}
-
-static int alloc_listen_socket( const uint16 port, const uint32 ip, const uint32 iface, const bool once )
-{
-	static int last_allocated_socket = -1;
-
-	int i = last_allocated_socket;
-
-	for( int j=0; j<MAX_SOCKETS; j++ ) {
-		if( ++i >= MAX_SOCKETS ) i = 0;
-		if( l_sockets[i].port == 0 ) {
-			D(bug("[%d] Slot allocated for listening port %d\r\n", i, port));
-			l_sockets[i].port = port;
-			l_sockets[i].ip = ip;
-			l_sockets[i].iface = iface;
-			l_sockets[i].once = once;
-			l_sockets[i].parent = -1;
-			last_allocated_socket = i;
-			_WSAResetEvent( l_sockets[i].ev );
-			return i;
-		}
-	}
-	return -1;
-}
-
-static void tcp_start_listen( const int i )
-{
-	if( l_sockets[i].port ) {
-		uint32 iface = l_sockets[i].iface;
-
-		D(bug("[%d] binding to interface 0x%08X\r\n", i, iface));
-
-		l_sockets[i].s = _socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
-		if(l_sockets[i].s != INVALID_SOCKET) {
-			struct sockaddr_in to;
-			memset( &to, 0, sizeof(to) );
-			to.sin_family = AF_INET;
-			to.sin_port = htons( l_sockets[i].port );
-			to.sin_addr.s_addr = htonl( iface );
-
-			if(	_bind ( l_sockets[i].s, (const struct sockaddr *)&to, sizeof(to) ) == 0 )
-			{
-				D(bug("[%d] socket bound to port %d on interface 0x%08X\r\n", i, l_sockets[i].port, iface));
-				if( _listen( l_sockets[i].s, SOMAXCONN ) == SOCKET_ERROR  ) {
-					D(bug("[%d] listen() failed with error code %d\r\n", i, _WSAGetLastError()));
-				} else {
-					D(bug("[%d] listening to port %d\r\n", i, l_sockets[i].port));
-					_WSAResetEvent( l_sockets[i].ev );
-					if( SOCKET_ERROR == _WSAEventSelect( l_sockets[i].s, l_sockets[i].ev, FD_ACCEPT ) ) {
-						D(bug("[%d] WSAEventSelect() failed with error code %d\r\n", i, _WSAGetLastError()));
-					}
-				}
-			} else {
-				D(bug("[%d] bind to port %d failed with error code %d\r\n", i, l_sockets[i].port, _WSAGetLastError()));
-			}
-		} else {
-			D(bug("[%d] could not create a socket for port %d, error = %d\r\n", i, l_sockets[i].port, _WSAGetLastError()));
-		}
-	}
-}
-
-static void set_ttl( const int t, const uint8 ttl )
-{
-	int _ttl = ttl; // defensive programming, I know VCx
-
-	if(_setsockopt( sockets[t].s, IPPROTO_IP, IP_TTL, (const char *)&_ttl, sizeof(int) ) == SOCKET_ERROR  ) {
-		D(bug("<%d> could not set ttl to %d, error=%d\r\n", t, ttl, _WSAGetLastError()));
-	} else {
-		D(bug("<%d> ttl set to %d.\r\n", t, ttl));
-	}
-}
-
-static void tcp_reply( const int flags, const int t )
-{
-	int tcp_size = sizeof(tcp_t);
-
-	tcp_t *tcp = (tcp_t *)malloc( tcp_size );
-	if(tcp) {
-		memcpy( tcp->ip.mac.dest, ether_addr, 6 );
-		memcpy( tcp->ip.mac.src, router_mac_addr, 6 );
-		tcp->ip.mac.type = htons(mac_type_ip4);
-
-		tcp->ip.version = 4;
-		tcp->ip.header_len = 5;
-		tcp->ip.tos = 0;
-		tcp->ip.total_len = htons(tcp_size - sizeof(mac_t));
-		tcp->ip.ident = htons(next_ip_ident_number++);
-		tcp->ip.flags_n_frag_offset = 0;
-		tcp->ip.ttl = 128;
-		tcp->ip.proto = ip_proto_tcp;
-		tcp->ip.src = htonl(sockets[t].ip_dest);
-		tcp->ip.dest = htonl(sockets[t].ip_src);
-		make_ip4_checksum( (ip_t *)tcp );
-
-		D(bug("<%d> Reply: Seq=%d, Ack=%d\r\n", t, sockets[t].seq_out, sockets[t].seq_in));
-
-		tcp->src_port = htons(sockets[t].dest_port);
-		tcp->dest_port = htons(sockets[t].src_port);
-		tcp->seq = htonl(sockets[t].seq_out);
-		tcp->ack = htonl(sockets[t].seq_in);
-		tcp->header_len = (uint8)( 20 << 2 );
-		tcp->flags = flags;
-		tcp->window = htons( sockets[t].our_window );
-		tcp->urgent_ptr = 0;
-		make_tcp_checksum( tcp, tcp_size );
-
-		// dump_bytes( (uint8 *)tcp, tcp_size );
-
-		enqueue_packet( (uint8 *)tcp, tcp_size );
-		free(tcp);
-	}
-}
-
-static bool has_mac_read_space( const int t )
-{
-	uint32 pending_bytes = sockets[t].seq_out - sockets[t].mac_ack;
-	uint32 mac_can_accept_bytes = sockets[t].mac_window - pending_bytes;
-
-	D(bug("<%d> mac_can_accept_bytes = %d\r\n", t, mac_can_accept_bytes));
-
-	// Modified Nagle, effectively disabling window sliding (which I don't support anyway):
-	return pending_bytes == 0;
-
-	// Use more of window bandwidth
-	// Enabling this would require that the buffers seq numbers are stored somewhere
-	// return mac_can_accept_bytes >= sockets[t].buffers_read[0].len;
-}
-
-static bool b_recfrom( const int t )
-{
-	bool result;
-
-	if( !has_mac_read_space(t) ) {
-		D(bug("<%d> read stalled, mac cannot accept any more data\r\n", t));
-
-		sockets[t].stream_to_mac_stalled_until = GetTickCount() + sockets[t].resend_timeout;
-		return true;
-	}
-
-	int ret = _WSARecv(
-		sockets[t].s,
-		sockets[t].buffers_read,
-		sockets[t].buffer_count_read,
-		&sockets[t].bytes_received,
-		&sockets[t].flags_read,
-		&sockets[t].overlapped_read,
-		tcp_read_completion
-	);
-
-	if(ret == SOCKET_ERROR) {
-		int socket_error = _WSAGetLastError();
-		if(socket_error == WSA_IO_PENDING) {
-			D(bug("<%d> WSARecv() i/o pending\r\n", t));
-			result = true;
-		} else {
-			D(bug("<%d> WSARecv() returned error %d\r\n", t, socket_error));
-			result = false;
-		}
-	} else /*if(ret == 0) */ {
-		D(bug("<%d> WSARecv() ok\r\n", t));
-		// Completion routine call is already scheduled.
-		result = true;
-	}
-	return result;
-}
-
-static bool b_send( const int t )
-{
-	int ret = _WSASend(
-		sockets[t].s,
-		sockets[t].buffers_write,
-		sockets[t].buffer_count_write,
-		&sockets[t].bytes_written,
-		sockets[t].flags_write,
-		&sockets[t].overlapped_write,
-		tcp_write_completion
-	);
-
-	bool result;
-	if(ret == SOCKET_ERROR) {
-		int socket_error = _WSAGetLastError();
-		if(socket_error == WSA_IO_PENDING) {
-			D(bug("<%d> WSASend() i/o pending\r\n", t));
-			result = true;
-		} else {
-			D(bug("<%d> WSASend() returned %d\r\n", t, socket_error));
-			result = false;
-		}
-	} else /*if(ret == 0) */ {
-		D(bug("<%d> WSASend() ok\r\n", t));
-		// Completion routine call is already scheduled.
-		result = true;
-	}
-	return result;
-}
-
-static void send_buffer( const int t, const bool resending )
-{
-	if(resending) {
-		if(sockets[t].last_seq_out == 0) {
-			D(bug("<%d> resend failure\r\n", t ));
-			return;
-		}
-		sockets[t].seq_out = sockets[t].last_seq_out;
-	} else {
-		sockets[t].last_seq_out = sockets[t].seq_out;
-	}
-
-	D(bug("<%d> %s data to Mac: Seq=%d, Ack=%d\r\n", t, (resending ? "resending" : "sending"), sockets[t].seq_out, sockets[t].seq_in));
-
-	uint32 bytes_read = sockets[t].bytes_received;
-
-	if( sockets[t].mac_mss && bytes_read > sockets[t].mac_mss ) {
-		D(bug("<%d> impossible: %d bytes to send, Mac mss is only %d\r\n", t, sockets[t].mac_mss && bytes_read, sockets[t].mac_mss));
-	}
-
-	int tcp_size = sizeof(tcp_t) + bytes_read;
-
-	tcp_t *tcp = (tcp_t *)malloc( tcp_size );
-	if(tcp) {
-		// Build MAC
-		// memcpy( tcp->ip.mac.dest, sockets[t].mac_src, 6 );
-		memcpy( tcp->ip.mac.dest, ether_addr, 6 );
-		memcpy( tcp->ip.mac.src, router_mac_addr, 6 );
-		tcp->ip.mac.type = htons(mac_type_ip4);
-
-		// Build IP
-		tcp->ip.version = 4;
-		tcp->ip.header_len = 5;
-		tcp->ip.tos = 0;
-		tcp->ip.total_len = htons(sizeof(tcp_t) - sizeof(mac_t) + bytes_read); // no options
-		tcp->ip.ident = htons(next_ip_ident_number++);
-		tcp->ip.flags_n_frag_offset = 0;
-		tcp->ip.ttl = 128; // one hop actually!
-		tcp->ip.proto = ip_proto_tcp;
-		tcp->ip.src = htonl(sockets[t].ip_dest);
-		tcp->ip.dest = htonl(sockets[t].ip_src);
-		make_ip4_checksum( (ip_t *)tcp );
-
-		// Copy payload (used by tcp checksum)
-		memcpy( (char *)tcp + sizeof(tcp_t), sockets[t].buffers_read[0].buf, bytes_read );
-
-		// Build tcp
-		tcp->src_port = htons(sockets[t].dest_port);
-		tcp->dest_port = htons(sockets[t].src_port);
-
-		tcp->seq = htonl(sockets[t].seq_out);
-		tcp->ack = htonl(sockets[t].seq_in);
-
-		tcp->header_len = (uint8)( 20 << 2 );
-#if PUSH_ALWAYS
-		tcp->flags = ACK|PSH;
-#else
-		tcp->flags = (bytes_read == MAX_SEGMENT_SIZE) ? ACK : (ACK|PSH);
-#endif
-		tcp->window = htons( sockets[t].our_window );
-		tcp->urgent_ptr = 0;
-		make_tcp_checksum( tcp, tcp_size );
-
-		sockets[t].seq_out += bytes_read;
-
-		// dump_bytes( (uint8 *)tcp, tcp_size );
-
-		enqueue_packet( (uint8 *)tcp, tcp_size );
-		free(tcp);
-	}
-}
-
-static void CALLBACK tcp_read_completion(
-	DWORD error,
-	DWORD bytes_read,
-	LPWSAOVERLAPPED lpOverlapped,
-	DWORD flags
-)
-{
-	EnterCriticalSection( &tcp_section );
-
-	const int t = (int)lpOverlapped->hEvent;
-
-	sockets[t].bytes_received = bytes_read;
-
-  D(bug("<%d> tcp_read_completion(error=%d, bytes_read=%d)\r\n", t, error, bytes_read));
-
-  D(bug("<%d> tcp_read_completion() start, old state = %s\r\n", t, STATENAME(sockets[t].state)));
-
-	if(!sockets[t].in_use) {
-	  D(bug("<%d> ignoring canceled read\r\n", t));
-	} else {
-		if( error != 0 ) {
-		  D(bug("<%d> resetting after read error\r\n", t));
-			tcp_reply( RST, t );
-			free_socket(t);
-		} else {
-			if(bytes_read == 0) {
-				_closesocket( sockets[t].s );
-				sockets[t].s = INVALID_SOCKET;
-			} else if( bytes_read > 0) {
-				send_buffer( t, false );
-			}
-
-			switch( sockets[t].state ) {
-				case SYN_RCVD:
-					if( bytes_read == 0 ) {
-						D(bug("<%d> Closing: SYN_RCVD -> FINWAIT_1\r\n", t));
-						tcp_reply( ACK|FIN, t );
-						sockets[t].seq_out++;
-						sockets[t].state = FINWAIT_1;
-					}
-					break;
-				case ESTABLISHED:
-					if( bytes_read == 0 ) {
-						D(bug("<%d> Closing: ESTABLISHED -> FINWAIT_1\r\n", t));
-						tcp_reply( ACK|FIN, t );
-						sockets[t].seq_out++;
-						sockets[t].state = FINWAIT_1;
-					}
-					break;
-				case LISTEN:
-					tcp_reply( SYN, t );
-					sockets[t].seq_out++;
-					sockets[t].state = SYN_SENT;
-					sockets[t].time_wait = GetTickCount() + SYN_FLOOD_PROTECTION_TIMEOUT;
-					D(bug("<%d> LISTEN -> SYN_SENT\r\n", t));
-					break;
-				case CLOSE_WAIT:
-					if( bytes_read == 0) {
-						tcp_reply( ACK|FIN, t );
-						sockets[t].seq_out++;
-						sockets[t].state = LAST_ACK;
-						D(bug("<%d> Closing: CLOSE_WAIT -> LAST_ACK\r\n", t));
-						if(sockets[t].remote_closed) {
-							// Just in case that mac gets out of sync.
-							_closesocket(sockets[t].s);
-							sockets[t].s = INVALID_SOCKET;
-						}
-					}
-					break;
-				default:
-					break;
-			}
-
-			if(!is_router_shutting_down && sockets[t].s != INVALID_SOCKET) {
-				if(sockets[t].state != LISTEN) {
-					b_recfrom(t);
-				}
-			}
-		}
-	}
-
-	LeaveCriticalSection( &tcp_section );
-}
-
-static void CALLBACK tcp_write_completion(
-	DWORD error,
-	DWORD bytes_written,
-	LPWSAOVERLAPPED lpOverlapped,
-	DWORD flags
-)
-{
-	EnterCriticalSection( &tcp_section );
-
-	const int t = (int)lpOverlapped->hEvent;
-
-	sockets[t].bytes_written = bytes_written;
-	sockets[t].bytes_remaining_to_send -= bytes_written;
-
-  D(bug("<%d> tcp_write_completion(error=%d, bytes_written=%d)\r\n", t, error, bytes_written));
-
-	if(!sockets[t].in_use) {
-	  D(bug("<%d> ignoring canceled write\r\n", t));
-	} else {
-		if(is_router_shutting_down || sockets[t].s == INVALID_SOCKET) {
-		  D(bug("<%d> is not alive for sending.\r\n", t));
-		} else {
-			if( sockets[t].bytes_remaining_to_send <= 0 ) {
-				D(bug("<%d> all data sent, accepting some more.\r\n", t));
-				sockets[t].seq_in += sockets[t].bytes_to_send;
-				sockets[t].bytes_to_send = sockets[t].bytes_remaining_to_send = 0; // superfluous
-				tcp_reply( ACK, t );
-				sockets[t].accept_more_data_from_mac = true;
-			} else {
-				D(bug("<%d> %d bytes (of %d total) remaining, sending.\r\n", t, sockets[t].bytes_remaining_to_send, sockets[t].bytes_to_send));
-				sockets[t].buffers_write[0].len = sockets[t].bytes_remaining_to_send;
-				char *p = sockets[t].buffers_write[0].buf;
-				memmove( p, &p[bytes_written], sockets[t].bytes_remaining_to_send );
-				if(!b_send(t)) {
-				} else {
-				}
-			}
-		}
-	}
-
-	LeaveCriticalSection( &tcp_section );
-}
-
-static void tcp_connect_callback( const int t )
-{
-  D(bug("<%d> tcp_connect_callback() start, old state = %s\r\n", t, STATENAME(sockets[t].state)));
-
-	switch( sockets[t].state ) {
-		case LISTEN:
-			tcp_reply( SYN|ACK, t );
-			sockets[t].seq_out++;
-			sockets[t].state = SYN_RCVD;
-		  D(bug("<%d> Connect: LISTEN -> SYN_RCVD\r\n", t));
-			break;
-		default:
-			break;
-	}
-  D(bug("<%d> tcp_connect_callback() end, new state = %s\r\n", t, STATENAME(sockets[t].state)));
-}
-
-static void tcp_accept_callback( const int lst )
-{
-  D(bug("[%d] tcp_accept_callback()\r\n", lst));
-
-	struct sockaddr_in to;
-	memset( &to, 0, sizeof(to) );
-	to.sin_family = AF_INET;
-	int tolen = sizeof(to);
-
-	SOCKET s = _accept( l_sockets[lst].s, (struct sockaddr *)&to, &tolen );
-	if( s == INVALID_SOCKET ) {
-		D(bug("[%d] connection not accepted, error code %d\r\n", lst, _WSAGetLastError()));
-	} else {
-		_WSAEventSelect( s, 0, 0 );
-
-		uint16 src_port = l_sockets[lst].port;
-		uint16 dest_port = ntohs(to.sin_port);
-		uint32 ip_dest = ntohl(to.sin_addr.s_addr);
-
-	  D(bug("[%d] connection accepted, local port:%d, remote %s:%d\r\n", lst, src_port, _inet_ntoa(to.sin_addr), dest_port));
-
-		if( l_sockets[lst].ip != 0 && l_sockets[lst].ip != ip_dest ) {
-			_closesocket( s );
-		  D(bug("[%d] authorization failure. connection closed.\r\n", lst ));
-		} else {
-			int t = alloc_new_socket( src_port, dest_port, ip_dest );
-			if( t < 0 ) {
-				D(bug("<%d> out of slot space, connection dropped\r\n", t ));
-				free_socket(t);
-			} else {
-				sockets[t].s = s;
-				sockets[t].state = LISTEN;
-				sockets[t].src_port = src_port;
-				sockets[t].dest_port = dest_port;
-				sockets[t].ip_src = macos_ip_address;
-				sockets[t].ip_dest = ip_dest;
-
-				sockets[t].seq_out = 0x00000001;
-				sockets[t].seq_in = 0; // not known yet
-				sockets[t].mac_ack = sockets[t].seq_out; // zero out pending bytes
-
-				tcp_reply( SYN, t );
-				sockets[t].seq_out++;
-				sockets[t].state = SYN_SENT;
-				sockets[t].time_wait = GetTickCount() + SYN_FLOOD_PROTECTION_TIMEOUT;
-				D(bug("<%d> Connect: LISTEN -> SYN_SENT\r\n", t));
-
-				_WSAResetEvent( sockets[t].ev );
-				if( SOCKET_ERROR == _WSAEventSelect( sockets[t].s, sockets[t].ev, FD_CLOSE ) ) {
-					D(bug("<%d> WSAEventSelect() failed with error code %d\r\n", t, _WSAGetLastError()));
-				}
-
-				// No data from the remote host is needed until the connection is established.
-				// So don't initiate read yet.
-			}
-		}
-	}
-}
-
-/*
-	MSS is the only option I care about, and since I'm on ethernet
-	I already pretty much know everything needed.
-
-	AFAIK window scaling is not in effect unless both parties specify it,
-	and I'm not doing it.
-*/
-static void process_options( const int t, const uint8 *opt, int len, uint32 &mss )
-{
-	mss = 0;
-
-	while( len > 0 ) {
-		switch( *opt ) {
-			case 0:		// End of Option List
-				D(bug("<%d> End of Option List\r\n", t));
-				len = 0;
-				break;
-			case 1:		// No-Operation
-				D(bug("<%d> No-Operation\r\n", t));
-				len--;
-				opt++;
-				break;
-			case 2:		// Maximum Segment Size
-				{
-					mss = ntohs( *((uint16 *)&opt[2]) );
-					D(bug("<%d> Maximum Segment Size = %d\r\n", t, mss));
-					len -= 4;
-					opt += 4;
-				}
-				break;
-			case 3:		// Window Scale
-				{
-					int wscale = opt[2];
-					D(bug("<%d> Window Scale = %d\r\n", t, (int)wscale));
-					len -= 3;
-					opt += 3;
-				}
-				break;
-			case 4:		// Sack-Permitted
-				D(bug("<%d> Sack-Permitted option is set\r\n", t));
-				len -= 2;
-				opt += 2;
-				break;
-			case 5:		// Sack
-				{
-					int sack_len = opt[1];
-					int hf = (sack_len-2) / 4;
-					D(bug("<%d> Sack, %d half-blocks\r\n", t, hf));
-					len -= sack_len;
-					opt += sack_len;
-				}
-				break;
-			case 8:		// Time Stamps
-				{
-					int valve = ntohl( *((uint32 *)&opt[2]) );
-					int ereply = ntohl( *((uint32 *)&opt[6]) );
-					D(bug("<%d> Time Stamps, TS valve = 0x%X, TS echo reply = 0x%X\r\n", t, valve, ereply));
-					len -= 10;
-					opt += 10;
-				}
-				break;
-			default:
-				D(bug("<%d> Unknown tcp header option 0x%02x, breaking out\r\n", t, (int)*opt));
-				len = 0;
-				break;
-		}
-	}
-}
-
-void write_tcp( tcp_t *tcp, int len )
-{
-	if(len < sizeof(tcp_t)) {
-	  D(bug("<%d> Too small tcp packet(%d) on unknown slot, dropped\r\n", -1, len));
-		return;
-	}
-	uint16 src_port = ntohs(tcp->src_port);
-	uint16 dest_port = ntohs(tcp->dest_port);
-
-	BOOL ok = true;
-	BOOL handle_data = false;
-	BOOL initiate_read = false;
-
-	EnterCriticalSection( &tcp_section );
-
-	int t = find_socket( src_port, dest_port );
-
-	if(t < 0) {
-		t = alloc_new_socket( src_port, dest_port, ntohl(tcp->ip.dest) );
-		ok = t >= 0;
-	}
-
-	if(ok) {
-		D(bug("<%d> write_tcp %d bytes from port %d to port %d\r\n", t, len, src_port, dest_port));
-	} else {
-		D(bug("<%d> FAILED write_tcp %d bytes from port %d to port %d\r\n", t, len, src_port, dest_port));
-	}
-
-	if( ok && ISSET(tcp->flags,RST) ) {
-		D(bug("<%d> RST set, resetting socket\r\n", t));
-		if( sockets[t].s != INVALID_SOCKET ) {
-			D(bug("<%d> doing an extra shutdown (ie4)\r\n", t));
-			_shutdown( sockets[t].s, SD_BOTH );
-		}
-		free_socket( t );
-		ok = false;
-	}
-
-	if(ok) {
-		D(bug("<%d> State machine start = %s\r\n", t, STATENAME(sockets[t].state)));
-
-		// always update receive window
-		sockets[t].mac_window = ntohs(tcp->window);
-
-		int header_len = tcp->header_len >> 2;
-		int option_bytes = header_len - 20;
-		char *data = (char *)tcp + sizeof(tcp_t) + option_bytes;
-		int dlen = len - sizeof(tcp_t) - option_bytes;
-
-		if( !ISSET(tcp->flags,ACK) ) {
-			D(bug("<%d> ACK not set\r\n", t));
-		}
-		if( ISSET(tcp->flags,SYN) ) {
-			D(bug("<%d> SYN set\r\n", t));
-
-			// Note that some options are valid even if there is no SYN.
-			// I don't care about those however.
-
-			uint32 new_mss;
-			process_options( t, (uint8 *)data - option_bytes, option_bytes, new_mss );
-			if(new_mss) {
-				sockets[t].mac_mss = (int)new_mss;
-				if( new_mss < sockets[t].buffers_read[0].len ) {
-					sockets[t].buffers_read[0].len = new_mss;
-				}
-				D(bug("<%d> Max segment size set to %d\r\n", t, new_mss));
-			}
-		}
-		if( ISSET(tcp->flags,FIN) ) {
-			D(bug("<%d> FIN set\r\n", t));
-		}
-
-		// The sequence number Mac expects to see next time.
-		sockets[t].mac_ack = ntohl(tcp->ack);
-
-		D(bug("<%d> From Mac: Seq=%d, Ack=%d, window=%d, router Seq=%d\r\n", t, ntohl(tcp->seq), sockets[t].mac_ack, sockets[t].mac_window, sockets[t].seq_out));
-
-		if( sockets[t].stream_to_mac_stalled_until &&
-				sockets[t].mac_ack == sockets[t].seq_out &&
-				(sockets[t].state == ESTABLISHED || sockets[t].state == CLOSE_WAIT) )
-		{
-			if( has_mac_read_space(t) ) {
-				initiate_read = true;
-				sockets[t].stream_to_mac_stalled_until = 0;
-				D(bug("<%d> read resumed, mac can accept more data\r\n", t));
-			}
-		}
-
-		switch( sockets[t].state ) {
-			case CLOSED:
-				sockets[t].src_port = src_port;
-				sockets[t].dest_port = dest_port;
-				sockets[t].ip_src = ntohl(tcp->ip.src);
-				sockets[t].ip_dest = ntohl(tcp->ip.dest);
-
-				if( ISSET(tcp->flags,SYN) ) {
-
-					sockets[t].seq_out = 0x00000001;
-					sockets[t].seq_in = ntohl(tcp->seq) + 1;
-
-					_WSAResetEvent( sockets[t].ev );
-					if( SOCKET_ERROR == _WSAEventSelect( sockets[t].s, sockets[t].ev, FD_CONNECT | FD_CLOSE ) ) {
-						D(bug("<%d> WSAEventSelect() failed with error code %d\r\n", t, _WSAGetLastError()));
-					}
-
-				  D(bug("<%d> connecting local port %d to remote %s:%d\r\n", t, src_port, _inet_ntoa(sockets[t].from.sin_addr), dest_port));
-
-					sockets[t].state = LISTEN;
-					if( _WSAConnect(
-						sockets[t].s,
-						(const struct sockaddr *)&sockets[t].from,
-						sockets[t].from_len,
-						NULL, NULL,
-						NULL, NULL
-					) == SOCKET_ERROR )
-					{
-						int connect_error = _WSAGetLastError();
-						if( connect_error == WSAEWOULDBLOCK ) {
-							D(bug("<%d> WSAConnect() i/o pending.\r\n", t));
-						} else {
-							D(bug("<%d> WSAConnect() failed with error %d.\r\n", t, connect_error));
-						}
-					} else {
-						D(bug("<%d> WSAConnect() ok.\r\n", t));
-					}
-				} else {
-					if( ISSET(tcp->flags,FIN) ) {
-						D(bug("<%d> No SYN but FIN on a closed socket.\r\n", t));
-						free_socket(t);
-					} else {
-						D(bug("<%d> No SYN on a closed socket. resetting.\r\n", t));
-						free_socket(t);
-					}
-				}
-				break;
-			case LISTEN:
-				// handled in connect callback
-				break;
-			case SYN_SENT:
-				if( ISSET(tcp->flags,SYN) && ISSET(tcp->flags,ACK) ) {
-					sockets[t].seq_in = ntohl(tcp->seq) + 1;
-					tcp_reply( ACK, t );
-					sockets[t].state = ESTABLISHED;
-					initiate_read = true;
-					sockets[t].accept_more_data_from_mac = true;
-					sockets[t].time_wait = 0;
-				} else if( ISSET(tcp->flags,SYN) ) {
-					sockets[t].seq_in = ntohl(tcp->seq) + 1;
-					tcp_reply( ACK|SYN, t );
-					sockets[t].seq_out++;
-					sockets[t].state = SYN_RCVD;
-					sockets[t].time_wait = 0;
-				} else if( ISSET(tcp->flags,ACK) ) {
-					// What was the bright idea here.
-					D(bug("<%d> State is SYN_SENT, but got only ACK from Mac??\r\n", t));
-					sockets[t].state = FINWAIT_2;
-					sockets[t].time_wait = 0;
-				}
-				break;
-			case SYN_RCVD:
-				if( ISSET(tcp->flags,ACK) ) {
-					sockets[t].state = ESTABLISHED;
-					handle_data = true;
-					initiate_read = true;
-					sockets[t].accept_more_data_from_mac = true;
-				}
-				break;
-			case ESTABLISHED:
-				if( ISSET(tcp->flags,FIN) ) {
-					sockets[t].seq_in++;
-					tcp_reply( ACK, t );
-					_shutdown( sockets[t].s, SD_SEND );
-					sockets[t].state = CLOSE_WAIT;
-				}
-				handle_data = true;
-				break;
-			case CLOSE_WAIT:
-				// handled in tcp_read_completion
-				break;
-			case LAST_ACK:
-				if( ISSET(tcp->flags,ACK) ) {
-					D(bug("<%d> LAST_ACK received, socket closed\r\n", t));
-					free_socket( t );
-				}
-				break;
-			case FINWAIT_1:
-				if( ISSET(tcp->flags,FIN) && ISSET(tcp->flags,ACK) ) {
-					sockets[t].seq_in++;
-					tcp_reply( ACK, t );
-					if(sockets[t].remote_closed) {
-						_closesocket(sockets[t].s);
-						sockets[t].s = INVALID_SOCKET;
-					} else {
-						_shutdown( sockets[t].s, SD_SEND );
-					}
-					sockets[t].state = TIME_WAIT;
-					sockets[t].time_wait = GetTickCount() + 2 * sockets[t].msl;
-				} else if( ISSET(tcp->flags,FIN) ) {
-					sockets[t].seq_in++;
-					tcp_reply( ACK, t );
-					if(sockets[t].remote_closed) {
-						_closesocket(sockets[t].s);
-						sockets[t].s = INVALID_SOCKET;
-					} else {
-						_shutdown( sockets[t].s, SD_SEND );
-					}
-					sockets[t].state = CLOSING;
-				} else if( ISSET(tcp->flags,ACK) ) {
-					sockets[t].state = FINWAIT_2;
-				}
-				break;
-			case FINWAIT_2:
-				if( ISSET(tcp->flags,FIN) ) {
-					sockets[t].seq_in++;
-					tcp_reply( ACK, t );
-					if(sockets[t].remote_closed) {
-						_closesocket(sockets[t].s);
-						sockets[t].s = INVALID_SOCKET;
-					} else {
-						_shutdown( sockets[t].s, SD_SEND );
-					}
-					sockets[t].state = TIME_WAIT;
-					sockets[t].time_wait = GetTickCount() + 2 * sockets[t].msl;
-				}
-				break;
-			case CLOSING:
-				if( ISSET(tcp->flags,ACK) ) {
-					sockets[t].state = TIME_WAIT;
-					sockets[t].time_wait = GetTickCount() + 2 * sockets[t].msl;
-				}
-				break;
-			case TIME_WAIT:
-				// Catching stray packets: wait MSL * 2 seconds, -> CLOSED
-				// Timer already set since we might not get here at all.
-				// I'm using exceptionally low MSL value (5 secs).
-				D(bug("<%d> time wait, datagram discarded\r\n", t));
-				break;
-		}
-
-		// The "t" descriptor may already be freed. However, it's safe
-		// to peek the state value inside the critical section.
-		D(bug("<%d> State machine end = %s\r\n", t, STATENAME(sockets[t].state)));
-
-		D(bug("<%d> handle_data=%d, initiate_read=%d\r\n", t, handle_data, initiate_read));
-
-		if( handle_data && dlen && sockets[t].accept_more_data_from_mac ) {
-			if( sockets[t].seq_in != ntohl(tcp->seq) ) {
-				D(bug("<%d> dropping duplicate datagram seq=%d, expected=%d\r\n", t, ntohl(tcp->seq), sockets[t].seq_in));
-			} else {
-				set_ttl( t, tcp->ip.ttl );
-
-				struct sockaddr_in to;
-				memset( &to, 0, sizeof(to) );
-				to.sin_family = AF_INET;
-				to.sin_port = tcp->dest_port;
-				to.sin_addr.s_addr = tcp->ip.dest;
-
-				D(bug("<%d> sending %d bytes to remote host\r\n", t, dlen));
-
-				sockets[t].accept_more_data_from_mac = false;
-
-				if( dlen > MAX_SEGMENT_SIZE ) {
-					D(bug("<%d> IMPOSSIBLE: b_send() dropped %d bytes! \r\n", t, dlen-MAX_SEGMENT_SIZE));
-					dlen = MAX_SEGMENT_SIZE;
-				}
-
-				memcpy( sockets[t].buffers_write[0].buf, data, dlen );
-
-				sockets[t].buffers_write[0].len = dlen;
-				sockets[t].bytes_remaining_to_send = dlen;
-				sockets[t].bytes_to_send = dlen;
-
-				bool send_now = false;
-				if( ISSET(tcp->flags,PSH) ) {
-					send_now = true;
-				} else {
-					// todo -- delayed send
-					send_now = true;
-				}
-
-				if(send_now) {
-
-					// Patch ftp server or client address if needed.
-
-					int lst = 1;
-					bool is_pasv;
-					uint16 ftp_data_port = 0;
-
-					if(ftp_is_ftp_port(sockets[t].src_port)) {
-						// Local ftp server may be entering to passive mode.
-						is_pasv = true;
-						ftp_parse_port_command(
-							sockets[t].buffers_write[0].buf,
-							dlen,
-							ftp_data_port,
-							is_pasv
-						);
-					} else if(ftp_is_ftp_port(sockets[t].dest_port)) {
-						// Local ftp client may be using port command.
-						is_pasv = false;
-						ftp_parse_port_command(
-							sockets[t].buffers_write[0].buf,
-							dlen,
-							ftp_data_port,
-							is_pasv
-						);
-					}
-
-					if(ftp_data_port) {
-						D(bug("<%d> ftp %s command detected, port %d\r\n", t, (is_pasv ? "SERVER PASV REPLY" : "CLIENT PORT"), ftp_data_port ));
-
-						// Note: for security reasons, only allow incoming connection from sockets[t].ip_dest
-						lst = alloc_listen_socket( ftp_data_port, sockets[t].ip_dest, 0/*iface*/, true );
-
-						if(lst < 0) {
-							D(bug("<%d> no more free slots\r\n", t));
-						} else {
-							// First start listening (need to know the local name later)
-							tcp_start_listen( lst );
-
-							// When t is closed, lst must be closed too.
-							sockets[t].child = lst;
-							l_sockets[lst].parent = t;
-
-							// Find out the local name
-							struct sockaddr_in name;
-							int namelen = sizeof(name);
-							memset( &name, 0, sizeof(name) );
-							if( _getsockname( sockets[t].s, (struct sockaddr *)&name, &namelen ) == SOCKET_ERROR ) {
-								D(bug("_getsockname() failed, error=%d\r\n", _WSAGetLastError() ));
-							}
-
-							ftp_modify_port_command(
-								sockets[t].buffers_write[0].buf,
-								dlen,
-								MAX_SEGMENT_SIZE,
-								ntohl(name.sin_addr.s_addr),
-								ftp_data_port,
-								is_pasv
-							);
-
-							sockets[t].buffers_write[0].len = dlen;
-							sockets[t].bytes_remaining_to_send = dlen;
-							// Do not change "bytes_to_send" field as it is used for ack calculation
-						}
-					} // end of ftp patch
-
-					if(!b_send(t)) {
-						// on error, close the ftp data listening socket if one was created
-						if(lst >= 0) {
-							D(bug("[%d] closing listening port %d after write error\r\n", t, l_sockets[lst].port));
-							_closesocket( l_sockets[lst].s );
-							l_sockets[lst].s = INVALID_SOCKET;
-							l_sockets[lst].port = 0;
-							l_sockets[lst].ip = 0;
-							l_sockets[lst].parent = -1;
-							sockets[t].child = -1;
-						}
-					}
-				}
-			}
-		}
-
-		if(initiate_read) {
-			if(!b_recfrom(t)) {
-				// post icmp error message
-			}
-		}
-	}
-
-	LeaveCriticalSection( &tcp_section );
-}
-
-/*
-	- Dispatch remote close and connect events.
-	- Expire time-waits.
-	- Handle resend timeouts.
-*/
-static unsigned int WINAPI tcp_connect_close_thread(void *arg)
-{
-	WSAEVENT wait_handles[MAX_SOCKETS];
-
-	for( int i=0; i<MAX_SOCKETS; i++ ) {
-		wait_handles[i] = sockets[i].ev;
-	}
-
-	while(!is_router_shutting_down) {
-		DWORD ret = WaitForMultipleObjects(
-			MAX_SOCKETS,
-			wait_handles,
-			FALSE,
-			200
-		);
-		if(is_router_shutting_down) break;
-
-		EnterCriticalSection( &tcp_section );
-		if( ret >= WAIT_OBJECT_0 && ret < WAIT_OBJECT_0 + MAX_SOCKETS ) {
-			const int t = ret - WAIT_OBJECT_0;
-
-			D(bug("<%d> Event %d\r\n", t, ret));
-
-			if(sockets[t].in_use) {
-				WSANETWORKEVENTS what;
-
-				if( _WSAEnumNetworkEvents( sockets[t].s, sockets[t].ev, &what ) != SOCKET_ERROR ) {
-					if( what.lNetworkEvents & FD_CONNECT ) {
-						if( what.iErrorCode[FD_CONNECT_BIT] == 0 ) {
-							D(bug("<%d> Connect ok\r\n", t));
-							tcp_connect_callback(t);
-						} else {
-							D(bug("<%d> Connect error=%d\r\n", t, what.iErrorCode[FD_CONNECT_BIT]));
-							// Post icmp error
-						}
-					} else if( what.lNetworkEvents & FD_CLOSE ) {
-						if( what.iErrorCode[FD_CLOSE_BIT] == 0 ) {
-							D(bug("<%d> graceful close, state = %s\r\n", t, STATENAME(sockets[t].state)));
-						} else {
-							D(bug("<%d> abortive close, state = %s, code=%d\r\n", t, STATENAME(sockets[t].state), what.iErrorCode[FD_CLOSE_BIT]));
-						}
-						sockets[t].remote_closed = true;
-					}
-				} else {
-					int err = _WSAGetLastError();
-					if( err == WSAENOTSOCK ) {
-						D(bug("<%d> WSAEnumNetworkEvents: socket is already closed\r\n", t));
-					} else {
-						D(bug("<%d> WSAEnumNetworkEvents failed with error code %d, freeing slot\r\n", t, err));
-						free_socket( t );
-					}
-				}
-			}
-			_WSAResetEvent( sockets[t].ev );
-		} else {
-			static int interval = 5;
-			if( !--interval ) {
-				for( int i=0; i<MAX_SOCKETS; i++ ) {
-					if(sockets[i].in_use) {
-						DWORD tmw = sockets[i].time_wait;
-						DWORD stl = sockets[i].stream_to_mac_stalled_until;
-						if( tmw ) {
-							if( GetTickCount() >= tmw ) {
-								if( sockets[i].state == SYN_SENT ) {
-									/*
-										A very basic SYN flood protection. Note that watching
-										SYN_SENT instead of SYN_RCVD, because the state codes are
-										from the point of view of the Mac-Router interface, not Router-Remote.
-									*/
-									D(bug("<%d> SYN_SENT time-out expired\r\n", i));
-								} else {
-									D(bug("<%d> TIME_WAIT expired\r\n", i));
-								}
-								free_socket( i );
-							}
-						} else if( stl ) {
-							if( sockets[i].state == ESTABLISHED ) {
-								if( GetTickCount() >= stl ) {
-									D(bug("<%d> RESEND timeout expired\r\n", i));
-									sockets[i].stream_to_mac_stalled_until = GetTickCount() + sockets[i].resend_timeout;
-									send_buffer( i, true );
-								}
-							} else {
-								sockets[i].stream_to_mac_stalled_until = 0;
-							}
-						}
-					}
-				}
-				interval = 5;
-			}
-		}
-		LeaveCriticalSection( &tcp_section );
-	}
-	return 0;
-}
-
-static unsigned int WINAPI tcp_listen_thread(void *arg)
-{
-	WSAEVENT wait_handles[MAX_SOCKETS];
-
-	for( int i=0; i<MAX_SOCKETS; i++ ) {
-		wait_handles[i] = l_sockets[i].ev;
-		tcp_start_listen( i );
-	}
-
-	while(!is_router_shutting_down) {
-		DWORD ret = WaitForMultipleObjects(
-			MAX_SOCKETS,
-			wait_handles,
-			FALSE,
-			200
-		);
-
-		if(is_router_shutting_down) break;
-
-		EnterCriticalSection( &tcp_section );
-		if( ret >= WAIT_OBJECT_0 && ret < WAIT_OBJECT_0 + MAX_SOCKETS ) {
-			const int lst = ret - WAIT_OBJECT_0;
-
-			D(bug("[%d] connection attempt to port %d\r\n", lst, l_sockets[lst].port));
-
-			WSANETWORKEVENTS what;
-
-			if( _WSAEnumNetworkEvents( l_sockets[lst].s, l_sockets[lst].ev, &what ) != SOCKET_ERROR ) {
-				if( what.lNetworkEvents & FD_ACCEPT ) {
-					if( what.iErrorCode[FD_ACCEPT_BIT] == 0 ) {
-						D(bug("[%d] Connect ok\r\n", lst));
-						tcp_accept_callback(lst);
-					} else {
-						D(bug("[%d] Connect error=%d\r\n", lst, what.iErrorCode[FD_ACCEPT_BIT]));
-						// Post icmp error
-					}
-				}
-			}
-
-			// close on errors too
-			if(l_sockets[lst].once) {
-				D(bug("[%d] once mode: closing listening socket on port %d\r\n", lst, l_sockets[lst].port));
-				if( _closesocket( l_sockets[lst].s ) == SOCKET_ERROR ) {
-					int err = _WSAGetLastError();
-					D(bug("[%d] close error %d\r\n", lst, err));
-				}
-
-				l_sockets[lst].s = INVALID_SOCKET;
-				l_sockets[lst].port = 0;
-				l_sockets[lst].ip = 0;
-
-				int t = l_sockets[lst].parent;
-				if( t >= 0 ) {
-					sockets[t].child = -1;
-				}
-				l_sockets[lst].parent = -1;
-			}
-
-			_WSAResetEvent( l_sockets[lst].ev );
-		}
-		LeaveCriticalSection( &tcp_section );
-	}
-	return 0;
-}
-
-/*
-	tcp_port=<port> [,<interface to bind>]
-	tcp_port=21,192.168.0.1
-*/
-
-static void init_tcp_listen_ports()
-{
-	int32 index = 0;
-	const char *port_str;
-	while ((port_str = PrefsFindString("tcp_port", index++)) != NULL) {
-		uint32 iface = 0;
-		const char *if_str = strchr(port_str,',');
-		if(if_str) {
-			if_str++;
-			uint32 if_net = _inet_addr( if_str );
-			if(if_net == INADDR_NONE) if_net = INADDR_ANY;
-			iface = ntohl( if_net );
-		}
-		uint16 port = (uint16)strtoul( port_str, 0, 0 );
-		if( port ) {
-			uint32 ip = 0;
-			bool once = false;
-			alloc_listen_socket( port, ip, iface, once );
-		}
-	}
-}
-
-static HANDLE tcp_handle = 0;
-static HANDLE tcp_l_handle = 0;
-
-void init_tcp()
-{
-	InitializeCriticalSection( &tcp_section );
-
-	for( int i=0; i<MAX_SOCKETS; i++ ) {
-		memset( &sockets[i], 0, sizeof(tcp_socket_t) );
-		sockets[i].s = INVALID_SOCKET;
-		sockets[i].state = CLOSED;
-		sockets[i].ev = _WSACreateEvent();
-		sockets[i].child = -1;
-	}
-
-	for( int i=0; i<MAX_SOCKETS; i++ ) {
-		memset( &l_sockets[i], 0, sizeof(tcp_listening_socket_t) );
-		l_sockets[i].s = INVALID_SOCKET;
-		l_sockets[i].ev = _WSACreateEvent();
-		l_sockets[i].parent = -1;
-		/*
-		l_sockets[i].port = 0;
-		l_sockets[i].ip = 0;
-		l_sockets[i].iface = 0;
-		l_sockets[i].once = false;
-		*/
-	}
-
-	init_tcp_listen_ports();
-
-	unsigned int tcp_tid;
-	tcp_handle = (HANDLE)_beginthreadex( 0, 0, tcp_connect_close_thread, 0, 0, &tcp_tid );
-
-	unsigned int tcp_l_tid;
-	tcp_l_handle = (HANDLE)_beginthreadex( 0, 0, tcp_listen_thread, 0, 0, &tcp_l_tid );
-}
-
-void final_tcp()
-{
-  D(bug("closing all tcp sockets\r\n"));
-	for( int i=0; i<MAX_SOCKETS; i++ ) {
-		if(sockets[i].s != INVALID_SOCKET) {
-		  D(bug("  closing socket %d\r\n", i));
-		}
-		free_socket( i );
-		if(sockets[i].buffers_write[0].buf) {
-			delete [] sockets[i].buffers_write[0].buf;
-			sockets[i].buffers_write[0].buf = 0;
-		}
-		if(sockets[i].buffers_read[0].buf) {
-			delete [] sockets[i].buffers_read[0].buf;
-			sockets[i].buffers_read[0].buf = 0;
-		}
-	}
-
-  D(bug("closing all tcp listening socket\r\n"));
-	for( int i=0; i<MAX_SOCKETS; i++ ) {
-		if(l_sockets[i].s != INVALID_SOCKET) {
-		  D(bug("  closing listening socket %d\r\n", i));
-			_closesocket( l_sockets[i].s );
-			l_sockets[i].s = INVALID_SOCKET;
-		}
-	}
-
-	// The router module has already set the shutdown flag.
-	WaitForSingleObject( tcp_handle, INFINITE );
-	WaitForSingleObject( tcp_l_handle, INFINITE );
-
-	for( int i=0; i<MAX_SOCKETS; i++ ) {
-		if(sockets[i].ev != WSA_INVALID_EVENT) {
-			_WSACloseEvent(sockets[i].ev);
-			sockets[i].ev = WSA_INVALID_EVENT;
-		}
-	}
-	for( int i=0; i<MAX_SOCKETS; i++ ) {
-		if(l_sockets[i].ev != WSA_INVALID_EVENT) {
-			_WSACloseEvent(l_sockets[i].ev);
-			l_sockets[i].ev = WSA_INVALID_EVENT;
-		}
-	}
-
-	DeleteCriticalSection( &tcp_section );
-}
+/*
+ *  tcp.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ *  Features implemented:
+ *		state machine, flow control, sequence numbers, RST/SYN/FIN/ACK/PSH
+ *  
+ *  Features not implemented:
+ *		oob data, urgent pointer, window sliding, some options
+ *		"Half-Nagle" implementation is a bit weird (mac-router interface; winsock has it on by default)
+ *  
+ *  
+ *  All possible tcp state machine transitions:
+ *  
+ *		CLOSED ->	LISTEN						passive open
+ *		CLOSED ->	SYN_SENT					active open				SYN->
+ *  
+ *		LISTEN ->	SYN_SENT					send data					SYN->
+ *		LISTEN ->	SYN_RCVD					->SYN							SYN+ACK->
+ *  
+ *		SYN_SENT ->	SYN_RCVD				->SYN							SYN+ACK->
+ *		SYN_SENT ->	ESTABLISHED			->SYN+ACK					ACK->
+ *		SYN_SENT ->	CLOSED					close/timeout
+ *  
+ *		SYN_RCVD ->	CLOSED					timeout						RST->
+ *		SYN_RCVD ->	LISTEN					->RST
+ *		SYN_RCVD ->	ESTABLISHED			->ACK
+ *		SYN_RCVD ->	FINWAIT_1				close							FIN->
+ *  
+ *		ESTABLISHED -> FINWAIT_1		close							FIN->
+ *		ESTABLISHED -> CLOSE_WAIT		->FIN							ACK->
+ *  
+ *		CLOSE_WAIT -> LAST_ACK			close							FIN->
+ *  
+ *		LAST_ACK -> CLOSED					->ACK
+ *  
+ *		FINWAIT_1 -> CLOSING				->FIN							ACK->
+ *		FINWAIT_1 -> FINWAIT_2			->ACK
+ *		FINWAIT_1 -> TIME_WAIT			->FIN+ACK					ACK->
+ *  
+ *		FINWAIT_2 -> TIME_WAIT			->FIN							ACK->
+ *  
+ *		CLOSING -> TIME_WAIT				->ACK
+ *  
+ *		TIME_WAIT -> CLOSED					timeout (2*msl)
+ *  
+ */
+
+#include "sysdeps.h"
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <process.h>
+
+#include "cpu_emulation.h"
+#include "ws2tcpip.h"
+#include "ether_windows.h"
+#include "ether.h"
+#include "prefs.h"
+#include "router.h"
+#include "router_types.h"
+#include "dynsockets.h"
+#include "iphelp.h"
+#include "tcp.h"
+#include "dump.h"
+#include "mib/interfaces.h"
+#include "ftp.h"
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+// If you need more, use multiple threads.
+#define MAX_SOCKETS MAXIMUM_WAIT_OBJECTS
+
+// If true, always sends the PSH tcp flag with data.
+// Otherwise only when a full buffer was received.
+#define PUSH_ALWAYS 0
+
+// In milliseconds. A TCP implementation should implement
+// this dynamically, adapting the timeout value to match to the
+// averaged packet round-trip time.
+#define RESEND_TIMEOUT 750
+
+// Just time out incoming connections after 5 secs if Mac has no time to reply
+// No backlogs.
+#define SYN_FLOOD_PROTECTION_TIMEOUT 5000
+
+const int MAX_SEGMENT_SIZE = 1460;
+
+// Shorthands
+#define ISSET(f,x) ( ((f) & (x)) != 0 )
+#define ISCLEAR(f,x) ( ((f) & (x)) == 0 )
+
+// Local aliases
+#define URG tcp_flags_URG
+#define ACK tcp_flags_ACK
+#define PSH tcp_flags_PSH
+#define RST tcp_flags_RST
+#define SYN tcp_flags_SYN
+#define FIN tcp_flags_FIN
+
+// Local aliases
+#define CLOSED 			tcp_state_closed
+#define LISTEN 			tcp_state_listen
+#define SYN_SENT 		tcp_state_syn_sent
+#define SYN_RCVD 		tcp_state_syn_rcvd
+#define ESTABLISHED tcp_state_established
+#define CLOSE_WAIT 	tcp_state_close_wait
+#define LAST_ACK 		tcp_state_last_ack
+#define FINWAIT_1 	tcp_state_finwait_1
+#define FINWAIT_2 	tcp_state_finwait_2
+#define CLOSING 		tcp_state_closing
+#define TIME_WAIT 	tcp_state_time_wait
+
+// For debugging only
+static const char *_tcp_state_name[] = {
+	"CLOSED",
+	"LISTEN",
+	"SYN_SENT",
+	"SYN_RCVD",
+	"ESTABLISHED",
+	"CLOSE_WAIT",
+	"LAST_ACK",
+	"FINWAIT_1",
+	"FINWAIT_2",
+	"CLOSING",
+	"TIME_WAIT"
+};
+#define STATENAME(i) _tcp_state_name[i]
+
+static CRITICAL_SECTION tcp_section;
+
+typedef struct {
+	SOCKET s;
+	int state;
+
+	uint32 ip_src;											// "source" is the mac, dest is the remote host,
+	uint32 ip_dest;											// no matter who opened the connection.
+	uint16 src_port;										// all in host byte order.
+	uint16 dest_port;
+
+	struct sockaddr_in from;						// remote host address, network byte order.
+	int from_len;
+
+	// note: no true windows sliding, only one buffer.
+	WSABUF buffers_read[1];							// data from remote host to Mac
+	DWORD buffer_count_read;
+	DWORD bytes_received;
+	DWORD flags_read;
+	WSAOVERLAPPED overlapped_read;
+
+	WSABUF buffers_write[1];						// data from Mac to remote host
+	DWORD buffer_count_write;
+	DWORD bytes_written;
+	DWORD flags_write;
+	WSAOVERLAPPED overlapped_write;
+
+	bool remote_closed;									// remote will not send any more data
+	bool accept_more_data_from_mac;			// are we ready to accept more data from mac
+
+	uint32 seq_in;											// will ack this mac sequence number
+	uint32 seq_out;											// next sequence number to mac (unless a resend is needed)
+	uint32 mac_ack;											// mac has acked this byte count. can be used to determined when to send some more data
+
+	uint32 bytes_to_send;								// total send block size
+	uint32 bytes_remaining_to_send;			// unsent byte count
+
+	uint16 mac_window;									// mac tcp receive window, slides according to the window principle
+	uint16 our_window;									// not really used
+	uint16 mac_mss;											// maximum segment size that mac reported at SYN handshaking
+
+	// resend info
+	uint32 last_seq_out;								// remember last packet seq number if a resend is needed
+	uint32 resend_timeout;							// currently set t0 0.75 secs but not updated
+	uint32 stream_to_mac_stalled_until;	// tick count indicating resend time
+
+	DWORD time_wait;										// do a graceful close after MSL*2
+	DWORD msl;
+
+	int child;
+
+	WSAEVENT ev;												// used to signal remote-initiated close and host-initiated connect.
+
+	bool in_use;
+} tcp_socket_t;
+
+static tcp_socket_t sockets[MAX_SOCKETS];
+
+typedef struct {
+	SOCKET s;
+	uint16 port;
+	uint32 ip;
+	uint32 iface;
+	bool once;
+	int parent;
+	WSAEVENT ev;
+} tcp_listening_socket_t;
+
+static tcp_listening_socket_t l_sockets[MAX_SOCKETS];
+
+static void CALLBACK tcp_read_completion(
+	DWORD error,
+	DWORD bytes_read,
+	LPWSAOVERLAPPED lpOverlapped,
+	DWORD flags
+);
+
+static void CALLBACK tcp_write_completion(
+	DWORD error,
+	DWORD bytes_read,
+	LPWSAOVERLAPPED lpOverlapped,
+	DWORD flags
+);
+
+// socket utilities assume that the critical section has already been entered.
+static void free_socket( const int t )
+{
+	_WSAResetEvent( sockets[t].ev );
+	if(sockets[t].s != INVALID_SOCKET) {
+		_closesocket( sockets[t].s );
+		sockets[t].s = INVALID_SOCKET;
+	}
+	sockets[t].state = CLOSED;
+	sockets[t].stream_to_mac_stalled_until = 0;
+	sockets[t].in_use = false;
+	sockets[t].time_wait = 0;
+
+	// if there was an attached listening socket (ftp), close it.
+	int lst = sockets[t].child;
+	if( lst >= 0 ) {
+		if(l_sockets[lst].s != INVALID_SOCKET) {
+		  D(bug("  closing listening socket %d\r\n", lst));
+			_closesocket( l_sockets[lst].s );
+			l_sockets[lst].s = INVALID_SOCKET;
+		}
+		l_sockets[lst].port = 0;
+		l_sockets[lst].parent = -1;
+	}
+	sockets[t].child = -1;
+}
+
+static int alloc_socket()
+{
+	static int last_allocated_socket = -1;
+
+	int i = last_allocated_socket;
+	for( int j=0; j<MAX_SOCKETS; j++ ) {
+		if( ++i >= MAX_SOCKETS ) i = 0;
+		if( !sockets[i].in_use ) {
+			D(bug("<%d> Socket allocated\r\n", i));
+
+			last_allocated_socket = i;
+			sockets[i].in_use = true;
+
+			sockets[i].s = INVALID_SOCKET;
+			sockets[i].state = CLOSED;
+			sockets[i].remote_closed = false;
+
+			sockets[i].accept_more_data_from_mac = false;
+
+			sockets[i].ip_src = sockets[i].ip_dest = 0;
+			// sockets[i].src_port = sockets[i].dest_port = 0;
+
+			memset( &sockets[i].overlapped_read, 0, sizeof(sockets[i].overlapped_read) );
+			sockets[i].overlapped_read.hEvent = (HANDLE)i;
+			memset( &sockets[i].overlapped_write, 0, sizeof(sockets[i].overlapped_write) );
+			sockets[i].overlapped_write.hEvent = (HANDLE)i;
+
+			sockets[i].bytes_received = 0;
+			sockets[i].bytes_written = 0;
+
+			sockets[i].flags_read = 0;
+			sockets[i].flags_write = 0;
+
+			// sockets[i].from_len = sizeof(struct sockaddr_in);
+			// memset( &sockets[i].from, 0, sizeof(sockets[i].from) );
+			// sockets[i].from.sin_family = AF_INET;
+
+			sockets[i].buffer_count_read = 1;
+			sockets[i].buffers_read[0].len = MAX_SEGMENT_SIZE;
+			if(!sockets[i].buffers_read[0].buf) {
+				sockets[i].buffers_read[0].buf = new char [sockets[i].buffers_read[0].len];
+			}
+			
+			sockets[i].buffer_count_write = 1;
+			sockets[i].buffers_write[0].len = MAX_SEGMENT_SIZE;
+			if(!sockets[i].buffers_write[0].buf) {
+				sockets[i].buffers_write[0].buf = new char [sockets[i].buffers_write[0].len];
+			}
+
+			sockets[i].mac_window = MAX_SEGMENT_SIZE; // updated for all mac datagrams
+			sockets[i].our_window = MAX_SEGMENT_SIZE; // should use about 8-16 kB, really
+			sockets[i].mac_mss = 0;			// not known yet
+
+			sockets[i].time_wait = 0;
+			sockets[i].msl = 5000L;			// The round-trip time can be hard to estimate.
+
+			sockets[i].seq_in = 0;
+			sockets[i].seq_out = 0x00000001;
+			sockets[i].mac_ack = 0;
+			sockets[i].stream_to_mac_stalled_until = 0;
+
+			sockets[i].resend_timeout = RESEND_TIMEOUT;
+
+			sockets[i].child = -1;
+
+			break;
+		}
+	}
+	if(i == MAX_SOCKETS) {
+		D(bug("Out of free sockets\r\n"));
+		i = -1;
+	}
+	return i;
+}
+
+static int alloc_new_socket( const uint16 src_port, const uint16 dest_port, const uint32 ip_dest )
+{
+	int t = alloc_socket();
+
+	if(t >= 0) {
+		sockets[t].s = _socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
+		if(sockets[t].s == INVALID_SOCKET) {
+			free_socket( t );
+			t = -1;
+		} else {
+			sockets[t].src_port = src_port;
+			sockets[t].dest_port = dest_port;
+			
+			sockets[t].from_len = sizeof(sockets[t].from);
+			memset( &sockets[t].from, 0, sockets[t].from_len );
+			sockets[t].from.sin_family = AF_INET;
+			sockets[t].from.sin_port = htons(dest_port);
+			sockets[t].from.sin_addr.s_addr = htonl(ip_dest);
+
+			struct sockaddr_in to;
+			memset( &to, 0, sizeof(to) );
+			to.sin_family = AF_INET;
+
+			if(	_bind ( sockets[t].s, (const struct sockaddr *)&to, sizeof(to) ) == 0 ) {
+				D(bug("<%d> socket bound\r\n", t));
+			} else {
+				if( _WSAGetLastError() == WSAEINPROGRESS ) {
+					D(bug("<%d> bind: a blocking call is in progress.\r\n", t));
+				} else {
+					D(bug("<%d> bind failed with error code %d\r\n", t, _WSAGetLastError()));
+				}
+				free_socket( t );
+				t = -1;
+			}
+		}
+	}
+	return t;
+}
+
+static int get_socket_index( const uint16 src_port, const uint16 dest_port )
+{
+	for( int i=0; i<MAX_SOCKETS; i++ ) {
+		if(sockets[i].in_use && sockets[i].src_port == src_port && sockets[i].dest_port == dest_port ) {
+			return i;
+		}
+	}
+	return -1;
+}
+
+static int get_socket_index( const uint16 src_port )
+{
+	for( int i=0; i<MAX_SOCKETS; i++ ) {
+		if(sockets[i].in_use && sockets[i].src_port == src_port ) {
+			return i;
+		}
+	}
+	return -1;
+}
+
+static int find_socket( const uint16 src_port, const uint16 dest_port )
+{
+	int i = get_socket_index( src_port, dest_port );
+	if( i < 0 ) {
+		i = get_socket_index( src_port );
+		if( i >= 0 ) {
+			if( sockets[i].s == INVALID_SOCKET ) {
+			  D(bug("find_socket reusing slot %d...\r\n", i));
+				sockets[i].in_use = false;
+			} else {
+			  D(bug("find_socket forcing close %d...\r\n", i));
+				free_socket( i );
+			}
+			i = -1;
+		}
+	}
+
+  D(bug("<%d> find_socket(%d,%d): %s\r\n", i, src_port, dest_port, i>=0 ? "found" : "not found"));
+
+	return i;
+}
+
+static int alloc_listen_socket( const uint16 port, const uint32 ip, const uint32 iface, const bool once )
+{
+	static int last_allocated_socket = -1;
+
+	int i = last_allocated_socket;
+
+	for( int j=0; j<MAX_SOCKETS; j++ ) {
+		if( ++i >= MAX_SOCKETS ) i = 0;
+		if( l_sockets[i].port == 0 ) {
+			D(bug("[%d] Slot allocated for listening port %d\r\n", i, port));
+			l_sockets[i].port = port;
+			l_sockets[i].ip = ip;
+			l_sockets[i].iface = iface;
+			l_sockets[i].once = once;
+			l_sockets[i].parent = -1;
+			last_allocated_socket = i;
+			_WSAResetEvent( l_sockets[i].ev );
+			return i;
+		}
+	}
+	return -1;
+}
+
+static void tcp_start_listen( const int i )
+{
+	if( l_sockets[i].port ) {
+		uint32 iface = l_sockets[i].iface;
+
+		D(bug("[%d] binding to interface 0x%08X\r\n", i, iface));
+
+		l_sockets[i].s = _socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
+		if(l_sockets[i].s != INVALID_SOCKET) {
+			struct sockaddr_in to;
+			memset( &to, 0, sizeof(to) );
+			to.sin_family = AF_INET;
+			to.sin_port = htons( l_sockets[i].port );
+			to.sin_addr.s_addr = htonl( iface );
+
+			if(	_bind ( l_sockets[i].s, (const struct sockaddr *)&to, sizeof(to) ) == 0 )
+			{
+				D(bug("[%d] socket bound to port %d on interface 0x%08X\r\n", i, l_sockets[i].port, iface));
+				if( _listen( l_sockets[i].s, SOMAXCONN ) == SOCKET_ERROR  ) {
+					D(bug("[%d] listen() failed with error code %d\r\n", i, _WSAGetLastError()));
+				} else {
+					D(bug("[%d] listening to port %d\r\n", i, l_sockets[i].port));
+					_WSAResetEvent( l_sockets[i].ev );
+					if( SOCKET_ERROR == _WSAEventSelect( l_sockets[i].s, l_sockets[i].ev, FD_ACCEPT ) ) {
+						D(bug("[%d] WSAEventSelect() failed with error code %d\r\n", i, _WSAGetLastError()));
+					}
+				}
+			} else {
+				D(bug("[%d] bind to port %d failed with error code %d\r\n", i, l_sockets[i].port, _WSAGetLastError()));
+			}
+		} else {
+			D(bug("[%d] could not create a socket for port %d, error = %d\r\n", i, l_sockets[i].port, _WSAGetLastError()));
+		}
+	}
+}
+
+static void set_ttl( const int t, const uint8 ttl )
+{
+	int _ttl = ttl; // defensive programming, I know VCx
+
+	if(_setsockopt( sockets[t].s, IPPROTO_IP, IP_TTL, (const char *)&_ttl, sizeof(int) ) == SOCKET_ERROR  ) {
+		D(bug("<%d> could not set ttl to %d, error=%d\r\n", t, ttl, _WSAGetLastError()));
+	} else {
+		D(bug("<%d> ttl set to %d.\r\n", t, ttl));
+	}
+}
+
+static void tcp_reply( const int flags, const int t )
+{
+	int tcp_size = sizeof(tcp_t);
+
+	tcp_t *tcp = (tcp_t *)malloc( tcp_size );
+	if(tcp) {
+		memcpy( tcp->ip.mac.dest, ether_addr, 6 );
+		memcpy( tcp->ip.mac.src, router_mac_addr, 6 );
+		tcp->ip.mac.type = htons(mac_type_ip4);
+
+		tcp->ip.version = 4;
+		tcp->ip.header_len = 5;
+		tcp->ip.tos = 0;
+		tcp->ip.total_len = htons(tcp_size - sizeof(mac_t));
+		tcp->ip.ident = htons(next_ip_ident_number++);
+		tcp->ip.flags_n_frag_offset = 0;
+		tcp->ip.ttl = 128;
+		tcp->ip.proto = ip_proto_tcp;
+		tcp->ip.src = htonl(sockets[t].ip_dest);
+		tcp->ip.dest = htonl(sockets[t].ip_src);
+		make_ip4_checksum( (ip_t *)tcp );
+
+		D(bug("<%d> Reply: Seq=%d, Ack=%d\r\n", t, sockets[t].seq_out, sockets[t].seq_in));
+
+		tcp->src_port = htons(sockets[t].dest_port);
+		tcp->dest_port = htons(sockets[t].src_port);
+		tcp->seq = htonl(sockets[t].seq_out);
+		tcp->ack = htonl(sockets[t].seq_in);
+		tcp->header_len = (uint8)( 20 << 2 );
+		tcp->flags = flags;
+		tcp->window = htons( sockets[t].our_window );
+		tcp->urgent_ptr = 0;
+		make_tcp_checksum( tcp, tcp_size );
+
+		// dump_bytes( (uint8 *)tcp, tcp_size );
+
+		enqueue_packet( (uint8 *)tcp, tcp_size );
+		free(tcp);
+	}
+}
+
+static bool has_mac_read_space( const int t )
+{
+	uint32 pending_bytes = sockets[t].seq_out - sockets[t].mac_ack;
+	uint32 mac_can_accept_bytes = sockets[t].mac_window - pending_bytes;
+
+	D(bug("<%d> mac_can_accept_bytes = %d\r\n", t, mac_can_accept_bytes));
+
+	// Modified Nagle, effectively disabling window sliding (which I don't support anyway):
+	return pending_bytes == 0;
+
+	// Use more of window bandwidth
+	// Enabling this would require that the buffers seq numbers are stored somewhere
+	// return mac_can_accept_bytes >= sockets[t].buffers_read[0].len;
+}
+
+static bool b_recfrom( const int t )
+{
+	bool result;
+
+	if( !has_mac_read_space(t) ) {
+		D(bug("<%d> read stalled, mac cannot accept any more data\r\n", t));
+
+		sockets[t].stream_to_mac_stalled_until = GetTickCount() + sockets[t].resend_timeout;
+		return true;
+	}
+
+	int ret = _WSARecv(
+		sockets[t].s,
+		sockets[t].buffers_read,
+		sockets[t].buffer_count_read,
+		&sockets[t].bytes_received,
+		&sockets[t].flags_read,
+		&sockets[t].overlapped_read,
+		tcp_read_completion
+	);
+
+	if(ret == SOCKET_ERROR) {
+		int socket_error = _WSAGetLastError();
+		if(socket_error == WSA_IO_PENDING) {
+			D(bug("<%d> WSARecv() i/o pending\r\n", t));
+			result = true;
+		} else {
+			D(bug("<%d> WSARecv() returned error %d\r\n", t, socket_error));
+			result = false;
+		}
+	} else /*if(ret == 0) */ {
+		D(bug("<%d> WSARecv() ok\r\n", t));
+		// Completion routine call is already scheduled.
+		result = true;
+	}
+	return result;
+}
+
+static bool b_send( const int t )
+{
+	int ret = _WSASend(
+		sockets[t].s,
+		sockets[t].buffers_write,
+		sockets[t].buffer_count_write,
+		&sockets[t].bytes_written,
+		sockets[t].flags_write,
+		&sockets[t].overlapped_write,
+		tcp_write_completion
+	);
+
+	bool result;
+	if(ret == SOCKET_ERROR) {
+		int socket_error = _WSAGetLastError();
+		if(socket_error == WSA_IO_PENDING) {
+			D(bug("<%d> WSASend() i/o pending\r\n", t));
+			result = true;
+		} else {
+			D(bug("<%d> WSASend() returned %d\r\n", t, socket_error));
+			result = false;
+		}
+	} else /*if(ret == 0) */ {
+		D(bug("<%d> WSASend() ok\r\n", t));
+		// Completion routine call is already scheduled.
+		result = true;
+	}
+	return result;
+}
+
+static void send_buffer( const int t, const bool resending )
+{
+	if(resending) {
+		if(sockets[t].last_seq_out == 0) {
+			D(bug("<%d> resend failure\r\n", t ));
+			return;
+		}
+		sockets[t].seq_out = sockets[t].last_seq_out;
+	} else {
+		sockets[t].last_seq_out = sockets[t].seq_out;
+	}
+
+	D(bug("<%d> %s data to Mac: Seq=%d, Ack=%d\r\n", t, (resending ? "resending" : "sending"), sockets[t].seq_out, sockets[t].seq_in));
+
+	uint32 bytes_read = sockets[t].bytes_received;
+
+	if( sockets[t].mac_mss && bytes_read > sockets[t].mac_mss ) {
+		D(bug("<%d> impossible: %d bytes to send, Mac mss is only %d\r\n", t, sockets[t].mac_mss && bytes_read, sockets[t].mac_mss));
+	}
+
+	int tcp_size = sizeof(tcp_t) + bytes_read;
+
+	tcp_t *tcp = (tcp_t *)malloc( tcp_size );
+	if(tcp) {
+		// Build MAC
+		// memcpy( tcp->ip.mac.dest, sockets[t].mac_src, 6 );
+		memcpy( tcp->ip.mac.dest, ether_addr, 6 );
+		memcpy( tcp->ip.mac.src, router_mac_addr, 6 );
+		tcp->ip.mac.type = htons(mac_type_ip4);
+
+		// Build IP
+		tcp->ip.version = 4;
+		tcp->ip.header_len = 5;
+		tcp->ip.tos = 0;
+		tcp->ip.total_len = htons(sizeof(tcp_t) - sizeof(mac_t) + bytes_read); // no options
+		tcp->ip.ident = htons(next_ip_ident_number++);
+		tcp->ip.flags_n_frag_offset = 0;
+		tcp->ip.ttl = 128; // one hop actually!
+		tcp->ip.proto = ip_proto_tcp;
+		tcp->ip.src = htonl(sockets[t].ip_dest);
+		tcp->ip.dest = htonl(sockets[t].ip_src);
+		make_ip4_checksum( (ip_t *)tcp );
+
+		// Copy payload (used by tcp checksum)
+		memcpy( (char *)tcp + sizeof(tcp_t), sockets[t].buffers_read[0].buf, bytes_read );
+
+		// Build tcp
+		tcp->src_port = htons(sockets[t].dest_port);
+		tcp->dest_port = htons(sockets[t].src_port);
+
+		tcp->seq = htonl(sockets[t].seq_out);
+		tcp->ack = htonl(sockets[t].seq_in);
+
+		tcp->header_len = (uint8)( 20 << 2 );
+#if PUSH_ALWAYS
+		tcp->flags = ACK|PSH;
+#else
+		tcp->flags = (bytes_read == MAX_SEGMENT_SIZE) ? ACK : (ACK|PSH);
+#endif
+		tcp->window = htons( sockets[t].our_window );
+		tcp->urgent_ptr = 0;
+		make_tcp_checksum( tcp, tcp_size );
+
+		sockets[t].seq_out += bytes_read;
+
+		// dump_bytes( (uint8 *)tcp, tcp_size );
+
+		enqueue_packet( (uint8 *)tcp, tcp_size );
+		free(tcp);
+	}
+}
+
+static void CALLBACK tcp_read_completion(
+	DWORD error,
+	DWORD bytes_read,
+	LPWSAOVERLAPPED lpOverlapped,
+	DWORD flags
+)
+{
+	EnterCriticalSection( &tcp_section );
+
+	const int t = (int)lpOverlapped->hEvent;
+
+	sockets[t].bytes_received = bytes_read;
+
+  D(bug("<%d> tcp_read_completion(error=%d, bytes_read=%d)\r\n", t, error, bytes_read));
+
+  D(bug("<%d> tcp_read_completion() start, old state = %s\r\n", t, STATENAME(sockets[t].state)));
+
+	if(!sockets[t].in_use) {
+	  D(bug("<%d> ignoring canceled read\r\n", t));
+	} else {
+		if( error != 0 ) {
+		  D(bug("<%d> resetting after read error\r\n", t));
+			tcp_reply( RST, t );
+			free_socket(t);
+		} else {
+			if(bytes_read == 0) {
+				_closesocket( sockets[t].s );
+				sockets[t].s = INVALID_SOCKET;
+			} else if( bytes_read > 0) {
+				send_buffer( t, false );
+			}
+
+			switch( sockets[t].state ) {
+				case SYN_RCVD:
+					if( bytes_read == 0 ) {
+						D(bug("<%d> Closing: SYN_RCVD -> FINWAIT_1\r\n", t));
+						tcp_reply( ACK|FIN, t );
+						sockets[t].seq_out++;
+						sockets[t].state = FINWAIT_1;
+					}
+					break;
+				case ESTABLISHED:
+					if( bytes_read == 0 ) {
+						D(bug("<%d> Closing: ESTABLISHED -> FINWAIT_1\r\n", t));
+						tcp_reply( ACK|FIN, t );
+						sockets[t].seq_out++;
+						sockets[t].state = FINWAIT_1;
+					} 
+					break;
+				case LISTEN:
+					tcp_reply( SYN, t );
+					sockets[t].seq_out++;
+					sockets[t].state = SYN_SENT;
+					sockets[t].time_wait = GetTickCount() + SYN_FLOOD_PROTECTION_TIMEOUT;
+					D(bug("<%d> LISTEN -> SYN_SENT\r\n", t));
+					break;
+				case CLOSE_WAIT:
+					if( bytes_read == 0) {
+						tcp_reply( ACK|FIN, t );
+						sockets[t].seq_out++;
+						sockets[t].state = LAST_ACK;
+						D(bug("<%d> Closing: CLOSE_WAIT -> LAST_ACK\r\n", t));
+						if(sockets[t].remote_closed) {
+							// Just in case that mac gets out of sync.
+							_closesocket(sockets[t].s);
+							sockets[t].s = INVALID_SOCKET;
+						}
+					}
+					break;
+				default:
+					break;
+			}
+
+			if(!is_router_shutting_down && sockets[t].s != INVALID_SOCKET) {
+				if(sockets[t].state != LISTEN) {
+					b_recfrom(t);
+				}
+			}
+		}
+	}
+
+	LeaveCriticalSection( &tcp_section );
+}
+
+static void CALLBACK tcp_write_completion(
+	DWORD error,
+	DWORD bytes_written,
+	LPWSAOVERLAPPED lpOverlapped,
+	DWORD flags
+)
+{
+	EnterCriticalSection( &tcp_section );
+
+	const int t = (int)lpOverlapped->hEvent;
+
+	sockets[t].bytes_written = bytes_written;
+	sockets[t].bytes_remaining_to_send -= bytes_written;
+
+  D(bug("<%d> tcp_write_completion(error=%d, bytes_written=%d)\r\n", t, error, bytes_written));
+
+	if(!sockets[t].in_use) {
+	  D(bug("<%d> ignoring canceled write\r\n", t));
+	} else {
+		if(is_router_shutting_down || sockets[t].s == INVALID_SOCKET) {
+		  D(bug("<%d> is not alive for sending.\r\n", t));
+		} else {
+			if( sockets[t].bytes_remaining_to_send <= 0 ) {
+				D(bug("<%d> all data sent, accepting some more.\r\n", t));
+				sockets[t].seq_in += sockets[t].bytes_to_send;
+				sockets[t].bytes_to_send = sockets[t].bytes_remaining_to_send = 0; // superfluous
+				tcp_reply( ACK, t );
+				sockets[t].accept_more_data_from_mac = true;
+			} else {
+				D(bug("<%d> %d bytes (of %d total) remaining, sending.\r\n", t, sockets[t].bytes_remaining_to_send, sockets[t].bytes_to_send));
+				sockets[t].buffers_write[0].len = sockets[t].bytes_remaining_to_send;
+				char *p = sockets[t].buffers_write[0].buf;
+				memmove( p, &p[bytes_written], sockets[t].bytes_remaining_to_send );
+				if(!b_send(t)) {
+				} else {
+				}
+			}
+		}
+	}
+
+	LeaveCriticalSection( &tcp_section );
+}
+
+static void tcp_connect_callback( const int t )
+{
+  D(bug("<%d> tcp_connect_callback() start, old state = %s\r\n", t, STATENAME(sockets[t].state)));
+
+	switch( sockets[t].state ) {
+		case LISTEN:
+			tcp_reply( SYN|ACK, t );
+			sockets[t].seq_out++;
+			sockets[t].state = SYN_RCVD;
+		  D(bug("<%d> Connect: LISTEN -> SYN_RCVD\r\n", t));
+			break;
+		default:
+			break;
+	}
+  D(bug("<%d> tcp_connect_callback() end, new state = %s\r\n", t, STATENAME(sockets[t].state)));
+}
+
+static void tcp_accept_callback( const int lst )
+{
+  D(bug("[%d] tcp_accept_callback()\r\n", lst));
+
+	struct sockaddr_in to;
+	memset( &to, 0, sizeof(to) );
+	to.sin_family = AF_INET;
+	int tolen = sizeof(to);
+
+	SOCKET s = _accept( l_sockets[lst].s, (struct sockaddr *)&to, &tolen );
+	if( s == INVALID_SOCKET ) {
+		D(bug("[%d] connection not accepted, error code %d\r\n", lst, _WSAGetLastError()));
+	} else {
+		_WSAEventSelect( s, 0, 0 );
+
+		uint16 src_port = l_sockets[lst].port;
+		uint16 dest_port = ntohs(to.sin_port);
+		uint32 ip_dest = ntohl(to.sin_addr.s_addr);
+
+	  D(bug("[%d] connection accepted, local port:%d, remote %s:%d\r\n", lst, src_port, _inet_ntoa(to.sin_addr), dest_port));
+
+		if( l_sockets[lst].ip != 0 && l_sockets[lst].ip != ip_dest ) {
+			_closesocket( s );
+		  D(bug("[%d] authorization failure. connection closed.\r\n", lst ));
+		} else {
+			int t = alloc_new_socket( src_port, dest_port, ip_dest );
+			if( t < 0 ) {
+				D(bug("<%d> out of slot space, connection dropped\r\n", t ));
+				free_socket(t);
+			} else {
+				sockets[t].s = s;
+				sockets[t].state = LISTEN;
+				sockets[t].src_port = src_port;
+				sockets[t].dest_port = dest_port;
+				sockets[t].ip_src = macos_ip_address;
+				sockets[t].ip_dest = ip_dest;
+
+				sockets[t].seq_out = 0x00000001;
+				sockets[t].seq_in = 0; // not known yet
+				sockets[t].mac_ack = sockets[t].seq_out; // zero out pending bytes
+
+				tcp_reply( SYN, t );
+				sockets[t].seq_out++;
+				sockets[t].state = SYN_SENT;
+				sockets[t].time_wait = GetTickCount() + SYN_FLOOD_PROTECTION_TIMEOUT;
+				D(bug("<%d> Connect: LISTEN -> SYN_SENT\r\n", t));
+
+				_WSAResetEvent( sockets[t].ev );
+				if( SOCKET_ERROR == _WSAEventSelect( sockets[t].s, sockets[t].ev, FD_CLOSE ) ) {
+					D(bug("<%d> WSAEventSelect() failed with error code %d\r\n", t, _WSAGetLastError()));
+				}
+
+				// No data from the remote host is needed until the connection is established.
+				// So don't initiate read yet.
+			}
+		}
+	}
+}
+
+/*
+	MSS is the only option I care about, and since I'm on ethernet
+	I already pretty much know everything needed.
+
+	AFAIK window scaling is not in effect unless both parties specify it,
+	and I'm not doing it.
+*/
+static void process_options( const int t, const uint8 *opt, int len, uint32 &mss )
+{
+	mss = 0;
+
+	while( len > 0 ) {
+		switch( *opt ) {
+			case 0:		// End of Option List
+				D(bug("<%d> End of Option List\r\n", t));
+				len = 0;
+				break;
+			case 1:		// No-Operation
+				D(bug("<%d> No-Operation\r\n", t));
+				len--;
+				opt++;
+				break;
+			case 2:		// Maximum Segment Size
+				{
+					mss = ntohs( *((uint16 *)&opt[2]) );
+					D(bug("<%d> Maximum Segment Size = %d\r\n", t, mss));
+					len -= 4;
+					opt += 4;
+				}
+				break;
+			case 3:		// Window Scale
+				{
+					int wscale = opt[2];
+					D(bug("<%d> Window Scale = %d\r\n", t, (int)wscale));
+					len -= 3;
+					opt += 3;
+				}
+				break;
+			case 4:		// Sack-Permitted
+				D(bug("<%d> Sack-Permitted option is set\r\n", t));
+				len -= 2;
+				opt += 2;
+				break;
+			case 5:		// Sack
+				{
+					int sack_len = opt[1];
+					int hf = (sack_len-2) / 4;
+					D(bug("<%d> Sack, %d half-blocks\r\n", t, hf));
+					len -= sack_len;
+					opt += sack_len;
+				}
+				break;
+			case 8:		// Time Stamps
+				{
+					int valve = ntohl( *((uint32 *)&opt[2]) );
+					int ereply = ntohl( *((uint32 *)&opt[6]) );
+					D(bug("<%d> Time Stamps, TS valve = 0x%X, TS echo reply = 0x%X\r\n", t, valve, ereply));
+					len -= 10;
+					opt += 10;
+				}
+				break;
+			default:
+				D(bug("<%d> Unknown tcp header option 0x%02x, breaking out\r\n", t, (int)*opt));
+				len = 0;
+				break;
+		}
+	}
+}
+
+void write_tcp( tcp_t *tcp, int len )
+{
+	if(len < sizeof(tcp_t)) {
+	  D(bug("<%d> Too small tcp packet(%d) on unknown slot, dropped\r\n", -1, len));
+		return;
+	}
+	uint16 src_port = ntohs(tcp->src_port);
+	uint16 dest_port = ntohs(tcp->dest_port);
+
+	BOOL ok = true;
+	BOOL handle_data = false;
+	BOOL initiate_read = false;
+
+	EnterCriticalSection( &tcp_section );
+
+	int t = find_socket( src_port, dest_port );
+
+	if(t < 0) {
+		t = alloc_new_socket( src_port, dest_port, ntohl(tcp->ip.dest) );
+		ok = t >= 0;
+	}
+
+	if(ok) {
+		D(bug("<%d> write_tcp %d bytes from port %d to port %d\r\n", t, len, src_port, dest_port));
+	} else {
+		D(bug("<%d> FAILED write_tcp %d bytes from port %d to port %d\r\n", t, len, src_port, dest_port));
+	}
+
+	if( ok && ISSET(tcp->flags,RST) ) {
+		D(bug("<%d> RST set, resetting socket\r\n", t));
+		if( sockets[t].s != INVALID_SOCKET ) {
+			D(bug("<%d> doing an extra shutdown (ie4)\r\n", t));
+			_shutdown( sockets[t].s, SD_BOTH );
+		}
+		free_socket( t );
+		ok = false;
+	}
+
+	if(ok) {
+		D(bug("<%d> State machine start = %s\r\n", t, STATENAME(sockets[t].state)));
+
+		// always update receive window
+		sockets[t].mac_window = ntohs(tcp->window);
+
+		int header_len = tcp->header_len >> 2;
+		int option_bytes = header_len - 20;
+		char *data = (char *)tcp + sizeof(tcp_t) + option_bytes;
+		int dlen = len - sizeof(tcp_t) - option_bytes;
+
+		if( !ISSET(tcp->flags,ACK) ) {
+			D(bug("<%d> ACK not set\r\n", t));
+		}
+		if( ISSET(tcp->flags,SYN) ) {
+			D(bug("<%d> SYN set\r\n", t));
+
+			// Note that some options are valid even if there is no SYN.
+			// I don't care about those however.
+
+			uint32 new_mss;
+			process_options( t, (uint8 *)data - option_bytes, option_bytes, new_mss );
+			if(new_mss) {
+				sockets[t].mac_mss = (int)new_mss;
+				if( new_mss < sockets[t].buffers_read[0].len ) {
+					sockets[t].buffers_read[0].len = new_mss;
+				}
+				D(bug("<%d> Max segment size set to %d\r\n", t, new_mss));
+			}
+		}
+		if( ISSET(tcp->flags,FIN) ) {
+			D(bug("<%d> FIN set\r\n", t));
+		}
+
+		// The sequence number Mac expects to see next time.
+		sockets[t].mac_ack = ntohl(tcp->ack);
+
+		D(bug("<%d> From Mac: Seq=%d, Ack=%d, window=%d, router Seq=%d\r\n", t, ntohl(tcp->seq), sockets[t].mac_ack, sockets[t].mac_window, sockets[t].seq_out));
+
+		if( sockets[t].stream_to_mac_stalled_until && 
+				sockets[t].mac_ack == sockets[t].seq_out &&
+				(sockets[t].state == ESTABLISHED || sockets[t].state == CLOSE_WAIT) )
+		{
+			if( has_mac_read_space(t) ) {
+				initiate_read = true;
+				sockets[t].stream_to_mac_stalled_until = 0;
+				D(bug("<%d> read resumed, mac can accept more data\r\n", t));
+			}
+		}
+
+		switch( sockets[t].state ) {
+			case CLOSED:
+				sockets[t].src_port = src_port;
+				sockets[t].dest_port = dest_port;
+				sockets[t].ip_src = ntohl(tcp->ip.src);
+				sockets[t].ip_dest = ntohl(tcp->ip.dest);
+
+				if( ISSET(tcp->flags,SYN) ) {
+
+					sockets[t].seq_out = 0x00000001;
+					sockets[t].seq_in = ntohl(tcp->seq) + 1;
+
+					_WSAResetEvent( sockets[t].ev );
+					if( SOCKET_ERROR == _WSAEventSelect( sockets[t].s, sockets[t].ev, FD_CONNECT | FD_CLOSE ) ) {
+						D(bug("<%d> WSAEventSelect() failed with error code %d\r\n", t, _WSAGetLastError()));
+					}
+
+				  D(bug("<%d> connecting local port %d to remote %s:%d\r\n", t, src_port, _inet_ntoa(sockets[t].from.sin_addr), dest_port));
+
+					sockets[t].state = LISTEN;
+					if( _WSAConnect(
+						sockets[t].s,
+						(const struct sockaddr *)&sockets[t].from,
+						sockets[t].from_len,
+						NULL, NULL,
+						NULL, NULL
+					) == SOCKET_ERROR )
+					{
+						int connect_error = _WSAGetLastError();
+						if( connect_error == WSAEWOULDBLOCK ) {
+							D(bug("<%d> WSAConnect() i/o pending.\r\n", t));
+						} else {
+							D(bug("<%d> WSAConnect() failed with error %d.\r\n", t, connect_error));
+						}
+					} else {
+						D(bug("<%d> WSAConnect() ok.\r\n", t));
+					}
+				} else {
+					if( ISSET(tcp->flags,FIN) ) {
+						D(bug("<%d> No SYN but FIN on a closed socket.\r\n", t));
+						free_socket(t);
+					} else {
+						D(bug("<%d> No SYN on a closed socket. resetting.\r\n", t));
+						free_socket(t);
+					}
+				}
+				break;
+			case LISTEN:
+				// handled in connect callback
+				break;
+			case SYN_SENT:
+				if( ISSET(tcp->flags,SYN) && ISSET(tcp->flags,ACK) ) {
+					sockets[t].seq_in = ntohl(tcp->seq) + 1;
+					tcp_reply( ACK, t );
+					sockets[t].state = ESTABLISHED;
+					initiate_read = true;
+					sockets[t].accept_more_data_from_mac = true;
+					sockets[t].time_wait = 0;
+				} else if( ISSET(tcp->flags,SYN) ) {
+					sockets[t].seq_in = ntohl(tcp->seq) + 1;
+					tcp_reply( ACK|SYN, t );
+					sockets[t].seq_out++;
+					sockets[t].state = SYN_RCVD;
+					sockets[t].time_wait = 0;
+				} else if( ISSET(tcp->flags,ACK) ) {
+					// What was the bright idea here.
+					D(bug("<%d> State is SYN_SENT, but got only ACK from Mac??\r\n", t));
+					sockets[t].state = FINWAIT_2;
+					sockets[t].time_wait = 0;
+				}
+				break;
+			case SYN_RCVD:
+				if( ISSET(tcp->flags,ACK) ) {
+					sockets[t].state = ESTABLISHED;
+					handle_data = true;
+					initiate_read = true;
+					sockets[t].accept_more_data_from_mac = true;
+				}
+				break;
+			case ESTABLISHED:
+				if( ISSET(tcp->flags,FIN) ) {
+					sockets[t].seq_in++;
+					tcp_reply( ACK, t );
+					_shutdown( sockets[t].s, SD_SEND );
+					sockets[t].state = CLOSE_WAIT;
+				}
+				handle_data = true;
+				break;
+			case CLOSE_WAIT:
+				// handled in tcp_read_completion
+				break;
+			case LAST_ACK:
+				if( ISSET(tcp->flags,ACK) ) {
+					D(bug("<%d> LAST_ACK received, socket closed\r\n", t));
+					free_socket( t );
+				}
+				break;
+			case FINWAIT_1:
+				if( ISSET(tcp->flags,FIN) && ISSET(tcp->flags,ACK) ) {
+					sockets[t].seq_in++;
+					tcp_reply( ACK, t );
+					if(sockets[t].remote_closed) {
+						_closesocket(sockets[t].s);
+						sockets[t].s = INVALID_SOCKET;
+					} else {
+						_shutdown( sockets[t].s, SD_SEND );
+					}
+					sockets[t].state = TIME_WAIT;
+					sockets[t].time_wait = GetTickCount() + 2 * sockets[t].msl;
+				} else if( ISSET(tcp->flags,FIN) ) {
+					sockets[t].seq_in++;
+					tcp_reply( ACK, t );
+					if(sockets[t].remote_closed) {
+						_closesocket(sockets[t].s);
+						sockets[t].s = INVALID_SOCKET;
+					} else {
+						_shutdown( sockets[t].s, SD_SEND );
+					}
+					sockets[t].state = CLOSING;
+				} else if( ISSET(tcp->flags,ACK) ) {
+					sockets[t].state = FINWAIT_2;
+				}
+				break;
+			case FINWAIT_2:
+				if( ISSET(tcp->flags,FIN) ) {
+					sockets[t].seq_in++;
+					tcp_reply( ACK, t );
+					if(sockets[t].remote_closed) {
+						_closesocket(sockets[t].s);
+						sockets[t].s = INVALID_SOCKET;
+					} else {
+						_shutdown( sockets[t].s, SD_SEND );
+					}
+					sockets[t].state = TIME_WAIT;
+					sockets[t].time_wait = GetTickCount() + 2 * sockets[t].msl;
+				}
+				break;
+			case CLOSING:
+				if( ISSET(tcp->flags,ACK) ) {
+					sockets[t].state = TIME_WAIT;
+					sockets[t].time_wait = GetTickCount() + 2 * sockets[t].msl;
+				}
+				break;
+			case TIME_WAIT:
+				// Catching stray packets: wait MSL * 2 seconds, -> CLOSED
+				// Timer already set since we might not get here at all.
+				// I'm using exceptionally low MSL value (5 secs).
+				D(bug("<%d> time wait, datagram discarded\r\n", t));
+				break;
+		}
+
+		// The "t" descriptor may already be freed. However, it's safe
+		// to peek the state value inside the critical section.
+		D(bug("<%d> State machine end = %s\r\n", t, STATENAME(sockets[t].state)));
+
+		D(bug("<%d> handle_data=%d, initiate_read=%d\r\n", t, handle_data, initiate_read));
+
+		if( handle_data && dlen && sockets[t].accept_more_data_from_mac ) {
+			if( sockets[t].seq_in != ntohl(tcp->seq) ) {
+				D(bug("<%d> dropping duplicate datagram seq=%d, expected=%d\r\n", t, ntohl(tcp->seq), sockets[t].seq_in));
+			} else {
+				set_ttl( t, tcp->ip.ttl );
+
+				struct sockaddr_in to;
+				memset( &to, 0, sizeof(to) );
+				to.sin_family = AF_INET;
+				to.sin_port = tcp->dest_port;
+				to.sin_addr.s_addr = tcp->ip.dest;
+
+				D(bug("<%d> sending %d bytes to remote host\r\n", t, dlen));
+
+				sockets[t].accept_more_data_from_mac = false;
+
+				if( dlen > MAX_SEGMENT_SIZE ) {
+					D(bug("<%d> IMPOSSIBLE: b_send() dropped %d bytes! \r\n", t, dlen-MAX_SEGMENT_SIZE));
+					dlen = MAX_SEGMENT_SIZE;
+				}
+
+				memcpy( sockets[t].buffers_write[0].buf, data, dlen );
+
+				sockets[t].buffers_write[0].len = dlen;
+				sockets[t].bytes_remaining_to_send = dlen;
+				sockets[t].bytes_to_send = dlen;
+
+				bool send_now = false;
+				if( ISSET(tcp->flags,PSH) ) {
+					send_now = true;
+				} else {
+					// todo -- delayed send
+					send_now = true;
+				}
+				
+				if(send_now) {
+
+					// Patch ftp server or client address if needed.
+
+					int lst = 1;
+					bool is_pasv;
+					uint16 ftp_data_port = 0;
+
+					if(ftp_is_ftp_port(sockets[t].src_port)) {
+						// Local ftp server may be entering to passive mode.
+						is_pasv = true;
+						ftp_parse_port_command( 
+							sockets[t].buffers_write[0].buf,
+							dlen,
+							ftp_data_port,
+							is_pasv
+						);
+					} else if(ftp_is_ftp_port(sockets[t].dest_port)) {
+						// Local ftp client may be using port command.
+						is_pasv = false;
+						ftp_parse_port_command( 
+							sockets[t].buffers_write[0].buf,
+							dlen,
+							ftp_data_port,
+							is_pasv
+						);
+					}
+
+					if(ftp_data_port) {
+						D(bug("<%d> ftp %s command detected, port %d\r\n", t, (is_pasv ? "SERVER PASV REPLY" : "CLIENT PORT"), ftp_data_port ));
+
+						// Note: for security reasons, only allow incoming connection from sockets[t].ip_dest
+						lst = alloc_listen_socket( ftp_data_port, sockets[t].ip_dest, 0/*iface*/, true );
+
+						if(lst < 0) {
+							D(bug("<%d> no more free slots\r\n", t));
+						} else {
+							// First start listening (need to know the local name later)
+							tcp_start_listen( lst );
+
+							// When t is closed, lst must be closed too.
+							sockets[t].child = lst;
+							l_sockets[lst].parent = t;
+
+							// Find out the local name
+							struct sockaddr_in name;
+							int namelen = sizeof(name);
+							memset( &name, 0, sizeof(name) );
+							if( _getsockname( sockets[t].s, (struct sockaddr *)&name, &namelen ) == SOCKET_ERROR ) {
+								D(bug("_getsockname() failed, error=%d\r\n", _WSAGetLastError() ));
+							}
+
+							ftp_modify_port_command( 
+								sockets[t].buffers_write[0].buf,
+								dlen,
+								MAX_SEGMENT_SIZE,
+								ntohl(name.sin_addr.s_addr),
+								ftp_data_port,
+								is_pasv
+							);
+
+							sockets[t].buffers_write[0].len = dlen;
+							sockets[t].bytes_remaining_to_send = dlen;
+							// Do not change "bytes_to_send" field as it is used for ack calculation
+						}
+					} // end of ftp patch
+
+					if(!b_send(t)) {
+						// on error, close the ftp data listening socket if one was created
+						if(lst >= 0) {
+							D(bug("[%d] closing listening port %d after write error\r\n", t, l_sockets[lst].port));
+							_closesocket( l_sockets[lst].s );
+							l_sockets[lst].s = INVALID_SOCKET;
+							l_sockets[lst].port = 0;
+							l_sockets[lst].ip = 0;
+							l_sockets[lst].parent = -1;
+							sockets[t].child = -1;
+						}
+					}
+				}
+			}
+		}
+
+		if(initiate_read) {
+			if(!b_recfrom(t)) {
+				// post icmp error message
+			}
+		}
+	}
+
+	LeaveCriticalSection( &tcp_section );
+}
+
+/*
+	- Dispatch remote close and connect events.
+	- Expire time-waits.
+	- Handle resend timeouts.
+*/
+static unsigned int WINAPI tcp_connect_close_thread(void *arg)
+{
+	WSAEVENT wait_handles[MAX_SOCKETS];
+
+	for( int i=0; i<MAX_SOCKETS; i++ ) {
+		wait_handles[i] = sockets[i].ev;
+	}
+
+	while(!is_router_shutting_down) {
+		DWORD ret = WaitForMultipleObjects(
+			MAX_SOCKETS,
+			wait_handles,
+			FALSE,
+			200
+		);
+		if(is_router_shutting_down) break;
+
+		EnterCriticalSection( &tcp_section );
+		if( ret >= WAIT_OBJECT_0 && ret < WAIT_OBJECT_0 + MAX_SOCKETS ) {
+			const int t = ret - WAIT_OBJECT_0;
+
+			D(bug("<%d> Event %d\r\n", t, ret));
+
+			if(sockets[t].in_use) {
+				WSANETWORKEVENTS what;
+
+				if( _WSAEnumNetworkEvents( sockets[t].s, sockets[t].ev, &what ) != SOCKET_ERROR ) {
+					if( what.lNetworkEvents & FD_CONNECT ) {
+						if( what.iErrorCode[FD_CONNECT_BIT] == 0 ) {
+							D(bug("<%d> Connect ok\r\n", t));
+							tcp_connect_callback(t);
+						} else {
+							D(bug("<%d> Connect error=%d\r\n", t, what.iErrorCode[FD_CONNECT_BIT]));
+							// Post icmp error
+						}
+					} else if( what.lNetworkEvents & FD_CLOSE ) {
+						if( what.iErrorCode[FD_CLOSE_BIT] == 0 ) {
+							D(bug("<%d> graceful close, state = %s\r\n", t, STATENAME(sockets[t].state)));
+						} else {
+							D(bug("<%d> abortive close, state = %s, code=%d\r\n", t, STATENAME(sockets[t].state), what.iErrorCode[FD_CLOSE_BIT]));
+						}
+						sockets[t].remote_closed = true;
+					}
+				} else {
+					int err = _WSAGetLastError();
+					if( err == WSAENOTSOCK ) {
+						D(bug("<%d> WSAEnumNetworkEvents: socket is already closed\r\n", t));
+					} else {
+						D(bug("<%d> WSAEnumNetworkEvents failed with error code %d, freeing slot\r\n", t, err));
+						free_socket( t );
+					}
+				}
+			}
+			_WSAResetEvent( sockets[t].ev );
+		} else {
+			static int interval = 5;
+			if( !--interval ) {
+				for( int i=0; i<MAX_SOCKETS; i++ ) {
+					if(sockets[i].in_use) {
+						DWORD tmw = sockets[i].time_wait;
+						DWORD stl = sockets[i].stream_to_mac_stalled_until;
+						if( tmw ) {
+							if( GetTickCount() >= tmw ) {
+								if( sockets[i].state == SYN_SENT ) {
+									/*
+										A very basic SYN flood protection. Note that watching
+										SYN_SENT instead of SYN_RCVD, because the state codes are
+										from the point of view of the Mac-Router interface, not Router-Remote.
+									*/
+									D(bug("<%d> SYN_SENT time-out expired\r\n", i));
+								} else {
+									D(bug("<%d> TIME_WAIT expired\r\n", i));
+								}
+								free_socket( i );
+							}
+						} else if( stl ) {
+							if( sockets[i].state == ESTABLISHED ) {
+								if( GetTickCount() >= stl ) {
+									D(bug("<%d> RESEND timeout expired\r\n", i));
+									sockets[i].stream_to_mac_stalled_until = GetTickCount() + sockets[i].resend_timeout;
+									send_buffer( i, true );
+								}
+							} else {
+								sockets[i].stream_to_mac_stalled_until = 0;
+							}
+						}
+					}
+				}
+				interval = 5;
+			}
+		}
+		LeaveCriticalSection( &tcp_section );
+	}
+	return 0;
+}
+
+static unsigned int WINAPI tcp_listen_thread(void *arg)
+{
+	WSAEVENT wait_handles[MAX_SOCKETS];
+
+	for( int i=0; i<MAX_SOCKETS; i++ ) {
+		wait_handles[i] = l_sockets[i].ev;
+		tcp_start_listen( i );
+	}
+
+	while(!is_router_shutting_down) {
+		DWORD ret = WaitForMultipleObjects(
+			MAX_SOCKETS,
+			wait_handles,
+			FALSE,
+			200
+		);
+
+		if(is_router_shutting_down) break;
+
+		EnterCriticalSection( &tcp_section );
+		if( ret >= WAIT_OBJECT_0 && ret < WAIT_OBJECT_0 + MAX_SOCKETS ) {
+			const int lst = ret - WAIT_OBJECT_0;
+
+			D(bug("[%d] connection attempt to port %d\r\n", lst, l_sockets[lst].port));
+
+			WSANETWORKEVENTS what;
+
+			if( _WSAEnumNetworkEvents( l_sockets[lst].s, l_sockets[lst].ev, &what ) != SOCKET_ERROR ) {
+				if( what.lNetworkEvents & FD_ACCEPT ) {
+					if( what.iErrorCode[FD_ACCEPT_BIT] == 0 ) {
+						D(bug("[%d] Connect ok\r\n", lst));
+						tcp_accept_callback(lst);
+					} else {
+						D(bug("[%d] Connect error=%d\r\n", lst, what.iErrorCode[FD_ACCEPT_BIT]));
+						// Post icmp error
+					}
+				}
+			}
+
+			// close on errors too
+			if(l_sockets[lst].once) {
+				D(bug("[%d] once mode: closing listening socket on port %d\r\n", lst, l_sockets[lst].port));
+				if( _closesocket( l_sockets[lst].s ) == SOCKET_ERROR ) {
+					int err = _WSAGetLastError();
+					D(bug("[%d] close error %d\r\n", lst, err));
+				}
+
+				l_sockets[lst].s = INVALID_SOCKET;
+				l_sockets[lst].port = 0;
+				l_sockets[lst].ip = 0;
+
+				int t = l_sockets[lst].parent;
+				if( t >= 0 ) {
+					sockets[t].child = -1;
+				}
+				l_sockets[lst].parent = -1;
+			}
+
+			_WSAResetEvent( l_sockets[lst].ev );
+		}
+		LeaveCriticalSection( &tcp_section );
+	}
+	return 0;
+}
+
+/*
+	tcp_port=<port> [,<interface to bind>]
+	tcp_port=21,192.168.0.1
+*/
+
+static void init_tcp_listen_ports()
+{
+	int32 index = 0;
+	char *port_str;
+	while ((port_str = strdup(PrefsFindString("tcp_port", index++))) != NULL) {
+		uint32 iface = 0;
+		char *if_str = strchr(port_str,',');
+		if(if_str) {
+			*if_str++ = 0;
+			uint32 if_net = _inet_addr( if_str );
+			if(if_net == INADDR_NONE) if_net = INADDR_ANY;
+			iface = ntohl( if_net );
+		}
+		uint16 port = (uint16)strtoul( port_str, 0, 0 );
+		free(port_str);
+		if( port ) {
+			uint32 ip = 0;
+			bool once = false;
+			alloc_listen_socket( port, ip, iface, once );
+		}
+	}
+}
+
+static HANDLE tcp_handle = 0;
+static HANDLE tcp_l_handle = 0;
+
+void init_tcp()
+{
+	InitializeCriticalSection( &tcp_section );
+
+	for( int i=0; i<MAX_SOCKETS; i++ ) {
+		memset( &sockets[i], 0, sizeof(tcp_socket_t) );
+		sockets[i].s = INVALID_SOCKET;
+		sockets[i].state = CLOSED;
+		sockets[i].ev = _WSACreateEvent();
+		sockets[i].child = -1;
+	}
+
+	for( int i=0; i<MAX_SOCKETS; i++ ) {
+		memset( &l_sockets[i], 0, sizeof(tcp_listening_socket_t) );
+		l_sockets[i].s = INVALID_SOCKET;
+		l_sockets[i].ev = _WSACreateEvent();
+		l_sockets[i].parent = -1;
+		/*
+		l_sockets[i].port = 0;
+		l_sockets[i].ip = 0;
+		l_sockets[i].iface = 0;
+		l_sockets[i].once = false;
+		*/
+	}
+
+	init_tcp_listen_ports();
+
+	unsigned int tcp_tid;
+	tcp_handle = (HANDLE)_beginthreadex( 0, 0, tcp_connect_close_thread, 0, 0, &tcp_tid );
+
+	unsigned int tcp_l_tid;
+	tcp_l_handle = (HANDLE)_beginthreadex( 0, 0, tcp_listen_thread, 0, 0, &tcp_l_tid );
+}
+
+void final_tcp()
+{
+  D(bug("closing all tcp sockets\r\n"));
+	for( int i=0; i<MAX_SOCKETS; i++ ) {
+		if(sockets[i].s != INVALID_SOCKET) {
+		  D(bug("  closing socket %d\r\n", i));
+		}
+		free_socket( i );
+		if(sockets[i].buffers_write[0].buf) {
+			delete [] sockets[i].buffers_write[0].buf;
+			sockets[i].buffers_write[0].buf = 0;
+		}
+		if(sockets[i].buffers_read[0].buf) {
+			delete [] sockets[i].buffers_read[0].buf;
+			sockets[i].buffers_read[0].buf = 0;
+		}
+	}
+
+  D(bug("closing all tcp listening socket\r\n"));
+	for( int i=0; i<MAX_SOCKETS; i++ ) {
+		if(l_sockets[i].s != INVALID_SOCKET) {
+		  D(bug("  closing listening socket %d\r\n", i));
+			_closesocket( l_sockets[i].s );
+			l_sockets[i].s = INVALID_SOCKET;
+		}
+	}
+
+	// The router module has already set the shutdown flag.
+	WaitForSingleObject( tcp_handle, INFINITE );
+	WaitForSingleObject( tcp_l_handle, INFINITE );
+
+	for( int i=0; i<MAX_SOCKETS; i++ ) {
+		if(sockets[i].ev != WSA_INVALID_EVENT) {
+			_WSACloseEvent(sockets[i].ev);
+			sockets[i].ev = WSA_INVALID_EVENT;
+		}
+	}
+	for( int i=0; i<MAX_SOCKETS; i++ ) {
+		if(l_sockets[i].ev != WSA_INVALID_EVENT) {
+			_WSACloseEvent(l_sockets[i].ev);
+			l_sockets[i].ev = WSA_INVALID_EVENT;
+		}
+	}
+
+	DeleteCriticalSection( &tcp_section );
+}
--- macemu/SheepShaver/src/Windows/router/tcp.h
+++ sheepshaver/SheepShaver/src/Windows/router/tcp.h
@@ -1,31 +1,31 @@
-/*
- *  tcp.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _TCP_H_
-#define _TCP_H_
-
-void write_tcp( tcp_t *tcp, int len );
-
-void init_tcp();
-void final_tcp();
-
-#endif // _TCP_H_
+/*
+ *  tcp.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _TCP_H_
+#define _TCP_H_
+
+void write_tcp( tcp_t *tcp, int len );
+
+void init_tcp();
+void final_tcp();
+
+#endif // _TCP_H_
--- macemu/SheepShaver/src/Windows/router/udp.cpp
+++ sheepshaver/SheepShaver/src/Windows/router/udp.cpp
@@ -1,206 +1,205 @@
-/*
- *  udp.cpp - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "main.h"
-#include "cpu_emulation.h"
-#include "prefs.h"
-#include "ether_windows.h"
-#include "ether.h"
-#include "router.h"
-#include "router_types.h"
-#include "dynsockets.h"
-#include "ipsocket.h"
-#include "iphelp.h"
-#include "udp.h"
-#include "dump.h"
-
-
-#if DEBUG
-#pragma optimize("",off)
-#endif
-
-#include "debug.h"
-
-
-void CALLBACK udp_read_completion(
-	DWORD error,
-	DWORD bytes_read,
-	LPWSAOVERLAPPED lpOverlapped,
-	DWORD flags
-)
-{
-  D(bug("udp_read_completion(error=0x%x, bytes_read=%d, flags=0x%x)\r\n", error, bytes_read, flags));
-
-	socket_t *cmpl = (socket_t *)lpOverlapped->hEvent;
-
-	// It's not easy to know whether empty upd datagrams should be passed along. doh.
-	if(error == 0 && bytes_read > 0) {
-
-		if(bytes_read > 1460) {
-		  D(bug("discarding oversized udp packet, size = \r\n", bytes_read));
-		} else {
-			struct sockaddr_in name;
-			int namelen = sizeof(name);
-			memset( &name, 0, sizeof(name) );
-			if( _getsockname( cmpl->s, (struct sockaddr *)&name, &namelen ) == SOCKET_ERROR ) {
-				D(bug("_getsockname() failed, error=%d\r\n", _WSAGetLastError() ));
-			} else {
-				D(bug("_getsockname(): port=%d\r\n", ntohs(name.sin_port) ));
-			}
-
-			int udp_size = sizeof(udp_t) + bytes_read;
-			udp_t *udp = (udp_t *)malloc( udp_size );
-			if(udp) {
-				mac_t *mac = (mac_t *)udp;
-				ip_t *ip = (ip_t *)udp;
-
-				// Build MAC
-				// memcpy( udp->ip.mac.dest, cmpl->mac_src, 6 );
-				memcpy( mac->dest, ether_addr, 6 );
-				memcpy( mac->src, router_mac_addr, 6 );
-				mac->type = htons(mac_type_ip4);
-
-				// Build IP
-				ip->version = 4;
-				ip->header_len = 5;
-				ip->tos = 0;
-				ip->total_len = htons(sizeof(udp_t) - sizeof(mac_t) + bytes_read); // no options
-				ip->ident = htons(next_ip_ident_number++); // htons() might be a macro... but does not really matter here.
-				ip->flags_n_frag_offset = 0;
-				ip->ttl = 128; // one hop actually!
-				ip->proto = ip_proto_udp;
-				ip->src = htonl(cmpl->ip_dest);
-				ip->dest = htonl(cmpl->ip_src);
-				make_ip4_checksum( (ip_t *)udp );
-
-				// Copy payload (used by UDP checksum)
-				memcpy( (char *)udp + sizeof(udp_t), cmpl->buffers[0].buf, bytes_read );
-
-				// Build UDP
-				udp->src_port = htons(cmpl->dest_port);
-				udp->dest_port = htons(cmpl->src_port);
-				udp->msg_len = htons(sizeof(udp_t) - sizeof(ip_t) + bytes_read); // no options
-				make_udp_checksum( udp );
-
-				dump_bytes( (uint8 *)udp, udp_size );
-
-				enqueue_packet( (uint8 *)udp, udp_size );
-				free(udp);
-			}
-		}
-	}
-
-	if(!is_router_shutting_down && cmpl->s != INVALID_SOCKET && cmpl->b_recfrom()) {
-		cmpl->socket_ttl = GetTickCount() + 60000L;
-	} else {
-		delete_socket( cmpl );
-	}
-}
-
-void write_udp( udp_t *udp, int len )
-{
-	if( len < sizeof(udp_t) ) {
-	  D(bug("Too small udp packet(%d), dropped\r\n", len));
-		return;
-	}
-
-	uint16 src_port = ntohs(udp->src_port);
-	uint16 dest_port = ntohs(udp->dest_port);
-
-	BOOL ok = true;
-
-	socket_t *cmpl = find_socket( src_port, dest_port, IPPROTO_UDP );
-
-	BOOL old_socket_found = cmpl != 0;
-
-	if(!cmpl) {
-		cmpl = new socket_t(IPPROTO_UDP);
-		if(cmpl) {
-			cmpl->s = _socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
-			if(cmpl->s == INVALID_SOCKET) {
-				delete cmpl;
-				cmpl = 0;
-				ok = false;
-			} else {
-				cmpl->src_port = src_port;
-				cmpl->dest_port = dest_port;
-				add_socket( cmpl );
-			}
-		} else {
-			ok = false;
-		}
-	}
-
-	if(ok) {
-		cmpl->src_port = src_port;
-		cmpl->dest_port = dest_port;
-		cmpl->ip_src = ntohl(udp->ip.src);
-		cmpl->ip_dest = ntohl(udp->ip.dest);
-
-		struct sockaddr_in to;
-		memset( &to, 0, sizeof(to) );
-		to.sin_family = AF_INET;
-		to.sin_port = udp->dest_port;
-		to.sin_addr.s_addr = udp->ip.dest;
-
-		char *data = (char *)udp + sizeof(udp_t);
-		int dlen = len - sizeof(udp_t);
-
-		// ttl changed, update checksum
-		make_udp_checksum( udp );
-
-		cmpl->set_ttl( udp->ip.ttl );
-
-		bool please_close = true;
-		/*
-			Note that broadcast messages fill fail, no setsockopt(SO_BROADCAST).
-			That's exactly what I want.
-		*/
-		if(SOCKET_ERROR != _sendto( cmpl->s, data, dlen, 0, (struct sockaddr *)&to, sizeof(to) )) {
-			if(old_socket_found) {
-				// This socket is not overlapped.
-				please_close = false;
-			} else {
-				if(cmpl->b_recfrom()) please_close = false;
-			}
-			cmpl->socket_ttl = GetTickCount() + 60000L;
-		} else {
-			int socket_error = _WSAGetLastError();
-			D(bug("_sendto() completed with error %d\r\n", socket_error));
-			// TODO: check this out: error_winsock_2_icmp() uses router_ip_address
-			// as source ip; but it's probably allright
-			error_winsock_2_icmp( socket_error, (ip_t *)udp, len );
-		}
-		if(please_close) {
-			delete_socket(cmpl);
-		}
-	}
-}
-
-void init_udp()
-{
-}
-
-void final_udp()
-{
-}
+/*
+ *  udp.cpp - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include "cpu_emulation.h"
+#include "prefs.h"
+#include "ether_windows.h"
+#include "ether.h"
+#include "router.h"
+#include "router_types.h"
+#include "dynsockets.h"
+#include "ipsocket.h"
+#include "iphelp.h"
+#include "udp.h"
+#include "dump.h"
+
+
+#if DEBUG
+#pragma optimize("",off)
+#endif
+
+#include "debug.h"
+
+
+void CALLBACK udp_read_completion(
+	DWORD error,
+	DWORD bytes_read,
+	LPWSAOVERLAPPED lpOverlapped,
+	DWORD flags
+)
+{
+  D(bug("udp_read_completion(error=0x%x, bytes_read=%d, flags=0x%x)\r\n", error, bytes_read, flags));
+
+	socket_t *cmpl = (socket_t *)lpOverlapped->hEvent;
+
+	// It's not easy to know whether empty upd datagrams should be passed along. doh.
+	if(error == 0 && bytes_read > 0) {
+
+		if(bytes_read > 1460) {
+		  D(bug("discarding oversized udp packet, size = \r\n", bytes_read));
+		} else {
+			struct sockaddr_in name;
+			int namelen = sizeof(name);
+			memset( &name, 0, sizeof(name) );
+			if( _getsockname( cmpl->s, (struct sockaddr *)&name, &namelen ) == SOCKET_ERROR ) {
+				D(bug("_getsockname() failed, error=%d\r\n", _WSAGetLastError() ));
+			} else {
+				D(bug("_getsockname(): port=%d\r\n", ntohs(name.sin_port) ));
+			}
+
+			int udp_size = sizeof(udp_t) + bytes_read;
+			udp_t *udp = (udp_t *)malloc( udp_size );
+			if(udp) {
+				mac_t *mac = (mac_t *)udp;
+				ip_t *ip = (ip_t *)udp;
+
+				// Build MAC
+				// memcpy( udp->ip.mac.dest, cmpl->mac_src, 6 );
+				memcpy( mac->dest, ether_addr, 6 );
+				memcpy( mac->src, router_mac_addr, 6 );
+				mac->type = htons(mac_type_ip4);
+
+				// Build IP
+				ip->version = 4;
+				ip->header_len = 5;
+				ip->tos = 0;
+				ip->total_len = htons(sizeof(udp_t) - sizeof(mac_t) + bytes_read); // no options
+				ip->ident = htons(next_ip_ident_number++); // htons() might be a macro... but does not really matter here.
+				ip->flags_n_frag_offset = 0;
+				ip->ttl = 128; // one hop actually!
+				ip->proto = ip_proto_udp;
+				ip->src = htonl(cmpl->ip_dest);
+				ip->dest = htonl(cmpl->ip_src);
+				make_ip4_checksum( (ip_t *)udp );
+
+				// Copy payload (used by UDP checksum)
+				memcpy( (char *)udp + sizeof(udp_t), cmpl->buffers[0].buf, bytes_read );
+
+				// Build UDP
+				udp->src_port = htons(cmpl->dest_port);
+				udp->dest_port = htons(cmpl->src_port);
+				udp->msg_len = htons(sizeof(udp_t) - sizeof(ip_t) + bytes_read); // no options
+				make_udp_checksum( udp );
+
+				dump_bytes( (uint8 *)udp, udp_size );
+
+				enqueue_packet( (uint8 *)udp, udp_size );
+				free(udp);
+			}
+		}
+	}
+
+	if(!is_router_shutting_down && cmpl->s != INVALID_SOCKET && cmpl->b_recfrom()) {
+		cmpl->socket_ttl = GetTickCount() + 60000L;
+	} else {
+		delete_socket( cmpl );
+	}
+}
+
+void write_udp( udp_t *udp, int len )
+{
+	if( len < sizeof(udp_t) ) {
+	  D(bug("Too small udp packet(%d), dropped\r\n", len));
+		return;
+	}
+
+	uint16 src_port = ntohs(udp->src_port);
+	uint16 dest_port = ntohs(udp->dest_port);
+
+	BOOL ok = true;
+
+	socket_t *cmpl = find_socket( src_port, dest_port, IPPROTO_UDP );
+
+	BOOL old_socket_found = cmpl != 0;
+
+	if(!cmpl) {
+		cmpl = new socket_t(IPPROTO_UDP);
+		if(cmpl) {
+			cmpl->s = _socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
+			if(cmpl->s == INVALID_SOCKET) {
+				delete cmpl;
+				cmpl = 0;
+				ok = false;
+			} else {
+				cmpl->src_port = src_port;
+				cmpl->dest_port = dest_port;
+				add_socket( cmpl );
+			}
+		} else {
+			ok = false;
+		}
+	}
+
+	if(ok) {
+		cmpl->src_port = src_port;
+		cmpl->dest_port = dest_port;
+		cmpl->ip_src = ntohl(udp->ip.src);
+		cmpl->ip_dest = ntohl(udp->ip.dest);
+
+		struct sockaddr_in to;
+		memset( &to, 0, sizeof(to) );
+		to.sin_family = AF_INET;
+		to.sin_port = udp->dest_port;
+		to.sin_addr.s_addr = udp->ip.dest;
+
+		char *data = (char *)udp + sizeof(udp_t);
+		int dlen = len - sizeof(udp_t);
+
+		// ttl changed, update checksum
+		make_udp_checksum( udp );
+
+		cmpl->set_ttl( udp->ip.ttl );
+
+		bool please_close = true;
+		/*
+			Note that broadcast messages fill fail, no setsockopt(SO_BROADCAST).
+			That's exactly what I want.
+		*/
+		if(SOCKET_ERROR != _sendto( cmpl->s, data, dlen, 0, (struct sockaddr *)&to, sizeof(to) )) {
+			if(old_socket_found) {
+				// This socket is not overlapped.
+				please_close = false;
+			} else {
+				if(cmpl->b_recfrom()) please_close = false;
+			}
+			cmpl->socket_ttl = GetTickCount() + 60000L;
+		} else {
+			int socket_error = _WSAGetLastError();
+			D(bug("_sendto() completed with error %d\r\n", socket_error));
+			// TODO: check this out: error_winsock_2_icmp() uses router_ip_address
+			// as source ip; but it's probably allright
+			error_winsock_2_icmp( socket_error, (ip_t *)udp, len );
+		}
+		if(please_close) {
+			delete_socket(cmpl);
+		}
+	}
+}
+
+void init_udp()
+{
+}
+
+void final_udp()
+{
+}
--- macemu/SheepShaver/src/Windows/router/udp.h
+++ sheepshaver/SheepShaver/src/Windows/router/udp.h
@@ -1,38 +1,38 @@
-/*
- *  udp.h - ip router
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _UDP_H_
-#define _UDP_H_
-
-void write_udp( udp_t *udp, int len );
-
-void CALLBACK udp_read_completion(
-	DWORD error,
-	DWORD bytes_read,
-	LPWSAOVERLAPPED lpOverlapped,
-	DWORD flags
-);
-
-void init_udp();
-void final_udp();
-
-#endif // _UDP_H_
+/*
+ *  udp.h - ip router
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _UDP_H_
+#define _UDP_H_
+
+void write_udp( udp_t *udp, int len );
+
+void CALLBACK udp_read_completion(
+	DWORD error,
+	DWORD bytes_read,
+	LPWSAOVERLAPPED lpOverlapped,
+	DWORD flags
+);
+
+void init_udp();
+void final_udp();
+
+#endif // _UDP_H_
--- macemu/SheepShaver/src/Windows/serial_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/serial_windows.cpp
@@ -1,1198 +1,1200 @@
-/*
- *  serial_windows.cpp - Serial device driver for Win32
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+/*
+ *  serial_windows.cpp - Serial device driver for Win32
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+// TODO: serial i/o threads should have high priority.
+#include "sysdeps.h"
+
+#include <algorithm>
 
-// TODO: serial i/o threads should have high priority.
-#include "sysdeps.h"
-
-#include <ctype.h>
-#include <process.h>
-
-#include "main.h"
-#include "util_windows.h"
-#include "macos_util.h"
-#include "prefs.h"
-#include "serial.h"
-#include "serial_defs.h"
-#include "cpu_emulation.h"
-
-// This must be always on.
-#define DEBUG 1
-#undef OutputDebugString
-#define OutputDebugString serial_log_write
-static void serial_log_write( char *s );
-#define SERIAL_LOG_FILE_NAME TEXT("serial.log")
-#include "debug.h"
-#undef D
-#define D(x) if(debug_serial != DB_SERIAL_NONE) (x);
-
-
-enum {
-	DB_SERIAL_NONE=0,
-	DB_SERIAL_NORMAL,
-	DB_SERIAL_LOUD
-};
-
-static int16 debug_serial = DB_SERIAL_NONE;
-
-static HANDLE serial_log_file = INVALID_HANDLE_VALUE;
-
-static void serial_log_open( LPCTSTR path )
-{
-	if(debug_serial == DB_SERIAL_NONE) return;
-
-	DeleteFile( path );
-	serial_log_file = CreateFile(
-			path,
-			GENERIC_READ|GENERIC_WRITE,
-			FILE_SHARE_READ,
-			NULL,
-			CREATE_ALWAYS,
-			FILE_FLAG_WRITE_THROUGH,
-			NULL
-	);
-	if( serial_log_file == INVALID_HANDLE_VALUE ) {
-		ErrorAlert( "Could not create the serial log file." );
-	}
-}
-
-static void serial_log_close( void )
-{
-	if(debug_serial == DB_SERIAL_NONE) return;
-
-	if( serial_log_file != INVALID_HANDLE_VALUE ) {
-		CloseHandle( serial_log_file );
-		serial_log_file = INVALID_HANDLE_VALUE;
-	}
-}
-
-static void serial_log_write( char *s )
-{
-	DWORD bytes_written;
-
-	// should have been checked already.
-	if(debug_serial == DB_SERIAL_NONE) return;
-
-	if( serial_log_file != INVALID_HANDLE_VALUE ) {
-
-		DWORD count = strlen(s);
-		if (0 == WriteFile(serial_log_file, s, count, &bytes_written, NULL) ||
-				(int)bytes_written != count)
-		{
-			serial_log_close();
-			ErrorAlert( "serial log file write error (out of disk space?). Log closed." );
-		} else {
-			FlushFileBuffers( serial_log_file );
-		}
-	}
-}
-
-
-// Driver private variables
-class XSERDPort : public SERDPort {
-public:
-  XSERDPort(LPCTSTR dev, LPCTSTR suffix)
-  {
-		D(bug(TEXT("XSERDPort constructor %s\r\n"), dev));
-
-		read_pending = write_pending = false;
-
-		if(dev)
-			_tcscpy( device_name, dev );
-		else
-			*device_name = 0;
-		_tcsupr(device_name);
-		is_parallel = (_tcsncmp(device_name, TEXT("LPT"), 3) == 0);
-		is_file = (_tcsncmp(device_name, TEXT("FILE"), 4) == 0);
-		if(is_file) {
-			char entry_name[20];
-			_snprintf( entry_name, lengthof(entry_name), "portfile%s", str(suffix).get() );
-			const char *path = PrefsFindString(entry_name);
-			if(path) {
-				_tcscpy( output_file_name, tstr(path).get() );
-			} else {
-				_tcscpy( output_file_name, TEXT("C:\\B2TEMP.OUT") );
-			}
-		}
-
-		is_serial = !is_parallel && !is_file;
-
-		fd = INVALID_HANDLE_VALUE;
-		input_thread_active = output_thread_active = NULL;
-  }
-
-  virtual ~XSERDPort()
-  {
-		D(bug("XSERDPort destructor \r\n"));
-		if (input_thread_active) {
-			D(bug("WARNING: brute TerminateThread(input)\r\n"));
-			TerminateThread(input_thread_active,0);
-			CloseHandle(input_signal);
-			input_thread_active = NULL;
-		}
-		if (output_thread_active) {
-			D(bug("WARNING: brute TerminateThread(output)\r\n"));
-			TerminateThread(output_thread_active,0);
-			CloseHandle(output_signal);
-			output_thread_active = NULL;
-		}
-  }
-
-  virtual int16 open(uint16 config);
-  virtual int16 prime_in(uint32 pb, uint32 dce);
-  virtual int16 prime_out(uint32 pb, uint32 dce);
-  virtual int16 control(uint32 pb, uint32 dce, uint16 code);
-  virtual int16 status(uint32 pb, uint32 dce, uint16 code);
-  virtual int16 close(void);
-
-private:
-	bool configure(uint16 config);
-	void set_handshake(uint32 s, bool with_dtr);
+#include <ctype.h>
+#include <process.h>
+
+#include "main.h"
+#include "macos_util.h"
+#include "prefs.h"
+#include "serial.h"
+#include "serial_defs.h"
+#include "cpu_emulation.h"
+
+// This must be always on.
+#define DEBUG 1
+#undef OutputDebugString
+#define OutputDebugString serial_log_write
+static void serial_log_write( char *s );
+#define SERIAL_LOG_FILE_NAME "serial.log"
+#include "debug.h"
+#undef D
+#define D(x) if(debug_serial != DB_SERIAL_NONE) (x);
+
+
+enum {
+	DB_SERIAL_NONE=0,
+	DB_SERIAL_NORMAL,
+	DB_SERIAL_LOUD
+};
+
+static int16 debug_serial = DB_SERIAL_NONE;
+
+static HANDLE serial_log_file = INVALID_HANDLE_VALUE;
+
+static void serial_log_open( char *path )
+{
+	if(debug_serial == DB_SERIAL_NONE) return;
+
+	DeleteFile( path );
+	serial_log_file = CreateFile(
+			path,
+			GENERIC_READ|GENERIC_WRITE,
+			FILE_SHARE_READ,
+			NULL,
+			CREATE_ALWAYS,
+			FILE_FLAG_WRITE_THROUGH,
+			NULL
+	);
+	if( serial_log_file == INVALID_HANDLE_VALUE ) {
+		ErrorAlert( "Could not create the serial log file." );
+	}
+}
+
+static void serial_log_close( void )
+{
+	if(debug_serial == DB_SERIAL_NONE) return;
+
+	if( serial_log_file != INVALID_HANDLE_VALUE ) {
+		CloseHandle( serial_log_file );
+		serial_log_file = INVALID_HANDLE_VALUE;
+	}
+}
+
+static void serial_log_write( char *s )
+{
+	DWORD bytes_written;
+
+	// should have been checked already.
+	if(debug_serial == DB_SERIAL_NONE) return;
+
+	if( serial_log_file != INVALID_HANDLE_VALUE ) {
+
+		DWORD count = strlen(s);
+		if (0 == WriteFile(serial_log_file, s, count, &bytes_written, NULL) ||
+				(int)bytes_written != count)
+		{
+			serial_log_close();
+			ErrorAlert( "serial log file write error (out of disk space?). Log closed." );
+		} else {
+			FlushFileBuffers( serial_log_file );
+		}
+	}
+}
+
+
+// Driver private variables
+class XSERDPort : public SERDPort {
+public:
+  XSERDPort(const char *dev, const char *suffix)
+  {
+		D(bug("XSERDPort constructor %s\r\n", dev));
+		// device_name = (char *)dev;
+
+		read_pending = write_pending = false;
+
+		if(dev)
+			strcpy( device_name, (char *)dev );
+		else
+			*device_name = 0;
+		strupr(device_name);
+		is_parallel = (strncmp(device_name,"LPT",3) == 0);
+		is_file = (strncmp(device_name,"FILE",4) == 0);
+		if(is_file) {
+			char entry_name[20];
+			wsprintf( entry_name, "portfile%s", suffix );
+			const char *path = PrefsFindString(entry_name);
+			if(path) {
+				strcpy( output_file_name, path );
+			} else {
+				strcpy( output_file_name, "C:\\B2TEMP.OUT" );
+			}
+		}
+
+		is_serial = !is_parallel && !is_file;
+
+		fd = INVALID_HANDLE_VALUE;
+		input_thread_active = output_thread_active = NULL;
+  }
+
+  virtual ~XSERDPort()
+  {
+		D(bug("XSERDPort destructor \r\n"));
+		if (input_thread_active) {
+			D(bug("WARNING: brute TerminateThread(input)\r\n"));
+			TerminateThread(input_thread_active,0);
+			CloseHandle(input_signal);
+			input_thread_active = NULL;
+		}
+		if (output_thread_active) {
+			D(bug("WARNING: brute TerminateThread(output)\r\n"));
+			TerminateThread(output_thread_active,0);
+			CloseHandle(output_signal);
+			output_thread_active = NULL;
+		}
+  }
+
+  virtual int16 open(uint16 config);
+  virtual int16 prime_in(uint32 pb, uint32 dce);
+  virtual int16 prime_out(uint32 pb, uint32 dce);
+  virtual int16 control(uint32 pb, uint32 dce, uint16 code);
+  virtual int16 status(uint32 pb, uint32 dce, uint16 code);
+  virtual int16 close(void);
+
+private:
+	bool configure(uint16 config);
+	void set_handshake(uint32 s, bool with_dtr);
 	static unsigned int WINAPI input_func(void *arg);
 	static unsigned int WINAPI output_func(void *arg);
-	static int acknowledge_error(HANDLE h, bool is_read);
-	bool set_timeouts(int bauds, int parity_bits, int stop_bits);
-
-	TCHAR device_name[256];
-	HANDLE fd;
-
-	bool io_killed;					// Flag: KillIO called, I/O threads must not call deferred tasks
-	bool quitting;					// Flag: Quit threads
-
-	HANDLE input_thread_active;		// Handle: Input thread installed (was a bool)
-	unsigned int input_thread_id;
-	HANDLE input_signal;				  // Signal for input thread: execute command
-	uint32 input_pb, input_dce;		// Command parameters for input thread
-
-	HANDLE output_thread_active;	// Handle: Output thread installed (was a bool)
-	unsigned int output_thread_id;
-	HANDLE output_signal;			    // Signal for output thread: execute command
-	uint32 output_pb, output_dce;	// Command parameters for output thread
-
-	DCB mode;			                // Terminal configuration
-
-	bool is_serial;
-	bool is_parallel;							// true if LPTx
-
-	bool is_file;									// true if FILE
-	TCHAR output_file_name[256];
-};
-
-/*
- *  Initialization
- */
-
-void SerialInit(void)
-{
-	const char *port;
-
-	debug_serial = PrefsFindInt32("debugserial");
-
-	serial_log_open( SERIAL_LOG_FILE_NAME );
-
-  // Read serial preferences and create structs for both ports
-
-	port = PrefsFindString("seriala");
-	if(port) {
-		D(bug("SerialInit seriala=%s\r\n",port));
-	}
-  the_serd_port[0] = new XSERDPort(tstr(port).get(), TEXT("0"));
-
-	port = PrefsFindString("serialb");
-	if(port) {
-		D(bug("SerialInit serialb=%s\r\n",port));
-	}
-  the_serd_port[1] = new XSERDPort(tstr(port).get(), TEXT("1"));
-}
-
-
-/*
- *  Deinitialization
- */
-
-void SerialExit(void)
-{
-	D(bug("SerialExit\r\n"));
-  if(the_serd_port[0]) delete (XSERDPort *)the_serd_port[0];
-  if(the_serd_port[1]) delete (XSERDPort *)the_serd_port[1];
-	D(bug("SerialExit done\r\n"));
-
-	serial_log_close();
-}
-
-
-/*
- *  Open serial port
- */
-
-int16 XSERDPort::open(uint16 config)
-{
-	// Don't open NULL name devices
-	if (!device_name || !*device_name)
-		return openErr;
-
-	D(bug(TEXT("XSERDPort::open device=%s,config=0x%X\r\n"),device_name,(int)config));
-
-	// Init variables
-	io_killed = false;
-	quitting = false;
-
-	// Open port
-	if(is_file) {
-		DeleteFile( output_file_name );
-		fd = CreateFile( output_file_name,
-			GENERIC_READ | GENERIC_WRITE,
-			FILE_SHARE_READ,
-			NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL
-		);
-	} else {
-		fd = CreateFile( device_name, GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0 );
-	}
-	if(fd == INVALID_HANDLE_VALUE) {
-		goto open_error;
-		D(bug(TEXT("XSERDPort::open failed to open port %s\r\n"),device_name));
-	}
-
-	if(is_serial) {
-		// Configure port for raw mode
-		memset( &mode, 0, sizeof(DCB) );
-		mode.DCBlength = sizeof(mode);
-		if(!GetCommState( fd, &mode ))
-			goto open_error;
-
-		mode.fBinary = TRUE;
-		if(!configure(config)) {
-			D(bug("XSERDPort::configure failed\r\n"));
-			goto open_error;
-		}
-	}
-
-	// Start input/output threads
-	input_signal = CreateSemaphore( 0, 0, 1, NULL);
-	if(!input_signal)
-		goto open_error;
-
-	output_signal = CreateSemaphore( 0, 0, 1, NULL);
-	if(!output_signal)
-		goto open_error;
-
-	D(bug("Semaphores created\r\n"));
-
-	input_thread_active = (HANDLE)_beginthreadex( 0, 0, input_func, (LPVOID)this, 0, &input_thread_id );
-	output_thread_active = (HANDLE)_beginthreadex( 0, 0, output_func, (LPVOID)this, 0, &output_thread_id );
-
-	if (!input_thread_active || !output_thread_active)
-		goto open_error;
-
-	D(bug("Threads created, Open returns success\r\n"));
-	return noErr;
-
-open_error:
-	D(bug("Open cleanup after failure\r\n"));
-	if (input_thread_active) {
-		TerminateThread(input_thread_active,0);
-		CloseHandle(input_signal);
-		input_thread_active = false;
-	}
-	if (output_thread_active) {
-		TerminateThread(output_thread_active,0);
-		CloseHandle(output_signal);
-		output_thread_active = false;
-	}
-	if(fd != INVALID_HANDLE_VALUE) {
-		CloseHandle(fd);
-		fd = 0;
-	}
-	return openErr;
-}
-
-/*
- *  Read data from port
- */
-
-int16 XSERDPort::prime_in(uint32 pb, uint32 dce)
-{
-	D(bug("XSERDPort::prime_in\r\n"));
-	// Send input command to input_thread
-	read_done = false;
-	read_pending = true;
-	input_pb = pb;
-	input_dce = dce;
-	ReleaseSemaphore(input_signal,1,NULL);
-	return 1;	// Command in progress
-}
-
-
-/*
- *  Write data to port
- */
-
-int16 XSERDPort::prime_out(uint32 pb, uint32 dce)
-{
-	D(bug("XSERDPort::prime_out\r\n"));
-	// Send output command to output_thread
-	write_done = false;
-	write_pending = true;
-	output_pb = pb;
-	output_dce = dce;
-	ReleaseSemaphore(output_signal,1,NULL);
-	return 1;	// Command in progress
-}
-
-
-static DWORD get_comm_output_buf_size( HANDLE h )
-{
-	DWORD size = 0;
-	COMMPROP cp;
-
-	if(GetCommProperties(h,&cp)) {
-		size = cp.dwCurrentTxQueue;
-	}
-	return size;
-}
-
-/*
- *  Control calls
- */
-
-int16 XSERDPort::control(uint32 pb, uint32 dce, uint16 code)
-{
-	D(bug("XSERDPort::control code=%d\r\n",(int)code));
-	switch (code) {
-
-		case kSERDClockMIDI:
-			/* http://til.info.apple.com/techinfo.nsf/artnum/n2425
-			 A MIDI interface operates at 31.25 Kbaud (+/- 1%) [== 31400]
-			 asynchronously, using a data format of one start bit, eight
-			 data bits, and one stop bit. This makes a total of 10 bits
-			 for each 320 microsecond period per serial byte.
-			*/
-			D(bug("kSERDClockMIDI setting 38400,n,8,1\n"));
-			return noErr;
-
-			/*
-			mode.BaudRate = 38400;
-		  mode.ByteSize = 8;
-		  mode.StopBits = ONESTOPBIT;
-		  mode.Parity = NOPARITY;
-			if(!SetCommState( fd, &mode )) {
-				D(bug("kSERDClockMIDI SetCommState() failed\n"));
-				return controlErr;
-			} else {
-				if(!set_timeouts(38400,0,2)) {
-					D(bug("kSERDClockMIDI set_timeouts() failed\n"));
-					return controlErr;
-				}
-				D(bug("kSERDClockMIDI OK\n"));
-				return noErr;
-			}
-			*/
-
-		case 1:			// KillIO
-			io_killed = true;
-
-			if(is_serial) {
-				// Make sure we won't hang waiting. There is something wrong
-				// in how read_pending & write_pending are handled.
-				DWORD endtime = GetTickCount() + 1000;
- 				while ( (read_pending || write_pending) && (GetTickCount() < endtime) ) {
-					Sleep(20);
-				}
-				if(read_pending || write_pending) {
-					D(bug("Warning (KillIO): read_pending=%d, write_pending=%d\n", read_pending, write_pending));
-					read_pending = write_pending = false;
-				}
-				// | PURGE_TXABORT | PURGE_RXABORT not needed, no overlapped i/o
-				PurgeComm(fd,PURGE_TXCLEAR|PURGE_RXCLEAR);
-				FlushFileBuffers(fd);
-			}
-			io_killed = false;
-			D(bug("KillIO done\n"));
-			return noErr;
-
-		case kSERDConfiguration:
-			if (configure((uint16)ReadMacInt16(pb + csParam)))
-				return noErr;
-			else
-				return paramErr;
-
-		case kSERDInputBuffer:
-			if(is_serial) {
-
-				// SetupComm() wants both values, so we need to know the output size.
-				DWORD osize = get_comm_output_buf_size(fd);
-
-				DWORD isize = ReadMacInt16(pb + csParam + 4) & 0xffffffc0;
-
-				// 1k minimum
-				// Was this something Amiga specific -- do I need to do this?
-				if (isize < 1024)
-					isize = 1024;
-
-				if(isize > 0 && osize > 0) {
-					if(SetupComm( fd, isize, osize )) {
-						D(bug(" buffer size is now %08lx\n", isize));
-						return noErr;
-					} else {
-						D(bug(" SetupComm(%d,%d) failed, error = %08lx\n", isize, osize, GetLastError()));
-					}
-				}
-			}
-			// Always return ok.
-			return noErr;
-
-		case kSERDSerHShake:
-			set_handshake(pb + csParam, false);
-			return noErr;
-
-		case kSERDSetBreak:
-			if(is_serial) {
-				if(!SetCommBreak(fd)) return controlErr;
-			}
-			return noErr;
-
-		case kSERDClearBreak:
-			if(is_serial) {
-				if(!ClearCommBreak(fd)) return controlErr;
-			}
-			return noErr;
-
-		case kSERDBaudRate: {
-			if (is_serial) {
-				uint16 rate = (uint16)ReadMacInt16(pb + csParam);
-				int baud_rate;
-				if (rate <= 50) {
-					rate = 50; baud_rate = CBR_110;
-				} else if (rate <= 75) {
-					rate = 75; baud_rate = CBR_110;
-				} else if (rate <= 110) {
-					rate = 110; baud_rate = CBR_110;
-				} else if (rate <= 134) {
-					rate = 134; baud_rate = CBR_110;
-				} else if (rate <= 150) {
-					rate = 150; baud_rate = CBR_110;
-				} else if (rate <= 200) {
-					rate = 200; baud_rate = CBR_300;
-				} else if (rate <= 300) {
-					rate = 300; baud_rate = CBR_300;
-				} else if (rate <= 600) {
-					rate = 600; baud_rate = CBR_600;
-				} else if (rate <= 1200) {
-					rate = 1200; baud_rate = CBR_1200;
-				} else if (rate <= 1800) {
-					rate = 1800; baud_rate = CBR_2400;
-				} else if (rate <= 2400) {
-					rate = 2400; baud_rate = CBR_2400;
-				} else if (rate <= 4800) {
-					rate = 4800; baud_rate = CBR_4800;
-				} else if (rate <= 9600) {
-					rate = 9600; baud_rate = CBR_9600;
-				} else if (rate <= 19200) {
-					rate = 19200; baud_rate = CBR_19200;
-				} else if (rate <= 38400) {
-					rate = 38400; baud_rate = CBR_38400;
-				} else if (rate <= 57600) {
-					rate = 57600; baud_rate = CBR_57600;
-				} else {
-					rate = 57600; baud_rate = CBR_57600;
-				}
-				WriteMacInt16(pb + csParam, rate);
-				mode.BaudRate = baud_rate;
-				if(!SetCommState( fd, &mode )) return controlErr;
-				// TODO: save parity/stop values and use here (not critical)
-				if(!set_timeouts(rate,0,1)) return controlErr;
-			}
-			return noErr;
-		}
-
-		case kSERDHandshake:
-		case kSERDHandshakeRS232:
-			set_handshake(pb + csParam, true);
-			return noErr;
-
-		case kSERDMiscOptions:
-			if (ReadMacInt8(pb + csParam) & kOptionPreserveDTR)
-			  mode.fDtrControl =  DTR_CONTROL_ENABLE; // correct?
-			else
-			  mode.fDtrControl =  DTR_CONTROL_DISABLE; // correct?
-			if(is_serial) {
-				if(!SetCommState( fd, &mode )) return controlErr;
-			}
-			return noErr;
-
-		case kSERDAssertDTR: {
-			if (is_serial) {
-				if(!EscapeCommFunction(fd,SETDTR)) return controlErr;
-			}
-			return noErr;
-		}
-
-		case kSERDNegateDTR: {
-			if (is_serial) {
-				if(!EscapeCommFunction(fd,CLRDTR)) return controlErr;
-			}
-			return noErr;
-		}
-
-		case kSERDSetPEChar:
-		case kSERDSetPEAltChar:
-			{
-			uint16 errChar = (uint16)ReadMacInt16(pb + csParam);
-			mode.fErrorChar = TRUE;
-			mode.ErrorChar = (char)errChar;
-			return noErr;
-			}
-
-		case kSERDResetChannel:
-			if (is_serial) {
-				// | PURGE_TXABORT | PURGE_RXABORT not needed, no overlapped i/o
-				PurgeComm(fd,PURGE_TXCLEAR|PURGE_RXCLEAR);
-				FlushFileBuffers(fd);
-			}
-			return noErr;
-
-		case kSERDAssertRTS: {
-			if (is_serial) {
-				if(!EscapeCommFunction(fd,SETRTS)) return controlErr;
-			}
-			return noErr;
-		}
-
-		case kSERDNegateRTS: {
-			if (is_serial) {
-				if(!EscapeCommFunction(fd,CLRRTS)) return controlErr;
-			}
-			return noErr;
-		}
-
-		case kSERD115KBaud:
-			if (is_serial) {
-				mode.BaudRate = CBR_115200;
-				if(!SetCommState( fd, &mode )) return controlErr;
-			}
-			return noErr;
-
-		case kSERD230KBaud:
-		case kSERDSetHighSpeed:
-			if (is_serial) {
-				mode.BaudRate = CBR_256000;
-				if(!SetCommState( fd, &mode )) return controlErr;
-			}
-			return noErr;
-
-		default:
-			D(bug("WARNING: SerialControl(): unimplemented control code %d\r\n", code));
-			return controlErr;
-	}
-}
-
-/*
- *  Status calls
- */
-
-int16 XSERDPort::status(uint32 pb, uint32 dce, uint16 code)
-{
-	// D(bug("XSERDPort::status code=%d\r\n",(int)code));
-
-	DWORD error_state;
-	COMSTAT comstat;
-
-	switch (code) {
-		case kSERDInputCount: {
-			uint32 num = 0;
-			if (is_serial) {
-				if(!ClearCommError(fd,&error_state,&comstat)) return statusErr;
-				num = comstat.cbInQue;
-			}
-			WriteMacInt32(pb + csParam, num);
-			return noErr;
-		}
-
-		case kSERDStatus: {
-			uint32 p = pb + csParam;
-			WriteMacInt8(p + staCumErrs, cum_errors);
-			cum_errors = 0;
-			DWORD status;
-
-			if(is_serial) {
-				if(!GetCommModemStatus(fd,&status)) return statusErr;
-			} else {
-				status = MS_CTS_ON | MS_DSR_ON | MS_RLSD_ON;
-				D(bug("kSERDStatus: faking status for LPT port or FILE\r\n"));
-			}
-
-			WriteMacInt8(p + staXOffSent, 0);
-			WriteMacInt8(p + staXOffHold, 0);
-			WriteMacInt8(p + staRdPend, read_pending);
-			WriteMacInt8(p + staWrPend, write_pending);
-
-			WriteMacInt8(p + staCtsHold, status & MS_CTS_ON ? 0 : 1);
-			WriteMacInt8(p + staDsrHold, status & MS_DSR_ON ? 0 : 1);
-
-			WriteMacInt8(p + staModemStatus,
-				(status & MS_DSR_ON ? dsrEvent : 0)
-				| (status & MS_RING_ON ? riEvent : 0)
-				| (status & MS_RLSD_ON ? dcdEvent : 0)   // is this carrier detect?
-				| (status & MS_CTS_ON ? ctsEvent : 0));
-			return noErr;
-		}
-
-		default:
-			D(bug("WARNING: SerialStatus(): unimplemented status code %d\r\n", code));
-			return statusErr;
-	}
-}
-
-
-/*
- *  Close serial port
- */
-
-int16 XSERDPort::close()
-{
-	D(bug("XSERDPort::close\r\n"));
-
-	// Kill threads
-	if (input_thread_active) {
-		quitting = true;
-		ReleaseSemaphore(input_signal,1,NULL);
-		input_thread_active = false;
-		CloseHandle(input_signal);
-	}
-	if (output_thread_active) {
-		quitting = true;
-		ReleaseSemaphore(output_signal,1,NULL);
-		output_thread_active = false;
-		// bugfix: was: CloseHandle(&output_signal);
-		CloseHandle(output_signal);
-	}
-
-	// Close port
-	if(fd != INVALID_HANDLE_VALUE) {
-		CloseHandle(fd);
-		fd = 0;
-	}
-  return noErr;
-}
-
-bool XSERDPort::set_timeouts(
-	int bauds, int parity_bits, int stop_bits )
-{
-	COMMTIMEOUTS timeouts;
-	uint32 bytes_per_sec;
-	uint32 msecs_per_ch;
-	bool result = false;
-
-	// Should already been checked
-	if (!is_serial)
-		return true;
-
-	bytes_per_sec = bauds / (mode.ByteSize + parity_bits + stop_bits);
-
-	// 75% bytes_per_sec
-	// bytes_per_sec = (bytes_per_sec+bytes_per_sec+bytes_per_sec) >> 2;
-
-	// 50% bytes_per_sec
-	bytes_per_sec = bytes_per_sec >> 1;
-
-	msecs_per_ch = 1000 / bytes_per_sec;
-	if(msecs_per_ch == 0) msecs_per_ch = 1;
-
-	if(GetCommTimeouts(fd,&timeouts)) {
-		D(bug("old timeout values: %ld %ld %ld %ld %ld\r\n",
-			timeouts.ReadIntervalTimeout,
-			timeouts.ReadTotalTimeoutMultiplier,
-			timeouts.ReadTotalTimeoutConstant,
-			timeouts.WriteTotalTimeoutMultiplier,
-			timeouts.WriteTotalTimeoutConstant
-		));
-
-		timeouts.WriteTotalTimeoutMultiplier = msecs_per_ch;
-		timeouts.WriteTotalTimeoutConstant = 10;
-
-		/*
-		timeouts.ReadIntervalTimeout = msecs_per_ch;
-		timeouts.ReadTotalTimeoutMultiplier = msecs_per_ch;
-		timeouts.ReadTotalTimeoutConstant = 10;
-		*/
-
-		timeouts.ReadIntervalTimeout = MAXDWORD;
-		timeouts.ReadTotalTimeoutMultiplier = 0;
-		timeouts.ReadTotalTimeoutConstant = 0;
-
-		if(!SetCommTimeouts(fd,&timeouts)) {
-			D(bug("SetCommTimeouts() failed in configure()\r\n"));
-		} else {
-			D(bug("new timeout values: %ld %ld %ld %ld %ld\r\n",
-				timeouts.ReadIntervalTimeout,
-				timeouts.ReadTotalTimeoutMultiplier,
-				timeouts.ReadTotalTimeoutConstant,
-				timeouts.WriteTotalTimeoutMultiplier,
-				timeouts.WriteTotalTimeoutConstant
-			));
-			result = true;
-		}
-	} else {
-		D(bug("GetCommTimeouts() failed in set_timeouts()\r\n"));
-	}
-	return(result);
-}
-
-/*
- *  Configure serial port with MacOS config word
- */
-
-bool XSERDPort::configure(uint16 config)
-{
-	D(bug("XSERDPort::configure, config=%d\r\n",(int)config));
-
-	if (!is_serial)
-		return true;
-
-	// needed to calculate optimal timeouts
-	uint32 bauds = 57600;
-	uint32 stop_bits = 1;
-	uint32 parity_bits = 0;
-
-	// Not all of these can be set here anyway.
-	/*
-	mode.fOutxCtsFlow = TRUE;
-	mode.fOutxDsrFlow = FALSE;
-	mode.fDtrControl = DTR_CONTROL_ENABLE; //  DTR_CONTROL_HANDSHAKE?
-  mode.fDsrSensitivity = FALSE; // ???
-  mode.fOutX = FALSE;
-  mode.fInX = FALSE;
-  mode.fTXContinueOnXoff = FALSE;
-  mode.fErrorChar = FALSE;
-  mode.ErrorChar = 0;
-  mode.fNull = FALSE;
-  mode.fRtsControl = 2; // ???
-  mode.fAbortOnError = FALSE;
-  mode.XonLim = 0x800;
-  mode.XoffLim = 0x200;
-  mode.XonChar = 0x11;
-  mode.XoffChar = 0x13;
-  mode.EofChar = 0;
-  mode.EvtChar = '\0';
-	*/
-
-	// Set baud rate
-	switch (config & 0x03ff) {
-		// no baud1800, CBR_14400, CBR_56000, CBR_115200, CBR_128000, CBR_256000
-		case baud150: mode.BaudRate = CBR_110; bauds = 110; break;
-		case baud300: mode.BaudRate = CBR_300; bauds = 300; break;
-		case baud600: mode.BaudRate = CBR_600; bauds = 600; break;
-		case baud1200: mode.BaudRate = CBR_1200; bauds = 1200; break;
-		case baud1800: return false;
-		case baud2400: mode.BaudRate = CBR_2400; bauds = 2400; break;
-		case baud4800: mode.BaudRate = CBR_4800; bauds = 4800; break;
-		case baud9600: mode.BaudRate = CBR_9600; bauds = 9600; break;
-		case baud19200: mode.BaudRate = CBR_19200; bauds = 19200; break;
-		case baud38400: mode.BaudRate = CBR_38400; bauds = 38400; break;
-		case baud57600: mode.BaudRate = CBR_57600; bauds = 57600; break;
-		default:
-			return false;
-	}
-
-	// Set number of stop bits
-	switch (config & 0xc000) {
-		case stop10:
-		  mode.StopBits = ONESTOPBIT;
-			stop_bits = 1;
-			break;
-		case stop15:
-		  mode.StopBits = ONE5STOPBITS;
-			stop_bits = 2;
-			break;
-		case stop20:
-		  mode.StopBits = TWOSTOPBITS;
-			stop_bits = 2;
-			break;
-		default:
-			return false;
-	}
-
-	// Set parity mode
-	switch (config & 0x3000) {
-		case noParity:
-		  mode.Parity = NOPARITY;
-		  mode.fParity = FALSE;
-			parity_bits = 0;
-			break;
-		case oddParity:
-		  mode.Parity = ODDPARITY;
-		  mode.fParity = TRUE;
-			parity_bits = 1;
-			break;
-		case evenParity:
-		  mode.Parity = EVENPARITY;
-		  mode.fParity = TRUE;
-			parity_bits = 1;
-			break;
-		// No MARKPARITY, SPACEPARITY
-		default:
-			return false;
-	}
-
-	// Set number of data bits
-	switch (config & 0x0c00) {
-		// No data4
-		case data5:
-		  mode.ByteSize = 5; break;
-		case data6:
-		  mode.ByteSize = 6; break;
-		case data7:
-		  mode.ByteSize = 7; break;
-		case data8:
-		  mode.ByteSize = 8; break;
-		default:
-			return false;
-	}
-
-	D(bug("Interpreted configuration: %d,%d,%d,%d\r\n",
-		bauds,
-		mode.ByteSize,
-		stop_bits,
-		parity_bits
-	));
-
-	if(!SetCommState( fd, &mode )) {
-		D(bug("SetCommState failed in configure()\r\n"));
-		return false;
-	}
-
-	if(!set_timeouts(bauds,parity_bits,stop_bits))
-		return false;
-
-	return true;
-}
-
-
-/*
- *  Set serial handshaking
- */
-
-void XSERDPort::set_handshake(uint32 s, bool with_dtr)
-{
-	D(bug(" set_handshake %02x %02x %02x %02x %02x %02x %02x %02x\r\n",
-		ReadMacInt8(s + 0), ReadMacInt8(s + 1), ReadMacInt8(s + 2), ReadMacInt8(s + 3),
-		ReadMacInt8(s + 4), ReadMacInt8(s + 5), ReadMacInt8(s + 6), ReadMacInt8(s + 7)));
-
-	if (!is_serial)
-		return;
-
-	if (with_dtr) {
-		mode.fDtrControl = DTR_CONTROL_ENABLE;
-		if (ReadMacInt8(s + shkFCTS) || ReadMacInt8(s + shkFDTR))
-			mode.fOutxCtsFlow = TRUE;
-		else
-			mode.fOutxCtsFlow = FALSE;
-	} else {
-		mode.fDtrControl = DTR_CONTROL_DISABLE;
-		if (ReadMacInt8(s + shkFCTS))
-			mode.fOutxCtsFlow = TRUE;
-		else
-			mode.fOutxCtsFlow = FALSE;
-	}
-
-	// MIDI: set_handshake 00 00 f4 f5 21 00 00 00
-	// shkFXOn = 0
-	// shkFCTS = 0
-	// shkXOn = f4
-	// shkXOff = f5
-	// shkErrs = 21
-	// shkEvts = 0
-	// shkFInX = 0
-	// shkFDTR = 0
-	if (ReadMacInt8(s + shkXOn) && ReadMacInt8(s + shkXOn)) {
-		mode.fOutX = 1;
-		mode.fInX = 1;
-		mode.XonChar = ReadMacInt8(s + shkXOn);
-		mode.XoffChar = ReadMacInt8(s + shkXOff);
-	} else {
-		mode.fOutX = 0;
-		mode.fInX = 0;
-	}
-	if (ReadMacInt8(s + shkErrs)) {
-	  mode.ErrorChar = ReadMacInt8(s + shkErrs);
-		mode.fErrorChar = 1;
-	} else {
-		mode.fErrorChar = 0;
-	}
-
-	(void)SetCommState( fd, &mode );
-
-	// D(bug(" %sware flow control\r\n", mode.c_cflag & CRTSCTS ? "hard" : "soft"));
-	// tcsetattr(fd, TCSANOW, &mode);
-}
-
-/*
-	if mode.fAbortOnError is TRUE, ClearCommError() *MUST* be called
-	after any read or write errors. Otherwise no i/o will occur again
-
-	These error codes should be translated but the Mac Device Manager
-	error code mnemonics are too cryptic to me.
-*/
-
-int XSERDPort::acknowledge_error(HANDLE h, bool is_read)
-{
-	DWORD error_state;
-	COMSTAT comstat;
-	int err;
-
-	// default error code if cannot map correctly
-	err = is_read ? readErr : writErr;
-
-	if(ClearCommError(h,&error_state,&comstat)) {
-		D(bug("A %s error 0x%X occured.\r\n", is_read ? "read" : "write", error_state));
-		D(bug("There was %d bytes in input buffer and %d bytes in output buffer.\r\n",(int)comstat.cbInQue,(int)comstat.cbOutQue));
-		if(error_state & CE_MODE) {
-			D(bug("The requested mode is not supported.\r\n"));
-		} else {
-			if(error_state & CE_BREAK) {
-				D(bug("The hardware detected a break condition.\r\n"));
-			}
-			if(error_state & CE_FRAME) {
-				D(bug("The hardware detected a framing error.\r\n"));
-			}
-			if(error_state & CE_IOE) {
-				D(bug("An I/O error occurred during communications with the device.\r\n"));
-			}
-			if(error_state & CE_RXOVER) {
-				D(bug("An input buffer overflow has occurred.\r\n"));
-			}
-			if(error_state & CE_RXPARITY) {
-				D(bug("The hardware detected a parity error.\r\n"));
-				err = badDCksum;
-			}
-			if(error_state & CE_TXFULL) {
-				D(bug("The application tried to transmit a character, but the output buffer was full.\r\n"));
-			}
-
-			// Win95 specific errors
-			if(error_state & CE_OVERRUN) {
-				D(bug("A character-buffer overrun has occurred. The next character is lost.\r\n"));
-				if(!is_read) err = wrUnderrun;
-			}
-
-			// Win95 parallel devices really.
-			if(error_state & CE_DNS) {
-				D(bug("A parallel device is not selected (Windows 95).\r\n"));
-			}
-			if(error_state & CE_OOP) {
-				D(bug("A parallel device signaled that it is out of paper (Windows 95 only).\r\n"));
-				err = unitEmptyErr;
-			}
-			if(error_state & CE_PTO) {
-				D(bug("A time-out occurred on a parallel device (Windows 95).\r\n"));
-			}
-
-		}
-	} else {
-		D(bug("Failed to resume after %s operation.\r\n",is_read ? "read" : "write"));
-	}
-	return(err);
-}
-
-#if DEBUG
-static void dump_dirst_bytes( BYTE *buf, int32 actual )
-{
-	if(debug_serial != DB_SERIAL_LOUD) return;
-
-	BYTE b[256];
-	int32 i, bytes = min(actual,sizeof(b)-3);
-
-	for (i=0; i<bytes; i++) {
-		b[i] = isprint(buf[i]) ? buf[i] : '.';
-	}
-	b[i] = 0;
-	strcat((char*)b,"\r\n");
-	D(bug((char*)b));
-}
-#else
-#define dump_dirst_bytes(b,a) {}
-#endif
-
-/*
- *  Data input thread
- */
-
-unsigned int XSERDPort::input_func(void *arg)
-{
-	XSERDPort *s = (XSERDPort *)arg;
-	int error_code;
-
-#if 0
-	SetThreadPriority( GetCurrentThread(), threads[THREAD_SERIAL_IN].priority_running );
-	SetThreadAffinityMask( GetCurrentThread(), threads[THREAD_SERIAL_IN].affinity_mask );
-	set_desktop();
-#endif
-
-	D(bug(TEXT("XSERDPort::input_func started for device %s\r\n"),s->device_name));
-
-	for (;;) {
-
-		// Wait for commands
-		WaitForSingleObject(s->input_signal,INFINITE);
-		if (s->quitting)
-			break;
-
-		// Execute command
-		void *buf = Mac2HostAddr(ReadMacInt32(s->input_pb + ioBuffer));
-		uint32 length = ReadMacInt32(s->input_pb + ioReqCount);
-		D(bug("input_func waiting for %ld bytes of data...\r\n", length));
-
-		if(length & 0xFFFF0000) {
-			length &= 0x0000FFFF;
-			D(bug("byte count fixed to be %ld...\r\n", length));
-		}
-
-		int32 actual;
-		if(s->is_file) {
-			actual = -1;
-			error_code = readErr;
-		} else if(!ReadFile(s->fd, buf, length, (LPDWORD)&actual, 0)) {
-			actual = -1;
-			if(s->is_serial)
-				error_code = acknowledge_error(s->fd,true);
-			else
-				error_code = readErr;
-		}
-		D(bug(" %ld bytes received\r\n", actual));
-		if(actual > 0) {
-			dump_dirst_bytes( (BYTE*)buf, actual );
-		}
-
-		// KillIO called? Then simply return
-		if (s->io_killed) {
-
-			WriteMacInt16(s->input_pb + ioResult, abortErr);
-			WriteMacInt32(s->input_pb + ioActCount, 0);
-			s->read_pending = s->read_done = false;
-
-		} else {
-
-			// Set error code
-			if (actual >= 0) {
-				WriteMacInt32(s->input_pb + ioActCount, actual);
-				WriteMacInt32(s->input_dt + serdtResult, noErr);
-			} else {
-				WriteMacInt32(s->input_pb + ioActCount, 0);
-				WriteMacInt32(s->input_dt + serdtResult, error_code);
-			}
-
-			// Trigger serial interrupt
-			D(bug(" triggering serial interrupt\r\n"));
-			WriteMacInt32(s->input_dt + serdtDCE, s->input_dce);
-			s->read_done = true;
-			SetInterruptFlag(INTFLAG_SERIAL);
-			TriggerInterrupt();
-		}
-	}
-
-	D(bug("XSERDPort::input_func terminating gracefully\r\n"));
-
-	_endthreadex( 0 );
-
-	return(0);
-}
-
-
-/*
- *  Data output thread
- */
-
-unsigned int XSERDPort::output_func(void *arg)
-{
-	XSERDPort *s = (XSERDPort *)arg;
-	int error_code;
-
-#if 0
-	SetThreadPriority( GetCurrentThread(), threads[THREAD_SERIAL_OUT].priority_running );
-	SetThreadAffinityMask( GetCurrentThread(), threads[THREAD_SERIAL_OUT].affinity_mask );
-	set_desktop();
-#endif
-
-	D(bug(TEXT("XSERDPort::output_func started for device %s\r\n"),s->device_name));
-
-	for (;;) {
-
-		// Wait for commands
-		WaitForSingleObject(s->output_signal,INFINITE);
-		if (s->quitting)
-			break;
-
-		// Execute command
-		void *buf = Mac2HostAddr(ReadMacInt32(s->output_pb + ioBuffer));
-		uint32 length = ReadMacInt32(s->output_pb + ioReqCount);
-		D(bug("output_func transmitting %ld bytes of data...\r\n", length));
-
-		if(length & 0xFFFF0000) {
-			length &= 0x0000FFFF;
-			D(bug("byte count fixed to be %ld...\r\n", length));
-		}
-
-		int32 actual;
-		if(!WriteFile(s->fd, buf, length, (LPDWORD)&actual, 0)) {
-			actual = -1;
-			if(s->is_serial)
-				error_code = acknowledge_error(s->fd,false);
-			else
-				error_code = writErr;
-		}
-		D(bug(" %ld bytes transmitted\r\n", actual));
-		if(actual > 0) {
-			dump_dirst_bytes( (BYTE*)buf, actual );
-		}
-
-		// KillIO called? Then simply return
-		if (s->io_killed) {
-
-			WriteMacInt16(s->output_pb + ioResult, abortErr);
-			WriteMacInt32(s->output_pb + ioActCount, 0);
-			s->write_pending = s->write_done = false;
-
-		} else {
-
-			// Set error code
-			if (actual >= 0) {
-				WriteMacInt32(s->output_pb + ioActCount, actual);
-				WriteMacInt32(s->output_dt + serdtResult, noErr);
-			} else {
-				WriteMacInt32(s->output_pb + ioActCount, 0);
-				WriteMacInt32(s->output_dt + serdtResult, error_code);
-			}
-
-			// Trigger serial interrupt
-			D(bug(" triggering serial interrupt\r\n"));
-			WriteMacInt32(s->output_dt + serdtDCE, s->output_dce);
-			s->write_done = true;
-			SetInterruptFlag(INTFLAG_SERIAL);
-			TriggerInterrupt();
-		}
-	}
-
-	D(bug("XSERDPort::output_func terminating gracefully\r\n"));
-
-	_endthreadex( 0 );
-
-	return(0);
-}
+	static int acknowledge_error(HANDLE h, bool is_read);
+	bool set_timeouts(int bauds, int parity_bits, int stop_bits);
+
+	char device_name[256];
+	HANDLE fd;
+
+	bool io_killed;					// Flag: KillIO called, I/O threads must not call deferred tasks
+	bool quitting;					// Flag: Quit threads
+
+	HANDLE input_thread_active;		// Handle: Input thread installed (was a bool)
+	unsigned int input_thread_id;
+	HANDLE input_signal;				  // Signal for input thread: execute command
+	uint32 input_pb, input_dce;		// Command parameters for input thread
+
+	HANDLE output_thread_active;	// Handle: Output thread installed (was a bool)
+	unsigned int output_thread_id;
+	HANDLE output_signal;			    // Signal for output thread: execute command
+	uint32 output_pb, output_dce;	// Command parameters for output thread
+
+	DCB mode;			                // Terminal configuration
+
+	bool is_serial;
+	bool is_parallel;							// true if LPTx
+
+	bool is_file;									// true if FILE
+	char output_file_name[256];
+};
+
+/*
+ *  Initialization
+ */
+
+void SerialInit(void)
+{
+	const char *port;
+
+	debug_serial = PrefsFindInt32("debugserial");
+
+	serial_log_open( SERIAL_LOG_FILE_NAME );
+
+  // Read serial preferences and create structs for both ports
+
+	port = PrefsFindString("seriala");
+	if(port) {
+		D(bug("SerialInit seriala=%s\r\n",port));
+	}
+  the_serd_port[0] = new XSERDPort(port,"0");
+
+	port = PrefsFindString("serialb");
+	if(port) {
+		D(bug("SerialInit serialb=%s\r\n",port));
+	}
+  the_serd_port[1] = new XSERDPort(port,"1");
+}
+
+
+/*
+ *  Deinitialization
+ */
+
+void SerialExit(void)
+{
+	D(bug("SerialExit\r\n"));
+  if(the_serd_port[0]) delete (XSERDPort *)the_serd_port[0];
+  if(the_serd_port[1]) delete (XSERDPort *)the_serd_port[1];
+	D(bug("SerialExit done\r\n"));
+
+	serial_log_close();
+}
+
+
+/*
+ *  Open serial port
+ */
+
+int16 XSERDPort::open(uint16 config)
+{
+	// Don't open NULL name devices
+	if (!device_name || !*device_name)
+		return openErr;
+
+	D(bug("XSERDPort::open device=%s,config=0x%X\r\n",device_name,(int)config));
+
+	// Init variables
+	io_killed = false;
+	quitting = false;
+
+	// Open port
+	if(is_file) {
+		DeleteFile( output_file_name );
+		fd = CreateFile( output_file_name,
+			GENERIC_READ | GENERIC_WRITE,
+			FILE_SHARE_READ,
+			NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL
+		);
+	} else {
+		fd = CreateFile( device_name, GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0 );
+	}
+	if(fd == INVALID_HANDLE_VALUE) {
+		goto open_error;
+		D(bug("XSERDPort::open failed to open port %s\r\n",device_name));
+	}
+
+	if(is_serial) {
+		// Configure port for raw mode
+		memset( &mode, 0, sizeof(DCB) );
+		mode.DCBlength = sizeof(mode);
+		if(!GetCommState( fd, &mode ))
+			goto open_error;
+
+		mode.fBinary = TRUE;
+		if(!configure(config)) {
+			D(bug("XSERDPort::configure failed\r\n"));
+			goto open_error;
+		}
+	}
+
+	// Start input/output threads
+	input_signal = CreateSemaphore( 0, 0, 1, NULL);
+	if(!input_signal)
+		goto open_error;
+
+	output_signal = CreateSemaphore( 0, 0, 1, NULL);
+	if(!output_signal)
+		goto open_error;
+
+	D(bug("Semaphores created\r\n"));
+
+	input_thread_active = (HANDLE)_beginthreadex( 0, 0, input_func, (LPVOID)this, 0, &input_thread_id );
+	output_thread_active = (HANDLE)_beginthreadex( 0, 0, output_func, (LPVOID)this, 0, &output_thread_id );
+
+	if (!input_thread_active || !output_thread_active)
+		goto open_error;
+
+	D(bug("Threads created, Open returns success\r\n"));
+	return noErr;
+
+open_error:
+	D(bug("Open cleanup after failure\r\n"));
+	if (input_thread_active) {
+		TerminateThread(input_thread_active,0);
+		CloseHandle(input_signal);
+		input_thread_active = false;
+	}
+	if (output_thread_active) {
+		TerminateThread(output_thread_active,0);
+		CloseHandle(output_signal);
+		output_thread_active = false;
+	}
+	if(fd != INVALID_HANDLE_VALUE) {
+		CloseHandle(fd);
+		fd = 0;
+	}
+	return openErr;
+}
+
+/*
+ *  Read data from port
+ */
+
+int16 XSERDPort::prime_in(uint32 pb, uint32 dce)
+{
+	D(bug("XSERDPort::prime_in\r\n"));
+	// Send input command to input_thread
+	read_done = false;
+	read_pending = true;
+	input_pb = pb;
+	input_dce = dce;
+	ReleaseSemaphore(input_signal,1,NULL);
+	return 1;	// Command in progress
+}
+
+
+/*
+ *  Write data to port
+ */
+
+int16 XSERDPort::prime_out(uint32 pb, uint32 dce)
+{
+	D(bug("XSERDPort::prime_out\r\n"));
+	// Send output command to output_thread
+	write_done = false;
+	write_pending = true;
+	output_pb = pb;
+	output_dce = dce;
+	ReleaseSemaphore(output_signal,1,NULL);
+	return 1;	// Command in progress
+}
+
+
+static DWORD get_comm_output_buf_size( HANDLE h )
+{
+	DWORD size = 0;
+	COMMPROP cp;
+
+	if(GetCommProperties(h,&cp)) {
+		size = cp.dwCurrentTxQueue;
+	}
+	return size;
+}
+
+/*
+ *  Control calls
+ */
+
+int16 XSERDPort::control(uint32 pb, uint32 dce, uint16 code)
+{
+	D(bug("XSERDPort::control code=%d\r\n",(int)code));
+	switch (code) {
+
+		case kSERDClockMIDI:
+			/* http://til.info.apple.com/techinfo.nsf/artnum/n2425
+			 A MIDI interface operates at 31.25 Kbaud (+/- 1%) [== 31400]
+			 asynchronously, using a data format of one start bit, eight
+			 data bits, and one stop bit. This makes a total of 10 bits
+			 for each 320 microsecond period per serial byte.
+			*/
+			D(bug("kSERDClockMIDI setting 38400,n,8,1\n"));
+			return noErr;
+
+			/*
+			mode.BaudRate = 38400;
+		  mode.ByteSize = 8;
+		  mode.StopBits = ONESTOPBIT;
+		  mode.Parity = NOPARITY;
+			if(!SetCommState( fd, &mode )) {
+				D(bug("kSERDClockMIDI SetCommState() failed\n"));
+				return controlErr;
+			} else {
+				if(!set_timeouts(38400,0,2)) {
+					D(bug("kSERDClockMIDI set_timeouts() failed\n"));
+					return controlErr;
+				}
+				D(bug("kSERDClockMIDI OK\n"));
+				return noErr;
+			}
+			*/
+
+		case 1:			// KillIO
+			io_killed = true;
+
+			if(is_serial) {
+				// Make sure we won't hang waiting. There is something wrong
+				// in how read_pending & write_pending are handled.
+				DWORD endtime = GetTickCount() + 1000;
+ 				while ( (read_pending || write_pending) && (GetTickCount() < endtime) ) {
+					Sleep(20);
+				}
+				if(read_pending || write_pending) {
+					D(bug("Warning (KillIO): read_pending=%d, write_pending=%d\n", read_pending, write_pending));
+					read_pending = write_pending = false;
+				}
+				// | PURGE_TXABORT | PURGE_RXABORT not needed, no overlapped i/o
+				PurgeComm(fd,PURGE_TXCLEAR|PURGE_RXCLEAR);
+				FlushFileBuffers(fd);
+			}
+			io_killed = false;
+			D(bug("KillIO done\n"));
+			return noErr;
+
+		case kSERDConfiguration:
+			if (configure((uint16)ReadMacInt16(pb + csParam)))
+				return noErr;
+			else
+				return paramErr;
+
+		case kSERDInputBuffer:
+			if(is_serial) {
+
+				// SetupComm() wants both values, so we need to know the output size.
+				DWORD osize = get_comm_output_buf_size(fd);
+
+				DWORD isize = ReadMacInt16(pb + csParam + 4) & 0xffffffc0;
+
+				// 1k minimum
+				// Was this something Amiga specific -- do I need to do this?
+				if (isize < 1024)
+					isize = 1024;
+
+				if(isize > 0 && osize > 0) {
+					if(SetupComm( fd, isize, osize )) {
+						D(bug(" buffer size is now %08lx\n", isize));
+						return noErr;
+					} else {
+						D(bug(" SetupComm(%d,%d) failed, error = %08lx\n", isize, osize, GetLastError()));
+					}
+				}
+			}
+			// Always return ok.
+			return noErr;
+
+		case kSERDSerHShake:
+			set_handshake(pb + csParam, false);
+			return noErr;
+
+		case kSERDSetBreak:
+			if(is_serial) {
+				if(!SetCommBreak(fd)) return controlErr;
+			}
+			return noErr;
+
+		case kSERDClearBreak:
+			if(is_serial) {
+				if(!ClearCommBreak(fd)) return controlErr;
+			}
+			return noErr;
+
+		case kSERDBaudRate: {
+			if (is_serial) {
+				uint16 rate = (uint16)ReadMacInt16(pb + csParam);
+				int baud_rate;
+				if (rate <= 50) {
+					rate = 50; baud_rate = CBR_110;
+				} else if (rate <= 75) {
+					rate = 75; baud_rate = CBR_110;
+				} else if (rate <= 110) {
+					rate = 110; baud_rate = CBR_110;
+				} else if (rate <= 134) {
+					rate = 134; baud_rate = CBR_110;
+				} else if (rate <= 150) {
+					rate = 150; baud_rate = CBR_110;
+				} else if (rate <= 200) {
+					rate = 200; baud_rate = CBR_300;
+				} else if (rate <= 300) {
+					rate = 300; baud_rate = CBR_300;
+				} else if (rate <= 600) {
+					rate = 600; baud_rate = CBR_600;
+				} else if (rate <= 1200) {
+					rate = 1200; baud_rate = CBR_1200;
+				} else if (rate <= 1800) {
+					rate = 1800; baud_rate = CBR_2400;
+				} else if (rate <= 2400) {
+					rate = 2400; baud_rate = CBR_2400;
+				} else if (rate <= 4800) {
+					rate = 4800; baud_rate = CBR_4800;
+				} else if (rate <= 9600) {
+					rate = 9600; baud_rate = CBR_9600;
+				} else if (rate <= 19200) {
+					rate = 19200; baud_rate = CBR_19200;
+				} else if (rate <= 38400) {
+					rate = 38400; baud_rate = CBR_38400;
+				} else if (rate <= 57600) {
+					rate = 57600; baud_rate = CBR_57600;
+				} else {
+					rate = 57600; baud_rate = CBR_57600;
+				}
+				WriteMacInt16(pb + csParam, rate);
+				mode.BaudRate = baud_rate;			
+				if(!SetCommState( fd, &mode )) return controlErr;
+				// TODO: save parity/stop values and use here (not critical)
+				if(!set_timeouts(rate,0,1)) return controlErr;
+			}
+			return noErr;
+		}
+
+		case kSERDHandshake:
+		case kSERDHandshakeRS232:
+			set_handshake(pb + csParam, true);
+			return noErr;
+
+		case kSERDMiscOptions:
+			if (ReadMacInt8(pb + csParam) & kOptionPreserveDTR)
+			  mode.fDtrControl =  DTR_CONTROL_ENABLE; // correct?
+			else
+			  mode.fDtrControl =  DTR_CONTROL_DISABLE; // correct?
+			if(is_serial) {
+				if(!SetCommState( fd, &mode )) return controlErr;
+			}
+			return noErr;
+
+		case kSERDAssertDTR: {
+			if (is_serial) {
+				if(!EscapeCommFunction(fd,SETDTR)) return controlErr;
+			}
+			return noErr;
+		}
+
+		case kSERDNegateDTR: {
+			if (is_serial) {
+				if(!EscapeCommFunction(fd,CLRDTR)) return controlErr;
+			}
+			return noErr;
+		}
+
+		case kSERDSetPEChar:
+		case kSERDSetPEAltChar:
+			{
+			uint16 errChar = (uint16)ReadMacInt16(pb + csParam);
+			mode.fErrorChar = TRUE;
+			mode.ErrorChar = (char)errChar;
+			return noErr;
+			}
+
+		case kSERDResetChannel:
+			if (is_serial) {
+				// | PURGE_TXABORT | PURGE_RXABORT not needed, no overlapped i/o
+				PurgeComm(fd,PURGE_TXCLEAR|PURGE_RXCLEAR);
+				FlushFileBuffers(fd);
+			}
+			return noErr;
+
+		case kSERDAssertRTS: {
+			if (is_serial) {
+				if(!EscapeCommFunction(fd,SETRTS)) return controlErr;
+			}
+			return noErr;
+		}
+
+		case kSERDNegateRTS: {
+			if (is_serial) {
+				if(!EscapeCommFunction(fd,CLRRTS)) return controlErr;
+			}
+			return noErr;
+		}
+
+		case kSERD115KBaud:
+			if (is_serial) {
+				mode.BaudRate = CBR_115200;
+				if(!SetCommState( fd, &mode )) return controlErr;
+			}
+			return noErr;
+
+		case kSERD230KBaud:
+		case kSERDSetHighSpeed:
+			if (is_serial) {
+				mode.BaudRate = CBR_256000;
+				if(!SetCommState( fd, &mode )) return controlErr;
+			}
+			return noErr;
+
+		default:
+			D(bug("WARNING: SerialControl(): unimplemented control code %d\r\n", code));
+			return controlErr;
+	}
+}
+
+/*
+ *  Status calls
+ */
+
+int16 XSERDPort::status(uint32 pb, uint32 dce, uint16 code)
+{
+	// D(bug("XSERDPort::status code=%d\r\n",(int)code));
+
+	DWORD error_state;
+	COMSTAT comstat;
+
+	switch (code) {
+		case kSERDInputCount: {
+			uint32 num = 0;
+			if (is_serial) {
+				if(!ClearCommError(fd,&error_state,&comstat)) return statusErr;
+				num = comstat.cbInQue;
+			}
+			WriteMacInt32(pb + csParam, num);
+			return noErr;
+		}
+
+		case kSERDStatus: {
+			uint32 p = pb + csParam;
+			WriteMacInt8(p + staCumErrs, cum_errors);
+			cum_errors = 0;
+			DWORD status;
+
+			if(is_serial) {
+				if(!GetCommModemStatus(fd,&status)) return statusErr;
+			} else {
+				status = MS_CTS_ON | MS_DSR_ON | MS_RLSD_ON;
+				D(bug("kSERDStatus: faking status for LPT port or FILE\r\n"));
+			}
+
+			WriteMacInt8(p + staXOffSent, 0);
+			WriteMacInt8(p + staXOffHold, 0);
+			WriteMacInt8(p + staRdPend, read_pending);
+			WriteMacInt8(p + staWrPend, write_pending);
+
+			WriteMacInt8(p + staCtsHold, status & MS_CTS_ON ? 0 : 1);
+			WriteMacInt8(p + staDsrHold, status & MS_DSR_ON ? 0 : 1);
+
+			WriteMacInt8(p + staModemStatus,
+				(status & MS_DSR_ON ? dsrEvent : 0)
+				| (status & MS_RING_ON ? riEvent : 0)
+				| (status & MS_RLSD_ON ? dcdEvent : 0)   // is this carrier detect?
+				| (status & MS_CTS_ON ? ctsEvent : 0));
+			return noErr;
+		}
+
+		default:
+			D(bug("WARNING: SerialStatus(): unimplemented status code %d\r\n", code));
+			return statusErr;
+	}
+}
+
+
+/*
+ *  Close serial port
+ */
+
+int16 XSERDPort::close()
+{
+	D(bug("XSERDPort::close\r\n"));
+
+	// Kill threads
+	if (input_thread_active) {
+		quitting = true;
+		ReleaseSemaphore(input_signal,1,NULL);
+		input_thread_active = false;
+		CloseHandle(input_signal);
+	}
+	if (output_thread_active) {
+		quitting = true;
+		ReleaseSemaphore(output_signal,1,NULL);
+		output_thread_active = false;
+		// bugfix: was: CloseHandle(&output_signal);
+		CloseHandle(output_signal);
+	}
+
+	// Close port
+	if(fd != INVALID_HANDLE_VALUE) {
+		CloseHandle(fd);
+		fd = 0;
+	}
+  return noErr;
+}
+
+bool XSERDPort::set_timeouts(
+	int bauds, int parity_bits, int stop_bits )
+{
+	COMMTIMEOUTS timeouts;
+	uint32 bytes_per_sec;
+	uint32 msecs_per_ch;
+	bool result = false;
+
+	// Should already been checked
+	if (!is_serial)
+		return true;
+
+	bytes_per_sec = bauds / (mode.ByteSize + parity_bits + stop_bits);
+
+	// 75% bytes_per_sec
+	// bytes_per_sec = (bytes_per_sec+bytes_per_sec+bytes_per_sec) >> 2;
+
+	// 50% bytes_per_sec
+	bytes_per_sec = bytes_per_sec >> 1;
+
+	msecs_per_ch = 1000 / bytes_per_sec;
+	if(msecs_per_ch == 0) msecs_per_ch = 1;
+
+	if(GetCommTimeouts(fd,&timeouts)) {
+		D(bug("old timeout values: %ld %ld %ld %ld %ld\r\n",
+			timeouts.ReadIntervalTimeout,
+			timeouts.ReadTotalTimeoutMultiplier,
+			timeouts.ReadTotalTimeoutConstant,
+			timeouts.WriteTotalTimeoutMultiplier,
+			timeouts.WriteTotalTimeoutConstant
+		));
+
+		timeouts.WriteTotalTimeoutMultiplier = msecs_per_ch;
+		timeouts.WriteTotalTimeoutConstant = 10;
+
+		/*
+		timeouts.ReadIntervalTimeout = msecs_per_ch;
+		timeouts.ReadTotalTimeoutMultiplier = msecs_per_ch;
+		timeouts.ReadTotalTimeoutConstant = 10;
+		*/
+
+		timeouts.ReadIntervalTimeout = MAXDWORD;
+		timeouts.ReadTotalTimeoutMultiplier = 0;
+		timeouts.ReadTotalTimeoutConstant = 0;
+
+		if(!SetCommTimeouts(fd,&timeouts)) {
+			D(bug("SetCommTimeouts() failed in configure()\r\n"));
+		} else {
+			D(bug("new timeout values: %ld %ld %ld %ld %ld\r\n",
+				timeouts.ReadIntervalTimeout,
+				timeouts.ReadTotalTimeoutMultiplier,
+				timeouts.ReadTotalTimeoutConstant,
+				timeouts.WriteTotalTimeoutMultiplier,
+				timeouts.WriteTotalTimeoutConstant
+			));
+			result = true;
+		}
+	} else {
+		D(bug("GetCommTimeouts() failed in set_timeouts()\r\n"));
+	}
+	return(result);
+}
+
+/*
+ *  Configure serial port with MacOS config word
+ */
+
+bool XSERDPort::configure(uint16 config)
+{
+	D(bug("XSERDPort::configure, config=%d\r\n",(int)config));
+
+	if (!is_serial)
+		return true;
+
+	// needed to calculate optimal timeouts
+	uint32 bauds = 57600;
+	uint32 stop_bits = 1;
+	uint32 parity_bits = 0;
+
+	// Not all of these can be set here anyway.
+	/*
+	mode.fOutxCtsFlow = TRUE;
+	mode.fOutxDsrFlow = FALSE;
+	mode.fDtrControl = DTR_CONTROL_ENABLE; //  DTR_CONTROL_HANDSHAKE?
+  mode.fDsrSensitivity = FALSE; // ???
+  mode.fOutX = FALSE;
+  mode.fInX = FALSE;
+  mode.fTXContinueOnXoff = FALSE;
+  mode.fErrorChar = FALSE;
+  mode.ErrorChar = 0;
+  mode.fNull = FALSE;
+  mode.fRtsControl = 2; // ???
+  mode.fAbortOnError = FALSE;
+  mode.XonLim = 0x800;
+  mode.XoffLim = 0x200;
+  mode.XonChar = 0x11;
+  mode.XoffChar = 0x13;
+  mode.EofChar = 0;
+  mode.EvtChar = '\0';
+	*/
+
+	// Set baud rate
+	switch (config & 0x03ff) {
+		// no baud1800, CBR_14400, CBR_56000, CBR_115200, CBR_128000, CBR_256000
+		case baud150: mode.BaudRate = CBR_110; bauds = 110; break;
+		case baud300: mode.BaudRate = CBR_300; bauds = 300; break;
+		case baud600: mode.BaudRate = CBR_600; bauds = 600; break;
+		case baud1200: mode.BaudRate = CBR_1200; bauds = 1200; break;
+		case baud1800: return false;
+		case baud2400: mode.BaudRate = CBR_2400; bauds = 2400; break;
+		case baud4800: mode.BaudRate = CBR_4800; bauds = 4800; break;
+		case baud9600: mode.BaudRate = CBR_9600; bauds = 9600; break;
+		case baud19200: mode.BaudRate = CBR_19200; bauds = 19200; break;
+		case baud38400: mode.BaudRate = CBR_38400; bauds = 38400; break;
+		case baud57600: mode.BaudRate = CBR_57600; bauds = 57600; break;
+		default:
+			return false;
+	}
+
+	// Set number of stop bits
+	switch (config & 0xc000) {
+		case stop10:
+		  mode.StopBits = ONESTOPBIT;
+			stop_bits = 1;
+			break;
+		case stop15:
+		  mode.StopBits = ONE5STOPBITS;
+			stop_bits = 2;
+			break;
+		case stop20:
+		  mode.StopBits = TWOSTOPBITS;
+			stop_bits = 2;
+			break;
+		default:
+			return false;
+	}
+
+	// Set parity mode
+	switch (config & 0x3000) {
+		case noParity:
+		  mode.Parity = NOPARITY;
+		  mode.fParity = FALSE;
+			parity_bits = 0;
+			break;
+		case oddParity:
+		  mode.Parity = ODDPARITY;
+		  mode.fParity = TRUE;
+			parity_bits = 1;
+			break;
+		case evenParity:
+		  mode.Parity = EVENPARITY;
+		  mode.fParity = TRUE;
+			parity_bits = 1;
+			break;
+		// No MARKPARITY, SPACEPARITY
+		default:
+			return false;
+	}
+
+	// Set number of data bits
+	switch (config & 0x0c00) {
+		// No data4
+		case data5:
+		  mode.ByteSize = 5; break;
+		case data6:
+		  mode.ByteSize = 6; break;
+		case data7:
+		  mode.ByteSize = 7; break;
+		case data8:
+		  mode.ByteSize = 8; break;
+		default:
+			return false;
+	}
+
+	D(bug("Interpreted configuration: %d,%d,%d,%d\r\n",
+		bauds,
+		mode.ByteSize,
+		stop_bits,
+		parity_bits
+	));
+
+	if(!SetCommState( fd, &mode )) {
+		D(bug("SetCommState failed in configure()\r\n"));
+		return false;
+	}
+
+	if(!set_timeouts(bauds,parity_bits,stop_bits))
+		return false;
+
+	return true;
+}
+
+
+/*
+ *  Set serial handshaking
+ */
+
+void XSERDPort::set_handshake(uint32 s, bool with_dtr)
+{
+	D(bug(" set_handshake %02x %02x %02x %02x %02x %02x %02x %02x\r\n",
+		ReadMacInt8(s + 0), ReadMacInt8(s + 1), ReadMacInt8(s + 2), ReadMacInt8(s + 3),
+		ReadMacInt8(s + 4), ReadMacInt8(s + 5), ReadMacInt8(s + 6), ReadMacInt8(s + 7)));
+
+	if (!is_serial)
+		return;
+
+	if (with_dtr) {
+		mode.fDtrControl = DTR_CONTROL_ENABLE;
+		if (ReadMacInt8(s + shkFCTS) || ReadMacInt8(s + shkFDTR))
+			mode.fOutxCtsFlow = TRUE;
+		else
+			mode.fOutxCtsFlow = FALSE;
+	} else {
+		mode.fDtrControl = DTR_CONTROL_DISABLE;
+		if (ReadMacInt8(s + shkFCTS))
+			mode.fOutxCtsFlow = TRUE;
+		else
+			mode.fOutxCtsFlow = FALSE;
+	}
+
+	// MIDI: set_handshake 00 00 f4 f5 21 00 00 00
+	// shkFXOn = 0
+	// shkFCTS = 0
+	// shkXOn = f4
+	// shkXOff = f5
+	// shkErrs = 21 
+	// shkEvts = 0
+	// shkFInX = 0
+	// shkFDTR = 0
+	if (ReadMacInt8(s + shkXOn) && ReadMacInt8(s + shkXOn)) {
+		mode.fOutX = 1;
+		mode.fInX = 1;
+		mode.XonChar = ReadMacInt8(s + shkXOn);
+		mode.XoffChar = ReadMacInt8(s + shkXOff);
+	} else {
+		mode.fOutX = 0;
+		mode.fInX = 0;
+	}
+	if (ReadMacInt8(s + shkErrs)) {
+	  mode.ErrorChar = ReadMacInt8(s + shkErrs);
+		mode.fErrorChar = 1;
+	} else {
+		mode.fErrorChar = 0;
+	}
+
+	(void)SetCommState( fd, &mode );
+
+	// D(bug(" %sware flow control\r\n", mode.c_cflag & CRTSCTS ? "hard" : "soft"));
+	// tcsetattr(fd, TCSANOW, &mode);
+}
+
+/*
+	if mode.fAbortOnError is TRUE, ClearCommError() *MUST* be called
+	after any read or write errors. Otherwise no i/o will occur again
+
+	These error codes should be translated but the Mac Device Manager
+	error code mnemonics are too cryptic to me.
+*/
+
+int XSERDPort::acknowledge_error(HANDLE h, bool is_read)
+{
+	DWORD error_state;
+	COMSTAT comstat;
+	int err;
+
+	// default error code if cannot map correctly
+	err = is_read ? readErr : writErr;
+
+	if(ClearCommError(h,&error_state,&comstat)) {
+		D(bug("A %s error 0x%X occured.\r\n", is_read ? "read" : "write", error_state));
+		D(bug("There was %d bytes in input buffer and %d bytes in output buffer.\r\n",(int)comstat.cbInQue,(int)comstat.cbOutQue));
+		if(error_state & CE_MODE) {
+			D(bug("The requested mode is not supported.\r\n"));
+		} else {
+			if(error_state & CE_BREAK) {
+				D(bug("The hardware detected a break condition.\r\n"));
+			}
+			if(error_state & CE_FRAME) {
+				D(bug("The hardware detected a framing error.\r\n"));
+			}
+			if(error_state & CE_IOE) {
+				D(bug("An I/O error occurred during communications with the device.\r\n"));
+			}
+			if(error_state & CE_RXOVER) {
+				D(bug("An input buffer overflow has occurred.\r\n"));
+			}
+			if(error_state & CE_RXPARITY) {
+				D(bug("The hardware detected a parity error.\r\n"));
+				err = badDCksum;
+			}
+			if(error_state & CE_TXFULL) {
+				D(bug("The application tried to transmit a character, but the output buffer was full.\r\n"));
+			}
+
+			// Win95 specific errors
+			if(error_state & CE_OVERRUN) {
+				D(bug("A character-buffer overrun has occurred. The next character is lost.\r\n"));
+				if(!is_read) err = wrUnderrun;
+			}
+
+			// Win95 parallel devices really.
+			if(error_state & CE_DNS) {
+				D(bug("A parallel device is not selected (Windows 95).\r\n"));
+			}
+			if(error_state & CE_OOP) {
+				D(bug("A parallel device signaled that it is out of paper (Windows 95 only).\r\n"));
+				err = unitEmptyErr;
+			}
+			if(error_state & CE_PTO) {
+				D(bug("A time-out occurred on a parallel device (Windows 95).\r\n"));
+			}
+
+		}
+	} else {
+		D(bug("Failed to resume after %s operation.\r\n",is_read ? "read" : "write"));
+	}
+	return(err);
+}
+
+#if DEBUG
+static void dump_dirst_bytes( BYTE *buf, int32 actual )
+{
+	if(debug_serial != DB_SERIAL_LOUD) return;
+
+	BYTE b[256];
+	int32 i, bytes = std::min<int32>(actual,sizeof(b)-3);
+
+	for (i=0; i<bytes; i++) {
+		b[i] = isprint(buf[i]) ? buf[i] : '.';
+	}
+	b[i] = 0;
+	strcat((char*)b,"\r\n");
+	D(bug((char*)b));
+}
+#else
+#define dump_dirst_bytes(b,a) {}
+#endif
+
+/*
+ *  Data input thread
+ */
+
+unsigned int XSERDPort::input_func(void *arg)
+{
+	XSERDPort *s = (XSERDPort *)arg;
+	int error_code;
+
+#if 0
+	SetThreadPriority( GetCurrentThread(), threads[THREAD_SERIAL_IN].priority_running );
+	SetThreadAffinityMask( GetCurrentThread(), threads[THREAD_SERIAL_IN].affinity_mask );
+	set_desktop();
+#endif
+
+	D(bug("XSERDPort::input_func started for device %s\r\n",s->device_name));
+
+	for (;;) {
+
+		// Wait for commands
+		WaitForSingleObject(s->input_signal,INFINITE);
+		if (s->quitting)
+			break;
+
+		// Execute command
+		void *buf = Mac2HostAddr(ReadMacInt32(s->input_pb + ioBuffer));
+		uint32 length = ReadMacInt32(s->input_pb + ioReqCount);
+		D(bug("input_func waiting for %ld bytes of data...\r\n", length));
+
+		if(length & 0xFFFF0000) {
+			length &= 0x0000FFFF;
+			D(bug("byte count fixed to be %ld...\r\n", length));
+		}
+
+		int32 actual;
+		if(s->is_file) {
+			actual = -1;
+			error_code = readErr;
+		} else if(!ReadFile(s->fd, buf, length, (LPDWORD)&actual, 0)) {
+			actual = -1;
+			if(s->is_serial)
+				error_code = acknowledge_error(s->fd,true);
+			else
+				error_code = readErr;
+		}
+		D(bug(" %ld bytes received\r\n", actual));
+		if(actual > 0) {
+			dump_dirst_bytes( (BYTE*)buf, actual );
+		}
+
+		// KillIO called? Then simply return
+		if (s->io_killed) {
+
+			WriteMacInt16(s->input_pb + ioResult, abortErr);
+			WriteMacInt32(s->input_pb + ioActCount, 0);
+			s->read_pending = s->read_done = false;
+
+		} else {
+
+			// Set error code
+			if (actual >= 0) {
+				WriteMacInt32(s->input_pb + ioActCount, actual);
+				WriteMacInt32(s->input_dt + serdtResult, noErr);
+			} else {
+				WriteMacInt32(s->input_pb + ioActCount, 0);
+				WriteMacInt32(s->input_dt + serdtResult, error_code);
+			}
+
+			// Trigger serial interrupt
+			D(bug(" triggering serial interrupt\r\n"));
+			WriteMacInt32(s->input_dt + serdtDCE, s->input_dce);
+			s->read_done = true;
+			SetInterruptFlag(INTFLAG_SERIAL);
+			TriggerInterrupt();
+		}
+	}
+
+	D(bug("XSERDPort::input_func terminating gracefully\r\n"));
+
+	_endthreadex( 0 );
+
+	return(0);
+}
+
+
+/*
+ *  Data output thread
+ */
+
+unsigned int XSERDPort::output_func(void *arg)
+{
+	XSERDPort *s = (XSERDPort *)arg;
+	int error_code;
+
+#if 0
+	SetThreadPriority( GetCurrentThread(), threads[THREAD_SERIAL_OUT].priority_running );
+	SetThreadAffinityMask( GetCurrentThread(), threads[THREAD_SERIAL_OUT].affinity_mask );
+	set_desktop();
+#endif
+
+	D(bug("XSERDPort::output_func started for device %s\r\n",s->device_name));
+
+	for (;;) {
+
+		// Wait for commands
+		WaitForSingleObject(s->output_signal,INFINITE);
+		if (s->quitting)
+			break;
+
+		// Execute command
+		void *buf = Mac2HostAddr(ReadMacInt32(s->output_pb + ioBuffer));
+		uint32 length = ReadMacInt32(s->output_pb + ioReqCount);
+		D(bug("output_func transmitting %ld bytes of data...\r\n", length));
+
+		if(length & 0xFFFF0000) {
+			length &= 0x0000FFFF;
+			D(bug("byte count fixed to be %ld...\r\n", length));
+		}
+
+		int32 actual;
+		if(!WriteFile(s->fd, buf, length, (LPDWORD)&actual, 0)) {
+			actual = -1;
+			if(s->is_serial)
+				error_code = acknowledge_error(s->fd,false);
+			else
+				error_code = writErr;
+		}
+		D(bug(" %ld bytes transmitted\r\n", actual));
+		if(actual > 0) {
+			dump_dirst_bytes( (BYTE*)buf, actual );
+		}
+
+		// KillIO called? Then simply return
+		if (s->io_killed) {
+
+			WriteMacInt16(s->output_pb + ioResult, abortErr);
+			WriteMacInt32(s->output_pb + ioActCount, 0);
+			s->write_pending = s->write_done = false;
+
+		} else {
+
+			// Set error code
+			if (actual >= 0) {
+				WriteMacInt32(s->output_pb + ioActCount, actual);
+				WriteMacInt32(s->output_dt + serdtResult, noErr);
+			} else {
+				WriteMacInt32(s->output_pb + ioActCount, 0);
+				WriteMacInt32(s->output_dt + serdtResult, error_code);
+			}
+
+			// Trigger serial interrupt
+			D(bug(" triggering serial interrupt\r\n"));
+			WriteMacInt32(s->output_dt + serdtDCE, s->output_dce);
+			s->write_done = true;
+			SetInterruptFlag(INTFLAG_SERIAL);
+			TriggerInterrupt();
+		}
+	}
+
+	D(bug("XSERDPort::output_func terminating gracefully\r\n"));
+
+	_endthreadex( 0 );
+
+	return(0);
+}
--- macemu/SheepShaver/src/Windows/sys_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/sys_windows.cpp
@@ -20,16 +20,17 @@
 
 #include "sysdeps.h"
 
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
 #include <winioctl.h>
 
 #include <string>
-typedef std::basic_string<TCHAR> tstring;
+using std::string;
 
 #include <algorithm>
 using std::min;
 
 #include "main.h"
-#include "util_windows.h"
 #include "macos_util.h"
 #include "prefs.h"
 #include "user_strings.h"
@@ -46,7 +47,7 @@
 
 // File handles are pointers to these structures
 struct file_handle {
-	TCHAR *name;		// Copy of device/file name
+	char *name;			// Copy of device/file name
 	HANDLE fh;
 	bool is_file;		// Flag: plain file or physical device?
 	bool is_floppy;		// Flag: floppy device
@@ -150,8 +151,8 @@
 				CloseHandle(fh->fh);
 
 			// Re-open device
-			TCHAR device_name[MAX_PATH];
-			_sntprintf(device_name, lengthof(device_name), TEXT("\\\\.\\%c:"), fh->name[0]);
+			char device_name[MAX_PATH];
+			sprintf(device_name, "\\\\.\\%c:", fh->name[0]);
 			fh->fh = CreateFile(
 				device_name,
 				GENERIC_READ,
@@ -231,10 +232,11 @@
 	if (PrefsFindBool("nocdrom"))
 		return;
 
-	char rootdir[] = "C:\\";
-	for (; rootdir[0] <= 'Z'; rootdir[0]++) {
-		if (GetDriveTypeA(rootdir) == DRIVE_CDROM)
-			PrefsAddString("cdrom", rootdir);
+	for (char letter = 'C'; letter <= 'Z'; letter++) {
+		int i = (int)(letter - 'A');
+		string rootdir = letter + ":\\";
+		if (GetDriveType(rootdir.c_str()) == DRIVE_CDROM)
+			PrefsAddString("cdrom", rootdir.c_str());
 	}
 }
 
@@ -395,9 +397,9 @@
  *  Check if NAME represents a read-only file
  */
 
-static bool is_read_only_path(const TCHAR *name)
+static bool is_read_only_path(const char *name)
 {
-	DWORD attrib = GetFileAttributes(name);
+	DWORD attrib = GetFileAttributes((char *)name);
 	return (attrib != INVALID_FILE_ATTRIBUTES && ((attrib & FILE_ATTRIBUTE_READONLY) != 0));
 }
 
@@ -411,25 +413,25 @@
 	file_handle * fh = NULL;
 
 	// Parse path name and options
-	TCHAR name[MAX_PATH];
-	tcslcpy(name, path_name, lengthof(name));
+	char name[MAX_PATH];
+	strcpy(name, path_name);
 
 	// Normalize floppy / cd path
-	int name_len = _tcslen(name);
-	if (name_len == 1 && _istalpha(name[0]))
-		_tcscat(name, TEXT(":\\"));
-	if (name_len > 0 && name[name_len - 1] == TEXT(':'))
-		_tcscat(name, TEXT("\\"));
-	name_len = _tcslen(name);
+	int name_len = strlen(name);
+	if (name_len == 1 && isalpha(name[0]))
+		strcat(name, ":\\");
+	if (name_len > 0 && name[name_len - 1] == ':')
+		strcat(name, "\\");
+	name_len = strlen(name);
 
-	D(bug(TEXT("Sys_open(%s, %s)\n"), name, read_only ? TEXT("read-only") : TEXT("read/write")));
-	if (name_len > 0 && name[name_len - 1] == TEXT('\\')) {
+	D(bug("Sys_open(%s, %s)\n", name, read_only ? "read-only" : "read/write"));
+	if (name_len > 0 && name[name_len - 1] == '\\') {
 		int type = GetDriveType(name);
 
 		if (type == DRIVE_CDROM) {
 			read_only = true;
-			TCHAR device_name[MAX_PATH];
-			_sntprintf(device_name, lengthof(device_name), TEXT("\\\\.\\%c:"), name[0]);
+			char device_name[MAX_PATH];
+			sprintf(device_name, "\\\\.\\%c:", name[0]);
 
 			// Open device
 			HANDLE h = CreateFile(
@@ -439,7 +441,7 @@
 
 			if (h != INVALID_HANDLE_VALUE) {
 				fh = new file_handle;
-				fh->name = _tcsdup(name);
+				fh->name = strdup(name);
 				fh->fh = h;
 				fh->is_file = false;
 				fh->read_only = read_only;
@@ -478,7 +480,7 @@
 
 		if (h != INVALID_HANDLE_VALUE) {
 			fh = new file_handle;
-			fh->name = _tcsdup(name);
+			fh->name = strdup(name);
 			fh->fh = h;
 			fh->is_file = true;
 			fh->read_only = read_only;
@@ -495,11 +497,11 @@
 		}
 	}
 
-	if (fh) {
-		if (fh->is_floppy && first_floppy == NULL)
-			first_floppy = fh;
+	if (fh->is_floppy && first_floppy == NULL)
+		first_floppy = fh;
+
+	if (fh)
 		sys_add_file_handle(fh);
-	}
 
 	return fh;
 }
@@ -791,7 +793,7 @@
 						   NULL, 0,
 						   toc, min((int)sizeof(CDROM_TOC), 804),
 						   &dummy,
-						   NULL) != FALSE;
+						   NULL);
 }
 
 
@@ -817,7 +819,7 @@
 							  &q_format, sizeof(CDROM_SUB_Q_DATA_FORMAT),
 							  &q_data, sizeof(SUB_Q_CHANNEL_DATA),
 							  &dwBytesReturned,
-							  NULL) != FALSE;
+							  NULL);
 	if (ok)
 		memcpy(pos, &q_data.CurrentPosition, sizeof(SUB_Q_CURRENT_POSITION));
 
@@ -849,7 +851,7 @@
 						   &msf, sizeof(CDROM_PLAY_AUDIO_MSF),
 						   NULL, 0,
 						   &dwBytesReturned,
-						   NULL) != FALSE;
+						   NULL);
 }
 
 
@@ -869,7 +871,7 @@
 						   NULL, 0,
 						   NULL, 0,
 						   &dwBytesReturned,
-						   NULL) != FALSE;
+						   NULL);
 }
 
 
@@ -888,7 +890,7 @@
 						   IOCTL_CDROM_RESUME_AUDIO,
 						   NULL, 0,
 						   NULL, 0,
-						   &dwBytesReturned, NULL) != FALSE;
+						   &dwBytesReturned, NULL);
 }
 
 
@@ -908,7 +910,7 @@
 						   NULL, 0,
 						   NULL, 0,
 						   &dwBytesReturned,
-						   NULL) != FALSE;
+						   NULL);
 }
 
 
@@ -933,7 +935,7 @@
 						   &msf, sizeof(CDROM_SEEK_AUDIO_MSF),
 						   NULL, 0,
 						   &dwBytesReturned,
-						   NULL) != FALSE;
+						   NULL);
 }
 
 
--- macemu/SheepShaver/src/Windows/sysdeps.h
+++ sheepshaver/SheepShaver/src/Windows/sysdeps.h
@@ -18,10 +18,10 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifndef SYSDEPS_H
-#define SYSDEPS_H
+#ifndef WIN_SYSDEPS_H
+#define WIN_SYSDEPS_H
 
-#ifndef __STDC__
+#if !defined(__STDC__) && !defined(_MSC_VER)
 #error "Your compiler is not ANSI. Get a real one."
 #endif
 
@@ -32,22 +32,59 @@
 #error "You don't have ANSI C header files."
 #endif
 
+#ifdef _MSC_VER
+#ifdef _M_IX86
+#define __i386__ 1
+#endif
+#ifdef _M_X64
+#define __x86_64__ 1
+#endif
+#endif
+
 #include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifndef _MSC_VER
 #include <stdint.h>
+#endif
+#include <inttypes.h>
 #include <string.h>
 #include <time.h>
 #ifdef __WIN32__
+#define NOMINMAX
+#define WINVER 0x0501
+#define _WIN32_WINNT 0x0501
+#include <winsock2.h>
 #include <windows.h>
 #endif
 #include <sys/types.h>
+#include <sys/timeb.h>
+#include <math.h>
 
+#ifdef _MSC_VER
+#define snprintf _snprintf
+#define O_ACCMODE 0x0003
+typedef size_t ssize_t;
+#include <float.h>
+extern double round(double x);
+extern float roundf(float x);
+extern double trunc(double x);
+extern float truncf(float x);
+#endif
 
+inline double sys_time()
+{
+    struct _timeb tb;
+    _ftime(&tb);
+	return (double)tb.time + ((double)tb.millitm / 1000.0);
+}
+
 // Define for external components
 #define SHEEPSHAVER 1
 #define POWERPC_ROM 1
+#ifndef EMULATED_PPC
 #define EMULATED_PPC 1
+#endif
 #define CONFIG_WIN32 1
 
 // Use Direct Addressing mode
@@ -74,7 +111,7 @@
 #define PPC_PROFILE_COMPILE_TIME 0
 #define PPC_PROFILE_GENERIC_CALLS 0
 #define KPX_MAX_CPUS 1
-#if ENABLE_DYNGEN
+#if defined(ENABLE_DYNGEN) && !defined(_MSC_VER)
 #define PPC_ENABLE_JIT 1
 #endif
 #if defined(__i386__)
@@ -148,6 +185,21 @@
 #endif
 #endif
 
+#if defined(_MSC_VER) && 0
+#define opt_bswap_16 _byteswap_ushort
+#define opt_bswap_32 do_opt_bswap_32
+static inline uint32 do_opt_bswap_32(uint32 x)
+{
+	uint32 v;
+	__asm {
+		mov eax, x;
+		bswap eax;
+		mov v, eax;
+	}
+	return v;
+}
+#endif
+
 #ifdef  opt_bswap_16
 #undef  bswap_16
 #define bswap_16 opt_bswap_16
@@ -178,12 +230,16 @@
 }
 
 #if defined(__i386__)
+#if defined(_MSC_VER) && 0
+#define opt_bswap_64 _byteswap_uint64
+#else
 #define opt_bswap_64 do_opt_bswap_64
 static inline uint64 do_opt_bswap_64(uint64 x)
 {
   return (bswap_32(x >> 32) | (((uint64)bswap_32((uint32)x)) << 32));
 }
 #endif
+#endif
 
 #ifdef  opt_bswap_64
 #undef  bswap_64
@@ -315,7 +371,20 @@
 
 #endif /* __GNUC__ */
 
+#ifdef _MSC_VER
+#define HAVE_TEST_AND_SET 1
+static inline LONG testandset(volatile LONG *p)
+{
+	assert(*p >= 0 && *p <= 1);
+	return InterlockedExchange(p, 1);
+}
+#endif /* _MSC_VER */
+
+#ifdef _MSC_VER
+typedef volatile LONG spinlock_t;
+#else
 typedef volatile int spinlock_t;
+#endif
 
 static const spinlock_t SPIN_LOCK_UNLOCKED = 0;
 
@@ -394,7 +463,9 @@
 // Misc platform specific definitions
 #ifdef __WIN32__
 typedef int64 loff_t;
-#endif
+#define ATTRIBUTE_PACKED
+#else
 #define ATTRIBUTE_PACKED __attribute__((__packed__))
+#endif
 
 #endif
--- macemu/SheepShaver/src/Windows/timer_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/timer_windows.cpp
@@ -20,6 +20,9 @@
 
 #include "sysdeps.h"
 
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
 #include "main.h"
 #include "macos_util.h"
 #include "timer.h"
@@ -166,9 +169,9 @@
 	else {
 		uint64 t = TICKS2USECS(hosttime);
 		if (t > 0x7fffffff)
-			return int32(t / 1000);	// Time in milliseconds
+			return t / 1000;	// Time in milliseconds
 		else
-			return -int32(t);			// Time in negative microseconds
+			return -t;			// Time in negative microseconds
 	}
 }
 
--- macemu/SheepShaver/src/Windows/user_strings_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/user_strings_windows.cpp
@@ -45,6 +45,7 @@
 	{STR_VOSF_INIT_ERR, "Cannot initialize Video on SEGV signals."},
 
 	{STR_OPEN_WINDOW_ERR, "Cannot open Mac window."},
+	{STR_WINDOW_TITLE_GRABBED, "SheepShaver (mouse grabbed, press Ctrl-F5 to release)"},
 	{STR_NO_WIN32_NT_4, "SheepShaver does not run on Windows NT versions less than 4.0"},
 
 	{STR_PREFS_MENU_FILE_GTK, "/_File"},
--- macemu/SheepShaver/src/Windows/user_strings_windows.h
+++ sheepshaver/SheepShaver/src/Windows/user_strings_windows.h
@@ -39,6 +39,7 @@
 	STR_KEYCODE_FILE_WARN,
 	STR_KEYCODE_VENDOR_WARN,
 	STR_OPEN_WINDOW_ERR,
+	STR_WINDOW_TITLE_GRABBED,
 	STR_NO_WIN32_NT_4,
 
 	STR_PREFS_MENU_FILE_GTK,
--- macemu/SheepShaver/src/Windows/util_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/util_windows.cpp
@@ -1,510 +1,378 @@
-/*
- *  util_windows.cpp - Miscellaneous utilities for Win32
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "sysdeps.h"
-#include "util_windows.h"
-#include "main.h"
-#include <io.h>
-#include <fcntl.h>
-
-#include <list>
-using std::list;
-
-#include <string>
-using std::string;
-using std::wstring;
-typedef std::basic_string<TCHAR> tstring;
-
-std::unique_ptr<char[]> str(const wchar_t* s)
-{
-	auto length = WideCharToMultiByte(CP_ACP, 0, s, -1, nullptr, 0, nullptr, nullptr);
-	if (length == -1)
-		return nullptr;
-
-	std::unique_ptr<char[]> p(new char[length]);
-	WideCharToMultiByte(CP_ACP, 0, s, -1, p.get(), length, nullptr, nullptr);
-	return p;
-}
-
-std::unique_ptr<wchar_t[]> wstr(const char* s)
-{
-	auto length = MultiByteToWideChar(CP_ACP, 0, s, -1, nullptr, 0);
-	if (length == -1)
-		return nullptr;
-
-	std::unique_ptr<wchar_t[]> p(new wchar_t[length]);
-	MultiByteToWideChar(CP_ACP, 0, s, -1, p.get(), length);
-	return p;
-}
-
-string to_string(const wchar_t* s)
-{
-	auto wlen = wcslen(s);	// length without null terminator
-	auto len = WideCharToMultiByte(CP_ACP, 0, s, wlen, nullptr, 0, nullptr, nullptr);
-	if (len == -1)
-		return string();
-
-	string str(len, '\0');
-	WideCharToMultiByte(CP_ACP, 0, s, wlen, &str.front(), len, nullptr, nullptr);
-	return str;
-}
-
-wstring to_wstring(const char* s)
-{
-	auto len = strlen(s);	// length without null terminator
-	auto wlen = MultiByteToWideChar(CP_ACP, 0, s, len, nullptr, 0);
-	if (len == -1)
-		return wstring();
-
-	wstring str(wlen, L'\0');
-	MultiByteToWideChar(CP_ACP, 0, s, len, &str.front(), wlen);
-	return str;
-}
-
-size_t strlcpy(char* dst, const char* src, size_t size)
-{
-	size_t length = strlen(src);
-	if (size-- > 0) {
-		if (length < size)
-			size = length;
-		memcpy(dst, src, size);
-		dst[size] = '\0';
-	}
-	return length;
-}
-
-size_t strlcpy(char* dst, const wchar_t* src, size_t size)
-{
-	size_t length = WideCharToMultiByte(CP_ACP, 0, src, -1, dst, size, nullptr, nullptr);
-	if (size > 0) {
-		if (length == 0)
-			return strlcpy(dst, str(src).get(), size);
-		--length;
-	}
-	return length;
-}
-
-size_t strlcat(char* dst, const char* src, size_t size)
-{
-	char* end = static_cast<char*>(memchr(dst, '\0', size));
-	if (end == nullptr)
-		return size;
-	size_t length = end - dst;
-	return length + strlcpy(end, src, size - length);
-}
-
-size_t strlcat(char* dst, const wchar_t* src, size_t size)
-{
-	char* end = static_cast<char*>(memchr(dst, '\0', size));
-	if (end == nullptr)
-		return size;
-	size_t length = end - dst;
-	return length + strlcpy(end, src, size - length);
-}
-
-size_t wcslcpy(wchar_t* dst, const wchar_t* src, size_t size)
-{
-	size_t length = wcslen(src);
-	if (size-- > 0) {
-		if (length < size)
-			size = length;
-		wmemcpy(dst, src, size);
-		dst[size] = '\0';
-	}
-	return length;
-}
-
-size_t wcslcpy(wchar_t* dst, const char* src, size_t size)
-{
-	size_t length = MultiByteToWideChar(CP_ACP, 0, src, -1, dst, size);
-	if (size > 0) {
-		if (length == 0)
-			return wcslcpy(dst, wstr(src).get(), size);
-		--length;
-	}
-	return length;
-}
-
-size_t wcslcat(wchar_t* dst, const wchar_t* src, size_t size)
-{
-	wchar_t* end = wmemchr(dst, L'\0', size);
-	if (end == nullptr)
-		return size;
-	size_t length = end - dst;
-	return length + wcslcpy(end, src, size - length);
-}
-
-size_t wcslcat(wchar_t* dst, const char* src, size_t size)
-{
-	wchar_t* end = wmemchr(dst, L'\0', size);
-	if (end == nullptr)
-		return size;
-	size_t length = end - dst;
-	return length + wcslcpy(end, src, size - length);
-}
-
-BOOL exists( const TCHAR *path )
-{
-	HFILE h;
-	bool ret = false;
-
-	h = _topen( path, _O_RDONLY | _O_BINARY );
-	if(h != -1) {
-		ret = true;
-		_close(h);
-	}
-	return(ret);
-}
-
-BOOL create_file( const TCHAR *path, DWORD size )
-{
-	HANDLE h;
-	bool ok = false;
-
-	h = CreateFile( path,
-		GENERIC_READ | GENERIC_WRITE,
-		0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL
-	);
-	if(h != INVALID_HANDLE_VALUE) {
-		if(size == 0) {
-			ok = true;
-		} else if(SetFilePointer( h, size, NULL, FILE_BEGIN) != 0xFFFFFFFF) {
-			if(SetEndOfFile(h)) {
-				ok = true;
-				if(SetFilePointer( h, 0, NULL, FILE_BEGIN) != 0xFFFFFFFF) {
-					DWORD written;
-					DWORD zeroed_size = size;
-					if (zeroed_size > 1024*1024)
-						zeroed_size = 1024*1024;
-					char *b = (char *)malloc(zeroed_size);
-					if(b) {
-						memset( b, 0, zeroed_size );
-						WriteFile( h, b, zeroed_size, &written, NULL );
-						free(b);
-					}
-				}
-			}
-		}
-		CloseHandle(h);
-	}
-	if(!ok) DeleteFile(path);
-	return(ok);
-}
-
-int32 get_file_size( const TCHAR *path )
-{
-	HANDLE h;
-	DWORD size = 0;
-
-	h = CreateFile( path,
-		GENERIC_READ,
-		0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
-	);
-	if(h != INVALID_HANDLE_VALUE) {
-		size = GetFileSize( h, NULL );
-		CloseHandle(h);
-	}
-	return(size);
-}
-
-
-/*
- *  Thread wrappers
- */
-
-HANDLE create_thread(LPTHREAD_START_ROUTINE start_routine, void *arg)
-{
-	DWORD dwThreadId;
-	return CreateThread(NULL, 0, start_routine, arg, 0, &dwThreadId);
-}
-
-void wait_thread(HANDLE thread)
-{
-	WaitForSingleObject(thread, INFINITE);
-	CloseHandle(thread);
-}
-
-void kill_thread(HANDLE thread)
-{
-	TerminateThread(thread, 0);
-}
-
-
-/*
- *  Check that drivers are installed
- */
-
-bool check_drivers(void)
-{
-	TCHAR path[_MAX_PATH];
-	GetSystemDirectory(path, lengthof(path));
-	_tcscat(path, TEXT("\\drivers\\cdenable.sys"));
-
-	if (exists(path)) {
-		int32 size = get_file_size(path);
-		if (size != 6112) {
-			TCHAR str[256];
-			_sntprintf(str, lengthof(str), TEXT("The CD-ROM driver file \"%s\" is too old or corrupted."), path);
-			ErrorAlert(str);
-			return false;
-		}
-	}
-	else {
-		TCHAR str[256];
-		_sntprintf(str, lengthof(str), TEXT("The CD-ROM driver file \"%s\" is missing."), path);
-		WarningAlert(str);
-	}
-
-	return true;
-}
-
-
-/*
- *  Network control panel helpers
- */
-
-struct panel_reg {
-	tstring name;
-	tstring guid;
-};
-
-static list<panel_reg> network_registry;
-typedef list<panel_reg>::const_iterator network_registry_iterator;
-
-#define NETWORK_CONNECTIONS_KEY \
-		TEXT("SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}")
-
-static void get_network_registry(void)
-{
-	LONG status;
-	HKEY network_connections_key;
-	DWORD len;
-	int i = 0;
-
-	if (network_registry.size() > 0)
-		return;
-
-	status = RegOpenKeyEx(
-		HKEY_LOCAL_MACHINE,
-		NETWORK_CONNECTIONS_KEY,
-		0,
-		KEY_READ,
-		&network_connections_key);
-
-	if (status != ERROR_SUCCESS)
-		return;
-
-	while (true) {
-		TCHAR enum_name[256];
-		TCHAR connection_string[256];
-		HKEY connection_key;
-		TCHAR name_data[256];
-		DWORD name_type;
-		const TCHAR name_string[] = TEXT("Name");
-
-		len = lengthof(enum_name);
-		status = RegEnumKeyEx(
-			network_connections_key,
-			i,
-			enum_name,
-			&len,
-			NULL,
-			NULL,
-			NULL,
-			NULL);
-		if (status != ERROR_SUCCESS)
-			break;
-
-		_sntprintf (connection_string, lengthof(connection_string),
-				  TEXT("%s\\%s\\Connection"),
-				  NETWORK_CONNECTIONS_KEY, enum_name);
-
-		status = RegOpenKeyEx(
-			HKEY_LOCAL_MACHINE,
-			connection_string,
-			0,
-			KEY_READ,
-			&connection_key);
-
-		if (status == ERROR_SUCCESS) {
-			len = lengthof(name_data);
-			status = RegQueryValueEx(
-				connection_key,
-				name_string,
-				NULL,
-				&name_type,
-				(BYTE *)name_data,
-				&len);
-
-			if (status == ERROR_SUCCESS && name_type == REG_SZ) {
-				panel_reg pr;
-				pr.name = name_data;
-				pr.guid = enum_name;
-				network_registry.push_back(pr);
-			}
-			RegCloseKey (connection_key);
-		}
-		++i;
-    }
-
-	RegCloseKey (network_connections_key);
-}
-
-const TCHAR *ether_name_to_guid(const TCHAR *name)
-{
-	get_network_registry();
-
-	for (network_registry_iterator it = network_registry.begin(); it != network_registry.end(); it++) {
-		if (_tcscmp((*it).name.c_str(), name) == 0)
-			return (*it).guid.c_str();
-	}
-
-	return NULL;
-}
-
-const TCHAR *ether_guid_to_name(const TCHAR *guid)
-{
-	get_network_registry();
-
-	for (network_registry_iterator it = network_registry.begin(); it != network_registry.end(); it++) {
-		if (_tcscmp((*it).guid.c_str(), guid) == 0)
-			return (*it).name.c_str();
-	}
-
-	return NULL;
-}
-
-
-/*
- *  Get TAP-Win32 adapters
- */
-
-#define ADAPTER_KEY TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}")
-
-#define TAP_COMPONENT_ID TEXT("tap0801")
-
-const TCHAR *ether_tap_devices(void)
-{
-	HKEY adapter_key;
-	LONG status;
-	DWORD len;
-	int i = 0;
-
-	status = RegOpenKeyEx(
-		HKEY_LOCAL_MACHINE,
-		ADAPTER_KEY,
-		0,
-		KEY_READ,
-		&adapter_key);
-
-	if (status != ERROR_SUCCESS)
-		return NULL;
-
-	list<tstring> devices;
-
-	while (true) {
-		TCHAR enum_name[256];
-		TCHAR unit_string[256];
-		HKEY unit_key;
-		TCHAR component_id_string[] = TEXT("ComponentId");
-		TCHAR component_id[256];
-		TCHAR net_cfg_instance_id_string[] = TEXT("NetCfgInstanceId");
-		TCHAR net_cfg_instance_id[256];
-		DWORD data_type;
-
-		len = lengthof(enum_name);
-		status = RegEnumKeyEx(
-			adapter_key,
-			i,
-			enum_name,
-			&len,
-			NULL,
-			NULL,
-			NULL,
-			NULL);
-		if (status != ERROR_SUCCESS)
-			break;
-
-		_sntprintf (unit_string, lengthof(unit_string), TEXT("%s\\%s"),
-				  ADAPTER_KEY, enum_name);
-
-		status = RegOpenKeyEx(
-			HKEY_LOCAL_MACHINE,
-			unit_string,
-			0,
-			KEY_READ,
-			&unit_key);
-
-		if (status == ERROR_SUCCESS) {
-			len = lengthof(component_id);
-			status = RegQueryValueEx(
-				unit_key,
-				component_id_string,
-				NULL,
-				&data_type,
-				(BYTE *)component_id,
-				&len);
-
-			if (status == ERROR_SUCCESS && data_type == REG_SZ) {
-				len = lengthof(net_cfg_instance_id);
-				status = RegQueryValueEx(
-					unit_key,
-					net_cfg_instance_id_string,
-					NULL,
-					&data_type,
-					(BYTE *)net_cfg_instance_id,
-					&len);
-
-				if (status == ERROR_SUCCESS && data_type == REG_SZ) {
-					if (!_tcscmp (component_id, TAP_COMPONENT_ID))
-						devices.push_back(net_cfg_instance_id);
-				}
-			}
-			RegCloseKey (unit_key);
-		}
-		++i;
-    }
-
-	RegCloseKey (adapter_key);
-
-	if (devices.empty())
-		return NULL;
-
-	// The result is a '\0' separated list of strings
-	list<tstring>::const_iterator it;
-	len = 0;
-	for (it = devices.begin(); it != devices.end(); it++)
-		len += (*it).length() + 1;
-
-	TCHAR *names = (TCHAR *)malloc(len * sizeof(TCHAR));
-	if (names) {
-		TCHAR *p = names;
-		for (it = devices.begin(); it != devices.end(); it++) {
-			len = (*it).length();
-			_tcscpy(p, (*it).c_str());
-			p[len] = '\0';
-			p += len + 1;
-		}
-	}
-
-	return names;
-}
\ No newline at end of file
+/*
+ *  util_windows.cpp - Miscellaneous utilities for Win32
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sysdeps.h"
+#include "util_windows.h"
+#include "main.h"
+
+#include <list>
+using std::list;
+
+#include <string>
+using std::string;
+
+BOOL exists( const char *path )
+{
+	HFILE h;
+	bool ret = false;
+
+	h = _lopen( path, OF_READ );
+	if(h != HFILE_ERROR) {
+		ret = true;
+		_lclose(h);
+	}
+	return(ret);
+}
+
+BOOL create_file( const char *path, DWORD size )
+{
+	HANDLE h;
+	bool ok = false;
+
+	h = CreateFile( path,
+		GENERIC_READ | GENERIC_WRITE,
+		0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL
+	);
+	if(h != INVALID_HANDLE_VALUE) {
+		if(size == 0) {
+			ok = true;
+		} else if(SetFilePointer( h, size, NULL, FILE_BEGIN) != 0xFFFFFFFF) {
+			if(SetEndOfFile(h)) {
+				ok = true;
+				if(SetFilePointer( h, 0, NULL, FILE_BEGIN) != 0xFFFFFFFF) {
+					DWORD written;
+					DWORD zeroed_size = size;
+					if (zeroed_size > 1024*1024)
+						zeroed_size = 1024*1024;
+					char *b = (char *)malloc(zeroed_size);
+					if(b) {
+						memset( b, 0, zeroed_size );
+						WriteFile( h, b, zeroed_size, &written, NULL );
+						free(b);
+					}
+				}
+			}
+		}
+		CloseHandle(h);
+	}
+	if(!ok) DeleteFile(path);
+	return(ok);
+}
+
+int32 get_file_size( const char *path )
+{
+	HANDLE h;
+	DWORD size = 0;
+
+	h = CreateFile( path,
+		GENERIC_READ,
+		0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
+	);
+	if(h != INVALID_HANDLE_VALUE) {
+		size = GetFileSize( h, NULL );
+		CloseHandle(h);
+	}
+	return(size);
+}
+
+
+/*
+ *  Thread wrappers
+ */
+
+HANDLE create_thread(LPTHREAD_START_ROUTINE start_routine, void *arg)
+{
+	DWORD dwThreadId;
+	return CreateThread(NULL, 0, start_routine, arg, 0, &dwThreadId);
+}
+
+void wait_thread(HANDLE thread)
+{
+	WaitForSingleObject(thread, INFINITE);
+	CloseHandle(thread);
+}
+
+void kill_thread(HANDLE thread)
+{
+	TerminateThread(thread, 0);
+}
+
+
+/*
+ *  Check that drivers are installed
+ */
+
+bool check_drivers(void)
+{
+	char path[_MAX_PATH];
+	GetSystemDirectory(path, sizeof(path));
+	strcat(path, "\\drivers\\cdenable.sys");
+
+	if (exists(path)) {
+		int32 size = get_file_size(path);
+		if (size != 6112) {
+			char str[256];
+			sprintf(str, "The CD-ROM driver file \"%s\" is too old or corrupted.", path);
+			ErrorAlert(str);
+			return false;
+		}
+	}
+	else {
+		char str[256];
+		sprintf(str, "The CD-ROM driver file \"%s\" is missing.", path);
+		WarningAlert(str);
+	}
+
+	return true;
+}
+
+
+/*
+ *  Network control panel helpers
+ */
+
+struct panel_reg {
+	string name;
+	string guid;
+};
+
+static list<panel_reg> network_registry;
+typedef list<panel_reg>::const_iterator network_registry_iterator;
+
+#define NETWORK_CONNECTIONS_KEY \
+		"SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}"
+
+static void get_network_registry(void)
+{
+	LONG status;
+	HKEY network_connections_key;
+	DWORD len;
+	int i = 0;
+
+	if (network_registry.size() > 0)
+		return;
+
+	status = RegOpenKeyEx(
+		HKEY_LOCAL_MACHINE,
+		NETWORK_CONNECTIONS_KEY,
+		0,
+		KEY_READ,
+		&network_connections_key);
+
+	if (status != ERROR_SUCCESS)
+		return;
+
+	while (true) {
+		char enum_name[256];
+		char connection_string[256];
+		HKEY connection_key;
+		char name_data[256];
+		DWORD name_type;
+		const char name_string[] = "Name";
+
+		len = sizeof (enum_name);
+		status = RegEnumKeyEx(
+			network_connections_key,
+			i,
+			enum_name,
+			&len,
+			NULL,
+			NULL,
+			NULL,
+			NULL);
+		if (status != ERROR_SUCCESS)
+			break;
+
+		snprintf (connection_string, sizeof(connection_string),
+				  "%s\\%s\\Connection",
+				  NETWORK_CONNECTIONS_KEY, enum_name);
+
+		status = RegOpenKeyEx(
+			HKEY_LOCAL_MACHINE,
+			connection_string,
+			0,
+			KEY_READ,
+			&connection_key);
+
+		if (status == ERROR_SUCCESS) {
+			len = sizeof (name_data);
+			status = RegQueryValueEx(
+				connection_key,
+				name_string,
+				NULL,
+				&name_type,
+				(BYTE *)name_data,
+				&len);
+
+			if (status == ERROR_SUCCESS && name_type == REG_SZ) {
+				panel_reg pr;
+				pr.name = name_data;
+				pr.guid = enum_name;
+				network_registry.push_back(pr);
+			}
+			RegCloseKey (connection_key);
+		}
+		++i;
+    }
+
+	RegCloseKey (network_connections_key);
+}
+
+const char *ether_name_to_guid(const char *name)
+{
+	get_network_registry();
+
+	for (network_registry_iterator it = network_registry.begin(); it != network_registry.end(); it++) {
+		if (strcmp((*it).name.c_str(), name) == 0)
+			return (*it).guid.c_str();
+	}
+
+	return NULL;
+}
+
+const char *ether_guid_to_name(const char *guid)
+{
+	get_network_registry();
+
+	for (network_registry_iterator it = network_registry.begin(); it != network_registry.end(); it++) {
+		if (strcmp((*it).guid.c_str(), guid) == 0)
+			return (*it).name.c_str();
+	}
+
+	return NULL;
+}
+
+
+/*
+ *  Get TAP-Win32 adapters
+ */
+
+#define ADAPTER_KEY "SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}"
+
+#define TAP_COMPONENT_ID "tap0801"
+
+const char *ether_tap_devices(void)
+{
+	HKEY adapter_key;
+	LONG status;
+	DWORD len;
+	int i = 0;
+
+	status = RegOpenKeyEx(
+		HKEY_LOCAL_MACHINE,
+		ADAPTER_KEY,
+		0,
+		KEY_READ,
+		&adapter_key);
+
+	if (status != ERROR_SUCCESS)
+		return NULL;
+
+	list<string> devices;
+
+	while (true) {
+		char enum_name[256];
+		char unit_string[256];
+		HKEY unit_key;
+		char component_id_string[] = "ComponentId";
+		char component_id[256];
+		char net_cfg_instance_id_string[] = "NetCfgInstanceId";
+		char net_cfg_instance_id[256];
+		DWORD data_type;
+
+		len = sizeof (enum_name);
+		status = RegEnumKeyEx(
+			adapter_key,
+			i,
+			enum_name,
+			&len,
+			NULL,
+			NULL,
+			NULL,
+			NULL);
+		if (status != ERROR_SUCCESS)
+			break;
+
+		snprintf (unit_string, sizeof(unit_string), "%s\\%s",
+				  ADAPTER_KEY, enum_name);
+
+		status = RegOpenKeyEx(
+			HKEY_LOCAL_MACHINE,
+			unit_string,
+			0,
+			KEY_READ,
+			&unit_key);
+
+		if (status == ERROR_SUCCESS) {
+			len = sizeof (component_id);
+			status = RegQueryValueEx(
+				unit_key,
+				component_id_string,
+				NULL,
+				&data_type,
+				(BYTE *)component_id,
+				&len);
+
+			if (status == ERROR_SUCCESS && data_type == REG_SZ) {
+				len = sizeof (net_cfg_instance_id);
+				status = RegQueryValueEx(
+					unit_key,
+					net_cfg_instance_id_string,
+					NULL,
+					&data_type,
+					(BYTE *)net_cfg_instance_id,
+					&len);
+
+				if (status == ERROR_SUCCESS && data_type == REG_SZ) {
+					if (!strcmp (component_id, TAP_COMPONENT_ID))
+						devices.push_back(net_cfg_instance_id);
+				}
+			}
+			RegCloseKey (unit_key);
+		}
+		++i;
+    }
+
+	RegCloseKey (adapter_key);
+
+	if (devices.empty())
+		return NULL;
+
+	// The result is a '\0' separated list of strings
+	list<string>::const_iterator it;
+	len = 0;
+	for (it = devices.begin(); it != devices.end(); it++)
+		len += (*it).length() + 1;
+
+	char *names = (char *)malloc(len);
+	if (names) {
+		char *p = names;
+		for (it = devices.begin(); it != devices.end(); it++) {
+			len = (*it).length();
+			strcpy(p, (*it).c_str());
+			p[len] = '\0';
+			p += len + 1;
+		}
+	}
+
+	return names;
+}
--- macemu/SheepShaver/src/Windows/util_windows.h
+++ sheepshaver/SheepShaver/src/Windows/util_windows.h
@@ -1,125 +1,53 @@
-/*
- *  util_windows.h - Miscellaneous utilities for Win32
- *
- *  Basilisk II (C) 1997-2008 Christian Bauer
- *
- *  Windows platform specific code copyright (C) Lauri Pesonen
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _UTIL_WINDOWS_H
-#define _UTIL_WINDOWS_H
-
-#include <memory>
-#include <string>
-
-BOOL exists( const TCHAR *path );
-int32 get_file_size( const TCHAR *path );
-BOOL create_file( const TCHAR *path, DWORD size );
-bool check_drivers(void);
-
-// Thread wrappers
-extern HANDLE create_thread(LPTHREAD_START_ROUTINE start_routine, void *arg = NULL);
-extern void wait_thread(HANDLE thread);
-extern void kill_thread(HANDLE thread);
-
-// Mutex wrappers
-class mutex_t {
-    CRITICAL_SECTION cs;
- public:
-    mutex_t()		{ InitializeCriticalSection(&cs); }
-    ~mutex_t()		{ DeleteCriticalSection(&cs); }
-    void lock()		{ EnterCriticalSection(&cs); }
-    void unlock()	{ LeaveCriticalSection(&cs); }
-};
-
-// Network control panel helpers
-extern const TCHAR *ether_name_to_guid(const TCHAR *name);
-extern const TCHAR *ether_guid_to_name(const TCHAR *guid);
-
-// Get TAP-Win32 devices (caller free()s returned buffer)
-extern const TCHAR *ether_tap_devices(void);
-
-// Wide string versions of commonly used functions
-extern void ErrorAlert(const wchar_t *text);
-extern void WarningAlert(const wchar_t *text);
-
-// ----------------- String conversion functions -----------------
-
-// Null deleter -- does nothing.  Allows returning a non-owning
-// unique_ptr.  This should go away if observer_ptr makes it into
-// the standard.
-template <class T> struct null_delete {
-    constexpr null_delete() noexcept = default;
-    template <class U> null_delete(const null_delete<U>&) noexcept { }
-    void operator ()(T*) const noexcept { }
-};
-template <class T> struct null_delete<T[]> {
-    constexpr null_delete() noexcept = default;
-    void operator ()(T*) const noexcept { }
-    template <class U> void operator ()(U*) const = delete;
-};
-
-// Functions returning null-terminated C strings
-std::unique_ptr<char[]>		str(const wchar_t* s);
-std::unique_ptr<wchar_t[]>  wstr(const char* s);
-
-inline std::unique_ptr<const char[], null_delete<const char[]>> str(const char* s)
-{
-    return std::unique_ptr<const char[], null_delete<const char[]>>(s);
-}
-inline std::unique_ptr<const wchar_t[], null_delete<const wchar_t[]>> wstr(const wchar_t* s)
-{
-    return std::unique_ptr<const wchar_t[], null_delete<const wchar_t[]>>(s);
-}
-
-#ifdef _UNICODE
-#define tstr wstr
-#else
-#define tstr str
-#endif
-
-// Functions returning std::strings
-std::string to_string(const wchar_t* s);
-std::wstring to_wstring(const char* s);
-inline std::string to_string(const char* s) { return std::string(s); }
-inline std::wstring to_wstring(const wchar_t* s) { return std::wstring(s); }
-
-#ifdef _UNICODE
-#define to_tstring to_wstring
-#else
-#define to_tstring to_string
-#endif
-
-// BSD strlcpy/strlcat with overloads for converting between wide and narrow strings
-size_t strlcpy(char* dst, const char* src, size_t size);
-size_t strlcpy(char* dst, const wchar_t* src, size_t size);
-size_t strlcat(char* dst, const char* src, size_t size);
-size_t strlcat(char* dst, const wchar_t* src, size_t size);
-size_t wcslcpy(wchar_t* dst, const wchar_t* src, size_t size);
-size_t wcslcpy(wchar_t* dst, const char* src, size_t size);
-size_t wcslcat(wchar_t* dst, const wchar_t* src, size_t size);
-size_t wcslcat(wchar_t* dst, const char* src, size_t size);
-
-#ifdef _UNICODE
-#define tcslcpy wcslcpy
-#define tcslcat wcslcat
-#else
-#define tcslcpy strlcpy
-#define tcslcat strlcat
-#endif
-
-#endif // _UTIL_WINDOWS_H
+/*
+ *  util_windows.h - Miscellaneous utilities for Win32
+ *
+ *  Basilisk II (C) 1997-2008 Christian Bauer
+ *
+ *  Windows platform specific code copyright (C) Lauri Pesonen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _UTIL_WINDOWS_H
+#define _UTIL_WINDOWS_H
+
+BOOL exists( const char *path );
+int32 get_file_size( const char *path );
+BOOL create_file( const char *path, DWORD size );
+bool check_drivers(void);
+
+// Thread wrappers
+extern HANDLE create_thread(LPTHREAD_START_ROUTINE start_routine, void *arg = NULL);
+extern void wait_thread(HANDLE thread);
+extern void kill_thread(HANDLE thread);
+
+// Mutex wrappers
+class mutex_t {
+    CRITICAL_SECTION cs;
+ public:
+    mutex_t()		{ InitializeCriticalSection(&cs); }
+    ~mutex_t()		{ DeleteCriticalSection(&cs); }
+    void lock()		{ EnterCriticalSection(&cs); }
+    void unlock()	{ LeaveCriticalSection(&cs); }
+};
+
+// Network control panel helpers
+extern const char *ether_name_to_guid(const char *name);
+extern const char *ether_guid_to_name(const char *guid);
+
+// Get TAP-Win32 devices (caller free()s returned buffer)
+extern const char *ether_tap_devices(void);
+
+#endif // _UTIL_WINDOWS_H
--- macemu/SheepShaver/src/Windows/xpram_windows.cpp
+++ sheepshaver/SheepShaver/src/Windows/xpram_windows.cpp
@@ -20,19 +20,22 @@
 
 #include "sysdeps.h"
 
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
 #include <string>
-typedef std::basic_string<TCHAR> tstring;
+using std::string;
 
 #include "xpram.h"
 
 
 // XPRAM file name and path
 #if POWERPC_ROM
-const TCHAR XPRAM_FILE_NAME[] = TEXT("SheepShaver_nvram.dat");
+const char XPRAM_FILE_NAME[] = "SheepShaver_nvram.dat";
 #else
-const TCHAR XPRAM_FILE_NAME[] = TEXT("BasiliskII_xpram.dat");
+const char XPRAM_FILE_NAME[] = "BasiliskII_xpram.dat";
 #endif
-static tstring xpram_path;
+static string xpram_path;
 
 
 /*
@@ -43,9 +46,9 @@
 {
 	xpram_path.clear();
 	int pwd_len = GetCurrentDirectory(0, NULL);
-	TCHAR *pwd = new TCHAR[pwd_len];
+	char *pwd = new char[pwd_len];
 	if (GetCurrentDirectory(pwd_len, pwd) == pwd_len - 1)
-		xpram_path = tstring(pwd) + TEXT('\\');
+		xpram_path = string(pwd) + '\\';
 	delete[] pwd;
 	xpram_path += XPRAM_FILE_NAME;
 }
--- macemu/SheepShaver/src/adb.cpp
+++ sheepshaver/SheepShaver/src/adb.cpp
@@ -152,7 +152,7 @@
 					break;
 				case 3:		// Address/HandlerID
 					data[0] = 2;
-					data[1] = (mouse_reg_3[0] & 0xf0) | (rand() & 0x0f);
+					data[1] = mouse_reg_3[0] & 0xf0 | (rand() & 0x0f);
 					data[2] = mouse_reg_3[1];
 					break;
 				default:
@@ -211,7 +211,7 @@
 				}
 				case 3:		// Address/HandlerID
 					data[0] = 2;
-					data[1] = (key_reg_3[0] & 0xf0) | (rand() & 0x0f);
+					data[1] = key_reg_3[0] & 0xf0 | (rand() & 0x0f);
 					data[2] = key_reg_3[1];
 					break;
 				default:
@@ -340,7 +340,7 @@
 	int my = mouse_y;
 	if (relative_mouse)
 		mouse_x = mouse_y = 0;
-	bool mb[3] = {mouse_button[0], mouse_button[1], mouse_button[2]};
+	int mb[3] = {mouse_button[0], mouse_button[1], mouse_button[2]};
 	B2_unlock_mutex(mouse_lock);
 
 	uint32 key_base = adb_base + 4;
--- macemu/SheepShaver/src/audio.cpp
+++ sheepshaver/SheepShaver/src/audio.cpp
@@ -24,7 +24,7 @@
  *    Inside Macintosh: Sound, chapter 5 "Sound Components"
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "cpu_emulation.h"
 #include "macos_util.h"
 #include "emul_op.h"
@@ -39,7 +39,7 @@
 // Supported sample rates, sizes and channels
 vector<uint32> audio_sample_rates;
 vector<uint16> audio_sample_sizes;
-vector<uint8> audio_channel_counts;
+vector<uint16> audio_channel_counts;
 
 // Global variables
 struct audio_status AudioStatus;	// Current audio status (sample rate etc.)
@@ -233,7 +233,7 @@
 			return badChannel;
 
 		case siSpeakerMute:
-			audio_set_speaker_mute(uint16(infoPtr) != 0);
+			audio_set_speaker_mute((uint16)infoPtr);
 			break;
 
 		case siSpeakerVolume:
@@ -242,7 +242,7 @@
 			break;
 
 		case siHardwareMute:
-			audio_set_main_mute(uint16(infoPtr) != 0);
+			audio_set_main_mute((uint16)infoPtr);
 			break;
 
 		case siHardwareVolume:
--- macemu/SheepShaver/src/cdrom.cpp
+++ sheepshaver/SheepShaver/src/cdrom.cpp
@@ -28,7 +28,7 @@
  *    Technote FL 36: "Apple Extensions to ISO 9660"
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <string.h>
 #include <vector>
@@ -466,13 +466,11 @@
 				// Yes, fake (otherwise audio CDs won't get mounted)
 				memset(buffer, 0, 0x200);
 				actual = 0x200;
-			} else {
+			} else
 				return readErr;
-			}
 		}
-	} else {
+	} else
 		return wPrErr;
-	}
 
 	// Update ParamBlock and DCE
 	WriteMacInt32(pb + ioActCount, actual);
@@ -502,7 +500,7 @@
 			return noErr;
 		}
 
-		case 81:	// Set poll freq
+		case 81:		// Set poll freq
 			WriteMacInt16(dce + dCtlDelay, ReadMacInt16(pb + csParam));
 			return noErr;
 	}
@@ -510,11 +508,10 @@
 	// Drive valid?
 	drive_vec::iterator info = get_drive_info(ReadMacInt16(pb + ioVRefNum));
 	if (info == drives.end()) {
-		if (drives.empty()) {
+		if (drives.empty())
 			return nsDrvErr;
-		} else {
+		else
 			info = drives.begin();	// This is needed for Apple's Audio CD program
-		}
 	}
 
 	// Drive-specific codes
@@ -542,30 +539,30 @@
 			WriteMacInt32(pb + csParam, CDROMIconAddr);
 			return noErr;
 
-		case 23:		// GetDriveInfo
+		case 23:		// drive_info
 			WriteMacInt32(pb + csParam, 0x00000b01);	// Unspecified external removable SCSI disk
 			return noErr;
 
 		case 70: {		// SetPowerMode
 			uint8 mode = ReadMacInt8(pb + csParam);
-			if (mode > 3) {
+			if (mode > 3)
 				return paramErr;
-			} else {
+			else {
 				info->power_mode = mode;
 				return noErr;
 			}
 		}
 
 		case 76:		// ModifyPostEvent
-			info->mount_non_hfs = ReadMacInt16(pb + csParam) != 0;
+			info->mount_non_hfs = ReadMacInt16(pb + csParam);
 			return noErr;
 
 		case 79: {		// Change block size
 			uint16 size = ReadMacInt16(pb + csParam);
 			D(bug(" change block size to %d bytes\n", size));
-			if (size != 512 && size != 2048) {
+			if (size != 512 && size != 2048)
 				return paramErr;
-			} else {
+			else {
 				info->block_size = size;
 				return noErr;
 			}
@@ -578,9 +575,8 @@
 				else
 					SysPreventRemoval(info->fh);
 				return noErr;
-			} else {
+			} else
 				return offLinErr;
-			}
 
 		case 100: {		// ReadTOC
 			if (ReadMacInt8(info->status + dsDiskInPlace) == 0)
@@ -615,7 +611,7 @@
 					}
 
 					// Fill buffer
-					if (i != 804) {
+					if (i != 804)
 						while (buf_size > 0) {
 							WriteMacInt8(buf, info->toc[i+1] & 0x0f); buf++;	// Control
 							WriteMacInt8(buf, bin2bcd[info->toc[i+5]]); buf++;	// M
@@ -629,7 +625,6 @@
 							buf_size -= 4;
 							i += 8;
 						}
-					}
 					break;
 				}
 
@@ -670,9 +665,8 @@
 				WriteMacInt8(p, bin2bcd[pos[11]]); p++;	// F (abs)
 				WriteMacInt8(p, 0);
 				return noErr;
-			} else {
+			} else
 				return ioErr;
-			}
 		}
 
 		case 102:		// ReadHeader
@@ -792,11 +786,10 @@
 			if (!position2msf(*info, ReadMacInt16(pb + csParam), ReadMacInt32(pb + csParam + 2), false, start_m, start_s, start_f))
 				return paramErr;
 
-			if (!SysCDScan(info->fh, start_m, start_s, start_f, ReadMacInt16(pb + csParam + 6) != 0)) {
+			if (!SysCDScan(info->fh, start_m, start_s, start_f, ReadMacInt16(pb + csParam + 6)))
 				return paramErr;
-			} else {
+			else
 				return noErr;
-			}
 		}
 
 		case 109:		// AudioControl
@@ -812,7 +805,7 @@
 			return controlErr;
 
 		case 112: {		// ReadAudioVolume
-			uint8 left = 0, right = 0;
+			uint8 left, right;
 			SysCDGetVolume(info->fh, left, right);
 			WriteMacInt8(pb + csParam, left);
 			WriteMacInt8(pb + csParam + 1, right);
@@ -944,12 +937,11 @@
 			if (ReadMacInt16(pb + csParam) > 0) {
 				uint32 adr = ReadMacInt32(pb + csParam + 2);
 				WriteMacInt16(pb + csParam, 1);						// 1 format
-				WriteMacInt32(adr, uint32(SysGetFileSize(info->fh) / 512));	// Number of blocks
+				WriteMacInt32(adr, SysGetFileSize(info->fh) / 512);	// Number of blocks
 				WriteMacInt32(adr + 4, 0);							// heads/track/sectors
 				return noErr;
-			} else {
+			} else
 				return paramErr;
-			}
 
 		case 8:			// DriveStatus
 			Mac2Mac_memcpy(pb + csParam, info->status, 22);
@@ -963,9 +955,8 @@
 			if (info->twok_offset > 0) {
 				WriteMacInt16(pb + csParam, info->twok_offset);
 				return noErr;
-			} else {
+			} else
 				return statusErr;
-			}
 
 		case 96:		// Get drive type
 			WriteMacInt16(pb + csParam, 3);			// Apple CD 300 or newer
--- macemu/SheepShaver/src/disk.cpp
+++ sheepshaver/SheepShaver/src/disk.cpp
@@ -26,7 +26,7 @@
  *    Technote FL 24: "Don't Look at ioPosOffset for Devices"
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <string.h>
 #include <vector>
@@ -200,7 +200,7 @@
 			WriteMacInt8(info->status + dsWriteProt, info->read_only ? 0xff : 0);
 			find_hfs_partition(*info);
 			if (info->start_byte == 0)
-				info->num_blocks = uint32(SysGetFileSize(info->fh) / 512);
+				info->num_blocks = SysGetFileSize(info->fh) / 512;
 			WriteMacInt16(info->status + dsDriveSize, info->num_blocks & 0xffff);
 			WriteMacInt16(info->status + dsDriveS1, info->num_blocks >> 16);
 			info->to_be_mounted = true;
@@ -288,7 +288,7 @@
 				WriteMacInt8(info->status + dsWriteProt, info->read_only ? 0x80 : 0);
 				find_hfs_partition(*info);
 				if (info->start_byte == 0)
-					info->num_blocks = uint32(SysGetFileSize(info->fh) / 512);
+					info->num_blocks = SysGetFileSize(info->fh) / 512;
 				info->to_be_mounted = true;
 			}
 			D(bug(" %d blocks\n", info->num_blocks));
--- macemu/SheepShaver/src/dummy/clip_dummy.cpp
+++ sheepshaver/SheepShaver/src/dummy/clip_dummy.cpp
@@ -54,14 +54,6 @@
 	D(bug("GetScrap handle %p, type %08x, offset %d\n", handle, type, offset));
 }
 
-/*
- * ZeroScrap() is called before a Mac application writes to the clipboard; clears out the previous contents
- */
-
-void ZeroScrap()
-{
-	D(bug("ZeroScrap\n"));
-}
 
 /*
  *  Mac application wrote to clipboard
--- macemu/SheepShaver/src/dummy/scsi_dummy.cpp
+++ sheepshaver/SheepShaver/src/dummy/scsi_dummy.cpp
@@ -18,8 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "../CrossPlatform/sysdeps.h"
-#include "main.h"
+#include "sysdeps.h"
 #include "scsi.h"
 
 #define DEBUG 0
--- macemu/SheepShaver/src/dummy/serial_dummy.cpp
+++ sheepshaver/SheepShaver/src/dummy/serial_dummy.cpp
@@ -110,7 +110,7 @@
 /*
  *	Control calls
  */
-
+ 
 int16 DSERDPort::control(uint32 pb, uint32 dce, uint16 code)
 {
 	return controlErr;
--- macemu/SheepShaver/src/emul_op.cpp
+++ sheepshaver/SheepShaver/src/emul_op.cpp
@@ -20,7 +20,7 @@
 
 #include <stdio.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "main.h"
 #include "version.h"
 #include "prefs.h"
@@ -227,10 +227,6 @@
 			Microseconds(r->a[0], r->d[0]);
 			break;
 
-		case OP_ZERO_SCRAP:			// ZeroScrap() patch
-			ZeroScrap();
-			break;
-
 		case OP_PUT_SCRAP:			// PutScrap() patch
 			PutScrap(ReadMacInt32(r->a[7] + 8), Mac2HostAddr(ReadMacInt32(r->a[7] + 4)), ReadMacInt32(r->a[7] + 12));
 			break;
@@ -259,13 +255,13 @@
 			MakeExecutableTvec = FindLibSymbol("\023PrivateInterfaceLib", "\016MakeExecutable");
 			D(bug("MakeExecutable TVECT at %08x\n", MakeExecutableTvec));
 			WriteMacInt32(MakeExecutableTvec, NativeFunction(NATIVE_MAKE_EXECUTABLE));
-#if !EMULATED_PPC
+#if !defined(EMULATED_PPC)
 			WriteMacInt32(MakeExecutableTvec + 4, (uint32)TOC);
 #endif
 
 			// Patch DebugStr()
 			static const uint8 proc_template[] = {
-				M68K_EMUL_OP_DEBUG_STR >> 8, M68K_EMUL_OP_DEBUG_STR & 0xFF,
+				M68K_EMUL_OP_DEBUG_STR >> 8, M68K_EMUL_OP_DEBUG_STR,
 				0x4e, 0x74,			// rtd	#4
 				0x00, 0x04
 			};
@@ -287,7 +283,7 @@
 			AudioReset();
 
 			// Enable DR emulator (disabled for now)
-			/*if (PrefsFindBool("jit68k") && 0) {
+			if (PrefsFindBool("jit68k") && 0) {
 				D(bug("DR activated\n"));
 				WriteMacInt32(KernelDataAddr + 0x17a0, 3);		// Prepare for DR emulator activation
 				WriteMacInt32(KernelDataAddr + 0x17c0, DR_CACHE_BASE);
@@ -296,7 +292,7 @@
 				WriteMacInt32(KernelDataAddr + 0x1b00, DR_EMULATOR_BASE);
 				memcpy((void *)DR_EMULATOR_BASE, (void *)(ROMBase + 0x370000), DR_EMULATOR_SIZE);
 				MakeExecutable(0, DR_EMULATOR_BASE, DR_EMULATOR_SIZE);
-			}*/
+			}
 			break;
 
 		case OP_IRQ:			// Level 1 interrupt
--- macemu/SheepShaver/src/ether.cpp
+++ sheepshaver/SheepShaver/src/ether.cpp
@@ -26,7 +26,7 @@
 
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "cpu_emulation.h"
 #include "ether.h"
 #include "ether_defs.h"
@@ -50,7 +50,7 @@
  *  Stream private data structure
  */
 
-static const int kGroupSAPMapSize = 128/32;	// Number of 32-bit values we need for 128 bits
+static const int kGroupSAPMapSize = 128/32;	// Number of 32-bit values we need for 128 bits	
 static const int kGSshift = 6;
 static const int kGSmask = 0x1F;
 
@@ -60,7 +60,7 @@
 };
 
 struct DLPIStream {
-	void SetGroupSAP(uint8 sap)
+	void SetGroupSAP(uint8 sap) 
 	{
 		group_sap[sap >> kGSshift] |= (1L << ((sap >> 1) & kGSmask));
 	}
@@ -76,7 +76,7 @@
 			group_sap[i] = 0;
 	}
 
-	bool TestGroupSAP(uint8 sap)
+	bool TestGroupSAP(uint8 sap) 
 	{
 		return group_sap[sap >> kGSshift] & (1L << ((sap >> 1) & kGSmask));
 	}
@@ -126,7 +126,6 @@
 	nw_uint32 flags;						// Flags
 	nw_uint16 dlsap;						// SAP bound to this stream
 	nw_bool framing_8022;					// Using 802.2 framing? This is only used to report the MAC type for DL_INFO_ACK and can be set with an ioctl() call
-	nw_bool raw_mode;					// Using raw mode? Header is treated as data
 	nw_queue_p rdq;							// Read queue for this stream
 	nw_uint32 group_sap[kGroupSAPMapSize];	// Map of bound group SAPs
 	uint8 snap[k8022SNAPLength];			// SNAP bound to this stream
@@ -488,7 +487,6 @@
 	the_stream->flags = 0;
 	the_stream->dlsap = 0;
 	the_stream->framing_8022 = false;
-	the_stream->raw_mode = false;
 	the_stream->multicast_list = NULL;
 	return 0;
 }
@@ -571,35 +569,35 @@
 				case DL_INFO_REQ:
 					DLPI_info(the_stream, q, mp);
 					break;
-
+	
 				case DL_PHYS_ADDR_REQ:
 					DLPI_phys_addr(the_stream, q, mp);
 					break;
-
+	
 				case DL_BIND_REQ:
 					DLPI_bind(the_stream, q, mp);
 					break;
-
+	
 				case DL_UNBIND_REQ:
 					DLPI_unbind(the_stream, q, mp);
 					break;
-
+	
 				case DL_SUBS_BIND_REQ:
 					DLPI_subs_bind(the_stream, q, mp);
 					break;
-
+	
 				case DL_SUBS_UNBIND_REQ:
 					DLPI_subs_unbind(the_stream, q, mp);
 					break;
-
+	
 				case DL_ENABMULTI_REQ:
 					DLPI_enable_multi(the_stream, q, mp);
 					break;
-
+	
 				case DL_DISABMULTI_REQ:
 					DLPI_disable_multi(the_stream, q, mp);
 					break;
-
+	
 				default:
 					D(bug("WARNING: ether_wsrv(): Unknown primitive\n"));
 					DLPI_error_ack(the_stream, q, mp, prim, DL_NOTSUPPORTED, 0);
@@ -690,7 +688,7 @@
 
 			// Construct header (converts DL_UNITDATA_REQ -> M_DATA)
 			mblk_t *header_mp = build_tx_packet_header(the_stream, unitdata_mp, true);
-
+			
 			if (header_mp == NULL) {
 				// Could not allocate a message block large enough
 				ioc->ioc_error = MAC_ENOMEM;
@@ -712,8 +710,8 @@
 			}
 			dlrc = (dl_recv_control_t *)(void *)info_mp->b_rptr;
 			D(bug("  I_OTSetRawMode primitive %d\n", (int)dlrc->dl_primitive));
-			the_stream->raw_mode = true;
-			goto ioctl_ok;
+			ioc->ioc_error = MAC_EINVAL;
+			goto ioctl_error;
 		}
 
 		default:
@@ -764,7 +762,7 @@
 
 static uint16 classify_packet_type(uint16 primarySAP, uint16 secondarySAP)
 {
-	if (primarySAP >= kMinDIXSAP)
+	if (primarySAP >= kMinDIXSAP) 		
 		return kPktDIX;
 
 	if ((primarySAP == kIPXSAP) && (secondarySAP == kIPXSAP))
@@ -813,7 +811,7 @@
 		mp->b_cont = NULL; 	// Detach the M_(PC)PROTO
 		freemsg(mp);		// Free the M_(PC)PROTO
 		mp = nmp;			// Point to the M_DATA blocks
-
+	
 		// Try to get space on the first M_DATA block
 		if (mp && (mp->b_datap->db_ref == 1) && ((mp->b_rptr - mp->b_datap->db_base) >= needed_size))
 			mp->b_rptr -= needed_size;
@@ -826,8 +824,8 @@
 			} else {
 				nmp->b_cont = mp;		// Attach the new message block as the head
 				nmp->b_wptr += needed_size;
-				mp = nmp;
-			}
+				mp = nmp; 				
+			} 
 		}
 	}
 
@@ -858,10 +856,10 @@
 	// Extract DLSAP
 	uint16 dlsap;
 	switch (destAddrLen) {
-		case kEnetPhysicalAddressLength:
+		case kEnetPhysicalAddressLength:	
 			dlsap = the_stream->dlsap;
 			break;
-		case kEnetAndSAPAddressLength:
+		case kEnetAndSAPAddressLength:	
 			dlsap = ntohs(*(uint16 *)(destAddrOrig + kEnetPhysicalAddressLength));
 			break;
 		case kEnetPhysicalAddressLength + k8022DLSAPLength + k8022SNAPLength:	// SNAP SAP
@@ -880,7 +878,7 @@
 	uint16 hdrsize, proto;
 	switch (packetType) {
 		case kPktDIX:
-			hdrsize = kEnetPacketHeaderLength;
+			hdrsize = kEnetPacketHeaderLength; 
 			proto = dlsap;
 			break;
 		case kPkt8022SAP:
@@ -893,7 +891,7 @@
 		case kPkt8022SNAP:
 			hdrsize = kEnetPacketHeaderLength + k8022SNAPHeaderLength;
 			if (fast_path)
-				proto = 0;
+				proto = 0;		
 			else
 				proto = datasize + k8022SNAPHeaderLength;
 			break;
@@ -902,10 +900,10 @@
 			if (fast_path)
 				proto = 0;
 			else
-				proto = datasize;
+				proto = datasize;		
 			break;
 		default:
-			hdrsize = kEnetPacketHeaderLength;
+			hdrsize = kEnetPacketHeaderLength; 
 			proto = dlsap;
 			break;
 	}
@@ -964,7 +962,7 @@
 		enetHeader->fProto = msgdsize(mp) - sizeof(EnetPacketHeader);
 
 	// Fill in ethernet source address
-	OTCopy48BitAddress(hardware_address, enetHeader->fSourceAddr);
+	OTCopy48BitAddress(hardware_address, enetHeader->fSourceAddr); 
 
 	// Tell add-on to transmit packet
 	AO_transmit_packet(Host2MacAddr((uint8 *)mp));
@@ -998,8 +996,7 @@
 
 	// In Fast Path mode, don't send DL_UNITDATA_IND messages for unicast packets
 	if ((the_stream->flags & kFastPathMode) && dest_addr_type == keaStandardAddress) {
-		if (the_stream->raw_mode == false)
-			mp->b_rptr += header_len;
+		mp->b_rptr += header_len;
 		num_rx_fastpath++;
 		putq(the_stream->rdq, mp);
 		return;
@@ -1048,8 +1045,7 @@
 	}
 
 	// "Hide" the ethernet and protocol header(s)
-	if (the_stream->raw_mode == false)
-		mp->b_rptr += header_len;
+	mp->b_rptr += header_len;
 
 	// Pass message up the stream
 	num_unitdata_ind++;
@@ -1105,11 +1101,11 @@
 				if (sum == 0)
 					goto type_found;
 			} else {
-				// No SNAP, found a match since saps match
+				// No SNAP, found a match since saps match 
 				goto type_found;
 			}
 		} else {
-			// Check for an 802.3 Group/Global (odd)
+			// Check for an 802.3 Group/Global (odd) 
 			if (((packetType == kPkt8022SAP) || (packetType == kPkt8022SNAP)) && (destSAP & 1) && the_stream->TestGroupSAP(destSAP))
 				goto type_found;
 		}
@@ -1233,11 +1229,11 @@
 	// Calculate header length
 	if (the_stream->dlpi_state != DL_UNBOUND) {
 		saplen = (the_stream->flags & kSnapStream) ? k8022DLSAPLength+k8022SNAPLength : k8022DLSAPLength;
-		if (the_stream->dlsap == kSNAPSAP)
-			hdrlen = kEnetPacketHeaderLength + k8022SNAPHeaderLength;	// SNAP address
+		if (the_stream->dlsap == kSNAPSAP) 	
+			hdrlen = kEnetPacketHeaderLength + k8022SNAPHeaderLength;	// SNAP address 
 		else if ((the_stream->dlsap <= kMax8022SAP) || (the_stream->dlsap == kIPXSAP))
-			hdrlen = kEnetPacketHeaderLength + k8022BasicHeaderLength;	// SAP or IPX
-		else
+			hdrlen = kEnetPacketHeaderLength + k8022BasicHeaderLength;	// SAP or IPX 
+		else								
 			hdrlen = kEnetPacketHeaderLength;							// Basic Ethernet
 	}
 
@@ -1276,12 +1272,12 @@
 	OTCopy48BitAddress(hardware_address, boundAddr->fHWAddr);
 	if (saplen) {
 		boundAddr->fSAP = the_stream->dlsap;
-		if (the_stream->flags & kSnapStream)
+		if (the_stream->flags & kSnapStream) 
 			OTCopy8022SNAP(the_stream->snap, boundAddr->fSNAP);
 	}
 	ackp->dl_brdcst_addr_length = bcastlen;
 	ackp->dl_brdcst_addr_offset = sizeof(dl_info_ack_t) + addrlen + saplen;
-	OTSet48BitBroadcastAddress(ack_mp->b_rptr + ackp->dl_brdcst_addr_offset);
+	OTSet48BitBroadcastAddress(ack_mp->b_rptr + ackp->dl_brdcst_addr_offset);	
 
 	// Advance write pointer
 	ack_mp->b_wptr += sizeof(dl_info_ack_t) + addrlen + saplen + bcastlen;
@@ -1384,7 +1380,7 @@
 
 	// Fill in other fields
 	ackp->dl_sap = sap;
-	ackp->dl_addr_length = kEnetAndSAPAddressLength;
+	ackp->dl_addr_length = kEnetAndSAPAddressLength;		
 	ackp->dl_addr_offset = sizeof(dl_bind_ack_t);
 	ackp->dl_max_conind = 0;
 	ackp->dl_xidtest_flg = 0;
@@ -1399,7 +1395,7 @@
 	// Set group SAP if necessary
 	the_stream->ClearAllGroupSAPs();
 	if (sap <= kMax8022SAP)
-		the_stream->SetGroupSAP(k8022GlobalSAP);
+		the_stream->SetGroupSAP(k8022GlobalSAP);	
 
 	// The stream is now bound and idle
 	the_stream->dlpi_state = DL_IDLE;
@@ -1431,7 +1427,7 @@
 
 	// Stream is now unbound
 	the_stream->dlpi_state = DL_UNBOUND;
-	the_stream->dlsap = 0;
+	the_stream->dlsap = 0;				
 
 	// Flush all pending outbound messages
 	flushq(q, FLUSHDATA);
@@ -1478,12 +1474,12 @@
 						error = DL_BADADDR;
 			} else
 				error = DL_UNSUPPORTED;
-			break;
+			break;	
 
 		case DL_HIERARCHICAL_BIND:	// Bind an additional SNAP
 			if (the_stream->dlsap == kSNAPSAP) {
-				if (the_stream->flags & kSnapStream)
-					error = DL_TOOMANY;	// only one SNAP binding allowed
+				if (the_stream->flags & kSnapStream) 
+					error = DL_TOOMANY;	// only one SNAP binding allowed 
 				else {
 					OTCopy8022SNAP(sap, the_stream->snap);
 					the_stream->flags |= kSnapStream;
@@ -1561,7 +1557,7 @@
 	} else if (length == k8022SNAPLength) {
 		if (the_stream->dlsap == kSNAPSAP) {
 			if (the_stream->flags & kSnapStream) {
-				if (memcmp(the_stream->snap, sap, length) != 0)
+				if (memcmp(the_stream->snap, sap, length) != 0) 
 					error = DL_BADADDR;
 			} else
 				error = DL_BADADDR;
@@ -1650,11 +1646,11 @@
 
 	// Tell add-on to disable multicast address
 	AO_disable_multicast(Host2MacAddr((uint8 *)reqaddr));
-
+	
 	// No longer check multicast packets if no multicast addresses are registered
 	if (the_stream->multicast_list == NULL)
 		the_stream->flags &= ~kAcceptMulticasts;
-
+			
 	// Send reply
 	DLPI_ok_ack(the_stream, q, mp, DL_DISABMULTI_REQ);
 	return;
--- macemu/SheepShaver/src/extfs.cpp
+++ sheepshaver/SheepShaver/src/extfs.cpp
@@ -33,7 +33,7 @@
  *    (SetForeignPrivs)
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -175,9 +175,9 @@
 
 #if defined __APPLE__ && defined __MACH__
 struct crtimebuf {
-    u_int32_t length;
-    struct timespec crtime;
-} __attribute__((aligned(4), packed));
+	unsigned long length;
+	struct timespec crtime;
+};
 
 static uint32 do_get_creation_time(const char *path)
 {
@@ -334,7 +334,7 @@
 // Convert C string to pascal string
 static void cstr2pstr(char *dst, const char *src)
 {
-	*dst++ = char(strlen(src));
+	*dst++ = strlen(src);
 	char c;
 	while ((c = *src++) != 0) {
 		// Note: we are converting host ':' characters to Mac '/' characters here
@@ -820,9 +820,9 @@
 				break;
 
 			case dtmvWDRefNum:		// Determined by working directory refNum
-				if (dirID) {
+				if (dirID)
 					current_dir = dirID;
-				} else {
+				else {
 					D(bug("  resolving WDCB\n"));
 					r.d[0] = 0;
 					r.d[1] = 0;
@@ -838,9 +838,9 @@
 				break;
 
 			case dtmvDefault:		// Determined by default volume
-				if (dirID) {
+				if (dirID)
 					current_dir = dirID;
-				} else {
+				else {
 					uint32 wdpb = fs_data + fsReturn;
 					WriteMacInt32(wdpb + ioNamePtr, 0);
 					D(bug("  getting default volume\n"));
@@ -1320,9 +1320,8 @@
 	get_finfo(full_path, pb + ioFlFndrInfo, hfs ? pb + ioFlXFndrInfo : 0, false);
 
 	WriteMacInt16(pb + ioFlStBlk, 0);
-	uint32 file_size = (uint32) st.st_size;
-	WriteMacInt32(pb + ioFlLgLen, file_size);
-	WriteMacInt32(pb + ioFlPyLen, (file_size | (AL_BLK_SIZE - 1)) + 1);
+	WriteMacInt32(pb + ioFlLgLen, st.st_size);
+	WriteMacInt32(pb + ioFlPyLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);
 	WriteMacInt16(pb + ioFlRStBlk, 0);
 	uint32 rf_size = get_rfork_size(full_path);
 	WriteMacInt32(pb + ioFlRLgLen, rf_size);
@@ -1477,9 +1476,8 @@
 		WriteMacInt16(pb + ioDrNmFls, count);
 	} else {
 		WriteMacInt16(pb + ioFlStBlk, 0);
-		uint32 file_size = (uint32) st.st_size;
-		WriteMacInt32(pb + ioFlLgLen, file_size);
-		WriteMacInt32(pb + ioFlPyLen, (file_size | (AL_BLK_SIZE - 1)) + 1);
+		WriteMacInt32(pb + ioFlLgLen, st.st_size);
+		WriteMacInt32(pb + ioFlPyLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);
 		WriteMacInt16(pb + ioFlRStBlk, 0);
 		uint32 rf_size = get_rfork_size(full_path);
 		WriteMacInt32(pb + ioFlRLgLen, rf_size);
@@ -1588,9 +1586,8 @@
 	// Initialize FCB, fd is stored in fcbCatPos
 	WriteMacInt32(fcb + fcbFlNm, fs_item->id);
 	WriteMacInt8(fcb + fcbFlags, ((flag == O_WRONLY || flag == O_RDWR) ? fcbWriteMask : 0) | (resource_fork ? fcbResourceMask : 0) | (write_ok ? 0 : fcbFileLockedMask));
-	uint32 file_size = (uint32) st.st_size;
-	WriteMacInt32(fcb + fcbEOF, file_size);
-	WriteMacInt32(fcb + fcbPLen, (file_size | (AL_BLK_SIZE - 1)) + 1);
+	WriteMacInt32(fcb + fcbEOF, st.st_size);
+	WriteMacInt32(fcb + fcbPLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);
 	WriteMacInt32(fcb + fcbCrPs, 0);
 	WriteMacInt32(fcb + fcbVPtr, vcb);
 	WriteMacInt32(fcb + fcbClmpSize, CLUMP_SIZE);
@@ -1696,13 +1693,12 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {	// "pseudo" resource fork
 			WriteMacInt32(pb + ioMisc, 0);
 			return noErr;
 		} else
 			return fnOpnErr;
-	}
 
 	// Get file size
 	struct stat st;
@@ -1710,10 +1706,9 @@
 		return errno2oserr();
 
 	// Adjust FCBs
-	uint32 file_size = (uint32) st.st_size;
-	WriteMacInt32(fcb + fcbEOF, file_size);
-	WriteMacInt32(fcb + fcbPLen, (file_size | (AL_BLK_SIZE - 1)) + 1);
-	WriteMacInt32(pb + ioMisc, file_size);
+	WriteMacInt32(fcb + fcbEOF, st.st_size);
+	WriteMacInt32(fcb + fcbPLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);
+	WriteMacInt32(pb + ioMisc, st.st_size);
 	D(bug("  adjusting FCBs\n"));
 	r.d[0] = ReadMacInt16(pb + ioRefNum);
 	Execute68k(fs_data + fsAdjustEOF, &r);
@@ -1734,12 +1729,11 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask)	// "pseudo" resource fork
 			return noErr;
 		else
 			return fnOpnErr;
-	}
 
 	// Truncate file
 	uint32 size = ReadMacInt32(pb + ioMisc);
@@ -1772,16 +1766,15 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {	// "pseudo" resource fork
 			WriteMacInt32(pb + ioPosOffset, 0);
 			return noErr;
 		} else
 			return fnOpnErr;
-	}
 
 	// Get file position
-	uint32 pos = (uint32) lseek(fd, 0, SEEK_CUR);
+	uint32 pos = lseek(fd, 0, SEEK_CUR);
 	WriteMacInt32(fcb + fcbCrPs, pos);
 	WriteMacInt32(pb + ioPosOffset, pos);
 	return noErr;
@@ -1799,13 +1792,12 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {	// "pseudo" resource fork
 			WriteMacInt32(pb + ioPosOffset, 0);
 			return noErr;
 		} else
 			return fnOpnErr;
-	}
 
 	// Set file position
 	switch (ReadMacInt16(pb + ioPosMode) & 3) {
@@ -1824,7 +1816,7 @@
 		default:
 			break;
 	}
-	uint32 pos = (uint32) lseek(fd, 0, SEEK_CUR);
+	uint32 pos = lseek(fd, 0, SEEK_CUR);
 	WriteMacInt32(fcb + fcbCrPs, pos);
 	WriteMacInt32(pb + ioPosOffset, pos);
 	return noErr;
@@ -1846,13 +1838,12 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {	// "pseudo" resource fork
 			WriteMacInt32(pb + ioActCount, 0);
 			return eofErr;
 		} else
 			return fnOpnErr;
-	}
 
 	// Seek
 	switch (ReadMacInt16(pb + ioPosMode) & 3) {
@@ -1875,7 +1866,7 @@
 	int16 read_err = errno2oserr();
 	D(bug("  actual %d\n", actual));
 	WriteMacInt32(pb + ioActCount, actual >= 0 ? actual : 0);
-	uint32 pos = (uint32) lseek(fd, 0, SEEK_CUR);
+	uint32 pos = lseek(fd, 0, SEEK_CUR);
 	WriteMacInt32(fcb + fcbCrPs, pos);
 	WriteMacInt32(pb + ioPosOffset, pos);
 	if (actual != (ssize_t)ReadMacInt32(pb + ioReqCount))
@@ -1900,13 +1891,12 @@
 	if (ReadMacInt32(fcb + fcbFlNm) == 0)
 		return fnOpnErr;
 	int fd = ReadMacInt32(fcb + fcbCatPos);
-	if (fd < 0) {
+	if (fd < 0)
 		if (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {	// "pseudo" resource fork
 			WriteMacInt32(pb + ioActCount, ReadMacInt32(pb + ioReqCount));
 			return noErr;
 		} else
 			return fnOpnErr;
-	}
 
 	// Seek
 	switch (ReadMacInt16(pb + ioPosMode) & 3) {
@@ -1929,7 +1919,7 @@
 	int16 write_err = errno2oserr();
 	D(bug("  actual %d\n", actual));
 	WriteMacInt32(pb + ioActCount, actual >= 0 ? actual : 0);
-	uint32 pos = (uint32) lseek(fd, 0, SEEK_CUR);
+	uint32 pos = lseek(fd, 0, SEEK_CUR);
 	WriteMacInt32(fcb + fcbCrPs, pos);
 	WriteMacInt32(pb + ioPosOffset, pos);
 	if (actual != (ssize_t)ReadMacInt32(pb + ioReqCount))
@@ -2162,7 +2152,7 @@
 int16 ExtFSHFS(uint32 vcb, uint16 selectCode, uint32 paramBlock, uint32 globalsPtr, int16 fsid)
 {
 	uint16 trapWord = selectCode & 0xf0ff;
-	bool hfs = (selectCode & kHFSMask) != 0;
+	bool hfs = selectCode & kHFSMask;
 	switch (trapWord) {
 		case kFSMOpen:
 			return fs_open(paramBlock, hfs ? ReadMacInt32(paramBlock + ioDirID) : 0, vcb, false);
--- macemu/SheepShaver/src/gfxaccel.cpp
+++ sheepshaver/SheepShaver/src/gfxaccel.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include "prefs.h"
 #include "video.h"
--- macemu/SheepShaver/src/include/audio.h
+++ sheepshaver/SheepShaver/src/include/audio.h
@@ -76,7 +76,7 @@
 
 extern vector<uint32> audio_sample_rates;	// Vector of supported sample rates (16.16 fixed point)
 extern vector<uint16> audio_sample_sizes;	// Vector of supported sample sizes
-extern vector<uint8> audio_channel_counts;	// Array of supported channels counts
+extern vector<uint16> audio_channel_counts;	// Array of supported channels counts
 
 // Audio component global data and 68k routines
 enum {
--- macemu/SheepShaver/src/include/clip.h
+++ sheepshaver/SheepShaver/src/include/clip.h
@@ -24,7 +24,6 @@
 extern void ClipInit(void);
 extern void ClipExit(void);
 
-extern void ZeroScrap();
 extern void PutScrap(uint32 type, void *scrap, int32 length);
 extern void GetScrap(void **handle, uint32 type, int32 offset);
 
--- macemu/SheepShaver/src/include/cpu_emulation.h
+++ sheepshaver/SheepShaver/src/include/cpu_emulation.h
@@ -58,46 +58,22 @@
 extern uint8 *ROMBaseHost;		// Base address of Mac ROM (host address space)
 
 // Mac memory access functions
-#if EMULATED_PPC
+#ifdef EMULATED_PPC
 #include "cpu/vm.hpp"
-
-#define ReadMacInt8(addr) vm_read_memory_1((vm_addr_t)addr)
-#define WriteMacInt8(addr, v) vm_write_memory_1((vm_addr_t)addr, v)
-#define ReadMacInt16(addr) vm_read_memory_2((vm_addr_t)addr)
-#define WriteMacInt16(addr, v) vm_write_memory_2((vm_addr_t)addr, v)
-#define ReadMacInt32(addr) vm_read_memory_4((vm_addr_t)addr)
-#define WriteMacInt32(addr, v) vm_write_memory_4((vm_addr_t)addr, v)
-#define ReadMacInt64(addr) vm_read_memory_8((vm_addr_t)addr)
-#define WriteMacInt64(addr, v) vm_write_memory_8((vm_addr_t)addr, v)
-#define Host2MacAddr vm_do_get_virtual_address
-#define Mac2HostAddr(addr) vm_do_get_real_address((vm_addr_t)addr)
-#define Mac_memset(addr, c, n) vm_memset((vm_addr_t)addr, c, n)
-#define Mac2Host_memcpy(dest, src, n) vm_memcpy(dest, src, n)
-#define Host2Mac_memcpy Mac2Host_memcpy
-#define Mac2Mac_memcpy Mac2Host_memcpy
-
-#define read_bswap_int_8 ReadMacInt8
-#define write_bswap_int_8 WriteMacInt8
-#define read_bswap_int_16(addr) vm_read_memory_2_reversed((vm_addr_t)addr)
-#define write_bswap_int_16(addr, v) vm_write_memory_2_reversed((vm_addr_t)addr, v)
-#define read_bswap_int_32(addr) vm_read_memory_4_reversed((vm_addr_t)addr)
-#define write_bswap_int_32(addr, v) vm_write_memory_4_reversed((vm_addr_t)addr, v)
-#define read_bswap_int_64(addr) vm_read_memory_8_reversed((vm_addr_t)addr)
-#define write_bswap_int_64(addr, v) vm_write_memory_8_reversed((vm_addr_t)addr, v)
-/*static inline uint32 ReadMacInt8(uint32 addr) {return vm_read_memory_1((vm_addr_t)addr);}
-static inline void WriteMacInt8(uint32 addr, uint32 v) {vm_write_memory_1((vm_addr_t)addr, v);}
-static inline uint32 ReadMacInt16(uint32 addr) {return vm_read_memory_2((vm_addr_t)addr);}
-static inline void WriteMacInt16(uint32 addr, uint32 v) {vm_write_memory_2((vm_addr_t)addr, v);}
-static inline uint32 ReadMacInt32(uint32 addr) {return vm_read_memory_4((vm_addr_t)addr);}
-static inline void WriteMacInt32(uint32 addr, uint32 v) {vm_write_memory_4((vm_addr_t)addr, v);}
-static inline uint64 ReadMacInt64(uint32 addr) {return vm_read_memory_8((vm_addr_t)addr);}
-static inline void WriteMacInt64(uint32 addr, uint64 v) {vm_write_memory_8((vm_addr_t)addr, v);}
+static inline uint32 ReadMacInt8(uint32 addr) {return vm_read_memory_1(addr);}
+static inline void WriteMacInt8(uint32 addr, uint32 v) {vm_write_memory_1(addr, v);}
+static inline uint32 ReadMacInt16(uint32 addr) {return vm_read_memory_2(addr);}
+static inline void WriteMacInt16(uint32 addr, uint32 v) {vm_write_memory_2(addr, v);}
+static inline uint32 ReadMacInt32(uint32 addr) {return vm_read_memory_4(addr);}
+static inline void WriteMacInt32(uint32 addr, uint32 v) {vm_write_memory_4(addr, v);}
+static inline uint64 ReadMacInt64(uint32 addr) {return vm_read_memory_8(addr);}
+static inline void WriteMacInt64(uint32 addr, uint64 v) {vm_write_memory_8(addr, v);}
 static inline uint32 Host2MacAddr(uint8 *addr) {return vm_do_get_virtual_address(addr);}
-static inline uint8 *Mac2HostAddr(uint32 addr) {return vm_do_get_real_address((vm_addr_t)addr);}
-static inline void *Mac_memset(uint32 addr, int c, size_t n) {return vm_memset((vm_addr_t)addr, c, n);}
+static inline uint8 *Mac2HostAddr(uint32 addr) {return vm_do_get_real_address(addr);}
+static inline void *Mac_memset(uint32 addr, int c, size_t n) {return vm_memset(addr, c, n);}
 static inline void *Mac2Host_memcpy(void *dest, uint32 src, size_t n) {return vm_memcpy(dest, src, n);}
 static inline void *Host2Mac_memcpy(uint32 dest, const void *src, size_t n) {return vm_memcpy(dest, src, n);}
-static inline void *Mac2Mac_memcpy(uint32 dest, uint32 src, size_t n) {return vm_memcpy(dest, src, n);}*/
+static inline void *Mac2Mac_memcpy(uint32 dest, uint32 src, size_t n) {return vm_memcpy(dest, src, n);}
 #else
 static inline uint32 ReadMacInt8(uint32 addr) {return *(uint8 *)addr;}
 static inline void WriteMacInt8(uint32 addr, uint32 b) {*(uint8 *)addr = b;}
@@ -124,24 +100,22 @@
 #ifdef WORDS_BIGENDIAN
 #define PW(W) W
 #else
-#define PW(X) bswap_16(X)
-/*#define PW(X) ((((X) >> 8) & 0xff) | (((X) & 0xff) << 8))*/
+#define PW(X) ((((X) >> 8) & 0xff) | (((X) & 0xff) << 8))
 #endif
 
 // PowerPC procedure helper to write a big-endian 32-bit word
 #ifdef WORDS_BIGENDIAN
 #define PL(X) X
 #else
-#define PL(X) bswap_32(X)
-/*#define PL(X)													\
+#define PL(X)													\
      ((((X) & 0xff000000) >> 24) | (((X) & 0x00ff0000) >>  8) |	\
-      (((X) & 0x0000ff00) <<  8) | (((X) & 0x000000ff) << 24))*/
+      (((X) & 0x0000ff00) <<  8) | (((X) & 0x000000ff) << 24))
 #endif
 
 struct M68kRegisters;
 extern void Execute68k(uint32, M68kRegisters *r);			// Execute 68k subroutine from EMUL_OP routine, must be ended with RTS
 extern void Execute68kTrap(uint16 trap, M68kRegisters *r);	// Execute 68k A-Trap from EMUL_OP routine
-#if EMULATED_PPC
+#ifdef EMULATED_PPC
 extern void FlushCodeCache(uintptr start, uintptr end);		// Invalidate emulator caches
 #endif
 extern void ExecuteNative(int selector);					// Execute native code from EMUL_OP routine (real mode switch)
--- macemu/SheepShaver/src/include/debug.h
+++ sheepshaver/SheepShaver/src/include/debug.h
@@ -30,62 +30,24 @@
 #include <sys/types.h>
 #include <sys/timeb.h>
 
-static inline void _cdecl vwinbug(const char *s, va_list vargs)
+static inline void _cdecl winbug( const char *s, ...)
 {
+	va_list vargs;
 	char msg[1024], date[50], hours[50];
 	struct _timeb tstruct;
 
 	_ftime( &tstruct );
 	_strtime( hours );
 	_strdate( date );
-	_snprintf( msg, lengthof(msg), "B2: %s %s:%03u ", date, hours, tstruct.millitm );
+	sprintf( msg, "B2: %s %s:%03u ", date, hours, tstruct.millitm );
+	
+	va_start( vargs, s );
+	vsprintf( &msg[strlen(msg)], s, vargs );
+	va_end( vargs );
 
-	char *rest = &msg[strlen(msg)];
-	_vsnprintf( rest, lengthof(msg) - (rest - msg), s, vargs );
-
-	OutputDebugStringA(msg);
+	printf(msg);
 }
-static inline void _cdecl vwwinbug( const wchar_t *s, va_list vargs)
-{
-	wchar_t msg[1024], date[50], hours[50];
-	struct _timeb tstruct;
-
-	_ftime( &tstruct );
-	_wstrtime( hours );
-	_wstrdate( date );
-	_snwprintf( msg, lengthof(msg), L"B2: %s %s:%03u ", date, hours, tstruct.millitm );
-
-	wchar_t *rest = &msg[wcslen(msg)];
-	_vsnwprintf( rest, lengthof(msg) - (rest - msg), s, vargs );
-
-	OutputDebugStringW(msg);
-}
-static inline void _cdecl winbug( const char *s, ...)
-{
-	va_list vargs;
-	va_start(vargs, s);
-	vwinbug(s, vargs);
-	va_end(vargs);
-}
-static inline void _cdecl wwinbug(const wchar_t *s, ...)
-{
-	va_list vargs;
-	va_start(vargs, s);
-	vwwinbug(s, vargs);
-	va_end(vargs);
-}
-
-#ifdef __cplusplus
-static inline void _cdecl winbug(wchar_t *s, ...)
-{
-	va_list vargs;
-	va_start(vargs, s);
-	vwwinbug(s, vargs);
-	va_end(vargs);
-}
-#endif
 #define bug winbug
-#define wbug wwinbug
 
 #elif defined(AMIGA)
 
--- macemu/SheepShaver/src/include/emul_op.h
+++ sheepshaver/SheepShaver/src/include/emul_op.h
@@ -44,7 +44,7 @@
 	OP_DISK_OPEN, OP_DISK_PRIME, OP_DISK_CONTROL, OP_DISK_STATUS,
 	OP_CDROM_OPEN, OP_CDROM_PRIME, OP_CDROM_CONTROL, OP_CDROM_STATUS,
 	OP_AUDIO_DISPATCH, OP_SOUNDIN_OPEN, OP_SOUNDIN_PRIME, OP_SOUNDIN_CONTROL, OP_SOUNDIN_STATUS, OP_SOUNDIN_CLOSE,
-	OP_ADBOP, OP_INSTIME, OP_RMVTIME, OP_PRIMETIME, OP_MICROSECONDS, OP_ZERO_SCRAP, OP_PUT_SCRAP, OP_GET_SCRAP,
+	OP_ADBOP, OP_INSTIME, OP_RMVTIME, OP_PRIMETIME, OP_MICROSECONDS, OP_PUT_SCRAP, OP_GET_SCRAP,
 	OP_DEBUG_STR, OP_INSTALL_DRIVERS, OP_NAME_REGISTRY, OP_RESET, OP_IRQ,
 	OP_SCSI_DISPATCH, OP_SCSI_ATOMIC,
 	OP_CHECK_SYSV, OP_NTRB_17_PATCH, OP_NTRB_17_PATCH2, OP_NTRB_17_PATCH3, OP_NTRB_17_PATCH4, OP_CHECKLOAD,
@@ -87,7 +87,6 @@
 const uint16 M68K_EMUL_OP_RMVTIME = M68K_EMUL_BREAK + OP_RMVTIME;
 const uint16 M68K_EMUL_OP_PRIMETIME = M68K_EMUL_BREAK + OP_PRIMETIME;
 const uint16 M68K_EMUL_OP_MICROSECONDS = M68K_EMUL_BREAK + OP_MICROSECONDS;
-const uint16 M68K_EMUL_OP_ZERO_SCRAP = M68K_EMUL_BREAK + OP_ZERO_SCRAP;
 const uint16 M68K_EMUL_OP_PUT_SCRAP = M68K_EMUL_BREAK + OP_PUT_SCRAP;
 const uint16 M68K_EMUL_OP_GET_SCRAP = M68K_EMUL_BREAK + OP_GET_SCRAP;
 const uint16 M68K_EMUL_OP_DEBUG_STR = M68K_EMUL_BREAK + OP_DEBUG_STR;
--- macemu/SheepShaver/src/include/ether_defs.h
+++ sheepshaver/SheepShaver/src/include/ether_defs.h
@@ -27,7 +27,7 @@
 #define PACKED__
 #elif defined __GNUC__
 #define PACKED__ __attribute__ ((packed))
-#elif defined __sgi
+#elif defined(__sgi) || defined(_MSC_VER)
 #define PRAGMA_PACK_SUPPORTED 1
 #define PACKED__
 #else
@@ -518,7 +518,7 @@
 #endif
 
 #ifdef PRAGMA_PACK_SUPPORTED
-#pragma pack(1)
+#pragma pack(push,1)
 #endif
 
 // Packet headers
@@ -553,7 +553,7 @@
 } PACKED__;
 
 #ifdef PRAGMA_PACK_SUPPORTED
-#pragma pack(0)
+#pragma pack(pop)
 #endif
 
 #ifdef PRAGMA_ALIGN_SUPPORTED
--- macemu/SheepShaver/src/include/extfs_defs.h
+++ sheepshaver/SheepShaver/src/include/extfs_defs.h
@@ -185,7 +185,7 @@
 	dtmvVRefNum					= 2,
 	dtmvWDRefNum				= 3,
 	dtmvDriveNum				= 4,
-	dtmvDefault					= 5
+	dtmvDefault					= 5	
 };
 
 // Miscellaneous constants used by FSM
--- macemu/SheepShaver/src/include/macos_util.h
+++ sheepshaver/SheepShaver/src/include/macos_util.h
@@ -298,7 +298,7 @@
 };
 
 
-/*
+/* 
  *  Definitions for Mixed Mode Manager
  */
 
@@ -357,7 +357,6 @@
 extern void InitCallUniversalProc(void);				// Init CallUniversalProc()
 extern long CallUniversalProc(void *upp, uint32 info);	// CallUniversalProc()
 extern uint32 TimeToMacTime(time_t t);					// Convert time_t value to MacOS time
-extern time_t MacTimeToTime(uint32 t);				// Convert MacOS time to time_t value
 extern uint32 Mac_sysalloc(uint32 size);				// Allocate block in MacOS system heap zone
 extern void Mac_sysfree(uint32 addr);					// Release block occupied by the nonrelocatable block p
 
Only in macemu/: SheepShaver/src/include/pict.h
--- macemu/SheepShaver/src/include/thunks.h
+++ sheepshaver/SheepShaver/src/include/thunks.h
@@ -22,7 +22,6 @@
 #define THUNKS_H
 
 #include "cpu_emulation.h"
-#include <assert.h>
 
 /*
  *  Native function invocation
@@ -78,7 +77,7 @@
 extern void ThunksExit(void);
 
 // Return the fake PowerPC opcode to handle specified native code
-#if EMULATED_PPC
+#ifdef EMULATED_PPC
 extern uint32 NativeOpcode(int selector);
 #endif
 
@@ -115,7 +114,7 @@
 class SheepMem {
 	static uint32 align(uint32 size);
 protected:
-	/*static uint32  page_size;*/
+	static uint32  page_size;
 	static uintptr zero_page;
 	static uintptr base;
 	static uintptr data;
--- macemu/SheepShaver/src/include/user_strings.h
+++ sheepshaver/SheepShaver/src/include/user_strings.h
@@ -166,7 +166,6 @@
 	// Mac window
 	STR_WINDOW_TITLE = 4000,
 	STR_WINDOW_TITLE_FROZEN,
-	STR_WINDOW_TITLE_GRABBED,
 	STR_WINDOW_MENU = 4050,
 	STR_WINDOW_ITEM_ABOUT,
 	STR_WINDOW_ITEM_REFRESH,
--- macemu/SheepShaver/src/include/version.h
+++ sheepshaver/SheepShaver/src/include/version.h
@@ -22,6 +22,6 @@
 #define VERSION_H
 
 const int VERSION_MAJOR = 2;
-const int VERSION_MINOR = 4;
+const int VERSION_MINOR = 3;
 
 #endif
--- macemu/SheepShaver/src/include/video_defs.h
+++ sheepshaver/SheepShaver/src/include/video_defs.h
@@ -25,10 +25,10 @@
 #include <stddef.h>
 
 
-/*
+/* 
  * Definitions for Display Manager
  */
-
+ 
 /* csMode values describing pixel depth in VDSwitchInfo */
 enum {
 	firstVidMode=128,						// first depth mode, representing lowest supported
@@ -45,7 +45,7 @@
 	kFixedModeCRTConnect,					// very limited displays
 	kMultiModeCRT1Connect,					// 12" optional, 13" default, 16" required
 	kMultiModeCRT2Connect,					// 12" optional, 13" req., 16" def., 19" req.
-	kMultiModeCRT3Connect,					// 12" optional, 13" req., 16" req., 19" req.,21" def.
+	kMultiModeCRT3Connect,					// 12" optional, 13" req., 16" req., 19" req.,21" def. 
 	kMultiModeCRT4Connect,					// expansion to large multimode (not yet implemented)
 	kModelessConnect,						// expansion to modeless model (not yet implemented)
 	kFullPageConnect,						// 640x818 (to get 8bpp in 512K case) and
@@ -60,7 +60,7 @@
 
 /* csConnectFlags values in VDDisplayConnectInfoRec */
 enum {
-	kAllModesValid=0,						// all display modes not deleted by PrimaryInit code
+	kAllModesValid=0,						// all display modes not deleted by PrimaryInit code 
 											// are optional
 	kAllModesSafe,							// all display modes not deleted by PrimaryInit code
 											// are required; is you set this bit, set the
@@ -78,7 +78,7 @@
 #define kDeclROMtables FOURCC('d','e','c','l')	// use information in this record instead of looking
 												// in the decl. ROM for timing info; used for patching
 												// existing card without updating declaration ROM
-
+										
 /* csTimingData values in VDTimingInfoRec */
 enum {
 	timingUnknown = 0,						// unknown timing
@@ -124,8 +124,8 @@
 enum {
 	kModeValid=0,							// this display mode is optional
 	kModeSafe,								// this display mode is required; if you set this
-											// bit, you should also set the kModeValid bit
-	kModeDefault,							// this display mode is the default for the attached
+											// bit, you should also set the kModeValid bit 
+	kModeDefault,							// this display mode is the default for the attached 
 											// display; if you set this bit, you should also set
 											// the kModeSafe and kModeValid bits
 	kShowModeNow,							// show this mode in Monitors control panel; useful
@@ -156,8 +156,8 @@
 	cscSetPowerState,
 	cscPrivateControlCall,				// Takes a VDPrivateSelectorDataRec
 	cscSetMultiConnect,					// From a GDI point of view, this call should be implemented completely in the HAL and not at all in the core.
-	cscSetClutBehavior,					// Takes a VDClutBehavior
-	cscUnusedCall=127					// This call used to expend the scrn resource.  Its imbedded data contains more control info
+	cscSetClutBehavior,					// Takes a VDClutBehavior 
+	cscUnusedCall=127					// This call used to expend the scrn resource.  Its imbedded data contains more control info 
 };
 
 /* Constants for the GetNextResolution call */
@@ -174,9 +174,9 @@
 	cscGetMode=2,
 	cscGetEntries,
 	cscGetPageCnt,
-	cscGetPages=4,					// This is what C&D 2 calls it.
+	cscGetPages=4,					// This is what C&D 2 calls it. 
 	cscGetPageBase,
-	cscGetBaseAddr=5,				// This is what C&D 2 calls it.
+	cscGetBaseAddr=5,				// This is what C&D 2 calls it. 
 	cscGetGray,
 	cscGetInterrupt,
 	cscGetGamma,
@@ -186,8 +186,8 @@
 	cscGetConnection,				// return information about display capabilities of
 									// connected display
 	cscGetModeTiming,				// return scan timings data for a display mode
-	cscGetModeBaseAddress,			// Return base address information about a particular mode
-	cscGetScanProc,					// QuickTime scan chasing routine
+	cscGetModeBaseAddress,			// Return base address information about a particular mode 
+	cscGetScanProc,					// QuickTime scan chasing routine 
 	cscGetPreferredConfiguration,
 	cscGetNextResolution,
 	cscGetVideoParameters,
@@ -198,10 +198,10 @@
 	cscGetConvolution,
 	cscGetPowerState,
 	cscPrivateStatusCall,			// Takes a VDPrivateSelectorDataRec
-	cscGetDDCBlock,					// Takes a VDDDCBlockRec
+	cscGetDDCBlock,					// Takes a VDDDCBlockRec  
 	cscGetMultiConnect,				// From a GDI point of view, this call should be implemented completely in the HAL and not at all in the core.
-	cscGetClutBehavior				// Takes a VDClutBehavior
-};
+	cscGetClutBehavior				// Takes a VDClutBehavior 
+};	
 
 enum {	// VDSwitchInfo struct
 	csMode = 0,
--- macemu/SheepShaver/src/include/xpram.h
+++ sheepshaver/SheepShaver/src/include/xpram.h
@@ -37,10 +37,4 @@
 extern void SaveXPRAM(void);
 extern void ZapPRAM(void);
 
-extern bool getXPRAMat(size_t off, uint8* out);
-extern bool setXPRAMat(size_t off, uint8 byte);
-
-extern size_t XPRAMtoString( const char* symbols );
-extern char* dumpXPRAM();
-
 #endif
Only in macemu/: SheepShaver/src/kpx_cpu/dis-asm.h
--- macemu/SheepShaver/src/kpx_cpu/include/basic-cpu.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/include/basic-cpu.hpp
@@ -35,7 +35,7 @@
 	uint64 j;
 	float  f;
 	double d;
-
+	
 	// Explicit casts may be required to use those constructors
 	any_register(uint32 v = 0)	: i(v) { }
 	any_register(uint64 v)		: j(v) { }
@@ -46,6 +46,8 @@
 /**
  *		Basic CPU model
  **/
+
+struct task_struct;
 
 struct basic_cpu
 	: public task_plugin
--- macemu/SheepShaver/src/kpx_cpu/include/task-plugin.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/include/task-plugin.hpp
@@ -24,9 +24,9 @@
 #include "basic-plugin.hpp"
 
 // Forward declarations
-class task_struct;
+struct task_struct;
 class basic_kernel;
-class basic_cpu;
+struct basic_cpu;
 class program_info;
 
 // Base class for all task components
Only in macemu/: SheepShaver/src/kpx_cpu/ppc-dis.c
--- macemu/SheepShaver/src/kpx_cpu/sheepshaver_glue.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/sheepshaver_glue.cpp
@@ -18,6 +18,10 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "sysdeps.h"
 #include "cpu_emulation.h"
 #include "main.h"
@@ -58,10 +62,6 @@
 #define DEBUG 0
 #include "debug.h"
 
-extern "C" {
-#include "dis-asm.h"
-}
-
 // Emulation time statistics
 #ifndef EMUL_TIME_STATS
 #define EMUL_TIME_STATS 0
@@ -83,7 +83,7 @@
 {
 	// Start up mon in real-mode
 #if ENABLE_MON
-	const char *arg[4] = {"mon", "-m", "-r", NULL};
+	char *arg[4] = {"mon", "-m", "-r", NULL};
 	mon(3, arg);
 #endif
 }
@@ -417,7 +417,7 @@
 		cg_context.done_compile = true;
 		status = COMPILE_EPILOGUE_OK;
 		break;
-#else
+#endif
 		// Invoke NativeOp handler
 		if (!FN_field::test(opcode)) {
 			typedef void (*func_t)(dyngen_cpu_base, uint32);
@@ -429,7 +429,6 @@
 		// Otherwise, let it generate a call to execute_sheep() which
 		// will cause necessary updates to the program counter
 		break;
-#endif
 	}
 
 	default: {	// EMUL_OP
@@ -442,7 +441,7 @@
 		cg_context.done_compile = true;
 		status = COMPILE_EPILOGUE_OK;
 		break;
-#else
+#endif
 		// Invoke EmulOp handler
 		typedef void (*func_t)(dyngen_cpu_base, uint32);
 		func_t func = (func_t)nv_mem_fun(&sheepshaver_cpu::execute_emul_op).ptr();
@@ -450,7 +449,6 @@
 		cg_context.done_compile = false;
 		status = COMPILE_CODE_OK;
 		break;
-#endif
 	}
 	}
 	return status;
@@ -478,10 +476,10 @@
 	SheepVar32 trampoline = POWERPC_EXEC_RETURN;
 
 	// Prepare registers for nanokernel interrupt routine
-	WriteMacInt32(KERNEL_DATA_BASE + 0x004, gpr(1));
-	WriteMacInt32(KERNEL_DATA_BASE + 0x018, gpr(6));
+	kernel_data->v[0x004 >> 2] = htonl(gpr(1));
+	kernel_data->v[0x018 >> 2] = htonl(gpr(6));
 
-	gpr(6) = ReadMacInt32(KERNEL_DATA_BASE + 0x65c);
+	gpr(6) = ntohl(kernel_data->v[0x65c >> 2]);
 	assert(gpr(6) != 0);
 	WriteMacInt32(gpr(6) + 0x13c, gpr(7));
 	WriteMacInt32(gpr(6) + 0x144, gpr(8));
@@ -492,7 +490,7 @@
 	WriteMacInt32(gpr(6) + 0x16c, gpr(13));
 
 	gpr(1)  = KernelDataAddr;
-	gpr(7)  = ReadMacInt32(KERNEL_DATA_BASE + 0x660);
+	gpr(7)  = ntohl(kernel_data->v[0x660 >> 2]);
 	gpr(8)  = 0;
 	gpr(10) = trampoline.addr();
 	gpr(12) = trampoline.addr();
@@ -564,14 +562,14 @@
 	gpr(25) = ReadMacInt32(XLM_68K_R25);		// MSB of SR
 	gpr(26) = 0;
 	gpr(28) = 0;								// VBR
-	gpr(29) = ReadMacInt32(KERNEL_DATA_BASE + 0x1074);		// Pointer to opcode table
-	gpr(30) = ReadMacInt32(KERNEL_DATA_BASE + 0x1078);		// Address of emulator
+	gpr(29) = ntohl(kernel_data->ed.v[0x74 >> 2]);		// Pointer to opcode table
+	gpr(30) = ntohl(kernel_data->ed.v[0x78 >> 2]);		// Address of emulator
 	gpr(31) = KernelDataAddr + 0x1000;
 
 	// Push return address (points to EXEC_RETURN opcode) on stack
 	gpr(1) -= 4;
 	WriteMacInt32(gpr(1), XLM_EXEC_RETURN_OPCODE);
-
+	
 	// Rentering 68k emulator
 	WriteMacInt32(XLM_RUN_MODE, MODE_68K);
 
@@ -580,8 +578,7 @@
 
 	// Execute 68k opcode
 	uint32 opcode = ReadMacInt16(gpr(24));
-	gpr(27) = (int32)(int16)ReadMacInt16(gpr(24) + 2);
-	gpr(24) += 2;
+	gpr(27) = (int32)(int16)ReadMacInt16(gpr(24) += 2);
 	gpr(29) += opcode * 8;
 	execute(gpr(29));
 
@@ -733,28 +730,10 @@
 	ppc_cpu->dump_log();
 }
 
-static int read_mem(bfd_vma memaddr, bfd_byte *myaddr, int length, struct disassemble_info *info)
-{
-	Mac2Host_memcpy(myaddr, memaddr, length);
-	return 0;
-}
+/*
+ *  Initialize CPU emulation
+ */
 
-static void dump_disassembly(const uint32 pc, const int prefix_count, const int suffix_count)
-{
-	struct disassemble_info info;
-	INIT_DISASSEMBLE_INFO(info, stderr, fprintf);
-	info.read_memory_func = read_mem;
-
-	const int count = prefix_count + suffix_count + 1;
-	const uint32 base_addr = pc - prefix_count * 4;
-	for (int i = 0; i < count; i++) {
-		const bfd_vma addr = base_addr + i * 4;
-		fprintf(stderr, "%s0x%8llx:  ", addr == pc ? " >" : "  ", addr);
-		print_insn_ppc(addr, &info);
-		fprintf(stderr, "\n");
-	}
-}
-
 sigsegv_return_t sigsegv_handler(sigsegv_info_t *sip)
 {
 #if ENABLE_VOSF
@@ -773,29 +752,29 @@
 	// Get program counter of target CPU
 	sheepshaver_cpu * const cpu = ppc_cpu;
 	const uint32 pc = cpu->pc();
-
+	
 	// Fault in Mac ROM or RAM?
-	bool mac_fault = (pc >= ROMBase && pc < (ROMBase + ROM_AREA_SIZE)) || (pc >= RAMBase && pc < (RAMBase + RAMSize)) || (pc >= DR_CACHE_BASE && pc < (DR_CACHE_BASE + DR_CACHE_SIZE));
+	bool mac_fault = (pc >= ROMBase) && (pc < (ROMBase + ROM_AREA_SIZE)) || (pc >= RAMBase) && (pc < (RAMBase + RAMSize)) || (pc >= DR_CACHE_BASE && pc < (DR_CACHE_BASE + DR_CACHE_SIZE));
 	if (mac_fault) {
 
 		// "VM settings" during MacOS 8 installation
 		if (pc == ROMBase + 0x488160 && cpu->gpr(20) == 0xf8000000)
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
-
+	
 		// MacOS 8.5 installation
 		else if (pc == ROMBase + 0x488140 && cpu->gpr(16) == 0xf8000000)
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
-
+	
 		// MacOS 8 serial drivers on startup
 		else if (pc == ROMBase + 0x48e080 && (cpu->gpr(8) == 0xf3012002 || cpu->gpr(8) == 0xf3012000))
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
-
+	
 		// MacOS 8.1 serial drivers on startup
 		else if (pc == ROMBase + 0x48c5e0 && (cpu->gpr(20) == 0xf3012002 || cpu->gpr(20) == 0xf3012000))
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
 		else if (pc == ROMBase + 0x4a10a0 && (cpu->gpr(20) == 0xf3012002 || cpu->gpr(20) == 0xf3012000))
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
-
+	
 		// MacOS 8.6 serial drivers on startup (with DR Cache and OldWorld ROM)
 		else if ((pc - DR_CACHE_BASE) < DR_CACHE_SIZE && (cpu->gpr(16) == 0xf3012002 || cpu->gpr(16) == 0xf3012000))
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
@@ -803,8 +782,8 @@
 			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
 
 		// Ignore writes to the zero page
-		/*else if ((uint32)(addr - SheepMem::ZeroPage()) < (uint32)SheepMem::PageSize())
-			return SIGSEGV_RETURN_SKIP_INSTRUCTION;*/
+		else if ((uint32)(addr - SheepMem::ZeroPage()) < (uint32)SheepMem::PageSize())
+			return SIGSEGV_RETURN_SKIP_INSTRUCTION;
 
 		// Ignore all other faults, if requested
 		if (PrefsFindBool("ignoresegv"))
@@ -818,19 +797,13 @@
 	fprintf(stderr, "  pc %p\n", sigsegv_get_fault_instruction_address(sip));
 	fprintf(stderr, "  ea %p\n", sigsegv_get_fault_address(sip));
 	dump_registers();
-	dump_log();
-	dump_disassembly(pc, 8, 8);
-
+	ppc_cpu->dump_log();
 	enter_mon();
 	QuitEmulator();
 
 	return SIGSEGV_RETURN_FAILURE;
 }
 
-/*
- *  Initialize CPU emulation
- */
-
 void init_emul_ppc(void)
 {
 	// Get pointer to KernelData in host address space
@@ -906,7 +879,7 @@
 	// NativeOp
 	native_op_trampoline = dg.gen_start();
 	func = (func_t)nv_mem_fun(&sheepshaver_cpu::execute_native_op).ptr();
-	dg.gen_invoke_CPU_T0(func);
+	dg.gen_invoke_CPU_T0(func);	
 	dg.gen_exec_return();
 	dg.gen_end();
 
@@ -964,21 +937,22 @@
 	switch (ReadMacInt32(XLM_RUN_MODE)) {
 	case MODE_68K:
 		// 68k emulator active, trigger 68k interrupt level 1
-		WriteMacInt16(ReadMacInt32(KERNEL_DATA_BASE + 0x67c), 1);
-		r->cr.set(r->cr.get() | ReadMacInt32(KERNEL_DATA_BASE + 0x674));
+		WriteMacInt16(tswap32(kernel_data->v[0x67c >> 2]), 1);
+		r->cr.set(r->cr.get() | tswap32(kernel_data->v[0x674 >> 2]));
 		break;
-
+    
 #if INTERRUPTS_IN_NATIVE_MODE
 	case MODE_NATIVE:
 		// 68k emulator inactive, in nanokernel?
 		if (r->gpr[1] != KernelDataAddr) {
 
 			// Prepare for 68k interrupt level 1
-			WriteMacInt16(ReadMacInt32(KERNEL_DATA_BASE + 0x67c), 1);
-			WriteMacInt32(ReadMacInt32(KERNEL_DATA_BASE + 0x658) + 0xdc,
-			ReadMacInt32(ReadMacInt32(KERNEL_DATA_BASE + 0x658) + 0xdc)
-						  | ReadMacInt32(KERNEL_DATA_BASE + 0x674));
-      			// Execute nanokernel interrupt routine (this will activate the 68k emulator)
+			WriteMacInt16(tswap32(kernel_data->v[0x67c >> 2]), 1);
+			WriteMacInt32(tswap32(kernel_data->v[0x658 >> 2]) + 0xdc,
+						  ReadMacInt32(tswap32(kernel_data->v[0x658 >> 2]) + 0xdc)
+						  | tswap32(kernel_data->v[0x674 >> 2]));
+      
+			// Execute nanokernel interrupt routine (this will activate the 68k emulator)
 			DisableInterrupt();
 			if (ROMType == ROMTYPE_NEWWORLD)
 				ppc_cpu->interrupt(ROMBase + 0x312b1c);
@@ -987,7 +961,7 @@
 		}
 		break;
 #endif
-
+    
 #if INTERRUPTS_IN_EMUL_OP_MODE
 	case MODE_EMUL_OP:
 		// 68k emulator active, within EMUL_OP routine, execute 68k interrupt routine directly when interrupt level is 0
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/block-cache.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/block-cache.hpp
@@ -23,6 +23,8 @@
 
 #include "block-alloc.hpp"
 
+#define GATHER_BLOCK_CACHE_STATISTICS 0
+
 template< class block_info, template<class T> class block_allocator = slow_allocator >
 class block_cache
 {
@@ -40,7 +42,7 @@
 		entry **				prev_p;
 	};
 
-	block_allocator<entry>		allocator;
+	block_allocator<entry>				allocator;
 	entry *						cache_tags[HASH_SIZE];
 	entry *						active;
 	entry *						dormant;
@@ -49,11 +51,22 @@
 		return (addr >> 2) & HASH_MASK;
 	}
 
+#if GATHER_BLOCK_CACHE_STATISTICS
+	struct {
+		uint32 searches;
+		uint32 hits;
+		uint32 misses;
+		uint32 faults;
+	} stats;
+#endif
+
 public:
 
 	block_cache();
 	~block_cache();
 
+	void print_statistics();
+
 	block_info *new_blockinfo();
 	void delete_blockinfo(block_info *bi);
 
@@ -78,6 +91,9 @@
 block_cache< block_info, block_allocator >::block_cache()
 	: active(NULL), dormant(NULL)
 {
+#if GATHER_BLOCK_CACHE_STATISTICS
+	memset(&stats, 0, sizeof(stats));
+#endif
 	initialize();
 }
 
@@ -183,25 +199,76 @@
 template< class block_info, template<class T> class block_allocator >
 block_info *block_cache< block_info, block_allocator >::find(uintptr pc)
 {
+	const uint32 cl = cacheline(pc);
+
+#if GATHER_BLOCK_CACHE_STATISTICS
+	stats.searches++;
+#endif
+
 	// Hit: return immediately
-	entry * bce = cache_tags[cacheline(pc)];
-	if (bce && bce->pc == pc)
+	entry * bce = cache_tags[cl];
+	if (bce && bce->pc == pc) {
+#if GATHER_BLOCK_CACHE_STATISTICS
+		stats.hits++;
+#endif
 		return bce;
+	}
 
 	// Miss: perform full list search and move block to front if found
 	while (bce) {
 		bce = bce->next_same_cl;
 		if (bce && bce->pc == pc) {
 			raise_in_cl_list(bce);
+#if GATHER_BLOCK_CACHE_STATISTICS
+			stats.misses++;
+#endif
 			return bce;
 		}
 	}
 
 	// Found none, will have to create a new block
+#if GATHER_BLOCK_CACHE_STATISTICS
+	stats.faults++;
+#endif
 	return NULL;
 }
 
 template< class block_info, template<class T> class block_allocator >
+void block_cache< block_info, block_allocator >::print_statistics()
+{
+#if GATHER_BLOCK_CACHE_STATISTICS
+	fprintf(stderr, "[Block Cache] Search Statistics: %9u searches, %9u hits, %9u misses, %9u faults\n",
+		stats.searches, stats.hits, stats.misses, stats.faults);
+	double hit_percent = (double)stats.hits / (double)stats.searches * 100.0,
+		miss_percent = (double)stats.misses / (double)stats.searches * 100.0,
+		fault_percent = (double)stats.faults / (double)stats.searches * 100.0;
+	fprintf(stderr, "[Block Cache] In percentages: %3.2lf%% hits, %3.2lf%% misses, %3.2lf%% faults\n",
+		hit_percent, miss_percent, fault_percent);
+	memset(&stats, 0, sizeof(stats));
+	uint32 c = 0, min = (uint32)-1, max = 0, average = 0;
+	for(uint32 cl = 0; cl < HASH_SIZE; cl++) {
+		if (cache_tags[cl] != NULL) {
+			c++;
+			entry *e = cache_tags[cl];
+			uint32 ct = 0;
+			while (e) {
+				e = e->next_same_cl;
+				ct++;
+			}
+			if (ct > max) max = ct;
+			if (ct < min) min = ct;
+			average += ct;
+		}
+	}
+	average /= c;
+	fprintf(stderr, "[Block Cache] %u of %u cache lines contain data\n",
+		c, HASH_SIZE);
+	fprintf(stderr, "[Block Cache] Line fill min: %u, max: %u, avg: %u\n",
+		min, max, average);
+#endif
+}
+
+template< class block_info, template<class T> class block_allocator >
 void block_cache< block_info, block_allocator >::remove_from_cl_list(block_info *bi)
 {
 	entry * bce = (entry *)bi;
@@ -219,7 +286,7 @@
 	if (cache_tags[cl])
 		cache_tags[cl]->prev_same_cl_p = &bce->next_same_cl;
 	bce->next_same_cl = cache_tags[cl];
-
+	
 	cache_tags[cl] = bce;
 	bce->prev_same_cl_p = &cache_tags[cl];
 }
@@ -245,11 +312,11 @@
 void block_cache< block_info, block_allocator >::add_to_active_list(block_info *bi)
 {
 	entry * bce = (entry *)bi;
-
+	
 	if (active)
 		active->prev_p = &bce->next;
 	bce->next = active;
-
+	
 	active = bce;
 	bce->prev_p = &active;
 }
@@ -258,11 +325,11 @@
 void block_cache< block_info, block_allocator >::add_to_dormant_list(block_info *bi)
 {
 	entry * bce = (entry *)bi;
-
+	
 	if (dormant)
 		dormant->prev_p = &bce->next;
 	bce->next = dormant;
-
+	
 	dormant = bce;
 	bce->prev_p = &dormant;
 }
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/amd64/dyngen-target-exec.h
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/amd64/dyngen-target-exec.h
@@ -34,7 +34,7 @@
 
 #define AREG1 "r12"
   AREG1_ID = 12,
-
+    
 #define AREG2 "r13"
   AREG2_ID = 13,
 
@@ -43,7 +43,7 @@
 
 #define AREG4 "r15"
   AREG4_ID = 15,
-
+    
 #else
 
 #define AREG1 "rbx"
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/basic-dyngen.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/basic-dyngen.cpp
@@ -147,9 +147,9 @@
 		f32_1, f32_2, f32_3, f32_4, f32_5, f32_6, f32_7, f32_8,
 		f32_9, f32_10, f32_11, f32_12, f32_13, f32_14, f32_15
 	};
+	static const uint8 prefixes[4] = { 0x66, 0x66, 0x66, 0x66 };
 
 #if defined(__x86_64__)
-	static const uint8 prefixes[4] = { 0x66, 0x66, 0x66, 0x66 };
 	/* The recommended way to pad 64bit code is to use NOPs preceded by
 	   maximally four 0x66 prefixes.  Balance the size of nops.  */
 	int i;
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/cxxdemangle.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/cxxdemangle.cpp
@@ -500,7 +500,7 @@
 demangle_qualifier PARAMS ((int));
 
 static int
-demangle_expression PARAMS ((work_stuff *, const char **, string *,
+demangle_expression PARAMS ((work_stuff *, const char **, string *, 
 			     type_kind_t));
 
 static int
@@ -1588,7 +1588,7 @@
     {
       if (**mangled == 'Q')
 	success = demangle_qualified (work, mangled, s,
-				      /*isfuncname=*/0,
+				      /*isfuncname=*/0, 
 				      /*append=*/1);
       else
 	{
@@ -3250,7 +3250,7 @@
 	    else if (**mangled == 'Q')
 	      {
 		success = demangle_qualified (work, mangled, &decl,
-					      /*isfuncnam=*/0,
+					      /*isfuncnam=*/0, 
 					      /*append=*/0);
 		if (!success)
 		  break;
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/dyngen-exec.h
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/dyngen-exec.h
@@ -71,7 +71,7 @@
 /* the symbols are considered non exported so a br immediate is generated */
 #define __hidden __attribute__((visibility("hidden")))
 #else
-#define __hidden
+#define __hidden 
 #endif
 
 #ifdef __alpha__
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/dyngen.c
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/dyngen.c
@@ -1,6 +1,6 @@
 /*
  *  Generic Dynamic compiler generator
- *
+ * 
  *  Copyright (c) 2003-2004 Fabrice Bellard
  *
  *  The COFF object format support was extracted from Kazu's QEMU port
@@ -352,8 +352,8 @@
        long  n_strx;
 #endif
    } n_un;
-   unsigned char n_type;
-   unsigned char n_sect;
+   unsigned char n_type; 
+   unsigned char n_sect; 
    short st_desc;
    unsigned long st_value;
    unsigned long st_size;
@@ -498,7 +498,7 @@
 
 /* generate op code */
 void gen_code(const char *name, const char *demangled_name,
-              host_ulong offset, host_ulong size,
+              host_ulong offset, host_ulong size, 
               FILE *outfile, int gen_switch, const char *prefix);
 void patch_relocations(FILE *outfile, const char *name, host_ulong size, host_ulong start_offset, int copy_size);
 
@@ -609,10 +609,10 @@
   } swaptest;
 
   swaptest.i = 1;
-  return (h->e_ident[EI_DATA] == ELFDATA2MSB) !=
+  return (h->e_ident[EI_DATA] == ELFDATA2MSB) != 
       (swaptest.b[0] == 0);
 }
-
+  
 void elf_swap_ehdr(elfhdr *h)
 {
     swab16s(&h->e_type);			/* Object file type */
@@ -665,7 +665,7 @@
 #endif
 }
 
-elf_shdr *find_elf_section(elf_shdr *shdr, int shnum, const char *shstr,
+elf_shdr *find_elf_section(elf_shdr *shdr, int shnum, const char *shstr, 
                                   const char *name)
 {
     int i;
@@ -690,7 +690,7 @@
 
     for(i = 0; i < ehdr.e_shnum; i++) {
         sec = &shdr[i];
-        if (sec->sh_type == type && sec->sh_info == sh_index)
+        if (sec->sh_type == type && sec->sh_info == sh_index) 
             return i;
     }
     return 0;
@@ -735,11 +735,11 @@
     elf_shdr *rodata_cst16_sec;
     uint8_t *rodata_cst16 = NULL;
     int rodata_cst16_shndx;
-
+    
     fd = open(filename, O_RDONLY);
-    if (fd < 0)
+    if (fd < 0) 
         error("can't open file '%s'", filename);
-
+    
     /* Read ELF header.  */
     if (read(fd, &ehdr, sizeof (ehdr)) != sizeof (ehdr))
         error("unable to read file header");
@@ -776,7 +776,7 @@
     /* read all section data */
     sdata = malloc(sizeof(void *) * ehdr.e_shnum);
     memset(sdata, 0, sizeof(void *) * ehdr.e_shnum);
-
+    
     for(i = 0;i < ehdr.e_shnum; i++) {
         sec = &shdr[i];
         if (sec->sh_type != SHT_NOBITS)
@@ -867,7 +867,7 @@
 
     symtab = (ElfW(Sym) *)sdata[symtab_sec - shdr];
     strtab = sdata[symtab_sec->sh_link];
-
+    
     nb_syms = symtab_sec->sh_size / sizeof(ElfW(Sym));
     if (do_swap) {
         for(i = 0, sym = symtab; i < nb_syms; i++, sym++) {
@@ -885,10 +885,8 @@
         char *demangled_name, *func_name;
         if ((demangled_name = malloc(nd)) == NULL)
             return -1;
-        if ((func_name = malloc(nf = nd)) == NULL) {
-            free(demangled_name);
+        if ((func_name = malloc(nf = nd)) == NULL)
             return -1;
-        }
 
         for(i = 0, sym = symtab; i < nb_syms; i++, sym++) {
             const char *name;
@@ -916,9 +914,6 @@
                 fprintf(outfile, "#endif\n");
             }
         }
-
-        free(func_name);
-        free(demangled_name);
     }
     return 0;
 }
@@ -947,7 +942,7 @@
 {
     char *q;
     int c, i, len;
-
+    
     if (ext_sym->e.e.e_zeroes != 0) {
         q = sym->st_name;
         for(i = 0; i < 8; i++) {
@@ -981,7 +976,7 @@
 		if (sym->st_syment->e_scnum == data_shndx &&
                     text_data >= sym->st_value &&
                     text_data < sym->st_value + sym->st_size) {
-
+                    
                     return sym->st_name;
 
 		}
@@ -1037,15 +1032,15 @@
     uint32_t *n_strtab;
     EXE_SYM *sym;
     EXE_RELOC *rel;
-
-    fd = open(filename, O_RDONLY
+	
+    fd = open(filename, O_RDONLY 
 #ifdef _WIN32
               | O_BINARY
 #endif
               );
-    if (fd < 0)
+    if (fd < 0) 
         error("can't open file '%s'", filename);
-
+    
     /* Read COFF header.  */
     if (read(fd, &fhdr, sizeof (fhdr)) != sizeof (fhdr))
         error("unable to read file header");
@@ -1058,11 +1053,11 @@
 
     /* read section headers */
     shdr = load_data(fd, sizeof(struct external_filehdr) + fhdr.f_opthdr, fhdr.f_nscns * sizeof(struct external_scnhdr));
-
+	
     /* read all section data */
     sdata = malloc(sizeof(void *) * fhdr.f_nscns);
     memset(sdata, 0, sizeof(void *) * fhdr.f_nscns);
-
+    
     const char *p;
     for(i = 0;i < fhdr.f_nscns; i++) {
         sec = &shdr[i];
@@ -1084,7 +1079,7 @@
         error("could not find .data section");
     coff_data_shndx = data_sec - shdr;
     data = sdata[coff_data_shndx];
-
+    
     coff_symtab = load_data(fd, fhdr.f_symptr, fhdr.f_nsyms*SYMESZ);
     for (i = 0, ext_sym = coff_symtab; i < nb_syms; i++, ext_sym++) {
         for(j=0;j<8;j++)
@@ -1094,8 +1089,8 @@
 
     nb_syms = fhdr.f_nsyms;
     n_strtab = load_data(fd, (fhdr.f_symptr + fhdr.f_nsyms*SYMESZ), STRTAB_SIZE);
-    strtab = load_data(fd, (fhdr.f_symptr + fhdr.f_nsyms*SYMESZ), *n_strtab);
-
+    strtab = load_data(fd, (fhdr.f_symptr + fhdr.f_nsyms*SYMESZ), *n_strtab); 
+    
     for (i = 0, ext_sym = coff_symtab; i < nb_syms; i++, ext_sym++) {
       if (strstart(ext_sym->e.e_name, ".text", NULL))
 		  text_shndx = ext_sym->e_scnum;
@@ -1140,12 +1135,12 @@
 		} else {
 			sym->st_size = 0;
 		}
-
+		
 		sym->st_type = ext_sym->e_type;
 		sym->st_shndx = ext_sym->e_scnum;
 	}
 
-
+		
     /* find text relocations, if any */
     sec = &shdr[coff_text_shndx];
     coff_relocs = load_data(fd, sec->s_relptr, sec->s_nreloc*RELSZ);
@@ -1153,7 +1148,7 @@
 
     /* set coff relocation */
     relocs = malloc(sizeof(struct coff_rel) * nb_relocs);
-    for (i = 0, ext_rel = coff_relocs, rel = relocs; i < nb_relocs;
+    for (i = 0, ext_rel = coff_relocs, rel = relocs; i < nb_relocs; 
          i++, ext_rel++, rel++) {
         memset(rel, 0, sizeof(*rel));
         rel->r_reloc = ext_rel;
@@ -1184,7 +1179,7 @@
 
 /* relocs */
 struct relocation_info *relocs;
-
+	
 /* symbols */
 EXE_SYM			*symtab;
 struct NLIST 	*symtab_std;
@@ -1204,10 +1199,10 @@
 static char *get_sym_name(EXE_SYM *sym)
 {
 	char *name = find_str_by_index(sym->n_un.n_strx);
-
+	
 	if ( sym->n_type & N_STAB ) /* Debug symbols are ignored */
 		return "debug";
-
+			
 	if(!name)
 		return name;
 	if(name[0]=='_')
@@ -1217,7 +1212,7 @@
 }
 
 /* find a section index given its segname, sectname */
-static int find_mach_sec_index(struct SECTION *section_hdr, int shnum, const char *segname,
+static int find_mach_sec_index(struct SECTION *section_hdr, int shnum, const char *segname, 
                                   const char *sectname)
 {
     int i;
@@ -1233,7 +1228,7 @@
 }
 
 /* find a section header given its segname, sectname */
-struct SECTION *find_mach_sec_hdr(struct SECTION *section_hdr, int shnum, const char *segname,
+struct SECTION *find_mach_sec_hdr(struct SECTION *section_hdr, int shnum, const char *segname, 
                                   const char *sectname)
 {
 	int index = find_mach_sec_index(section_hdr, shnum, segname, sectname);
@@ -1246,7 +1241,7 @@
 static inline void fetch_next_pair_value(struct relocation_info * rel, unsigned int *value)
 {
 	struct scattered_relocation_info * scarel;
-
+	
 	if(R_SCATTERED & rel->r_address) {
 		scarel = (struct scattered_relocation_info*)rel;
 		if(scarel->r_type != PPC_RELOC_PAIR)
@@ -1263,7 +1258,7 @@
 static const char * find_sym_with_value_and_sec_number( int value, int sectnum, int * offset )
 {
 	int i, ret = -1;
-
+	
 	for( i = 0 ; i < nb_syms; i++ )
 	{
 	    if( !(symtab[i].n_type & N_STAB) && (symtab[i].n_type & N_SECT) &&
@@ -1282,8 +1277,8 @@
 	}
 }
 
-/*
- *  Find symbol name given a (virtual) address, and a section which is of type
+/* 
+ *  Find symbol name given a (virtual) address, and a section which is of type 
  *  S_NON_LAZY_SYMBOL_POINTERS or S_LAZY_SYMBOL_POINTERS or S_SYMBOL_STUBS
  */
 static const char * find_reloc_name_in_sec_ptr(int address, struct SECTION * sec_hdr)
@@ -1294,23 +1289,23 @@
 	/* Sanity check */
 	if(!( address >= sec_hdr->addr && address < (sec_hdr->addr + sec_hdr->size) ) )
 		return (char*)0;
-
+		
 	if( sec_hdr->flags & S_SYMBOL_STUBS ){
 		size = sec_hdr->reserved2;
 		if(size == 0)
 		    error("size = 0");
-
+		
 	}
 	else if( (sec_hdr->flags & S_LAZY_SYMBOL_POINTERS) ||
 	            (sec_hdr->flags & S_NON_LAZY_SYMBOL_POINTERS) )
 		size = sizeof(unsigned long);
 	else
 		return 0;
-
+		
     /* Compute our index in toc */
 	tocindex = (address - sec_hdr->addr)/size;
 	symindex = tocdylib[sec_hdr->reserved1 + tocindex];
-
+	
 	name = get_sym_name(&symtab[symindex]);
 
 	return name;
@@ -1335,7 +1330,7 @@
 	int sectnum = rel->r_symbolnum;
 	int sectoffset;
 	unsigned int other_half=0;
-
+	
 	/* init the slide value */
 #ifdef HOST_X86_64 /* no scattered on x86_64 */
 	switch(rel->r_length)
@@ -1347,7 +1342,7 @@
 	}
 #else
 	*sslide = 0;
-
+	
 	if (R_SCATTERED & rel->r_address) {
         char *name = (char *)find_reloc_name_given_its_address(sca_rel->r_value);
 
@@ -1374,7 +1369,7 @@
 	if(rel->r_extern)
 	{
 		/* ignore debug sym */
-		if ( symtab[rel->r_symbolnum].n_type & N_STAB )
+		if ( symtab[rel->r_symbolnum].n_type & N_STAB ) 
 			return 0;
 		return get_sym_name(&symtab[rel->r_symbolnum]);
 	}
@@ -1385,7 +1380,7 @@
 
 	/* Intruction contains an offset to the symbols pointed to, in the rel->r_symbolnum section */
 	sectoffset = *(uint32_t *)(text + rel->r_address) & 0xffff;
-
+			
 	if(sectnum==0xffffff)
 		return 0;
 
@@ -1427,7 +1422,7 @@
 	/* search it in the full symbol list, if not found */
 	if(!name)
 		name = (char *)find_sym_with_value_and_sec_number(sectoffset, sectnum, sslide);
-
+	
 	return name;
 #endif
 }
@@ -1460,11 +1455,11 @@
     unsigned int i, j;
     EXE_SYM *sym;
     struct NLIST *syment;
-
+    
     fd = open(filename, O_RDONLY);
-    if (fd < 0)
+    if (fd < 0) 
         error("can't open file '%s'", filename);
-
+		
     /* Read Mach header.  */
     if (read(fd, &mach_hdr, sizeof (mach_hdr)) != sizeof (mach_hdr))
         error("unable to read file header");
@@ -1473,13 +1468,13 @@
     if (!check_mach_header(mach_hdr)) {
         error("bad Mach header");
     }
-
+    
     if (!mach_check_cputype(mach_hdr.cputype))
         error("Unsupported CPU");
-
+        
     if (mach_hdr.filetype != MH_OBJECT)
         error("Unsupported Mach Object");
-
+    
     /* read segment headers */
     for(i=0, j=sizeof(mach_hdr); i<mach_hdr.ncmds ; i++)
     {
@@ -1531,7 +1526,7 @@
     /* read all section data */
     sdata = (uint8_t **)malloc(sizeof(void *) * segment->nsects);
     memset(sdata, 0, sizeof(void *) * segment->nsects);
-
+    
     /* Load the data in section data */
     for(i = 0; i < segment->nsects; i++)
         sdata[i] = load_data(fd, section_hdr[i].offset, section_hdr[i].size);
@@ -1552,30 +1547,30 @@
     if (i == -1 || !text_sec_hdr)
         error("could not find __TEXT,__text section");
     text = sdata[i];
-
+	    
     /* Make sure dysym was loaded */
-    if(dysymtabcmd == NULL)
+    if(!(int)dysymtabcmd)
         error("could not find __DYSYMTAB segment");
-
+    
     /* read the table of content of the indirect sym */
     tocdylib = load_data( fd, dysymtabcmd->indirectsymoff, dysymtabcmd->nindirectsyms * sizeof(uint32_t) );
-
+    
     /* Make sure symtab was loaded  */
-    if(symtabcmd == NULL)
+    if(!(int)symtabcmd)
         error("could not find __SYMTAB segment");
     nb_syms = symtabcmd->nsyms;
 
     symtab_std = load_data(fd, symtabcmd->symoff, symtabcmd->nsyms * sizeof(struct NLIST));
     strtab = load_data(fd, symtabcmd->stroff, symtabcmd->strsize);
-
+	
     symtab = malloc(sizeof(EXE_SYM) * nb_syms);
-
+	
     /* Now transform the symtab, to an extended version, with the sym size, and the C name */
     for(i = 0, sym = symtab, syment = symtab_std; i < nb_syms; i++, sym++, syment++) {
         struct NLIST *sym_follow, *sym_next = 0;
         unsigned int j;
         memset(sym, 0, sizeof(*sym));
-
+		
         if ( syment->n_type & N_STAB ) /* Debug symbols are skipped */
             continue;
 
@@ -1601,7 +1596,7 @@
         else
             sym->st_size = text_sec_hdr->size - sym->st_value;
     }
-
+	
     /* Find Reloc */
     relocs = load_data(fd, text_sec_hdr->reloff, text_sec_hdr->nreloc * sizeof(struct relocation_info));
     nb_relocs = text_sec_hdr->nreloc;
@@ -1619,7 +1614,7 @@
     char demangled_buf[256];
     size_t nd = sizeof(demangled_buf);
     int status;
-
+    
     demangled = cxx_demangle(sym_name, demangled_buf, &nd, &status);
     if (!status && demangled)
         sym_name = demangled;
@@ -1628,7 +1623,7 @@
     } else if (is_op_gen_label(sym_name, &p)) {
         snprintf(name, name_size, "gen_labels[param%s]", p);
     } else if (strstart(sym_name, ".LC", NULL)) {
-        snprintf(name, name_size, "(long)(gen_const_%s())", gen_dot_prefix(sym_name));
+        snprintf(name, name_size, "(long)(gen_const_%s())", gen_dot_prefix(sym_name));	
     } else {
 #ifdef HOST_SPARC
         if (sym_name[0] == '.')
@@ -1652,9 +1647,9 @@
     int offset, min_offset, pc_offset, data_size;
     uint8_t data_allocated[1024];
     unsigned int data_index;
-
+    
     memset(data_allocated, 0, sizeof(data_allocated));
-
+    
     p = p_start;
     min_offset = p_end - p_start;
     while (p < p_start + min_offset) {
@@ -1665,22 +1660,22 @@
             if (!(insn & 0x00800000))
                         offset = -offset;
             if ((offset & 3) !=0)
-                error("%s:%04x: ldr pc offset must be 32 bit aligned",
+                error("%s:%04x: ldr pc offset must be 32 bit aligned", 
                       name, start_offset + p - p_start);
             pc_offset = p - p_start + offset + 8;
-            if (pc_offset <= (p - p_start) ||
+            if (pc_offset <= (p - p_start) || 
                 pc_offset >= (p_end - p_start))
-                error("%s:%04x: ldr pc offset must point inside the function code",
+                error("%s:%04x: ldr pc offset must point inside the function code", 
                       name, start_offset + p - p_start);
             if (pc_offset < min_offset)
                 min_offset = pc_offset;
             if (outfile) {
                 /* ldr position */
-                fprintf(outfile, "    arm_ldr_ptr->ptr = ptr() + %d;\n",
+                fprintf(outfile, "    arm_ldr_ptr->ptr = ptr() + %d;\n", 
                         p - p_start);
                 /* ldr data index */
                 data_index = ((p_end - p_start) - pc_offset - 4) >> 2;
-                fprintf(outfile, "    arm_ldr_ptr->data_ptr = arm_data_ptr + %d;\n",
+                fprintf(outfile, "    arm_ldr_ptr->data_ptr = arm_data_ptr + %d;\n", 
                         data_index);
                 fprintf(outfile, "    arm_ldr_ptr++;\n");
                 if (data_index >= sizeof(data_allocated))
@@ -1732,7 +1727,7 @@
         if (!outfile)
             printf("%s: invalid epilog\n", name);
     }
-    return p - p_start;
+    return p - p_start;	    
 }
 #endif
 
@@ -1741,7 +1736,7 @@
 
 /* generate op code */
 void gen_code(const char *name, const char *demangled_name,
-              host_ulong offset, host_ulong size,
+              host_ulong offset, host_ulong size, 
               FILE *outfile, int gen_switch, const char *prefix)
 {
     int copy_size = 0;
@@ -1788,6 +1783,7 @@
     }
     else
 #if defined(HOST_I386) || defined(HOST_X86_64)
+#if defined(CONFIG_FORMAT_COFF) || defined(CONFIG_FORMAT_MACH)
     {
         uint8_t *p;
         p = p_end - 1;
@@ -1800,6 +1796,20 @@
         }
         copy_size = p - p_start;
     }
+#else
+    {
+        int len;
+        len = p_end - p_start;
+        if (len == 0)
+            error("empty code for %s", name);
+        if (p_end[-1] == 0xc3) {
+            len--;
+        } else {
+            error("ret or jmp expected at the end of %s", name);
+        }
+        copy_size = len;
+    }
+#endif    
 #elif defined(HOST_PPC)
     {
         uint8_t *p;
@@ -1831,7 +1841,7 @@
 #endif
         if (get32((uint32_t *)p) != 0x6bfa8001)
             error("ret expected at the end of %s", name);
-        copy_size = p - p_start;
+        copy_size = p - p_start;	    
     }
 #elif defined(HOST_IA64)
     {
@@ -1895,14 +1905,14 @@
         } else {
             error("No save at the beginning of %s", name);
         }
-
+        
         /* Skip a preceeding nop, if present.  */
         if (p > p_start) {
             skip_insn = get32((uint32_t *)(p - 0x4));
             if (skip_insn == 0x01000000)
                 p -= 4;
         }
-
+        
         copy_size = p - p_start;
     }
 #elif defined(HOST_ARM)
@@ -1915,7 +1925,7 @@
             error("%s: invalid prolog", name);
         p_start += 12;
         start_offset += 12;
-        copy_size = arm_emit_ldr_info(name, start_offset, NULL, p_start, p_end,
+        copy_size = arm_emit_ldr_info(name, start_offset, NULL, p_start, p_end, 
                                       relocs, nb_relocs);
     }
 #elif defined(HOST_M68K)
@@ -1926,7 +1936,7 @@
             error("empty code for %s", name);
         // remove NOP's, probably added for alignment
         while ((get16((uint16_t *)p) == 0x4e71) &&
-               (p>p_start))
+               (p>p_start)) 
             p -= 2;
         if (get16((uint16_t *)p) != 0x4e75)
             error("rts expected at the end of %s", name);
@@ -1948,8 +1958,8 @@
 #error unsupported CPU
 #endif
 
+    
 
-
     /* compute the number of arguments by looking at the relocations */
     for(i = 0;i < MAX_ARGS; i++)
         args_present[i] = 0;
@@ -1973,7 +1983,7 @@
             }
         }
     }
-
+    
     nb_args = 0;
     while (nb_args < MAX_ARGS && args_present[nb_args])
         nb_args++;
@@ -2015,7 +2025,7 @@
                 demangled = cxx_demangle(sym_name, demangled_buf, &nd, &status);
                 if (!status && demangled)
                     sym_name = demangled;
-                if (*sym_name &&
+                if (*sym_name && 
                     !is_op_param(sym_name, NULL) &&
                     !is_op_jmp(sym_name, NULL) &&
                     !strstart(sym_name, ".LC", NULL))
@@ -2037,7 +2047,7 @@
                 if (strstart(sym_name, "__op_label", &p)) {
                     uint8_t *ptr;
                     unsigned long offset;
-
+                    
                     /* test if the variable refers to a label inside
                        the code we are generating */
 #ifdef CONFIG_FORMAT_COFF
@@ -2069,7 +2079,7 @@
                         /* try to find a matching relocation */
                         reloc_shndx = find_reloc(sym->st_shndx);
                         if (reloc_shndx) {
-                            nb_relocs1 = shdr[reloc_shndx].sh_size /
+                            nb_relocs1 = shdr[reloc_shndx].sh_size / 
                                 shdr[reloc_shndx].sh_entsize;
                             rel = (ELF_RELOC *)sdata[reloc_shndx];
                             for(j = 0; j < nb_relocs1; j++) {
@@ -2081,7 +2091,7 @@
                             }
                         }
                     }
-#endif
+#endif                    
 
                     if (val >= start_offset && val < start_offset + copy_size) {
                         n = strtol(p, NULL, 10);
@@ -2136,7 +2146,7 @@
 
 		slide = offset - start_offset;
 
-		if (!(offset >= start_offset && offset < start_offset + size))
+		if (!(offset >= start_offset && offset < start_offset + size)) 
 			continue;  /* not in our range */
 
 		sym_name = get_reloc_name(rel, &sslide);
@@ -2169,7 +2179,7 @@
 						slide, final_sym_name, slide);
 				}
 				else {
-					fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (%s + %d);\n",
+					fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (%s + %d);\n", 
 						slide, final_sym_name, sslide);
 				}
 				break;
@@ -2205,11 +2215,11 @@
 			type = ELF32_R_TYPE(rel->r_info);
 			switch(type) {
 			case R_386_32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					rel->r_offset - start_offset, final_sym_name, addend);
 				break;
 			case R_386_PC32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d;\n", 
 					rel->r_offset - start_offset, final_sym_name, rel->r_offset - start_offset, addend);
 				break;
 			default:
@@ -2232,11 +2242,11 @@
 			type = rel->r_type;
 			switch(type) {
 			case DIR32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					rel->r_offset - start_offset, final_sym_name, addend);
 				break;
 			case DISP32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d -4;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d -4;\n", 
 					rel->r_offset - start_offset, final_sym_name, rel->r_offset - start_offset, addend);
 				break;
 			default:
@@ -2259,7 +2269,6 @@
 
 	for (i = 0, rel = relocs, local16 = 0; i < nb_relocs; i++, rel++) {
 		unsigned int isym, usesym, offset, length, pcrel, type;
-		int adjustment = 0;
 
 		isym = rel->r_symbolnum;
 		usesym = rel->r_extern;
@@ -2270,13 +2279,13 @@
 
 		if (usesym && (symtab[isym].n_type & N_STAB))
 			continue; /* don't handle STAB (debug sym) */
-
-		if (!(offset >= start_offset && offset < start_offset + size))
+                    
+		if (!(offset >= start_offset && offset < start_offset + size)) 
 			continue;  /* not in our range */
 
 		if (length > 3)
 			error("unsupported %d-bit relocation", 8 * (1 << length));
-
+                    
 		bytecount = (1 << length);
 		bitlength = 8 * bytecount;
 		slide = offset - start_offset;
@@ -2284,15 +2293,15 @@
 		if (!usesym) {
 			// local reloc
 			sslide = get32((uint32_t *)(text + offset)) + rel->r_address + 4;
-			if ( literal16_sec_hdr
-				&& sslide >= literal16_sec_hdr->addr
+			if ( literal16_sec_hdr 
+				&& sslide >= literal16_sec_hdr->addr 
 				&& sslide + 16 <= literal16_sec_hdr->addr + literal16_sec_hdr->size ) {
 				sprintf(final_sym_name, "literal16_%d", ++local16);
 				print_data(outfile, final_sym_name, literal16 + sslide - literal16_sec_hdr->addr, 16);
 				fprintf(outfile, "    static uint8 *data_p_%d = NULL;\n", local16);
 				fprintf(outfile, "    if (data_p_%d == NULL)\n", local16);
 				fprintf(outfile, "        data_p_%d = copy_data(%s, %d);\n", local16, final_sym_name, 16);
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (int32_t)((long)data_p_%d - (long)(code_ptr() + %d + %d));\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (int32_t)((long)data_p_%d - (long)(code_ptr() + %d + %d));\n", 
 						slide, local16, slide, bytecount);
 			} else {
 				fprintf(outfile, "/* #warning relocation not handled in %s (section %d, offset 0x%x, length 0x%x, %s, type 0x%x) */\n",
@@ -2316,29 +2325,17 @@
 		}
 
 		get_reloc_expr(final_sym_name, sizeof(final_sym_name), sym_name);
-
-		switch (type) {
-			case X86_64_RELOC_SIGNED_1:		// Signed displacement with a -1 added.
-				adjustment = -1;
-				type = X86_64_RELOC_SIGNED;
-				break;
-			case X86_64_RELOC_SIGNED_2:		// Signed displacement with a -2 added.
-				adjustment = -2;
-				type = X86_64_RELOC_SIGNED;
-				break;
-			case X86_64_RELOC_SIGNED_4:		// Signed displacement with a -4 added.
-				adjustment = -4;
-				type = X86_64_RELOC_SIGNED;
-				break;
-		}
-
+                    
 		if (pcrel || is_op_gen_label(sym_name, &p)) {
 			switch (type) {
 			case X86_64_RELOC_UNSIGNED:     // for absolute addresses
 			case X86_64_RELOC_SIGNED:		// for signed 32-bit displacement
 			case X86_64_RELOC_BRANCH:		// a CALL/JMP instruction with 32-bit displacement
-				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (int%d_t)((long)%s - (long)(code_ptr() + %d + %d)) + %d;\n",
-					bitlength, slide, bitlength, final_sym_name, slide, bytecount, sslide + adjustment);
+			case X86_64_RELOC_SIGNED_1:     // for signed 32-bit displacement with a -1 addend
+			case X86_64_RELOC_SIGNED_2:     // for signed 32-bit displacement with a -2 addend
+			case X86_64_RELOC_SIGNED_4:     // for signed 32-bit displacement with a -4 addend
+				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (int%d_t)((long)%s - (long)(code_ptr() + %d + %d)) + %d;\n", 
+					bitlength, slide, bitlength, final_sym_name, slide, bytecount, sslide);
 				break;
 			default:
 				error("unsupported x86_64 relocation (%d) in %s\n", type, sym_name);
@@ -2346,18 +2343,18 @@
 		} else {
 			switch (type) {
 			case X86_64_RELOC_UNSIGNED:     // for absolute addresses
-				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (uint%d_t)%s + %d;\n",
+				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (uint%d_t)%s + %d;\n", 
 					bitlength, slide, bitlength, final_sym_name, sslide);
 				break;
 			case X86_64_RELOC_SIGNED:		// for signed 32-bit displacement
-				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (int%d_t)%s + %d;\n",
-					bitlength, slide, bitlength, final_sym_name, sslide + adjustment);
+				fprintf(outfile, "    *(uint%d_t *)(code_ptr() + %d) = (int%d_t)%s + %d;\n", 
+					bitlength, slide, bitlength, final_sym_name, sslide);
 				break;
 			default:
 				error("unsupported x86_64 relocation (%d) in %s\n", type, sym_name);
 			}
 		}
-	}
+	}                
 #elif defined (CONFIG_FORMAT_ELF)
 	char final_sym_name[256];
 	const char *sym_name;
@@ -2396,7 +2393,7 @@
 				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (int32_t)%s + %d;\n", slide, final_sym_name, addend);
 				break;
 			case R_X86_64_PC32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %d) + %d;\n", 
 					slide, final_sym_name, slide, addend);
 				break;
 			default:
@@ -2405,7 +2402,7 @@
 		}
 	}
 #else
-#error unsupport object format for HOST_X86_64
+#error unsupport object format for HOST_X86_64 
 #endif
 #elif defined(HOST_PPC)
 #ifdef CONFIG_FORMAT_ELF
@@ -2432,24 +2429,24 @@
 			addend = rel->r_addend;
 			switch(type) {
 			case R_PPC_ADDR32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_PPC_ADDR16_LO:
-				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d);\n",
+				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d);\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_PPC_ADDR16_HI:
-				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d) >> 16;\n",
+				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d) >> 16;\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_PPC_ADDR16_HA:
-				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d + 0x8000) >> 16;\n",
+				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = (%s + %d + 0x8000) >> 16;\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_PPC_REL24:
 				/* warning: must be at 32 MB distancy */
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (*(uint32_t *)(code_ptr() + %d) & ~0x03fffffc) | ((%s - (long)(code_ptr() + %d) + %d) & 0x03fffffc);\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (*(uint32_t *)(code_ptr() + %d) & ~0x03fffffc) | ((%s - (long)(code_ptr() + %d) + %d) & 0x03fffffc);\n", 
 					slide, slide, final_sym_name, slide, addend);
 				break;
 			default:
@@ -2486,15 +2483,15 @@
 		}
 
 		slide = offset - start_offset;
-
-		if (!(offset >= start_offset && offset < start_offset + size))
+		
+		if (!(offset >= start_offset && offset < start_offset + size)) 
 			continue;  /* not in our range */
 
 		sym_name = get_reloc_name(rel, &sslide);
-
+	
 		if(usesym && (symtab[isym].n_type & N_STAB))
 			continue; /* don't handle STAB (debug sym) */
-
+					
 		if (sym_name && is_op_jmp(sym_name, &p)) {
 			int n;
 			n = strtol(p, NULL, 10);
@@ -2502,7 +2499,7 @@
 				n, slide);
 			continue; /* Nothing more to do */
 		}
-
+	
 		if(!sym_name)
 		{
 			fprintf(outfile, "/* #warning relocation not handled in %s (value 0x%x, %s, offset 0x%x, length 0x%x, %s, type 0x%x) */\n",
@@ -2517,7 +2514,7 @@
 			if (!is_op_param(sym_name, &p)) {
 				fprintf(outfile, "{\n");
 				fprintf(outfile, "    uint32_t imm = *(uint32_t *)(code_ptr() + %d) & 0x3fffffc;\n", slide);
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (*(uint32_t *)(code_ptr() + %d) & ~0x03fffffc) | ((imm + ((long)%s - (long)code_ptr()) + %d) & 0x03fffffc);\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = (*(uint32_t *)(code_ptr() + %d) & ~0x03fffffc) | ((imm + ((long)%s - (long)code_ptr()) + %d) & 0x03fffffc);\n", 
 					slide, slide, final_sym_name, sslide );
 				fprintf(outfile, "}\n");
 			} else {
@@ -2526,15 +2523,15 @@
 			}
 			break;
 		case PPC_RELOC_HI16:
-			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d) >> 16;\n",
+			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d) >> 16;\n", 
 				slide, final_sym_name, sslide);
 			break;
 		case PPC_RELOC_LO16:
-			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d);\n",
+			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d);\n", 
 				slide, final_sym_name, sslide);
 			break;
 		case PPC_RELOC_HA16:
-			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d + 0x8000) >> 16;\n",
+			fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d + 2) = (%s + %d + 0x8000) >> 16;\n", 
 				slide, final_sym_name, sslide);
 			break;
 		default:
@@ -2560,15 +2557,15 @@
 			addend = rel->r_addend;
 			switch(type) {
 			case R_390_32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_390_16:
-				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint16_t *)(code_ptr() + %d) = %s + %d;\n", 
 					slide, final_sym_name, addend);
 				break;
 			case R_390_8:
-				fprintf(outfile, "    *(uint8_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint8_t *)(code_ptr() + %d) = %s + %d;\n", 
 					slide, final_sym_name, addend);
 				break;
 			default:
@@ -2674,7 +2671,7 @@
 			addend = rel->r_addend;
 			switch(type) {
 			case R_SPARC_32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					rel->r_offset - start_offset, final_sym_name, addend);
 				break;
 			case R_SPARC_HI22:
@@ -2789,11 +2786,11 @@
 			addend = get32((uint32_t *)(text + rel->r_offset));
 			switch(type) {
 			case R_ARM_ABS32:
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %d;\n", 
 					rel->r_offset - start_offset, final_sym_name, addend);
 				break;
 			case R_ARM_PC24:
-				fprintf(outfile, "    arm_reloc_pc24((uint32_t *)(code_ptr() + %d), 0x%x, %s);\n",
+				fprintf(outfile, "    arm_reloc_pc24((uint32_t *)(code_ptr() + %d), 0x%x, %s);\n", 
 					rel->r_offset - start_offset, addend, final_sym_name);
 				break;
 			default:
@@ -2818,12 +2815,12 @@
 			switch(type) {
 			case R_68K_32:
 				fprintf(outfile, "    /* R_68K_32 RELOC, offset %x */\n", rel->r_offset) ;
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %#x;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s + %#x;\n", 
 					rel->r_offset - start_offset, final_sym_name, addend );
 				break;
 			case R_68K_PC32:
 				fprintf(outfile, "    /* R_68K_PC32 RELOC, offset %x */\n", rel->r_offset);
-				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %#x) + %#x;\n",
+				fprintf(outfile, "    *(uint32_t *)(code_ptr() + %d) = %s - (long)(code_ptr() + %#x) + %#x;\n", 
 					rel->r_offset - start_offset, final_sym_name, rel->r_offset - start_offset, /*sym->st_value+*/ addend);
 				break;
 			default:
@@ -2890,10 +2887,8 @@
 		char *demangled_name, *func_name;
 		if ((demangled_name = malloc(nd)) == NULL)
 			return -1;
-		if ((func_name = malloc(nf = nd)) == NULL) {
-			free(demangled_name);
+		if ((func_name = malloc(nf = nd)) == NULL)
 			return -1;
-		}
 
 		fprintf(outfile, "#ifndef DEFINE_CST\n");
 		fprintf(outfile, "#define DEFINE_CST(NAME, VALUE)\n");
@@ -2942,24 +2937,20 @@
 				demangled_name = cxx_demangle(name, demangled_name, &nd, &status);
 				if (status == 0 && strstart(demangled_name, OP_PREFIX, NULL)) {
 					/* get real function name */
-					char *p = strchr(demangled_name, '(');
-					if (p && !strstart(p, "()::label", NULL)) {
-						int func_name_length = p - demangled_name;
-						if (nd > nf) {
-							char *new_func_name;
-							nf = nd;
-							if ((new_func_name = realloc(func_name, nf)) == NULL) {
-								free(func_name);
-								return -1;
-							}
-							func_name = new_func_name;
-						}
-						strncpy(func_name, demangled_name, func_name_length);
-						func_name[func_name_length] = '\0';
-						/* emit code generator */
+						char *p = strchr(demangled_name, '(');
+						if (p && !strstart(p, "()::label", NULL)) {
+							int func_name_length = p - demangled_name;
+							if (nd > nf) {
+								nf = nd;
+								if ((func_name = realloc(func_name, nf)) == NULL)
+									return -1;
+								}
+							strncpy(func_name, demangled_name, func_name_length);
+							func_name[func_name_length] = '\0';
+							/* emit code generator */
 #if defined(CONFIG_FORMAT_ELF) || defined(CONFIG_FORMAT_COFF)
-						if (sym->st_shndx != text_shndx)
-							error("invalid section for opcode (%s:0x%x)", name, sym->st_shndx);
+							if (sym->st_shndx != text_shndx)
+								error("invalid section for opcode (%s:0x%x)", name, sym->st_shndx);
 #endif
 						gen_code(func_name, demangled_name, sym->st_value, sym->st_size, outfile, 3, NULL);
 					}
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/jit-cache.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/jit-cache.cpp
@@ -76,7 +76,8 @@
 		tcode_start = NULL;
 		return false;
 	}
-
+	
+  done:
 	D(bug("basic_jit_cache: Translation cache: %d KB at %p\n", cache_size / 1024, tcode_start));
 	code_start = tcode_start;
 	code_p = code_start;
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/ppc/jit-target-cache.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/ppc/jit-target-cache.hpp
@@ -29,7 +29,7 @@
 
     p = start & ~(MIN_CACHE_LINE_SIZE - 1);
     stop = (stop + MIN_CACHE_LINE_SIZE - 1) & ~(MIN_CACHE_LINE_SIZE - 1);
-
+    
     for (p = start; p < stop; p += MIN_CACHE_LINE_SIZE) {
         asm volatile ("dcbst 0,%0" : : "r"(p) : "memory");
     }
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/jit/x86/codegen_x86.h
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/jit/x86/codegen_x86.h
@@ -15,7 +15,7 @@
  *    Gwenole Beauchesne
  *
  *  Basilisk II (C) 1997-2008 Christian Bauer
- *
+ *  
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
@@ -72,7 +72,7 @@
 /* Define to optimize absolute addresses for RIP relative addressing.  */
 #ifndef X86_RIP_RELATIVE_ADDR
 #define X86_RIP_RELATIVE_ADDR	1
-#endif
+#endif 
 
 
 /* --- Macros -------------------------------------------------------------- */
@@ -206,11 +206,11 @@
 #define _rC(R)		((R) & 0xf0)
 #define _rR(R)		((R) & 0x0f)
 #define _rN(R)		((R) & 0x07)
-#define _rXP(R)		(((R) > 0 && _rR(R) > 7) ? 1 : 0)
+#define _rXP(R)		((R) > 0 && _rR(R) > 7)
 #else
 #define _rN(R)		((R) & 0x07)
 #define _rR(R)		(int(R))
-#define _rXP(R)		((_rR(R) > 7 && _rR(R) < 16) ? 1 : 0)
+#define _rXP(R)		(_rR(R) > 7 && _rR(R) < 16)
 #endif
 
 #if !defined(_ASM_SAFETY) || ! X86_FLAT_REGISTERS
@@ -495,7 +495,7 @@
 /* --- REX prefixes -------------------------------------------------------- */
 
 #define _VOID()			((void)0)
-#define _BIT(X)			((X) ? 1 : 0)
+#define _BIT(X)			(!!(X))
 #define _d64(W,R,X,B)		(_B(0x40|(W)<<3|(R)<<2|(X)<<1|(B)))
 
 #define __REXwrxb(L,W,R,X,B)	((W|R|X|B) || (L) ? _d64(W,R,X,B) : _VOID())
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-config.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-config.hpp
@@ -63,6 +63,18 @@
 
 
 /**
+ *	PPC_MIPS_COUNTER
+ *
+ *		Define to 1 to enable the MIPS counter, which is useful for
+ *      performance measurements.
+ **/
+
+#ifndef PPC_MIPS_COUNTER
+#define PPC_MIPS_COUNTER 1
+#endif
+
+
+/**
  *	PPC_ENABLE_JIT
  *
  *		Define to 1 if dynamic translation is used. This requires
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-cpu.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-cpu.cpp
@@ -123,6 +123,7 @@
 void powerpc_cpu::init_registers()
 {
 	assert((((uintptr)&vr(0)) % 16) == 0);
+	memset(&_regs, 0, sizeof(_regs));
 	for (int i = 0; i < 32; i++) {
 		gpr(i) = 0;
 		fpr(i) = 0;
@@ -231,7 +232,7 @@
 }
 #endif
 
-/*#if ENABLE_MON
+#if ENABLE_MON
 static uint32 mon_read_byte_ppc(uintptr addr)
 {
 	return *((uint8 *)addr);
@@ -242,7 +243,7 @@
 	uint8 *m = (uint8 *)addr;
 	*m = b;
 }
-#endif*/
+#endif
 
 void powerpc_cpu::initialize()
 {
@@ -527,7 +528,7 @@
 		spcflags().clear(SPCFLAG_CPU_ENTER_MON);
 #if ENABLE_MON
 		// Start up mon in real-mode
-		const char *arg[] = {
+		char *arg[] = {
 			"mon",
 #ifdef SHEEPSHAVER
 			"-m",
@@ -548,6 +549,7 @@
 	// which is aligned at least on 4-byte boundaries
 	const int n = ((uintptr)sbi) & 3;
 	sbi = (block_info *)(((uintptr)sbi) & ~3L);
+	const uint32 bpc = sbi->pc;
 
 	const uint32 tpc = sbi->li[n].jmp_pc;
 	block_info *tbi = my_block_cache.find(tpc);
@@ -563,6 +565,12 @@
 void powerpc_cpu::execute(uint32 entry)
 {
 	bool invalidated_cache = false;
+#if PPC_MIPS_COUNTER
+	unsigned long retired = 0, retired_ovf = 0;
+	double start, snap;
+	static uint32 mips_prints = 0;
+	start = snap = sys_time();
+#endif
 	pc() = entry;
 #if PPC_EXECUTE_DUMP_STATE
 	const bool dump_state = true;
@@ -602,13 +610,15 @@
 				// Compile new block
 				bi = compile_block(pc());
 			}
+			goto return_site;
 		}
 #endif
 #if PPC_DECODE_CACHE
-		block_info *bi = my_block_cache.find(pc());
-		if (bi != NULL)
-			goto pdi_execute;
 		for (;;) {
+			block_info *bi = my_block_cache.find(pc());
+			if (bi != NULL)
+				goto pdi_execute;
+		  pdi_compile:
 #if PPC_PROFILE_COMPILE_TIME
 			compile_count++;
 			clock_t start_time;
@@ -618,6 +628,7 @@
 			bi->init(pc());
 
 			// Predecode a new block
+		  pdi_decode:
 			block_info::decode_info *di;
 			const instr_info_t *ii;
 			uint32 dpc;
@@ -673,18 +684,45 @@
 			// Execute all cached blocks
 		  pdi_execute:
 			for (;;) {
+#if PPC_MIPS_COUNTER
+				retired += bi->size;
+#endif
 				const int r = bi->size % 4;
 				di = bi->di + r;
 				int n = (bi->size + 3) / 4;
 				switch (r) {
 				case 0: do {
-						di += 4;
-						di[-4].execute(this, di[-4].opcode);
+				        di += 4;
+				        di[-4].execute(this, di[-4].opcode);
 				case 3: di[-3].execute(this, di[-3].opcode);
 				case 2: di[-2].execute(this, di[-2].opcode);
 				case 1: di[-1].execute(this, di[-1].opcode);
 					} while (--n > 0);
 				}
+#if PPC_MIPS_COUNTER
+				if (retired > (1 << 27)) {
+					double now = sys_time(),
+					       diff = now - snap;
+					if (diff > 1.0) {
+						double mips = (double)(retired + retired_ovf) / 1e6;
+						fprintf(stderr, "%3.5lf MIPS @ %0.3lfs\n", mips / diff, now - start);
+						mips_prints++;
+						if (mips_prints == 5) {
+							mips_prints = 0;
+							my_block_cache.print_statistics();
+						}
+						retired_ovf = 0;
+						retired = 0;
+						snap = now;
+					} else {
+						// We should wait until we hit the *next* 134,217,728
+						// instructions. It's too soon to print a new MIPS
+						// count.
+						retired_ovf += retired;
+						retired = 0;
+					}
+				}
+#endif
 
 				if (!spcflags().empty()) {
 					if (!check_spcflags())
@@ -702,9 +740,9 @@
 					break;
 			}
 		}
-#else
-		goto do_interpret;
+		goto return_site;
 #endif
+		goto do_interpret;
 	}
 #endif
   do_interpret:
@@ -719,8 +757,37 @@
 		if (is_logging())
 			record_step(opcode);
 #endif
-		assert(ii->execute.ptr() != 0);
+		//assert(ii->execute.ptr() != 0);
 		ii->execute(this, opcode);
+
+#if PPC_MIPS_COUNTER
+		retired++;
+
+		if (retired > (1 << 27)) {
+			double now = sys_time(),
+			       diff = now - snap;
+			if (diff > 1.0) {
+				double mips = (double)(retired + retired_ovf) / 1e6;
+				fprintf(stderr, "%3.5lf MIPS @ %0.3lfs\n", mips / diff, now - start);
+#if PPC_DECODE_CACHE
+				mips_prints++;
+				if (mips_prints == 5) {
+					mips_prints = 0;
+					my_block_cache.print_statistics();
+				}
+#endif
+				retired_ovf = 0;
+				retired = 0;
+				snap = now;
+			} else {
+				// We should wait until we hit the *next* 134,217,728
+				// instructions. It's too soon to print a new MIPS
+				// count.
+				retired_ovf += retired;
+				retired = 0;
+			}
+		}
+#endif
 #if PPC_EXECUTE_DUMP_STATE
 		if (dump_state)
 			dump_registers();
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-cpu.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-cpu.hpp
@@ -29,7 +29,7 @@
 #include "cpu/ppc/ppc-bitfields.hpp"
 #include "cpu/ppc/ppc-blockinfo.hpp"
 #include "cpu/ppc/ppc-registers.hpp"
-#if PPC_ENABLE_JIT
+#if PPC_ENABLE_JIT 
 #include "cpu/ppc/ppc-jit.hpp"
 #endif
 #include "cpu/ppc/ppc-instructions.hpp"
@@ -98,12 +98,12 @@
 	uint32 pc() const			{ return regs().pc; }
 	void increment_pc(int o)	{ pc() += o; }
 
-	friend class pc_operand;
-	friend class lr_operand;
-	friend class ctr_operand;
-	friend class cr_operand;
-	template< class field > friend class xer_operand;
-	template< class field > friend class fpscr_operand;
+	friend struct pc_operand;
+	friend struct lr_operand;
+	friend struct ctr_operand;
+	friend struct cr_operand;
+	template< class field > friend struct xer_operand;
+	template< class field > friend struct fpscr_operand;
 
 public:
 
@@ -288,7 +288,7 @@
 
 	// Interrupts handling
 	void trigger_interrupt();
-
+	
 	// Set VALUE to register ID
 	void set_register(int id, any_register const & value);
 
@@ -353,7 +353,7 @@
 
 	// Block lookup table
 	typedef powerpc_block_info block_info;
-	block_cache< block_info, lazy_allocator > my_block_cache;
+	block_cache< block_info, slow_allocator > my_block_cache;
 
 #if PPC_DECODE_CACHE
 	// Decode Cache
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-dyngen-ops.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-dyngen-ops.cpp
@@ -27,19 +27,6 @@
 #include "cpu/ppc/ppc-registers.hpp"
 #include "cpu/ppc/ppc-operations.hpp"
 
-#if defined(__GNUC__)
-// Force inlining under newer versions of GCC.
-static inline uint64 vm_read_memory_8(vm_addr_t addr) __attribute__((always_inline));
-static inline void vm_write_memory_8(vm_addr_t addr, uint64 value) __attribute__((always_inline));
-static inline uint64 vm_do_read_memory_8(uint64 *a) __attribute__((always_inline));
-static inline void vm_do_write_memory_8(uint64 *a, uint64 v) __attribute__((always_inline));
-static inline uint64 generic_bswap_64(uint64 x) __attribute__((always_inline));
-static inline uint32 fp_store_single_convert(uint64 v) __attribute__((always_inline));
-#define INLINE inline __attribute__((always_inline))
-#else
-#define INLINE inline
-#endif
-
 // We need at least 4 general purpose registers
 register struct powerpc_cpu *CPU asm(REG_CPU);
 #define DYNGEN_DEFINE_GLOBAL_REGISTER(REG) \
@@ -82,38 +69,38 @@
  **/
 
 struct powerpc_dyngen_helper {
-	static INLINE uint32 get_pc()				{ return CPU->pc(); }
-	static INLINE void set_pc(uint32 value)		{ CPU->pc() = value; }
-	static INLINE void inc_pc(int32 offset)		{ CPU->pc() += offset; }
-	static INLINE uint32 get_lr()				{ return CPU->lr(); }
-	static INLINE void set_lr(uint32 value)		{ CPU->lr() = value; }
-	static INLINE uint32 get_ctr()				{ return CPU->ctr(); }
-	static INLINE void set_ctr(uint32 value)	{ CPU->ctr() = value; }
-	static INLINE uint32 get_cr()				{ return CPU->cr().get(); }
-	static INLINE void set_cr(uint32 value)		{ CPU->cr().set(value); }
-	static INLINE uint32 get_fpscr()			{ return CPU->fpscr(); }
-	static INLINE void set_fpscr(uint32 value)	{ CPU->fpscr() = value; }
-	static INLINE uint32 get_xer()				{ return CPU->xer().get(); }
-	static INLINE void set_xer(uint32 value)	{ CPU->xer().set(value); }
-	static INLINE uint32 get_vrsave()			{ return CPU->vrsave(); }
-	static INLINE void set_vrsave(uint32 value)	{ CPU->vrsave() = value; }
-	static INLINE uint32 get_vscr()				{ return CPU->vscr().get(); }
-	static INLINE void set_vscr(uint32 value)	{ CPU->vscr().set(value); }
-	static INLINE void record(int crf, int32 v)	{ CPU->record_cr(crf, v); }
-	static INLINE powerpc_cr_register & cr()	{ return CPU->cr(); }
-	static INLINE powerpc_xer_register & xer()	{ return CPU->xer(); }
-	static INLINE powerpc_spcflags & spcflags()	{ return CPU->spcflags(); }
-	static INLINE void set_cr(int crfd, int v)	{ CPU->cr().set(crfd, v); }
-	static INLINE powerpc_registers *regs()		{ return &CPU->regs(); }
+	static inline uint32 get_pc()				{ return CPU->pc(); }
+	static inline void set_pc(uint32 value)		{ CPU->pc() = value; }
+	static inline void inc_pc(int32 offset)		{ CPU->pc() += offset; }
+	static inline uint32 get_lr()				{ return CPU->lr(); }
+	static inline void set_lr(uint32 value)		{ CPU->lr() = value; }
+	static inline uint32 get_ctr()				{ return CPU->ctr(); }
+	static inline void set_ctr(uint32 value)	{ CPU->ctr() = value; }
+	static inline uint32 get_cr()				{ return CPU->cr().get(); }
+	static inline void set_cr(uint32 value)		{ CPU->cr().set(value); }
+	static inline uint32 get_fpscr()			{ return CPU->fpscr(); }
+	static inline void set_fpscr(uint32 value)	{ CPU->fpscr() = value; }
+	static inline uint32 get_xer()				{ return CPU->xer().get(); }
+	static inline void set_xer(uint32 value)	{ CPU->xer().set(value); }
+	static inline uint32 get_vrsave()			{ return CPU->vrsave(); }
+	static inline void set_vrsave(uint32 value)	{ CPU->vrsave() = value; }
+	static inline uint32 get_vscr()				{ return CPU->vscr().get(); }
+	static inline void set_vscr(uint32 value)	{ CPU->vscr().set(value); }
+	static inline void record(int crf, int32 v)	{ CPU->record_cr(crf, v); }
+	static inline powerpc_cr_register & cr()	{ return CPU->cr(); }
+	static inline powerpc_xer_register & xer()	{ return CPU->xer(); }
+	static inline powerpc_spcflags & spcflags()	{ return CPU->spcflags(); }
+	static inline void set_cr(int crfd, int v)	{ CPU->cr().set(crfd, v); }
+	static inline powerpc_registers *regs()		{ return &CPU->regs(); }
 
 #ifndef REG_T3
-	static INLINE uintptr & reg_T3()			{ return CPU->codegen.reg_T3; }
+	static inline uintptr & reg_T3()			{ return CPU->codegen.reg_T3; }
 #endif
 //#ifndef REG_F3
-	static INLINE powerpc_fpr & reg_F3()		{ return CPU->codegen.reg_F3; }
+	static inline powerpc_fpr & reg_F3()		{ return CPU->codegen.reg_F3; }
 //#endif
 
-	static INLINE powerpc_block_info *find_block(uint32 pc) { return CPU->my_block_cache.fast_find(pc); }
+	static inline powerpc_block_info *find_block(uint32 pc) { return CPU->my_block_cache.fast_find(pc); }
 };
 
 // Semantic action templates
@@ -636,7 +623,7 @@
  **/
 
 template< int bo >
-static INLINE void do_prep_branch_bo(void)
+static inline void do_prep_branch_bo(void)
 {
 	bool ctr_ok = true;
 	bool cond_ok = true;
@@ -696,7 +683,7 @@
 	dyngen_barrier();
 }
 
-static INLINE void do_execute_branch_1(uint32 tpc)
+static inline void do_execute_branch_1(uint32 tpc)
 {
 	powerpc_dyngen_helper::set_pc(tpc);
 }
@@ -711,7 +698,7 @@
 	do_execute_branch_1(PARAM1);
 }
 
-static INLINE void do_execute_branch_2(uint32 tpc, uint32 npc)
+static inline void do_execute_branch_2(uint32 tpc, uint32 npc)
 {
 	powerpc_dyngen_helper::set_pc(T1 ? tpc : npc);
 	dyngen_barrier();
@@ -1385,7 +1372,7 @@
  **/
 
 template< int N >
-static INLINE void do_lmw(void)
+static inline void do_lmw(void)
 {
 	CPU->gpr(N) = vm_read_memory_4(T0);
 	T0 += 4;
@@ -1393,21 +1380,20 @@
 }
 
 template<>
-INLINE void do_lmw<31>(void)
+inline void do_lmw<31>(void)
 {
 	CPU->gpr(31) = vm_read_memory_4(T0);
 }
 
 template<>
-INLINE void do_lmw<32>(void)
+inline void do_lmw<32>(void)
 {
 	for (uint32 r = PARAM1, ad = T0; r <= 31; r++, ad += 4)
 		CPU->gpr(r) = vm_read_memory_4(ad);
-	dyngen_barrier();
 }
 
 template< int N >
-static INLINE void do_stmw(void)
+static inline void do_stmw(void)
 {
 	vm_write_memory_4(T0, CPU->gpr(N));
 	T0 += 4;
@@ -1415,17 +1401,16 @@
 }
 
 template<>
-INLINE void do_stmw<31>(void)
+inline void do_stmw<31>(void)
 {
 	vm_write_memory_4(T0, CPU->gpr(31));
 }
 
 template<>
-INLINE void do_stmw<32>(void)
+inline void do_stmw<32>(void)
 {
 	for (uint32 r = PARAM1, ad = T0; r <= 31; r++, ad += 4)
 		vm_write_memory_4(ad, CPU->gpr(r));
-	dyngen_barrier();
 }
 
 #define im 32
@@ -1452,7 +1437,7 @@
 void OPPROTO op_load_ad_V##REG##_VR##N(void)	\
 {												\
 	reg_V##REG = (uintptr)&CPU->vr(N);			\
-}
+}												
 #define DEFINE_REG(N)							\
 DEFINE_OP(D,N);									\
 DEFINE_OP(0,N);									\
@@ -1533,48 +1518,48 @@
 #define VNONE op_VNONE
 struct op_VNONE {
 	typedef null_operand type;
-	static INLINE uint32 get(powerpc_vr const & v, int i) { return 0; }
-	static INLINE void set(powerpc_vr const & v, int i, uint32) { }
+	static inline uint32 get(powerpc_vr const & v, int i) { return 0; }
+	static inline void set(powerpc_vr const & v, int i, uint32) { }
 };
 
 #define V16QI op_V16QI
 struct op_V16QI {
 	typedef uint8 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.b[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.b[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.b[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.b[i] = x; }
 };
 
 #define V8HI op_V8HI
 struct op_V8HI {
 	typedef uint16 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.h[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.h[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.h[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.h[i] = x; }
 };
 
 #define V4SI op_V4SI
 struct op_V4SI {
 	typedef uint32 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.w[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.w[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.w[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.w[i] = x; }
 };
 
 #define V2DI op_V2DI
 struct op_V2DI {
 	typedef uint64 type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.j[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.j[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.j[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.j[i] = x; }
 };
 
 #define V4SF op_V4SF
 struct op_V4SF {
 	typedef float type;
-	static INLINE type get(powerpc_vr const & v, int i) { return v.f[i]; }
-	static INLINE void set(powerpc_vr & v, int i, type x) { v.f[i] = x; }
+	static inline type get(powerpc_vr const & v, int i) { return v.f[i]; }
+	static inline void set(powerpc_vr & v, int i, type x) { v.f[i] = x; }
 };
 
 template< class OP, class VX, class VA, class VB, class VC, int N >
 struct do_vector_execute {
-	static INLINE void apply() {
+	static inline void apply() {
 		do_vector_execute<OP, VX, VA, VB, VC, N - 1>::apply();
 		VX::set(
 			VD, N,
@@ -1587,7 +1572,7 @@
 
 template< class OP, class VX, class VA, class VB, class VC >
 struct do_vector_execute<OP, VX, VA, VB, VC, 0> {
-	static INLINE void apply() {
+	static inline void apply() {
 		VX::set(
 			VD, 0, op_apply<typename VX::type, OP, typename VA::type, typename VB::type, typename VC::type>::apply(
 				VA::get(V0, 0),
@@ -1598,7 +1583,7 @@
 
 template< class OP, class VX, class VA, class VB = VNONE, class VC = VNONE >
 struct vector_execute {
-	static INLINE void apply() {
+	static inline void apply() {
 		do_vector_execute<OP, VX, VA, VB, VC, (16 / sizeof(typename VX::type)) - 1>::apply();
 	}
 };
@@ -1626,7 +1611,7 @@
 #if defined(__i386__) && defined(__SSE__)
 // Workaround gcc 3.2.2 miscompilation that inserts SSE instructions
 struct op_do_vnmsubfp {
-	static INLINE float apply(float x, float y, float z) {
+	static inline float apply(float x, float y, float z) {
 //		return 0. - ((x * z) - y);
 		return y - (x * z);
 	}
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-dyngen.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-dyngen.cpp
@@ -259,7 +259,7 @@
 #undef _
 	default: abort();
 	}
-
+	
 	if (BO_CONDITIONAL_BRANCH(bo) || BO_DECREMENT_CTR(bo)) {
 		// two-way branches
 		if (direct_chaining)
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-execute.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-execute.cpp
@@ -67,7 +67,7 @@
 	disass_ppc(stdout, pc(), opcode);
 
 	// Start up mon in real-mode
-	const char *arg[4] = {"mon", "-m", "-r", NULL};
+	char *arg[4] = {"mon", "-m", "-r", NULL};
 	mon(3, arg);
 #endif
 	abort();
@@ -92,6 +92,16 @@
 	}
 }
 
+static inline int native_to_ppc_rounding_mode(int round)
+{
+	switch (round) {
+	case FE_TONEAREST:	return 0;
+	case FE_TOWARDZERO:	return 1;
+	case FE_UPWARD:		return 2;
+	case FE_DOWNWARD:	return 3;
+	}
+}
+
 /**
  *	Helper class to compute the overflow/carry condition
  *
@@ -521,7 +531,7 @@
 		if (!FPSCR_VE_field::test(fpscr()))
 			fp_classify(d);
 	}
-
+	
 	// Set CR1 (FX, FEX, VX, VOX) if instruction has Rc set
 	if (Rc::test(opcode))
 		record_cr1();
@@ -1223,7 +1233,7 @@
 void powerpc_cpu::execute_mftbr(uint32 opcode)
 {
 	uint32 tbr = TBR::get(this, opcode);
-	uint32 d = 0;
+	uint32 d;
 	switch (tbr) {
 	case 268: d = (uint32)get_tb_ticks(); break;
 	case 269: d = (get_tb_ticks() >> 32); break;
@@ -1620,6 +1630,7 @@
 	typename VA::type const & vA = VA::const_ref(this, opcode);
 	typename VB::type const & vB = VB::const_ref(this, opcode);
 	typename VD::type & vD = VD::ref(this, opcode);
+	const int n_elements = 16 / VD::element_size;
 
 	const int sh = SH::get(this, opcode);
 	if (SD < 0) {
@@ -1689,7 +1700,7 @@
 	typename VB::type const & vB = VB::const_ref(this, opcode);
 	typename VD::type & vD = VD::ref(this, opcode);
 	typename VD::element_type d;
-
+	
 	switch (SZ) {
 	case 1: // vsum
 		d = VB::get_element(vB, 3);
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-registers.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-registers.hpp
@@ -225,7 +225,7 @@
 	static inline int GPR(int r) { return GPR_BASE + r; }
 	static inline int FPR(int r) { return FPR_BASE + r; }
 	static void interrupt_copy(powerpc_registers &oregs, powerpc_registers const &iregs);
-
+	
 	uint32 gpr[32];				// General-Purpose Registers
 	powerpc_fpr fpr[32];		// Floating-Point Registers
 	powerpc_vr vr[32];			// Vector Registers
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-translate.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/ppc/ppc-translate.cpp
@@ -95,7 +95,7 @@
 			target == TARGET_POWERPC ? "d" : "x",
 			start, start + length - 1);
 
-	const char *arg[] = {"mon",
+	char *arg[] = {"mon",
 #ifdef SHEEPSHAVER
 				   "-m",
 #endif
@@ -880,7 +880,8 @@
 			case PPC_I(SUBFIC):
 				dg.gen_subfc_T0_im(val);
 				break;
-			default: abort();
+			  defautl:
+				abort();
 			}
 			dg.gen_store_T0_GPR(rD_field::extract(opcode));
 			break;
@@ -1492,7 +1493,7 @@
 			goto do_invoke;
 		  do_illegal:
 			func = (func_t)nv_mem_fun(&powerpc_cpu::execute_illegal).ptr();
-			goto do_invoke;
+			goto do_invoke;	
 		  do_invoke:
 #if PPC_PROFILE_GENERIC_CALLS
 			if (ii->mnemo <= PPC_I(MAX)) {
Only in macemu/: SheepShaver/src/kpx_cpu/src/cpu/vm.cc
--- macemu/SheepShaver/src/kpx_cpu/src/cpu/vm.hpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/cpu/vm.hpp
@@ -21,119 +21,78 @@
 #ifndef VM_H
 #define VM_H
 
-
-#ifdef i386
-
-#ifndef ___X86___
-#define ___X86___
-#endif
-
-#elif defined __x86_64__
-
-#ifndef ___X86___
-#define ___X86___
-#endif
-
-#endif
-
-#ifdef ___X86___
-#ifdef WORDS_BIGENDIAN
-#undef WORDS_BIGENDIAN
-#endif
-#else
-#warning non-x86 computers are currently unsupported in some parts of this
-#endif
-#ifndef __APPLE__
-#warning non-mac computers are currently unsupported in some parts of this
-#endif
 ///
 ///		Optimized memory accessors
 ///
 
-/*#if defined(__i386__) || defined(__powerpc__) || defined(__ppc__) || defined(__m68k__) || defined(__x86_64__)*/
-#define VM_CAN_ACCESS_UNALIGNED
-/*#endif*/
+#if defined(__i386__) || defined(__powerpc__) || defined(__ppc__) || defined(__m68k__) || defined(__x86_64__)
+# define VM_CAN_ACCESS_UNALIGNED
+#endif
 
 #ifdef WORDS_BIGENDIAN
 
-/*#ifdef VM_CAN_ACCESS_UNALIGNED
+#ifdef VM_CAN_ACCESS_UNALIGNED
 
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_2
-#define VM_OPTIMIZED_MEMORY_ACCESS_2*/
+#define VM_OPTIMIZED_MEMORY_ACCESS_2
 static inline uint32 vm_do_read_memory_2(uint16 *a) { return *a; }
 static inline void vm_do_write_memory_2(uint16 *a, uint32 v) { *a = v; }
-/*#endif
+#endif
 
-
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_4
-#define VM_OPTIMIZED_MEMORY_ACCESS_4*/
+#define VM_OPTIMIZED_MEMORY_ACCESS_4
 static inline uint32 vm_do_read_memory_4(uint32 *a) { return *a; }
 static inline void vm_do_write_memory_4(uint32 *a, uint32 v) { *a = v; }
-/*#endif
+#endif
 
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_8
-#define VM_OPTIMIZED_MEMORY_ACCESS_8*/
+#define VM_OPTIMIZED_MEMORY_ACCESS_8
 static inline uint64 vm_do_read_memory_8(uint64 *a) { return *a; }
 static inline void vm_do_write_memory_8(uint64 *a, uint64 v) { *a = v; }
-/*#endif
+#endif
 
-#endif  VM_CAN_ACCESS_UNALIGNED*/
+#endif /* VM_CAN_ACCESS_UNALIGNED */
 
 #else
 
-/*#ifdef VM_CAN_ACCESS_UNALIGNED
+#ifdef VM_CAN_ACCESS_UNALIGNED
 
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_2
 #define VM_OPTIMIZED_MEMORY_ACCESS_2
 static inline uint32 vm_do_read_memory_2(uint16 *a) { return bswap_16(*a); }
-static inline void vm_do_write_memory_2(uint16 *a, uint32 v) { *a = bswap_16(v); }*/
+static inline void vm_do_write_memory_2(uint16 *a, uint32 v) { *a = bswap_16(v); }
+#endif
 
-#define vm_do_read_memory_2(a) (uint32)bswap_16(*((uint16 *)a))
-#define vm_do_write_memory_2(a, v) *((uint16 *)a) = bswap_16((uint16)v)
-
-/*#endif
-
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_4
 #define VM_OPTIMIZED_MEMORY_ACCESS_4
 static inline uint32 vm_do_read_memory_4(uint32 *a) { return bswap_32(*a); }
-static inline void vm_do_write_memory_4(uint32 *a, uint32 v) { *a = bswap_32(v); }*/
+static inline void vm_do_write_memory_4(uint32 *a, uint32 v) { *a = bswap_32(v); }
+#endif
 
-#define vm_do_read_memory_4(a) bswap_32(*(uint32 *)a)
-#define vm_do_write_memory_4(a, v) *(uint32 *)a = bswap_32((uint32)v)
-
-/*#endif
-
 #ifndef VM_OPTIMIZED_MEMORY_ACCESS_8
 #define VM_OPTIMIZED_MEMORY_ACCESS_8
 static inline uint64 vm_do_read_memory_8(uint64 *a) { return bswap_64(*a); }
-static inline void vm_do_write_memory_8(uint64 *a, uint64 v) { *a = bswap_64(v); }*/
+static inline void vm_do_write_memory_8(uint64 *a, uint64 v) { *a = bswap_64(v); }
+#endif
 
-#define vm_do_read_memory_8(a) bswap_64(*(uint64 *)a)
-#define vm_do_write_memory_8(a, v) *(uint64 *)a = bswap_64((uint64)v)
+#endif /* VM_CAN_ACCESS_UNALIGNED */
 
-/*#endif
+#endif /* WORDS_BIGENDIAN */
 
-#endif  VM_CAN_ACCESS_UNALIGNED*/
-
-#endif  /* WORDS_BIGENDIAN */
-
 ///
 ///		Generic core memory accessors
 ///
 
-#define vm_do_read_memory_1(a) (uint32)*(uint8 *)a
-#define vm_do_write_memory_1(a, v) *(uint8 *)a = (uint8)v
-
-/*static inline uint32 vm_do_read_memory_1(uint8 *a)
+static inline uint32 vm_do_read_memory_1(uint8 *a)
 {
 	return *a;
 }
 static inline void vm_do_write_memory_1(uint8 *a, uint32 v)
 {
 	*a = v;
-}*/
+}
 
-/*#ifndef VM_OPTIMIZED_MEMORY_ACCESS_2
+#ifndef VM_OPTIMIZED_MEMORY_ACCESS_2
 static inline uint32 vm_do_read_memory_2(uint16 *a)
 {
 	uint8 * b = (uint8 *)a;
@@ -190,288 +149,146 @@
 	b[6] = v >> 8;
 	b[7] = v;
 }
-#endif*/
+#endif
 
-#ifdef WORDS_BIGENDIAN
-/*#ifndef VM_OPTIMIZED_MEMORY_ACCESS_2_REVERSED*/
+#ifndef VM_OPTIMIZED_MEMORY_ACCESS_2_REVERSED
 static inline uint32 vm_do_read_memory_2_reversed(uint16 *a)
 {
-	return bswap_16(*a);
+	uint8 * b = (uint8 *)a;
+	return b[0] | (b[1] << 8);
 }
 static inline void vm_do_write_memory_2_reversed(uint16 *a, uint32 v)
 {
-	*a = bswap_16((uint16)v);
+	uint8 * b = (uint8 *)a;
+	b[0] = v;
+	b[1] = v >> 8;
 }
-/*#endif
+#endif
 
-#ifndef VM_OPTIMIZED_MEMORY_ACCESS_4_REVERSED*/
+#ifndef VM_OPTIMIZED_MEMORY_ACCESS_4_REVERSED
 static inline uint32 vm_do_read_memory_4_reversed(uint32 *a)
 {
-	return bswap_32(*a);
+	uint8 * b = (uint8 *)a;
+	return b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
 }
 static inline void vm_do_write_memory_4_reversed(uint32 *a, uint32 v)
 {
-	*a = bswap_32(v);
+	uint8 * b = (uint8 *)a;
+	b[0] = v;
+	b[1] = v >> 8;
+	b[2] = v >> 16;
+	b[3] = v >> 24;
 }
-/*#endif*/
-static inline uint64 vm_do_read_memory_8_reversed(uint64 * a)
-{
-	return bswap_64(*a);
-}
-static inline void vm_do_write_memory_8_reversed(uint64 * a, uint64 v)
-{
-	*a = bswap_64(v);
-}
-#else
-
-#define vm_do_read_memory_2_reversed(a) (uint32)*(uint16 *)a
-#define vm_do_write_memory_2_reversed(a, v) *(uint16 *)a = (uint16)v
-#define vm_do_read_memory_4_reversed(a) *(uint32 *)a
-#define vm_do_write_memory_4_reversed(a, v) *(uint32 *)a = (uint32)v
-#define vm_do_read_memory_8_reversed(a) *(uint64 *)a
-#define vm_do_write_memory_8_reversed(a, v) *(uint64 *)a = (uint64)v
-
-/*static inline uint32 vm_do_read_memory_2_reversed(uint16 * a)
-{
-	return *a;
-}
-static inline void vm_do_write_memory_2_reversed(uint16 * a, uint32 v)
-{
-	*a = (uint16)v;
-}
-static inline uint32 vm_do_read_memory_4_reversed(uint32 * a)
-{
-	return *a;
-}
-static inline void vm_do_write_memory_4_reversed(uint32 * a, uint32 v)
-{
-	*a = v;
-}
-static inline uint64 vm_do_read_memory_8_reversed(uint64 * a)
-{
-	return *a;
-}
-static inline void vm_do_write_memory_8_reversed(uint64 * a, uint64 v)
-{
-	*a = v;
-}*/
-
 #endif
+
 ///
 ///		Actual memory accessors visible to CPU through virtual addresses
 ///
 
 typedef uintptr vm_addr_t;
 
-/*#if REAL_ADDRESSING
-const uintptr VMBaseDiff = 8192;
+#if REAL_ADDRESSING
+const uintptr VMBaseDiff = 0;
 #elif DIRECT_ADDRESSING
 #ifdef NATMEM_OFFSET
 const uintptr VMBaseDiff = NATMEM_OFFSET;
 #endif
-// Wrap address to 32-bit if we are not using 33-bit addressing space
-#if defined(SHEEPSHAVER) && SIZEOF_VOID_P == 8
-#define vm_wrap_address(ADDR) (uintptr)(uint32)(ADDR)
 #endif
-#else
-const uintptr VMBaseDiff = 0x100000000;
-#endif*/
-extern uintptr VMBaseDiff;
-extern uint32 address_size;
-extern uint8 * sheep_mem;
-void vm_ini(uint8 * mem);
-void setSize(uint32 size);
-void init_sheep_mem(uint8 * mem);
 #ifndef vm_wrap_address
 #define vm_wrap_address(ADDR) (ADDR)
 #endif
-#define sheep_base 0x60000000
-#define page_size 4096
-#define NULL_PAGE 0x59000000
-#define NULL_PAGE_SIZE 0x3000
-#define KERNEL_DATA_BASE  0x68ffe000	// Address of Kernel Data
-#define KERNEL_DATA2_BASE  0x5fffe000	// Alternate address of Kernel Data
-#define KERNEL_AREA_SIZE  0x2000		// Size of Kernel Data area
-#define KERNEL_DATA(a) ((a & 0xFFFFE000) == KERNEL_DATA_BASE)
-#define KERNEL_DATA2(a) ((a & 0xFFFFE000) == KERNEL_DATA2_BASE)
-#define KERNEL(a) (KERNEL_DATA(a) || KERNEL_DATA2(a))
-#define in_sheep_mem(addr) ((addr >= sheep_base) && (addr <= (sheep_base + page_size)))
-#define HIMEM(a) ((in_sheep_mem(a))||(KERNEL(a)))
-#define too_big(addr) ((addr >= address_size)&&(!(HIMEM(addr))))
-#define ZERO too_big
-/*too_big(addr) is so we don't crash on too big addresses*/
-#define NO_WRITE ZERO
-/*NO_WRITE is from when I incorrectly disabled writing to the Kernel Data section*/
-/*#if REAL_ADDRESSING || DIRECT_ADDRESSING*/
-extern uint8 /*gZeroPage[0x3000],*/ gKernelData[0x2000];
+
+#if REAL_ADDRESSING || DIRECT_ADDRESSING
 static inline uint8 * vm_do_get_real_address(vm_addr_t addr)
 {
-/*#ifdef __APPLE__
-#ifdef __x86_64__*/
-
-	/*if (a < 0x3000) return &gZeroPage[a];
-	else*/ if (KERNEL(addr)) {
-		return (uint8 *)vm_wrap_address((gKernelData + (addr & 0x1fff)));
-	}
-	else if (in_sheep_mem(addr)) {
-		return (uint8 *)vm_wrap_address((sheep_mem + (addr - sheep_base)));
-	}
-	/*else if (too_big((uint32)addr)) {
-		printf("address too big: 0x%08x\n", addr);
-	}*/
-/*#elif defined i386
-#endif*/
-	/*else*/
 	return (uint8 *)vm_wrap_address(VMBaseDiff + addr);
-
 }
 static inline vm_addr_t vm_do_get_virtual_address(uint8 *addr)
 {
-	if ((addr >= gKernelData) && (addr <= gKernelData + 0x2000)) {
-		return KERNEL_DATA_BASE + addr - gKernelData;
-	}
-	/*else*/
-		return vm_wrap_address((uintptr)addr - VMBaseDiff);
+	return vm_wrap_address((uintptr)addr - VMBaseDiff);
 }
-/*#define vm_do_get_virtual_address(addr) ((vm_addr_t)addr)*/
 static inline uint32 vm_read_memory_1(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_1(vm_do_get_real_address(addr));
+	uint8 * const m = vm_do_get_real_address(addr);
+	return vm_do_read_memory_1(m);
 }
 static inline uint32 vm_read_memory_2(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_2((uint16 *)vm_do_get_real_address(addr));
+	uint16 * const m = (uint16 *)vm_do_get_real_address(addr);
+	return vm_do_read_memory_2(m);
 }
 static inline uint32 vm_read_memory_4(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_4((uint32 *)vm_do_get_real_address(addr));
+	uint32 * const m = (uint32 *)vm_do_get_real_address(addr);
+	return vm_do_read_memory_4(m);
 }
 static inline uint64 vm_read_memory_8(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_8((uint64 *)vm_do_get_real_address(addr));
+	uint64 * const m = (uint64 *)vm_do_get_real_address(addr);
+	return vm_do_read_memory_8(m);
 }
 #define vm_read_memory_1_reversed vm_read_memory_1
 static inline uint32 vm_read_memory_2_reversed(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_2_reversed((uint16 *)vm_do_get_real_address(addr));
+	uint16 * const m = (uint16 *)vm_do_get_real_address(addr);
+	return vm_do_read_memory_2_reversed(m);
 }
 static inline uint32 vm_read_memory_4_reversed(vm_addr_t addr)
 {
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_4_reversed((uint32 *)vm_do_get_real_address(addr));
+	uint32 * const m = (uint32 *)vm_do_get_real_address(addr);
+	return vm_do_read_memory_4_reversed(m);
 }
-static inline uint64 vm_read_memory_8_reversed(vm_addr_t addr)
-{
-	if (ZERO(addr)) {
-		return 0;
-	}
-	return vm_do_read_memory_8_reversed((uint64 *)vm_do_get_real_address(addr));
-}
 static inline void vm_write_memory_1(vm_addr_t addr, uint32 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_1(vm_do_get_real_address(addr), value);
+	uint8 * const m = vm_do_get_real_address(addr);
+	vm_do_write_memory_1(m, value);
 }
 static inline void vm_write_memory_2(vm_addr_t addr, uint32 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_2((uint16 *)vm_do_get_real_address(addr), value);
+	uint16 * const m = (uint16 *)vm_do_get_real_address(addr);
+	vm_do_write_memory_2(m, value);
 }
 static inline void vm_write_memory_4(vm_addr_t addr, uint32 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_4((uint32 *)vm_do_get_real_address(addr), value);
+	uint32 * const m = (uint32 *)vm_do_get_real_address(addr);
+	vm_do_write_memory_4(m, value);
 }
 static inline void vm_write_memory_8(vm_addr_t addr, uint64 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_8((uint64 *)vm_do_get_real_address(addr), value);
+	uint64 * const m = (uint64 *)vm_do_get_real_address(addr);
+	vm_do_write_memory_8(m, value);
 }
 #define vm_write_memory_1_reversed vm_write_memory_1
 static inline void vm_write_memory_2_reversed(vm_addr_t addr, uint32 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_2_reversed((uint16 *)vm_do_get_real_address(addr), value);
+	uint16 * const m = (uint16 *)vm_do_get_real_address(addr);
+	vm_do_write_memory_2_reversed(m, value);
 }
 static inline void vm_write_memory_4_reversed(vm_addr_t addr, uint32 value)
 {
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_4_reversed((uint32 *)vm_do_get_real_address(addr), value);
+	uint32 * const m = (uint32 *)vm_do_get_real_address(addr);
+	vm_do_write_memory_4_reversed(m, value);
 }
-static inline void vm_write_memory_8_reversed(vm_addr_t addr, uint64 value)
-{
-	if (NO_WRITE(addr)) {
-		return;/*just ignore invalid writes*/
-	}
-	vm_do_write_memory_8_reversed((uint64 *)vm_do_get_real_address(addr), value);
-}
 static inline void *vm_memset(vm_addr_t addr, int c, size_t n)
 {
-	if (NO_WRITE(addr)) {
-		return NULL;/*just ignore invalid writes*/
-	}
-	return memset((uint8 *)vm_do_get_real_address(addr), c, n);
+	uint8 * const m = (uint8 *)vm_do_get_real_address(addr);
+	return memset(m, c, n);
 }
 #ifdef __cplusplus
 static inline void *vm_memcpy(void *dest, vm_addr_t src, size_t n)
 {
-	if (ZERO(src)) {
-		return memset(dest, 0, n);
-	}
-	else {
-		return memcpy(dest, vm_do_get_real_address(src), n);
-	}
+	return memcpy(dest, vm_do_get_real_address(src), n);
 }
 static inline void *vm_memcpy(vm_addr_t dest, const void *src, size_t n)
 {
-	if (NO_WRITE(dest)) {
-		return NULL;
-	}
-	/*else*/
-		return memcpy(vm_do_get_real_address(dest), src, n);
+	return memcpy(vm_do_get_real_address(dest), src, n);
 }
 #endif
 static inline void *vm_memcpy(vm_addr_t dest, vm_addr_t src, size_t n)
 {
-	if (NO_WRITE(dest)) {
-		return NULL;
-	}
-	else if (ZERO(src)) {
-		return memset(vm_do_get_real_address(dest), 0, n);
-	}
-	/*else*/
-		return memcpy(vm_do_get_real_address(dest), vm_do_get_real_address(src), n);
+	return memcpy(vm_do_get_real_address(dest), vm_do_get_real_address(src), n);
 }
-/*#endif*/
+#endif
 
 #endif /* VM_H */
 
--- macemu/SheepShaver/src/kpx_cpu/src/mathlib/ieeefp-i386.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/mathlib/ieeefp-i386.cpp
@@ -23,6 +23,10 @@
  *  CPU features
  */
 
+#ifdef _MSC_VER
+#include <float.h>
+#endif
+
 /* XXX: duplicate from cpu/ppc/ppc-dyngen.cpp! */
 static uint32 cpu_features = 0;
 
@@ -36,27 +40,73 @@
 static unsigned int x86_cpuid(void)
 {
 	int fl1, fl2;
+	const unsigned int id_flag = 0x00200000;
 
 	/* See if we can use cpuid. On AMD64 we always can.  */
-	__asm__ ("pushfl; pushfl; popl %0; movl %0,%1; xorl %2,%0;"
-			 "pushl %0; popfl; pushfl; popl %0; popfl"
-			 : "=&r" (fl1), "=&r" (fl2)
-			 : "i" (0x00200000));
-	if (((fl1 ^ fl2) & 0x00200000) == 0)
+#ifdef _MSC_VER
+	__asm {
+		mov edx, id_flag;
+		pushfd;                         /* Save %eflags to restore later.  */
+		pushfd;                         /* Push second copy, for manipulation.  */
+		pop ebx;                        /* Pop it into post_change.  */
+		mov eax, ebx;                   /* Save copy in pre_change.   */
+		xor ebx, edx;                   /* Tweak bit in post_change.  */
+		push ebx;                       /* Push tweaked copy... */
+		popfd;                          /* ... and pop it into eflags.  */
+		pushfd;                         /* Did it change?  Push new %eflags... */
+		pop ebx;                        /* ... and pop it into post_change.  */
+		popfd;                          /* Restore original value.  */
+		mov fl1, eax;
+		mov fl2, ebx;
+	}
+#else
+	asm ("pushfl\n\t"          /* Save %eflags to restore later.  */
+		 "pushfl\n\t"          /* Push second copy, for manipulation.  */
+		 "popl %1\n\t"         /* Pop it into post_change.  */
+		 "movl %1,%0\n\t"      /* Save copy in pre_change.   */
+		 "xorl %2,%1\n\t"      /* Tweak bit in post_change.  */
+		 "pushl %1\n\t"        /* Push tweaked copy... */
+		 "popfl\n\t"           /* ... and pop it into %eflags.  */
+		 "pushfl\n\t"          /* Did it change?  Push new %eflags... */
+		 "popl %1\n\t"         /* ... and pop it into post_change.  */
+		 "popfl"               /* Restore original value.  */
+		 : "=&r" (fl1), "=&r" (fl2)
+		 : "ir" (id_flag));
+#endif
+	if (((fl1 ^ fl2) & id_flag) == 0)
 		return (0);
 
 	/* Host supports cpuid.  See if cpuid gives capabilities, try
 	   CPUID(0).  Preserve %ebx and %ecx; cpuid insn clobbers these, we
 	   don't need their CPUID values here, and %ebx may be the PIC
 	   register.  */
+#ifdef _MSC_VER
+	__asm {
+		xor ecx, ecx;
+		xor eax, eax;
+		cpuid;
+		mov fl1, eax;
+	}
+#else
 	__asm__ ("push %%ecx ; push %%ebx ; cpuid ; pop %%ebx ; pop %%ecx"
 			 : "=a" (fl1) : "0" (0) : "edx", "cc");
+#endif
 	if (fl1 == 0)
 		return (0);
 
 	/* Invoke CPUID(1), return %edx; caller can examine bits to
 	   determine what's supported.  */
+#ifdef _MSC_VER
+	__asm {
+		xor ecx, ecx;
+		xor ebx, ebx;
+		mov eax, 1;
+		cpuid;
+		mov fl2, edx;
+	}
+#else
 	__asm__ ("push %%ecx ; push %%ebx ; cpuid ; pop %%ebx ; pop %%ecx" : "=d" (fl2) : "a" (1) : "cc");
+#endif
 
 	return fl2;
 }
@@ -79,18 +129,22 @@
 // Get current rounding direction
 int fegetround(void)
 {
+#ifdef _MSC_VER
+	return _status87() & _MCW_RC;
+#else
 	unsigned short cw;
-
 	__asm__ __volatile__("fnstcw %0" : "=m" (*&cw));
-
 	return cw & 0xc00;
+#endif
 }
 
 // Set the rounding direction represented by ROUND
 int fesetround(int round)
 {
-	unsigned short cw;
-
+#ifdef _MSC_VER
+	_control87(round, _MCW_RC);
+#else
+	uint16 cw;
 	if ((round & ~0xc00) != 0)
 		return 1;
 
@@ -106,6 +160,7 @@
 		xcw |= round << 3;
 		__asm__ __volatile__("ldmxcsr %0" : : "m" (*&xcw));
 	}
+#endif
 
 	return 0;
 }
--- macemu/SheepShaver/src/kpx_cpu/src/mathlib/mathlib-i386.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/mathlib/mathlib-i386.cpp
@@ -24,6 +24,10 @@
 #define HAVE_TRUNC
 double trunc(double x)
 {
+#ifdef _MSC_VER
+	/* FIXME: This is probably semantically wrong, and it's slow. */
+	return (double)((long long)x);
+#else
 	volatile unsigned short int cw;
 	volatile unsigned short int cwtmp;
 	double value;
@@ -34,5 +38,11 @@
 	__asm__ __volatile__("frndint" : "=t" (value) : "0" (x));
 	__asm__ __volatile__("fldcw %0" : : "m" (cw));
 	return value;
+#endif
+}
+
+float truncf(float x)
+{
+	return (float)trunc((float)x);
 }
 #endif
--- macemu/SheepShaver/src/kpx_cpu/src/mathlib/mathlib.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/mathlib/mathlib.cpp
@@ -88,6 +88,7 @@
 int mathlib_fpclassifyl(long double x)
 {
 	unimplemented("fpclassifyl");
+	return -1;
 }
 
 
@@ -114,6 +115,7 @@
 int mathlib_signbitl(long double x)
 {
 	unimplemented("signbitl");
+	return -1;
 }
 
 
@@ -191,7 +193,7 @@
 float mathlib_roundf(float x)
 {
 	int32 i0, j0;
-	static const float huge = 1.0e30;
+	static const float huge = 1.0e30f;
 
 	MATHLIB_GET_FLOAT_WORD (i0, x);
 	j0 = ((i0 >> 23) & 0xff) - 0x7f;
--- macemu/SheepShaver/src/kpx_cpu/src/test/test-powerpc.cpp
+++ sheepshaver/SheepShaver/src/kpx_cpu/src/test/test-powerpc.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-// NOTE: Results file md5sum: 3e29432abb6e21e625a2eef8cf2f0840 ($Revision$)
+// NOTE: Results file md5sum: 3e29432abb6e21e625a2eef8cf2f0840 ($Revision: 1.35 $)
 
 #include <vector>
 #include <limits>
@@ -38,8 +38,8 @@
 #if EMU_KHEPERIX
 #include "sysdeps.h"
 #include "vm_alloc.h"
-/*#include "cpu/ppc/ppc-cpu.hpp"
-#include "cpu/ppc/ppc-instructions.hpp"*/
+#include "cpu/ppc/ppc-cpu.hpp"
+#include "cpu/ppc/ppc-instructions.hpp"
 #endif
 
 #if EMU_MICROLIB
@@ -64,14 +64,14 @@
 typedef int BOOL;
 #endif
 
-/*#if EMU_QEMU
+#if EMU_QEMU
 extern "C" {
 #include "target-ppc/cpu.h"
 extern void tb_flush();
-}*/
+}
 typedef uint32_t uint32;
 typedef uintptr_t uintptr;
-/*#endif*/
+#endif
 
 // Disassemblers needed for debugging purposes
 #if ENABLE_MON
@@ -176,7 +176,7 @@
 
     p = start & ~(MIN_CACHE_LINE_SIZE - 1);
     stop = (stop + MIN_CACHE_LINE_SIZE - 1) & ~(MIN_CACHE_LINE_SIZE - 1);
-
+    
     for (p = start; p < stop; p += MIN_CACHE_LINE_SIZE) {
         asm volatile ("dcbst 0,%0" : : "r"(p) : "memory");
     }
@@ -193,18 +193,12 @@
 }
 #endif
 
-/*#if EMU_KHEPERIX
-// Wrappers when building from SheepShaver tree*/
+#if EMU_KHEPERIX
+// Wrappers when building from SheepShaver tree
 #ifdef SHEEPSHAVER
-uint32 ROMBase = 0x40800000;
 int64 TimebaseSpeed = 25000000;	// Default:  25 MHz
 uint32 PVR = 0x000c0000;		// Default: 7400 (with AltiVec)
 
-bool PrefsFindBool(const char *name)
-{
-	return false;
-}
-
 uint64 GetTicks_usec(void)
 {
 	return clock();
@@ -214,12 +208,12 @@
 {
 }
 
-/*#if PPC_ENABLE_JIT && PPC_REENTRANT_JIT
+#if PPC_ENABLE_JIT && PPC_REENTRANT_JIT
 void init_emul_op_trampolines(basic_dyngen & dg)
 {
 }
-#endif*/
 #endif
+#endif
 
 struct powerpc_cpu_base
 	: public powerpc_cpu
@@ -987,7 +981,7 @@
 	const uint32 emul_rd = get_gpr(RD);
 	const uint32 emul_xer = emul_get_xer();
 	const uint32 emul_cr = emul_get_cr();
-
+	
 	++tests;
 
 	bool ok = native_rd == emul_rd
--- macemu/SheepShaver/src/macos_util.cpp
+++ sheepshaver/SheepShaver/src/macos_util.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "cpu_emulation.h"
 #include "main.h"
 #include "sony.h"
@@ -179,7 +179,7 @@
 
 	if (ReadMacInt32(XLM_RUN_MODE) == MODE_EMUL_OP) {
 		M68kRegisters r;
-
+	
 		// Find shared library
 		static const uint8 proc1_template[] = {
 			0x55, 0x8f,							// subq.l	#2,a7
@@ -203,7 +203,7 @@
 		D(bug(" GetSharedLibrary: ret %d, connection ID %ld, main %p\n", (int16)r.d[0], conn_id.value(), main_addr.value()));
 		if (r.d[0])
 			return 0;
-
+	
 		// Find symbol
 		static const uint8 proc2_template[] = {
 			0x55, 0x8f,					// subq.l	#2,a7
@@ -324,13 +324,7 @@
 	// This code is taken from glibc 2.2
 
 	// Convert to number of seconds elapsed since 1-Jan-1904
-#ifdef WIN32
 	struct tm *local = localtime(&t);
-#else
-	struct tm result;
-	localtime_r(&t, &result);
-	struct tm *local = &result;
-#endif
 	const int TM_EPOCH_YEAR = 1900;
 	const int MAC_EPOCH_YEAR = 1904;
 	int a4 = ((local->tm_year + TM_EPOCH_YEAR) >> 2) - !(local->tm_year & 3);
@@ -342,17 +336,6 @@
 	int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);
 	uint32 days = local->tm_yday + 365 * (local->tm_year - 4) + intervening_leap_days;
 	return local->tm_sec + 60 * (local->tm_min + 60 * (local->tm_hour + 24 * days));
-}
-
-
-/*
- *  Convert MacOS time to time_t (seconds since 1.1.1970)
- */
-
-time_t MacTimeToTime(uint32 t)
-{
-	// simply subtract number of seconds between 1.1.1904 and 1.1.1970
-	return t - 2082826800;
 }
 
 
--- macemu/SheepShaver/src/main.cpp
+++ sheepshaver/SheepShaver/src/main.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include "main.h"
 #include "version.h"
@@ -44,13 +44,13 @@
 #include "macos_util.h"
 #include "rom_patches.h"
 #include "user_strings.h"
-#include "CrossPlatform/vm_alloc.h"
-#include "CrossPlatform/sigsegv.h"
+#include "vm_alloc.h"
+#include "sigsegv.h"
 #include "thunks.h"
 
 #define DEBUG 0
 #include "debug.h"
-extern uint8 gKernelData[];
+
 #ifdef ENABLE_MON
 #include "mon.h"
 
@@ -133,7 +133,7 @@
 	SCSIInit();
 
 	// Init external file system
-	ExtFSInit();
+	ExtFSInit(); 
 
 	// Init ADB
 	ADBInit();
@@ -164,62 +164,63 @@
 	}
 
 	// Initialize Kernel Data
-	memset(gKernelData, 0, sizeof(KernelData));
+	KernelData *kernel_data = (KernelData *)Mac2HostAddr(KERNEL_DATA_BASE);
+	memset(kernel_data, 0, sizeof(KernelData));
 	if (ROMType == ROMTYPE_NEWWORLD) {
 		uint32 of_dev_tree = SheepMem::Reserve(4 * sizeof(uint32));
 		Mac_memset(of_dev_tree, 0, 4 * sizeof(uint32));
 		uint32 vector_lookup_tbl = SheepMem::Reserve(128);
 		uint32 vector_mask_tbl = SheepMem::Reserve(64);
-		Mac_memset(KERNEL_DATA_BASE + 0xb80, 0x3d, 0x80);
+		memset((uint8 *)kernel_data + 0xb80, 0x3d, 0x80);
 		Mac_memset(vector_lookup_tbl, 0, 128);
 		Mac_memset(vector_mask_tbl, 0, 64);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xb80, ROMBase);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xb84, of_dev_tree);			// OF device tree base
-		WriteMacInt32(KERNEL_DATA_BASE + 0xb90, vector_lookup_tbl);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xb94, vector_mask_tbl);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xb98, ROMBase);				// OpenPIC base
-		WriteMacInt32(KERNEL_DATA_BASE + 0xbb0, 0);						// ADB base
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc20, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc24, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc30, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc34, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc38, 0x00010020);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc3c, 0x00200001);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc40, 0x00010000);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc50, RAMBase);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc54, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf60, PVR);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf64, CPUClockSpeed);			// clock-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf68, BusClockSpeed);			// bus-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf6c, TimebaseSpeed);			// timebase-frequency
+		kernel_data->v[0xb80 >> 2] = htonl(ROMBase);
+		kernel_data->v[0xb84 >> 2] = htonl(of_dev_tree);			// OF device tree base
+		kernel_data->v[0xb90 >> 2] = htonl(vector_lookup_tbl);
+		kernel_data->v[0xb94 >> 2] = htonl(vector_mask_tbl);
+		kernel_data->v[0xb98 >> 2] = htonl(ROMBase);				// OpenPIC base
+		kernel_data->v[0xbb0 >> 2] = htonl(0);						// ADB base
+		kernel_data->v[0xc20 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc24 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc30 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc34 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc38 >> 2] = htonl(0x00010020);
+		kernel_data->v[0xc3c >> 2] = htonl(0x00200001);
+		kernel_data->v[0xc40 >> 2] = htonl(0x00010000);
+		kernel_data->v[0xc50 >> 2] = htonl(RAMBase);
+		kernel_data->v[0xc54 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xf60 >> 2] = htonl(PVR);
+		kernel_data->v[0xf64 >> 2] = htonl(CPUClockSpeed);			// clock-frequency
+		kernel_data->v[0xf68 >> 2] = htonl(BusClockSpeed);			// bus-frequency
+		kernel_data->v[0xf6c >> 2] = htonl(TimebaseSpeed);			// timebase-frequency
 	} else if (ROMType == ROMTYPE_GOSSAMER) {
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc80, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc84, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc90, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc94, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc98, 0x00010020);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc9c, 0x00200001);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xca0, 0x00010000);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xcb0, RAMBase);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xcb4, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf60, PVR);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf64, CPUClockSpeed);			// clock-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf68, BusClockSpeed);			// bus-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf6c, TimebaseSpeed);			// timebase-frequency
+		kernel_data->v[0xc80 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc84 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc90 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc94 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc98 >> 2] = htonl(0x00010020);
+		kernel_data->v[0xc9c >> 2] = htonl(0x00200001);
+		kernel_data->v[0xca0 >> 2] = htonl(0x00010000);
+		kernel_data->v[0xcb0 >> 2] = htonl(RAMBase);
+		kernel_data->v[0xcb4 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xf60 >> 2] = htonl(PVR);
+		kernel_data->v[0xf64 >> 2] = htonl(CPUClockSpeed);			// clock-frequency
+		kernel_data->v[0xf68 >> 2] = htonl(BusClockSpeed);			// bus-frequency
+		kernel_data->v[0xf6c >> 2] = htonl(TimebaseSpeed);			// timebase-frequency
 	} else {
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc80, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc84, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc90, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc94, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc98, 0x00010020);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xc9c, 0x00200001);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xca0, 0x00010000);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xcb0, RAMBase);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xcb4, RAMSize);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf80, PVR);
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf84, CPUClockSpeed);			// clock-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf88, BusClockSpeed);			// bus-frequency
-		WriteMacInt32(KERNEL_DATA_BASE + 0xf8c, TimebaseSpeed);			// timebase-frequency
+		kernel_data->v[0xc80 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc84 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc90 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc94 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xc98 >> 2] = htonl(0x00010020);
+		kernel_data->v[0xc9c >> 2] = htonl(0x00200001);
+		kernel_data->v[0xca0 >> 2] = htonl(0x00010000);
+		kernel_data->v[0xcb0 >> 2] = htonl(RAMBase);
+		kernel_data->v[0xcb4 >> 2] = htonl(RAMSize);
+		kernel_data->v[0xf80 >> 2] = htonl(PVR);
+		kernel_data->v[0xf84 >> 2] = htonl(CPUClockSpeed);			// clock-frequency
+		kernel_data->v[0xf88 >> 2] = htonl(BusClockSpeed);			// bus-frequency
+		kernel_data->v[0xf8c >> 2] = htonl(TimebaseSpeed);			// timebase-frequency
 	}
 
 	// Initialize extra low memory
@@ -230,8 +231,8 @@
 	WriteMacInt32(XLM_PVR, PVR);									// Theoretical PVR
 	WriteMacInt32(XLM_BUS_CLOCK, BusClockSpeed);					// For DriverServicesLib patch
 	WriteMacInt16(XLM_EXEC_RETURN_OPCODE, M68K_EXEC_RETURN);		// For Execute68k() (RTS from the executed 68k code will jump here and end 68k mode)
-	WriteMacInt32(XLM_ZERO_PAGE, /*SheepMem::ZeroPage()*//*0*/NULL_PAGE);	// Pointer to read-only page with all bits set to 0
-#if !EMULATED_PPC
+	WriteMacInt32(XLM_ZERO_PAGE, SheepMem::ZeroPage());				// Pointer to read-only page with all bits set to 0
+#if !defined(EMULATED_PPC)
 #ifdef SYSTEM_CLOBBERS_R2
 	WriteMacInt32(XLM_TOC, (uint32)TOC);							// TOC pointer of emulator
 #endif
--- macemu/SheepShaver/src/name_registry.cpp
+++ sheepshaver/SheepShaver/src/name_registry.cpp
@@ -20,7 +20,7 @@
 
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "name_registry.h"
 #include "main.h"
 #include "macos_util.h"
Only in macemu/: SheepShaver/src/pict.c
--- macemu/SheepShaver/src/prefs.cpp
+++ sheepshaver/SheepShaver/src/prefs.cpp
@@ -23,7 +23,7 @@
 #include <stdio.h>
 #include <ctype.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "sys.h"
 #include "prefs.h"
 
@@ -382,15 +382,12 @@
 void LoadPrefsFromStream(FILE *f)
 {
 	char line[256];
-	while(fgets(line, sizeof(line), f)) {
-		// Remove newline, if present
+	while(fgets(line, 255, f)) {
+		// Read line
 		int len = strlen(line);
-		if (len > 0 && line[len-1] == '\n') {
-			line[len-1] = '\0';
-			len--;
-		}
 		if (len == 0)
 			continue;
+		line[len-1] = 0;
 
 		// Comments begin with "#" or ";"
 		if (line[0] == '#' || line[0] == ';')
@@ -398,12 +395,11 @@
 
 		// Terminate string after keyword
 		char *p = line;
-		while (*p && !isspace(*p)) p++;
-		if (*p != '\0')
-			*p++ = 0;
+		while (!isspace(*p)) p++;
+		*p++ = 0;
 
 		// Skip whitespace until value
-		while (*p && isspace(*p)) p++;
+		while (isspace(*p)) p++;
 		char *keyword = line;
 		char *value = p;
 		int32 i = atol(value);
--- macemu/SheepShaver/src/prefs_items.cpp
+++ sheepshaver/SheepShaver/src/prefs_items.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include "sys.h"
 #include "prefs.h"
--- macemu/SheepShaver/src/rom_patches.cpp
+++ sheepshaver/SheepShaver/src/rom_patches.cpp
@@ -26,7 +26,7 @@
 
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "rom_patches.h"
 #include "main.h"
 #include "prefs.h"
@@ -60,10 +60,9 @@
 
 // Other ROM addresses
 const uint32 CHECK_LOAD_PATCH_SPACE = 0x2fcf00;
-const uint32 ZERO_SCRAP_PATCH_SPACE = 0x2fcf80;
-const uint32 PUT_SCRAP_PATCH_SPACE = 0x2fcfc0;
-const uint32 GET_SCRAP_PATCH_SPACE = 0x2fd100;
-const uint32 ADDR_MAP_PATCH_SPACE = 0x2fd140;
+const uint32 PUT_SCRAP_PATCH_SPACE = 0x2fcf80;
+const uint32 GET_SCRAP_PATCH_SPACE = 0x2fcfc0;
+const uint32 ADDR_MAP_PATCH_SPACE = 0x2fd100;
 
 // Global variables
 int ROMType;				// ROM type
@@ -156,7 +155,7 @@
 		// CHRP compressed ROM image
 		uint32 image_offset, image_size;
 		bool decode_info_ok = false;
-
+		
 		char *s = strstr((char *)data, "constant lzss-offset");
 		if (s != NULL) {
 			// Probably a plain LZSS compressed ROM image
@@ -177,11 +176,11 @@
 				}
 			}
 		}
-
+		
 		// No valid information to decode the ROM found?
 		if (!decode_info_ok)
 			return false;
-
+		
 		// Check signature, this could be a parcels-based ROM image
 		uint32 rom_signature = ntohl(*(uint32 *)(data + image_offset));
 		if (rom_signature == FOURCC('p','r','c','l')) {
@@ -665,6 +664,23 @@
 
 
 /*
+ *  Copy PowerPC code to ROM image and reverse bytes if necessary
+ */
+
+static inline void memcpy_powerpc_code(void *dst, const void *src, size_t len)
+{
+#ifdef WORDS_BIGENDIAN
+	(void)memcpy(dst, src, len);
+#else
+	uint32 *d = (uint32 *)dst;
+	uint32 *s = (uint32 *)src;
+	for (int i = 0; i < len/4; i++)
+		d[i] = htonl(s[i]);
+#endif
+}
+
+
+/*
  *  Install ROM patches (RAMBase and KernelDataAddr must be set)
  */
 
@@ -697,8 +713,6 @@
 	// Check that other ROM addresses point to really free regions
 	if (!check_rom_patch_space(CHECK_LOAD_PATCH_SPACE, 0x40))
 		return false;
-	if (!check_rom_patch_space(ZERO_SCRAP_PATCH_SPACE, 0x40))
-		return false;
 	if (!check_rom_patch_space(PUT_SCRAP_PATCH_SPACE, 0x40))
 		return false;
 	if (!check_rom_patch_space(GET_SCRAP_PATCH_SPACE, 0x40))
@@ -1012,7 +1026,7 @@
 	if ((base = find_rom_data(0x310000, 0x320000, pm_check_dat, sizeof(pm_check_dat))) == 0) return false;
 	D(bug("pm_check %08lx\n", base));
 	lp = (uint32 *)(ROMBaseHost + base);
-
+	
 	static const int spr_check_list[] = {
 		952 /* mmcr0 */, 953 /* pmc1 */, 954 /* pmc2 */, 955 /* sia */,
 		956 /* mmcr1 */, 957 /* pmc3 */, 958 /* pmc4 */, 959 /* sda */
@@ -1081,7 +1095,7 @@
 	*lp++ = htonl(POWERPC_ILLEGAL);
 	*lp = htonl(POWERPC_ILLEGAL);
 
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	// Install EMUL_RETURN, EXEC_RETURN, EXEC_NATIVE and EMUL_OP opcodes
 	lp = (uint32 *)(ROMBaseHost + 0x380000 + (M68K_EMUL_RETURN << 3));
 	*lp++ = htonl(POWERPC_EMUL_OP);
@@ -2281,16 +2295,6 @@
 		*wp++ = htons((level1_int - 12) >> 16);
 		*wp = htons((level1_int - 12) & 0xffff);
 	}
-
-	// Patch ZeroScrap() for clipboard exchange with host OS
-	uint32 zero_scrap = find_rom_trap(0xa9fc);	// ZeroScrap()
-	wp = (uint16 *)(ROMBaseHost + ZERO_SCRAP_PATCH_SPACE);
-	*wp++ = htons(M68K_EMUL_OP_ZERO_SCRAP);
-	*wp++ = htons(M68K_JMP);
-	*wp++ = htons((ROMBase + zero_scrap) >> 16);
-	*wp++ = htons((ROMBase + zero_scrap) & 0xffff);
-	base = ROMBase + ReadMacInt32(ROMBase + 0x22);
-	WriteMacInt32(base + 4 * (0xa9fc & 0x3ff), ZERO_SCRAP_PATCH_SPACE);
 
 	// Patch PutScrap() for clipboard exchange with host OS
 	uint32 put_scrap = find_rom_trap(0xa9fe);	// PutScrap()
--- macemu/SheepShaver/src/rsrc_patches.cpp
+++ sheepshaver/SheepShaver/src/rsrc_patches.cpp
@@ -22,7 +22,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "rsrc_patches.h"
 #include "cpu_emulation.h"
 #include "emul_op.h"
@@ -627,7 +627,7 @@
 
 	if (type == FOURCC('D','R','V','R') && strncmp(&name[1], ".AFPTranslator", name[0]) == 0) {
 		D(bug(" DRVR .AFPTranslator found\n"));
-
+		
 		// Don't access ROM85 as it it was a pointer to a ROM version number (8.0, 8.1)
 		static const uint8 dat[] = {0x3a, 0x2e, 0x00, 0x0a, 0x55, 0x4f, 0x3e, 0xb8, 0x02, 0x8e, 0x30, 0x1f, 0x48, 0xc0, 0x24, 0x40, 0x20, 0x40};
 		base = find_rsrc_data(p, size, dat, sizeof(dat));
@@ -935,7 +935,7 @@
 	D(bug(" GetResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_RES_LIB_TOC, ReadMacInt32(tvec + 4));
 	WriteMacInt32(XLM_GET_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -952,7 +952,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" Get1Resource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_GET_1_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_1_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -969,7 +969,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" GetIndResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_GET_IND_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_IND_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -986,7 +986,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" Get1IndResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_GET_1_IND_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_1_IND_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -1003,7 +1003,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" RGetResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_R_GET_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_R_GET_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -1020,7 +1020,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" GetNamedResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_GET_NAMED_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_NAMED_RESOURCE));
 #else
 #ifdef __BEOS__
@@ -1037,7 +1037,7 @@
 	tvec = ReadMacInt32(upp + 5 * 4);
 	D(bug(" Get1NamedResource() entry %08x, TOC %08x\n", ReadMacInt32(tvec), ReadMacInt32(tvec + 4)));
 	WriteMacInt32(XLM_GET_1_NAMED_RESOURCE, ReadMacInt32(tvec));
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	WriteMacInt32(tvec, NativeFunction(NATIVE_GET_1_NAMED_RESOURCE));
 #else
 #ifdef __BEOS__
--- macemu/SheepShaver/src/scsi.cpp
+++ sheepshaver/SheepShaver/src/scsi.cpp
@@ -27,7 +27,7 @@
 #include <stdio.h>
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "cpu_emulation.h"
 #include "main.h"
 #include "user_strings.h"
@@ -115,11 +115,10 @@
 		switch (cmd) {
 			case scInc:
 				WriteMacInt32(tib - 8, ptr + len);
-				// fall through to scNoInc
 			case scNoInc:
-				if ((sg_index > 0) && (Mac2HostAddr(ptr) == sg_ptr[sg_index-1] + sg_len[sg_index-1])) {
+				if ((sg_index > 0) && (Mac2HostAddr(ptr) == sg_ptr[sg_index-1] + sg_len[sg_index-1]))
 					sg_len[sg_index-1] += len;				// Merge to previous entry
-				} else {
+				else {
 					if (sg_index == SG_TABLE_SIZE) {
 						ErrorAlert(GetString(STR_SCSI_SG_FULL_ERR));
 						return -108;
@@ -209,20 +208,21 @@
 		return scSequenceErr;
 
 	// ID valid?
-	if (id < 0 || id > 7)
-		return scBadParmsErr;
+	if (id >= 0 && id <= 7) {
+		target_id = id;
 
-	// Target present?
-	target_id = id;
-	if (!scsi_is_target_present(target_id)) {
-		phase = PH_FREE;
-		fake_status = 0x0000;	// Bus free
-		return scCommErr;
+		// Target present?
+		if (scsi_is_target_present(target_id)) {
+			phase = PH_SELECTED;
+			fake_status = 0x006a;			// Target selected, command phase
+			return 0;
+		}
 	}
 
-	phase = PH_SELECTED;
-	fake_status = 0x006a;		// Target selected, command phase
-	return 0;
+	// Error
+	phase = PH_FREE;
+	fake_status = 0x0000;		// Bus free
+	return scCommErr;
 }
 
 
--- macemu/SheepShaver/src/serial.cpp
+++ sheepshaver/SheepShaver/src/serial.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "main.h"
 #include "macos_util.h"
 #include "serial.h"
@@ -244,7 +244,7 @@
 				WriteMacInt16(pb + csParam + 6, 0x0616);
 				res = noErr;
 				break;
-
+	
 			default:
 				res = the_port->status(pb, dce, code);
 				break;
--- macemu/SheepShaver/src/sony.cpp
+++ sheepshaver/SheepShaver/src/sony.cpp
@@ -28,7 +28,7 @@
  *    Technote FL 24: "Don't Look at ioPosOffset for Devices"
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 
 #include <string.h>
 #include <vector>
@@ -115,6 +115,7 @@
 	void *fh;			// Floppy driver file handle
 	bool to_be_mounted;	// Flag: drive must be mounted in accRun
 	bool read_only;		// Flag: force write protection
+	uint32 tag_buffer;	// Mac address of tag buffer
 	uint32 status;		// Mac address of drive status record
 };
 
@@ -282,6 +283,7 @@
 
 		info->num = FindFreeDriveNumber(1);
 		info->to_be_mounted = false;
+		info->tag_buffer = 0;
 
 		if (info->fh) {
 
@@ -300,9 +302,9 @@
 			WriteMacInt8(info->status + dsSides, 0xff);
 			WriteMacInt8(info->status + dsTwoSideFmt, 0xff);
 			WriteMacInt8(info->status + dsNewIntf, 0xff);
-			WriteMacInt8(info->status + dsMFMDrive, 0xff);	// SuperDrive (0 = 400/800K GCR drive)
-			WriteMacInt8(info->status + dsMFMDisk, 0xff);	// MFM (0 = GCR)
-			WriteMacInt8(info->status + dsTwoMegFmt, 0xff);	// 1.44MB (0 = 720K)
+			WriteMacInt8(info->status + dsMFMDrive, 0xff);
+			WriteMacInt8(info->status + dsMFMDisk, 0xff);
+			WriteMacInt8(info->status + dsTwoMegFmt, 0xff);
 
 			// Disk in drive?
 			if (SysIsDiskInserted(info->fh)) {
@@ -387,10 +389,10 @@
 
 	// General codes
 	switch (code) {
-		case 1:		// KillIO (not supported)
+		case 1:		// KillIO
 			return set_dsk_err(-1);
 
-		case 9:		// Track cache control (ignore, assume that host OS does the caching)
+		case 9:		// Track cache
 			return set_dsk_err(noErr);
 
 		case 65:	// Periodic action (accRun, "insert" disks on startup)
@@ -409,30 +411,30 @@
 	// Drive-specific codes
 	int16 err = noErr;
 	switch (code) {
-		case 5:			// Verify disk
-			if (ReadMacInt8(info->status + dsDiskInPlace) <= 0) {
-				err = offLinErr;
-			}
+		case 5:		// Verify disk
+			if (ReadMacInt8(info->status + dsDiskInPlace) <= 0)
+				err = verErr;
 			break;
 
-		case 6:			// Format disk
-			if (info->read_only) {
+		case 6:		// Format disk
+			if (info->read_only)
 				err = wPrErr;
-			} else if (ReadMacInt8(info->status + dsDiskInPlace) > 0) {
+			else if (ReadMacInt8(info->status + dsDiskInPlace) > 0) {
 				if (!SysFormat(info->fh))
 					err = writErr;
 			} else
 				err = offLinErr;
 			break;
 
-		case 7:			// Eject
+		case 7:		// Eject
 			if (ReadMacInt8(info->status + dsDiskInPlace) > 0) {
 				SysEject(info->fh);
 				WriteMacInt8(info->status + dsDiskInPlace, 0);
 			}
 			break;
 
-		case 8:			// Set tag buffer (ignore, not supported)
+		case 8:		// Set tag buffer
+			info->tag_buffer = ReadMacInt32(pb + csParam);
 			break;
 
 		case 21:		// Get drive icon
@@ -444,26 +446,18 @@
 			break;
 
 		case 23:		// Get drive info
-			if (info->num == 1) {
-				WriteMacInt32(pb + csParam, 0x0004);	// Internal SuperDrive
-			} else {
-				WriteMacInt32(pb + csParam, 0x0104);	// External SuperDrive
-			}
+			if (info->num == 1)
+				WriteMacInt32(pb + csParam, 0x0004);	// Internal drive
+			else
+				WriteMacInt32(pb + csParam, 0x0104);	// External drive
 			break;
 
-//		case 0x4350:	// Enable/disable retries ('CP') (not supported)
-//			break;
-
-//		case 0x4744:	// Get raw track data ('GD') (not supported)
-//			break;
-
-		case 0x5343:	// Format and write to disk ('SC') in one pass, used by DiskCopy to speed things up
-			if (!ReadMacInt8(info->status + dsDiskInPlace)) {
+		case 0x5343:	// Format and write to disk ('SC'), used by DiskCopy
+			if (!ReadMacInt8(info->status + dsDiskInPlace))
 				err = offLinErr;
-			} else if (info->read_only) {
+			else if (info->read_only)
 				err = wPrErr;
-			} else {
-				// Assume that the disk is already formatted and only write the data
+			else {
 				void *data = Mac2HostAddr(ReadMacInt32(pb + csParam + 2));
 				size_t actual = Sys_write(info->fh, data, 0, 2880*512);
 				if (actual != 2880*512)
@@ -497,44 +491,30 @@
 
 	int16 err = noErr;
 	switch (code) {
-		case 6:			// Return list of supported disk formats
-			if (ReadMacInt16(pb + csParam) > 0) {	// At least one entry requested?
+		case 6:		// Return format list
+			if (ReadMacInt16(pb + csParam) > 0) {
 				uint32 adr = ReadMacInt32(pb + csParam + 2);
-				WriteMacInt16(pb + csParam, 1);		// 1 format supported
+				WriteMacInt16(pb + csParam, 1);		// 1 format
 				WriteMacInt32(adr, 2880);			// 2880 sectors
-				WriteMacInt32(adr + 4, 0xd2120050);	// DD, 2 heads, 18 secs/track, 80 tracks
-
-				// Upper byte of format flags:
-				//  bit #7: number of tracks, sectors, and heads is valid
-				//  bit #6: current disk has this format
-				//  bit #5: <unused>
-				//  bit #4: double density
-				//  bits #3..#0: number of heads
-			} else {
+				WriteMacInt32(adr + 4, 0xd2120050);	// 2 heads, 18 secs/track, 80 tracks
+			} else
 				err = paramErr;
-			}
 			break;
 
-		case 8:			// Get drive status
+		case 8:		// Get drive status
 			Mac2Mac_memcpy(pb + csParam, info->status, 22);
 			break;
 
-		case 10:		// Get disk type and MFM info
-			WriteMacInt32(pb + csParam, ReadMacInt32(info->status + dsMFMDrive) & 0xffffff00 | 0xfe);	// 0xfe = SWIM2 controller
+		case 10:	// Get disk type
+			WriteMacInt32(pb + csParam, ReadMacInt32(info->status + dsMFMDrive) & 0xffffff00 | 0xfe);
 			break;
 
-//		case 0x4350:	// Measure disk speed at a given track ('CP') (not supported)
-//			break;
-
-		case 0x4456:	// Duplicator (DiskCopy) version supported ('DV'), enables the 'SC' control code above
-			WriteMacInt16(pb + csParam, 0x0410);	// Version 4.1 and later
+		case 0x4456: // Duplicator version supported ('DV')
+			WriteMacInt16(pb + csParam, 0x0410);
 			break;
 
-//		case 0x5250:	// Get floppy info record ('RP') (not supported)
-//			break;
-
-		case 0x5343:	// Get address header format byte ('SC')
-			WriteMacInt8(pb + csParam, 0x02);	// 500 kbit/s (HD) MFM
+		case 0x5343: // Get address header format byte ('SC')
+			WriteMacInt8(pb + csParam, 0x22);	// 512 bytes/sector
 			break;
 
 		default:
--- macemu/SheepShaver/src/thunks.cpp
+++ sheepshaver/SheepShaver/src/thunks.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "thunks.h"
 #include "emul_op.h"
 #include "cpu_emulation.h"
@@ -50,7 +50,7 @@
  *  Return the fake PowerPC opcode to handle specified native code
  */
 
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 uint32 NativeOpcode(int selector)
 {
 	uint32 opcode;
@@ -110,7 +110,7 @@
  *  Generate PowerPC thunks for GetResource() replacements
  */
 
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 static uint32 get_resource_func;
 static uint32 get_1_resource_func;
 static uint32 get_ind_resource_func;
@@ -260,7 +260,7 @@
 
 bool ThunksInit(void)
 {
-#if EMULATED_PPC
+#if defined(EMULATED_PPC)
 	for (int i = 0; i < NATIVE_OP_MAX; i++) {
 		uintptr base = SheepMem::Reserve(16);
 		WriteMacInt32(base + 0, base + 8);
--- macemu/SheepShaver/src/timer.cpp
+++ sheepshaver/SheepShaver/src/timer.cpp
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "timer.h"
 #include "macos_util.h"
 #include "main.h"
@@ -62,7 +62,7 @@
 #ifdef PRECISE_TIMING_BEOS
 static thread_id timer_thread = -1;
 static bool thread_active = true;
-static const tm_time_t wakeup_time_max = 0x7fffffffffffffff;
+static const tm_time_t wakeup_time_max = 0x7fffffffffffffff; 
 static volatile tm_time_t wakeup_time = wakeup_time_max;
 static sem_id wakeup_time_sem = -1;
 static int32 timer_func(void *arg);
@@ -272,7 +272,7 @@
 	resume_thread(timer_thread);
 #elif PRECISE_TIMING_MACH
 	pthread_t pthread;
-
+	
 	host_get_clock_service(mach_host_self(), REALTIME_CLOCK, &system_clock);
 	semaphore_create(mach_task_self(), &wakeup_time_sem, SYNC_POLICY_FIFO, 1);
 
@@ -324,7 +324,7 @@
 	while (desc) {
 		TMDesc *next = desc->next;
 		delete desc;
-		desc = next;
+		desc = desc->next;
 	}
 	tmDescList = NULL;
 }
@@ -339,7 +339,7 @@
 	D(bug("InsTime %08lx, trap %04x\n", tm, trap));
 	WriteMacInt16((uint32)tm + qType, ReadMacInt16((uint32)tm + qType) & 0x1fff | (trap << 4) & 0x6000);
 	if (find_desc(tm))
-		printf("WARNING: InsTime(%08x): Task re-inserted\n", tm);
+		printf("WARNING: InsTime(%08lx): Task re-inserted\n", tm);
 	else {
 		TMDesc *desc = new TMDesc;
 		desc->task = tm;
@@ -361,7 +361,7 @@
 	// Find descriptor
 	TMDesc *desc = find_desc(tm);
 	if (!desc) {
-		printf("WARNING: RmvTime(%08x): Descriptor not found\n", tm);
+		printf("WARNING: RmvTime(%08lx): Descriptor not found\n", tm);
 		return 0;
 	}
 
@@ -436,7 +436,7 @@
 	// Find descriptor
 	TMDesc *desc = find_desc(tm);
 	if (!desc) {
-		printf("FATAL: PrimeTime(%08x): Descriptor not found\n", tm);
+		printf("FATAL: PrimeTime(%08lx): Descriptor not found\n", tm);
 		return 0;
 	}
 
@@ -558,13 +558,13 @@
 {
 	timer_thread = mach_thread_self();
 	timer_thread_active = true;
-
+	
 	while (timer_thread_active) {
 		clock_sleep(system_clock, TIME_ABSOLUTE, wakeup_time, NULL);
 		semaphore_wait(wakeup_time_sem);
-
+	   
 		tm_time_t system_time;
-
+		
 		timer_current_time(system_time);
 		if (timer_cmp_time(wakeup_time, system_time) < 0) {
 			wakeup_time = wakeup_time_max;
--- macemu/SheepShaver/src/user_strings.cpp
+++ sheepshaver/SheepShaver/src/user_strings.cpp
@@ -30,7 +30,7 @@
  *   - error messages that only go to the shell ("FATAL"/"WARNING", those are really debugging messages)
  */
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "user_strings.h"
 
 #ifdef __BEOS__
@@ -172,7 +172,6 @@
 
 	{STR_WINDOW_TITLE, "SheepShaver"},
 	{STR_WINDOW_TITLE_FROZEN, "SheepShaver *** FROZEN ***"},
-	{STR_WINDOW_TITLE_GRABBED, "SheepShaver (mouse grabbed, press Ctrl-F5 to release)"},
 	{STR_WINDOW_MENU, "SheepShaver"},
 	{STR_WINDOW_ITEM_ABOUT, "About SheepShaver" ELLIPSIS},
 	{STR_WINDOW_ITEM_REFRESH, "Refresh Rate"},
--- macemu/SheepShaver/src/video.cpp
+++ sheepshaver/SheepShaver/src/video.cpp
@@ -26,7 +26,7 @@
 #include <stdio.h>
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "video.h"
 #include "video_defs.h"
 #include "main.h"
@@ -63,9 +63,9 @@
 /*
  *  Driver local variables
  */
-/*VidLocals vre_data;*/
-VidLocals *private_data = /*&vre_data*/NULL;	// Pointer to driver local variables (there is only one display, so this is ok)
 
+VidLocals *private_data = NULL;	// Pointer to driver local variables (there is only one display, so this is ok)
+
 static long save_conf_id = APPLE_W_640x480;
 static long save_conf_mode = APPLE_8_BIT;
 
@@ -110,10 +110,10 @@
 /*
  *  Tell whether window/screen is activated or not (for mouse/keyboard polling)
  */
-
+ 
 bool VideoActivated(void)
 {
-	return video_activated;
+	return video_activated;	
 }
 
 
@@ -125,7 +125,7 @@
 {
 	if (display_type == DIS_WINDOW) {
 		uint8 *screen = (uint8 *)private_data->saveBaseAddr;
-		uint32 row_bytes = VModes[cur_mode].viRowBytes;
+		uint32 row_bytes = VModes[cur_mode].viRowBytes;	
 		uint32 y2size = VModes[cur_mode].viYsize;
 		uint32 x2size = VModes[cur_mode].viXsize;
 		for (int j=0;j<ysize;j++) {
@@ -213,6 +213,8 @@
 
 static int16 set_gamma(VidLocals *csSave, uint32 gamma)
 {
+	return paramErr;
+
 	if (gamma == 0) { // Build linear ramp, 256 entries
 
 		// Allocate new table, if necessary
@@ -245,7 +247,7 @@
 		int data_width = ReadMacInt16(gamma + gDataWidth);
 		if (data_width > 8)
 			return paramErr;
-		int data_cnt = ReadMacInt16(gamma + gDataCnt);
+		int data_cnt = ReadMacInt16(gamma + gDataWidth);
 		if (data_cnt != (1 << data_width))
 			return paramErr;
 
@@ -283,7 +285,7 @@
 			return video_mode_change(csSave, param);
 
 		case cscSetEntries: {							// SetEntries
-			D(bug("SetEntries\n"));
+			D(bug("SetEntries\n"));					
 			if (VModes[cur_mode].viAppleMode > APPLE_8_BIT) return controlErr;
 			uint32 s_pal = ReadMacInt32(param + csTable);
 			uint16 start = ReadMacInt16(param + csStart);
@@ -366,7 +368,7 @@
 		case cscSetGamma: {							// SetGamma
 			uint32 user_table = ReadMacInt32(param + csGTable);
 			D(bug("SetGamma %08x\n", user_table));
-			return set_gamma(csSave, user_table);
+			return set_gamma(csSave, ReadMacInt32(user_table));
 		}
 
 		case cscGrayPage: {							// GrayPage
@@ -453,6 +455,9 @@
 				return controlErr;
 			uint32 bitmap = ReadMacInt32(bmhandle);
 
+			if (!video_can_change_cursor())
+				return controlErr;
+
 			// Get cursor data even on a screen, to set the right cursor image when switching back to a window.
 			// Hotspot is stale, but will be fixed by the next call to DrawHardwareCursor, which is likely to
 			// occur immediately hereafter.
@@ -466,9 +471,6 @@
 				changed = true;
 			}
 
-			// Set new cursor image
-			if (!video_can_change_cursor())
-				return controlErr;
 			if (changed)
 				video_set_cursor();
 
@@ -634,7 +636,7 @@
 			return noErr;
 
 		case cscGetEntries: {						// GetEntries
-			D(bug("GetEntries\n"));
+			D(bug("GetEntries\n"));	
 			uint32 d_pal = ReadMacInt32(param + csTable);
 			uint16 start = ReadMacInt16(param + csStart);
 			uint16 count = ReadMacInt16(param + csCount);
@@ -697,7 +699,7 @@
 		case cscGetGamma:							// GetGamma
 			D(bug("GetGamma\n"));
 			WriteMacInt32(param, (uint32)csSave->gammaTable);
-			return noErr;
+			return statusErr;
 
 		case cscGetDefaultMode:						// GetDefaultMode
 			D(bug("GetDefaultMode\n"));
@@ -709,7 +711,7 @@
 			WriteMacInt32(param + csData, csSave->saveData);
 			WriteMacInt16(param + csPage, csSave->savePage);
 			WriteMacInt32(param + csBaseAddr, csSave->saveBaseAddr);
-
+			
 			D(bug("return: mode:%04x ID:%08lx page:%04x ", ReadMacInt16(param + csMode),
 				ReadMacInt32(param + csData), ReadMacInt16(param + csPage)));
 			D(bug("base adress %08lx\n", ReadMacInt32(param + csBaseAddr)));
@@ -824,7 +826,7 @@
 				ReadMacInt32(param + csDisplayModeID),
 				ReadMacInt16(param + csDepthMode)));
 
-			// find right video mode
+			// find right video mode						
 			for (int i=0; VModes[i].viType!=DIS_INVALID; i++) {
 				if ((ReadMacInt16(param + csDepthMode) == VModes[i].viAppleMode) &&
 					(ReadMacInt32(param + csDisplayModeID) == VModes[i].viAppleID)) {
@@ -842,42 +844,42 @@
 					WriteMacInt32(vpb + vpVRes, 0x00480000);	// vert res of the device (ppi)
 					switch (VModes[i].viAppleMode) {
 						case APPLE_1_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0);
+							WriteMacInt16(vpb + vpPixelType, 0); 
 							WriteMacInt16(vpb + vpPixelSize, 1);
 							WriteMacInt16(vpb + vpCmpCount, 1);
 							WriteMacInt16(vpb + vpCmpSize, 1);
 							WriteMacInt32(param + csDeviceType, 0); // CLUT
 							break;
 						case APPLE_2_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0);
+							WriteMacInt16(vpb + vpPixelType, 0); 
 							WriteMacInt16(vpb + vpPixelSize, 2);
 							WriteMacInt16(vpb + vpCmpCount, 1);
 							WriteMacInt16(vpb + vpCmpSize, 2);
 							WriteMacInt32(param + csDeviceType, 0); // CLUT
 							break;
 						case APPLE_4_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0);
+							WriteMacInt16(vpb + vpPixelType, 0); 
 							WriteMacInt16(vpb + vpPixelSize, 4);
 							WriteMacInt16(vpb + vpCmpCount, 1);
 							WriteMacInt16(vpb + vpCmpSize, 4);
 							WriteMacInt32(param + csDeviceType, 0); // CLUT
 							break;
 						case APPLE_8_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0);
+							WriteMacInt16(vpb + vpPixelType, 0); 
 							WriteMacInt16(vpb + vpPixelSize, 8);
 							WriteMacInt16(vpb + vpCmpCount, 1);
 							WriteMacInt16(vpb + vpCmpSize, 8);
 							WriteMacInt32(param + csDeviceType, 0); // CLUT
 							break;
 						case APPLE_16_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0x10);
+							WriteMacInt16(vpb + vpPixelType, 0x10); 
 							WriteMacInt16(vpb + vpPixelSize, 16);
 							WriteMacInt16(vpb + vpCmpCount, 3);
 							WriteMacInt16(vpb + vpCmpSize, 5);
 							WriteMacInt32(param + csDeviceType, 2); // DIRECT
 							break;
 						case APPLE_32_BIT:
-							WriteMacInt16(vpb + vpPixelType, 0x10);
+							WriteMacInt16(vpb + vpPixelType, 0x10); 
 							WriteMacInt16(vpb + vpPixelSize, 32);
 							WriteMacInt16(vpb + vpCmpCount, 3);
 							WriteMacInt16(vpb + vpCmpSize, 8);
@@ -1045,7 +1047,7 @@
 				err = -1;
 				break;
 			}
-			Host2Mac_memcpy(private_data->regEntryID, commandContents + 2, 16);	// DriverInitInfo.deviceEntry
+			Mac2Mac_memcpy(private_data->regEntryID, commandContents + 2, 16);	// DriverInitInfo.deviceEntry
 			private_data->interruptsEnabled = false;	// Disable interrupts
 			break;
 
--- macemu/SheepShaver/src/xpram.cpp
+++ sheepshaver/SheepShaver/src/xpram.cpp
@@ -25,26 +25,14 @@
 
 #include <string.h>
 
-#include "CrossPlatform/sysdeps.h"
+#include "sysdeps.h"
 #include "xpram.h"
 
 
 // Extended parameter RAM
 uint8 XPRAM[XPRAM_SIZE];
 
-char* xpramStr = { 0 };
 
-char* dumpXPRAM()
-{
-	if ( !xpramStr || strlen( xpramStr ) < 1 )
-	{
-		xpramStr = (char*)malloc( 1 << 16 );
-	}
-
-	XPRAMtoString( xpramStr );
-	return xpramStr;
-}
-
 /*
  *  Initialize XPRAM
  */
@@ -67,71 +55,4 @@
 {
 	// Save XPRAM to settings file
 	SaveXPRAM();
-}
-
-size_t XPRAMtoString( const char* buf )
-{
-	char* b = (char*)buf;
-	size_t len;
-
-	*b = '\n'; b++;
-	const char* str = "XPRAM";
-	len = strlen( str );
-	memcpy( b, str, len );
-	b += len;
-	*b = '\n'; b++;
-	*b = '\n'; b++;
-
-	char s[256];
-	for ( size_t offset = 0; offset < XPRAM_SIZE; offset += 16 ) {
-		sprintf( s, "    %08x", offset );
-		len = strlen( s );
-		memcpy( b, s, len );
-		b += len;
-		*b = ' '; b++;
-		*b = ' '; b++;
-
-		//char ascii[17];
-		for ( size_t bytePos = 0; bytePos < 16; bytePos++ )
-		{
-			uint8 symbol = XPRAM[offset + bytePos];
-			//if ( symbol >= 32 && symbol < 128 )
-			//	ascii[bytePos] = (char)symbol;
-			//else
-			//	ascii[bytePos] = ' ';
-			sprintf( s, "%02x", symbol );
-			len = strlen( s );
-			memcpy( b, s, len );
-			b += len;
-			*b = ' '; b++;
-		}
-		//*b = ' '; b++;
-		//memcpy( b, ascii, 16 );
-		//b += 16;
-
-		*b = '\n'; b++;
-	}
-
-	*b = 0;
-	return b - buf;
-}
-
-bool getXPRAMat(size_t off, uint8* out)
-{
-	if ( !out )
-		return false;
-	if ( off >= XPRAM_SIZE )
-		return false;
-
-	*out = XPRAM[ off ];
-	return true;
-}
-
-bool setXPRAMat(size_t off, uint8 byte)
-{
-	if ( off >= XPRAM_SIZE )
-		return false;
-
-	XPRAM[ off ] = byte;
-	return true;
 }
Only in macemu/: bintrailingspacechars-sed-bsd.sh
Only in macemu/: build--basiliskii
Only in macemu/: build--sheepshaver
